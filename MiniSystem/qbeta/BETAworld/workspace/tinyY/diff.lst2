47305c47305
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
47306a47307,47308
> **** BinaryExp:checkOI:i + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
47448c47450
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
47554c47556
< **** INV:check:i=1 rec:i label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:i + 1
47641,47644c47643,47646
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
---
> i := i + 1
> if (i <= get[0]) :then 
>    current := get[i]
>    inner(scan)
47666c47668
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
47898,47899d47899
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
47903,47905c47903,47908
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
47971c47974
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
47972a47976,47977
> **** BinaryExp:checkOI:i <= get[0]
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
48220c48225
< **** INV:check:i=1 rec:i label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:i <= get[0]
48340,48344c48345
< 
< if (i <= get[0]) :then 
<    current := get[i]
<    inner(scan)
<    restart(loop)
---
> (i <= get[0])
48462c48463
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
48653,48654d48653
< **** INV:check:i=2 rec:<= get[0] label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
48658,48660c48657,48662
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
52434c52436
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
52435a52438,52439
> **** BinaryExp:checkOI:V = current
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
52852c52856
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V = current
52971,52974c52975
< 
< if (V = current) :then 
<    B := true
<    leave(L)
---
> (V = current)
53100c53101
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
53292,53293d53292
< **** INV:check:i=2 rec:= current label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
53297,53300c53296,53301
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
60375c60376
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
60376a60378,60379
> **** BinaryExp:checkOI:inx <= last
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
60708c60711
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:inx <= last
60828,60834c60831
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
---
> (inx <= last)
60952c60949
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
61143,61144d61139
< **** INV:check:i=2 rec:<= last label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
61148,61150c61143,61148
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
62003c62001
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
62004a62003,62004
> **** BinaryExp:checkOI:inx + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
62294c62294
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
62400c62400
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:inx + 1
62487,62488c62487,62488
<    inx := inx + 1
<    restart(_doIt)
---
> inx := inx + 1
> restart(_doIt)
62509c62509
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
62741,62742d62740
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
62746,62748c62744,62749
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
72674c72675
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
72675a72677,72678
> **** BinaryExp:checkOI:L <> Veq.length
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
72915c72918
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L <> Veq.length
73019,73021c73022
< 
< if (L <> Veq.length) :then 
<    leave(loop)
---
> (L <> Veq.length)
73042c73043
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
73200,73201d73200
< **** INV:check:i=2 rec:<> Veq.length label: ObjectInvocation_Binary
< **   OGS: [0:=,nest(loop)]
73205,73207c73204,73209
< %basic 55
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
77587c77589
< **** INV:check:i=0 rec:none label: ObjectInvocation_KeyWord
---
> **** INV:check:i=0 rec:none label: BinOp
77588a77591,77592
> **** BinaryExp:checkOI:this(String) = V
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
78579c78583
< **** INV:check:i=1 rec:this(String) label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:this(String) = V
78727c78731
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
78886,78887d78889
< **** INV:check:i=2 rec:= V label: ObjectInvocation_Binary
< **   OGS: [0:StringLib]
78891,78895c78893,78897
< loop: do 
<    c1: var char
<    c2: var char
<    L: var integer
<    L := length
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
82632c82634
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
82633a82636,82637
> **** BinaryExp:checkOI:L1 = 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
83865c83869
< **** INV:check:i=1 rec:L1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L1 = 0
83992,83995c83996
< 
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
---
> (L1 = 0)
84121c84122
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
84313,84314d84313
< **** INV:check:i=2 rec:= 0 label: ObjectInvocation_Binary
< **   OGS: [0:<=,nest(isEmpty)]
84318,84321c84317,84322
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
85063c85064
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
85064a85066,85067
> **** BinaryExp:checkOI:L1 <= L2
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
85436c85439
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
85542c85545
< **** INV:check:i=1 rec:L1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L1 <= L2
85672c85675
<    leave(matchEq)
---
> leave(matchEq)
85790c85793
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
85981,85982d85983
< **** INV:check:i=2 rec:<= L2 label: ObjectInvocation_Binary
< **   OGS: [0:<=,nest($0)]
85986,85988c85987,85992
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
87042c87046
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
87043a87048,87049
> **** BinaryExp:checkOI:L2 = 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
88276c88282
< **** INV:check:i=1 rec:L2 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L2 = 0
88403,88406c88409
< 
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
---
> (L2 = 0)
88532c88535
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
88724,88725d88726
< **** INV:check:i=2 rec:= 0 label: ObjectInvocation_Binary
< **   OGS: [0:<=,nest(isEmpty)]
88729,88732c88730,88735
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
92504c92507
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
92505a92509,92510
> **** BinaryExp:checkOI:inx + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
92725c92730
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
92831c92836
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:inx + 1
92926,92929c92931,92934
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
---
> c1 := get[inx]
> c2 := Veq.get[inx]
> if (c1 = c2) :then 
>    if (inx < L) :then 
92951c92956
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
93183,93184d93187
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:loop,nest(loop)]
93188,93190c93191,93196
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
95480c95486
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
95481a95488,95489
> **** BinaryExp:checkOI:c1 = c2
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
95788c95796
< **** INV:check:i=1 rec:c1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:c1 = c2
95910,95913c95918
< 
< if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
---
> (c1 = c2)
96039c96044
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
96231,96232d96235
< **** INV:check:i=2 rec:= c2 label: ObjectInvocation_Binary
< **   OGS: [0:loop,nest(loop)]
96236,96239c96239,96244
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
96325c96330
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
96326a96332,96333
> **** BinaryExp:checkOI:inx < L
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
96700c96707
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:inx < L
96800,96802c96807
< 
< if (inx < L) :then 
<    restart(loop)
---
> (inx < L)
96823c96828
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
96981,96982d96985
< **** INV:check:i=2 rec:< L label: ObjectInvocation_Binary
< **   OGS: [0:loop,nest($0)]
96986,96988c96989,96994
< %basic 51
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
98235c98241
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
98236a98243,98244
> **** BinaryExp:checkOI:c1 = c2
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
98543c98551
< **** INV:check:i=1 rec:c1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:c1 = c2
98665,98671c98673
< 
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
---
> (c1 = c2)
98797c98799
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
98989,98990d98990
< **** INV:check:i=2 rec:= c2 label: ObjectInvocation_Binary
< **   OGS: [0:loop,nest(doit)]
98994,98997c98994,98999
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
99739c99741
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
99740a99743,99744
> **** BinaryExp:checkOI:L1 <= L2
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
100112c100116
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
100218c100222
< **** INV:check:i=1 rec:L1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L1 <= L2
100348c100352
<    leave(matchEq)
---
> leave(matchEq)
100466c100470
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
100657,100658d100660
< **** INV:check:i=2 rec:<= L2 label: ObjectInvocation_Binary
< **   OGS: [0:<=,nest($0)]
100662,100664c100664,100669
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
102375c102380
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
102376a102382,102383
> **** BinaryExp:checkOI:c1 < c2
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
102645c102652
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
102731c102738
< **** INV:check:i=1 rec:c1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:c1 < c2
102829c102836
<    leave(matchEq)
---
> leave(matchEq)
102850c102857
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
103008,103009d103014
< **** INV:check:i=2 rec:< c2 label: ObjectInvocation_Binary
< **   OGS: [0:loop,nest($0)]
103013,103015c103018,103023
< %basic 51
< in V: var char
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
106705c106713
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
106706a106715,106716
> **** BinaryExp:checkOI:L1 < L2
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
106946c106956
< **** INV:check:i=1 rec:L1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L1 < L2
107046,107050c107056
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
---
> (L1 < L2)
107071c107077
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
107229,107230d107234
< **** INV:check:i=2 rec:< L2 label: ObjectInvocation_Binary
< **   OGS: [0:<=,nest(loop)]
107234,107236c107238,107243
< %basic 51
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
115680c115687
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
115681a115689,115690
> **** BinaryExp:checkOI:V < 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
115813c115822
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
115919c115928
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V < 0
116021,116024c116030,116033
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
---
> %OSDvisibility disguised
> %globals
> in V: var integer
> out Si2s: var String
116046c116055
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
116204,116205d116212
< **** INV:check:i=2 rec:< 0 label: ObjectInvocation_Binary
< **   OGS: [0:StringLib,nest(I2S)]
116209,116211c116216,116221
< %basic 51
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
116861c116871
< **** INV:check:i=0 rec:none label: ConstLiteral
---
> **** INV:check:i=0 rec:none label: BinOp
116863c116873,116875
< **** INV:check:i=1 rec:0 label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:0 - V
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:0 - V
116951c116963
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
117183,117184d117194
< **** INV:check:i=2 rec:- V label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
117188,117190c117198,117203
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
118395c118408
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
118396a118410,118411
> **** BinaryExp:checkOI:L + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
118610c118625
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
118716c118731
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L + 1
118811,118814c118826,118829
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
---
> D.put('0' + V /% 10):at[L]
> V := V // 10
> if (V > 0) :then 
>    restart(loop)
118835c118850
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
119067,119068d119081
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:StringLib,nest(loop)]
119072,119074c119085,119090
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
119867c119883
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
119868a119885,119886
> **** BinaryExp:checkOI:V // 10
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
120078c120096
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
120184c120202
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V // 10
120283,120286c120301,120304
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
---
> D.put('0' + V /% 10):at[L]
> V := V // 10
> if (V > 0) :then 
>    restart(loop)
120307c120325
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
120539,120540d120556
< **** INV:check:i=2 rec:// 10 label: ObjectInvocation_Binary
< **   OGS: [0:StringLib,nest(loop)]
120544,120546c120560,120565
< %basic 68
< in V: var integer
< out B: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
120599c120618
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
120600a120620,120621
> **** BinaryExp:checkOI:V > 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
120916c120937
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V > 0
121018,121020c121039
< 
< if (V > 0) :then 
<    restart(loop)
---
> (V > 0)
121041c121060
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
121199,121200d121217
< **** INV:check:i=2 rec:> 0 label: ObjectInvocation_Binary
< **   OGS: [0:StringLib,nest(loop)]
121204,121206c121221,121226
< %basic 53
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
154574c154594
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
154575a154596,154597
> **** BinaryExp:checkOI:i + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
154717c154739
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
154823c154845
< **** INV:check:i=1 rec:i label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:i + 1
154910,154913c154932,154935
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
---
> i := i + 1
> if (i <= get[0]) :then 
>    current := get[i]
>    inner(scan)
154935c154957
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
155167,155168d155188
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
155172,155174c155192,155197
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
155240c155263
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
155241a155265,155266
> **** BinaryExp:checkOI:i <= get[0]
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
155489c155514
< **** INV:check:i=1 rec:i label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:i <= get[0]
155609,155613c155634
< 
< if (i <= get[0]) :then 
<    current := get[i]
<    inner(scan)
<    restart(loop)
---
> (i <= get[0])
155731c155752
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
155922,155923d155942
< **** INV:check:i=2 rec:<= get[0] label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
155927,155929c155946,155951
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
158089c158111
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
158090a158113,158114
> **** BinaryExp:checkOI:V = current
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
158424c158448
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V = current
158543,158546c158567
< 
< if (V = current) :then 
<    B := true
<    leave(has)
---
> (V = current)
158672c158693
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
158864,158865d158884
< **** INV:check:i=2 rec:= current label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
158869,158872c158888,158893
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
178853c178874
< **** INV:check:i=0 rec:none label: BracketedExp
---
> **** INV:check:i=0 rec:none label: BinOp
178854a178876,178877
> **** BinaryExp:checkOI:(('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z'))
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
178861c178884
< **** INV:check:i=0 rec:none label: BracketedExp
---
> **** INV:check:i=0 rec:none label: BinOp
178862a178886,178887
> **** BinaryExp:checkOI:('a' <= ch) && (ch <= 'z')
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
178869c178894
< **** INV:check:i=0 rec:none label: Char:
---
> **** INV:check:i=0 rec:none label: BinOp
178871c178896,178898
< **** INV:check:i=1 rec:'a' label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:'a' <= ch
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:'a' <= ch
179085c179112
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
179276,179278c179303
< **** INV:check:i=2 rec:<= ch label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** INV:check:i=1 rec:('a' <= ch) label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:('a' <= ch) && (ch <= 'z')
179365c179390
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
179523,179525c179548
< **** INV:check:i=2 rec:&& (ch <= 'z') label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** INV:check:i=1 rec:(('a' <= ch) && (ch <= 'z')) label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:(('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z'))
179613c179636
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
179771,179772d179793
< **** INV:check:i=2 rec:|| (('A' <= ch) && (ch <= 'Z')) label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
179776,179778c179797,179802
< %basic 63
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
180683c180707
< **** INV:check:i=0 rec:none label: BracketedExp
---
> **** INV:check:i=0 rec:none label: BinOp
180684a180709,180710
> **** BinaryExp:checkOI:('0' <= ch) && (ch <= '9')
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
180688c180714
< **** INV:check:i=0 rec:none label: Char:
---
> **** INV:check:i=0 rec:none label: BinOp
180690c180716,180718
< **** INV:check:i=1 rec:'0' label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:'0' <= ch
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:'0' <= ch
180904c180932
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
181095,181097c181123
< **** INV:check:i=2 rec:<= ch label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** INV:check:i=1 rec:('0' <= ch) label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:('0' <= ch) && (ch <= '9')
181184c181210
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
181342,181343d181367
< **** INV:check:i=2 rec:&& (ch <= '9') label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
181347,181349c181371,181376
< %basic 70
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
184270c184297
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
184271a184299,184300
> **** BinaryExp:checkOI:V < 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
184409c184438
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
184515c184544
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V < 0
184609,184612c184638,184641
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
---
> in V: var integer
> ch: var char
> D: obj Indexed(20,#integer)
> L: var integer
184634c184663
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
184792,184793d184820
< **** INV:check:i=2 rec:< 0 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
184797,184799c184824,184829
< %basic 51
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
185410c185440
< **** INV:check:i=0 rec:none label: ConstLiteral
---
> **** INV:check:i=0 rec:none label: BinOp
185412c185442,185444
< **** INV:check:i=1 rec:0 label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:0 - V
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:0 - V
185500c185532
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
185732,185733d185763
< **** INV:check:i=2 rec:- V label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
185737,185739c185767,185772
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
186359c186392
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
186360a186394,186395
> **** BinaryExp:checkOI:L + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
186678c186713
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
186784c186819
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L + 1
186871,186874c186906,186909
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
---
> D.put(V /% 10):at[L]
> V := V // 10
> if (V > 0) :then 
>    restart(loop)
186895c186930
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
187127,187128d187161
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
187132,187134c187165,187170
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
188129c188165
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
188130a188167,188168
> **** BinaryExp:checkOI:V // 10
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
188445c188483
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
188551c188589
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V // 10
188642,188645c188680,188683
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
---
> D.put(V /% 10):at[L]
> V := V // 10
> if (V > 0) :then 
>    restart(loop)
188666c188704
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
188898,188899d188935
< **** INV:check:i=2 rec:// 10 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
188903,188905c188939,188944
< %basic 68
< in V: var integer
< out B: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
188958c188997
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
188959a188999,189000
> **** BinaryExp:checkOI:V > 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
189380c189421
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V > 0
189474,189476c189515
< 
< if (V > 0) :then 
<    restart(loop)
---
> (V > 0)
189497c189536
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
189655,189656d189693
< **** INV:check:i=2 rec:> 0 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
189660,189662c189697,189702
< %basic 53
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
193743c193783
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
193744a193785,193786
> **** BinaryExp:checkOI:V < 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
193882c193924
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
193988c194030
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V < 0
194082,194085c194124,194127
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
---
> in V: var integer
> D: obj Indexed(20,#integer)
> L: var integer
> isNeg: var Boolean
194107c194149
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
194265,194266d194306
< **** INV:check:i=2 rec:< 0 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
194270,194272c194310,194315
< %basic 51
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
194882c194925
< **** INV:check:i=0 rec:none label: ConstLiteral
---
> **** INV:check:i=0 rec:none label: BinOp
194884c194927,194929
< **** INV:check:i=1 rec:0 label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:0 - V
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:0 - V
194972c195017
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
195204,195205d195248
< **** INV:check:i=2 rec:- V label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
195209,195211c195252,195257
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
195663c195709
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
195664a195711,195712
> **** BinaryExp:checkOI:L + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
195884c195932
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
195990c196038
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L + 1
196077,196080c196125,196128
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
---
> D.put(V /% 10):at[L]
> V := V // 10
> if (V > 0) :then 
>    restart(loop)
196101c196149
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
196333,196334d196380
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
196338,196340c196384,196389
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
197140c197189
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
197141a197191,197192
> **** BinaryExp:checkOI:V // 10
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
197359c197410
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
197465c197516
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V // 10
197556,197559c197607,197610
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
---
> D.put(V /% 10):at[L]
> V := V // 10
> if (V > 0) :then 
>    restart(loop)
197580c197631
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
197812,197813d197862
< **** INV:check:i=2 rec:// 10 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
197817,197819c197866,197871
< %basic 68
< in V: var integer
< out B: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
197872c197924
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
197873a197926,197927
> **** BinaryExp:checkOI:V > 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
198197c198251
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V > 0
198291,198293c198345
< 
< if (V > 0) :then 
<    restart(loop)
---
> (V > 0)
198314c198366
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
198472,198473d198523
< **** INV:check:i=2 rec:> 0 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
198477,198479c198527,198532
< %basic 53
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
201565c201618
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
201566a201620,201621
> **** BinaryExp:checkOI:n > 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
201811c201866
< **** INV:check:i=1 rec:n label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:n > 0
201905,201911c201960
< 
< if (n > 0) :then 
<    for(1):to(n - 1):repeat
<       R := R * F
<    
< :else 
< ...
---
> (n > 0)
201932c201981
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
202090,202091d202138
< **** INV:check:i=2 rec:> 0 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
202095,202097c202142,202147
< %basic 53
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
202984c203034
< **** INV:check:i=0 rec:none label: ConstLiteral
---
> **** INV:check:i=0 rec:none label: BinOp
202986c203036,203038
< **** INV:check:i=1 rec:0 label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:0 - n
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:0 - n
203074c203126
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
203306,203307d203357
< **** INV:check:i=2 rec:- n label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
203311,203313c203361,203366
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
204089c204142
< **** INV:check:i=0 rec:none label: FloatLiteral
---
> **** INV:check:i=0 rec:none label: BinOp
204091c204144,204146
< **** INV:check:i=1 rec:1.0 label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:1.0 / R
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:1.0 / R
204181c204236
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
204393,204394d204447
< **** INV:check:i=2 rec:/ R label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
204398,204400c204451,204456
< %basic 121
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
211291c211347
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
211292a211349,211350
> **** BinaryExp:checkOI:V - Y
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
211533c211591
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
211629c211687
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V - Y
211717,211720c211775,211778
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
---
> rest: var float
> Irest: var integer
> ch: var char
> Y := N
211742c211800
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
211954,211955d212011
< **** INV:check:i=2 rec:- Y label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
211959,211961c212015,212020
< %basic 110
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
232865c232924
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
232866a232926,232927
> **** BinaryExp:checkOI:res = 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
233192c233253
< **** INV:check:i=1 rec:res label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:res = 1
233319,233323c233380
< 
< if (res = 1) :then 
<    enable
<    sleep(50)
<    restart(loop)
---
> (res = 1)
233449c233506
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
233641,233642d233697
< **** INV:check:i=2 rec:= 1 label: ObjectInvocation_Binary
< **   OGS: [0:Lock,nest(loop)]
233646,233649c233701,233706
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
242253c242310
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
242254a242312,242313
> **** BinaryExp:checkOI:ch = 13
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
242472c242531
< **** INV:check:i=1 rec:ch label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:ch = 13
242594,242596c242653
< 
< if (ch = 13) :then  -- ch = ascii.newline fails!?
<    leave(read)
---
> (ch = 13)
242722c242779
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
242914,242915d242970
< **** INV:check:i=2 rec:= 13 label: ObjectInvocation_Binary
< **   OGS: [0:readLine,nest(read)]
242919,242922c242974,242979
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
244051c244108
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
244052a244110,244111
> **** BinaryExp:checkOI:inx + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
244274c244333
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
244380c244439
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:inx + 1
244475,244478c244534,244537
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
---
> ch := _iGet
> put(ch)
> if (ch = 13) :then  -- ch = ascii.newline fails!?
>    leave(read)
244500c244559
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
244732,244733d244790
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:keyboard,nest(read)]
244737,244739c244794,244799
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
256143c256203
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
256144a256205,256206
> **** BinaryExp:checkOI:magnitude + V.magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
256344c256406
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
256440c256502
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude + V.magnitude
256535,256536c256597,256598
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
---
> out R: var thisUnit
> R.magnitude := magnitude + V.magnitude
256557c256619
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
256769,256770d256830
< **** INV:check:i=2 rec:+ V.magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(+?)]
256774,256776c256834,256839
< %basic 109
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
258058c258121
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
258059a258123,258124
> **** BinaryExp:checkOI:magnitude - V.magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
258259c258324
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
258355c258420
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude - V.magnitude
258451,258452c258516,258517
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
---
> out R: var thisUnit
> R.magnitude := magnitude - V.magnitude
258473c258538
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
258685,258686d258749
< **** INV:check:i=2 rec:- V.magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(-?)]
258690,258692c258753,258758
< %basic 110
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
260422c260488
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
260423a260490,260491
> **** BinaryExp:checkOI:magnitude * V
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
260623c260691
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
260719c260787
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude * V
260816,260817c260884,260885
<    out R: var thisUnit
<    R.magnitude := magnitude * V
---
> out R: var thisUnit
> R.magnitude := magnitude * V
260838c260906
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
261050,261051d261117
< **** INV:check:i=2 rec:* V label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(*?)]
261055,261057c261121,261126
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
262791c262860
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
262792a262862,262863
> **** BinaryExp:checkOI:magnitude / V
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
262992c263063
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
263088c263159
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude / V
263186,263187c263257,263258
<    out R: var thisUnit
<    R.magnitude := magnitude / V
---
> out R: var thisUnit
> R.magnitude := magnitude / V
263208c263279
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
263420,263421d263490
< **** INV:check:i=2 rec:/ V label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(/?)]
263425,263427c263494,263499
< %basic 121
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
265689c265761
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
265690a265763,265764
> **** BinaryExp:checkOI:exp > 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
265928c266002
< **** INV:check:i=1 rec:exp label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:exp > 0
266030,266036c266104
< 
< if (exp > 0) :then 
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< :else 
< ...
---
> (exp > 0)
266057c266125
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
266215,266216d266282
< **** INV:check:i=2 rec:> 0 label: ObjectInvocation_Binary
< **   OGS: [0:Unit,nest(^?)]
266220,266222c266286,266291
< %basic 53
< in V: var integer
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
267590c267659
< **** INV:check:i=0 rec:none label: ConstLiteral
---
> **** INV:check:i=0 rec:none label: BinOp
267592c267661,267663
< **** INV:check:i=1 rec:0 label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:0 - exp
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:0 - exp
267680c267751
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
267912,267913d267982
< **** INV:check:i=2 rec:- exp label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
267917,267919c267986,267991
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
269503c269575
< **** INV:check:i=0 rec:none label: FloatLiteral
---
> **** INV:check:i=0 rec:none label: BinOp
269505c269577,269579
< **** INV:check:i=1 rec:1.0 label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:1.0 / R.magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:1.0 / R.magnitude
269595c269669
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
269807,269808d269880
< **** INV:check:i=2 rec:/ R.magnitude label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
269812,269814c269884,269889
< %basic 121
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
271128c271203
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
271129a271205,271206
> **** BinaryExp:checkOI:magnitude * V.magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
271329c271406
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
271425c271502
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude * V.magnitude
271522,271523c271599,271600
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
---
> out R: var resUnit
> R.magnitude := magnitude * V.magnitude
271544c271621
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
271756,271757d271832
< **** INV:check:i=2 rec:* V.magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(***)]
271761,271763c271836,271841
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
272895c272973
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
272896a272975,272976
> **** BinaryExp:checkOI:magnitude + V
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
273085c273165
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
273181c273261
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude + V
273276c273356
<    magnitude := magnitude + V
---
> magnitude := magnitude + V
273297c273377
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
273509,273510d273588
< **** INV:check:i=2 rec:+ V label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(=+)]
273514,273516c273592,273597
< %basic 109
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
274394c274475
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
274395a274477,274478
> **** BinaryExp:checkOI:magnitude < V.magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
274721c274804
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude < V.magnitude
274819,274823c274902
< 
< if (magnitude < V.magnitude) :then 
<    R.magnitude := magnitude
< :else 
<    R.magnitude := V.magnitude
---
> (magnitude < V.magnitude)
274844c274923
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
275002,275003d275080
< **** INV:check:i=2 rec:< V.magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(min)]
275007,275009c275084,275089
< %basic 123
< in V: var float
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
278143c278223
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
278144a278225,278226
> **** BinaryExp:checkOI:magnitude > V.magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
278470c278552
< **** INV:check:i=1 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:magnitude > V.magnitude
278570,278574c278652
< 
< if (magnitude > V.magnitude) :then 
<    R.magnitude := magnitude
< :else 
<    R.magnitude := V.magnitude
---
> (magnitude > V.magnitude)
278595c278673
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
278753,278754d278830
< **** INV:check:i=2 rec:> V.magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Dimension,nest(max)]
278758,278760c278834,278839
< %basic 125
< in V: var float
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
290236c290315
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
290237a290317,290318
> **** BinaryExp:checkOI:L.magnitude * R.magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
290389c290470
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
290506,290507d290586
< **** INV:check:i=1 rec:L label: ObjectInvocation_Unary
< **   OGS: [0:Dimension&]
290588c290667
< **   father: L.magnitude * R.magnitude
---
> **   father: L.magnitude
290590,290594c290669
< 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
---
> U.magnitude := L.magnitude * R.magnitude
290672c290747
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
290768c290843
< **** INV:check:i=2 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L.magnitude * R.magnitude
290867,290869c290942,290944
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
---
> in R: var MultArgR
> out U: var MultRes
> U.magnitude := L.magnitude * R.magnitude
290890c290965
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
291102,291103d291176
< **** INV:check:i=3 rec:* R.magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Dimension&]
291107,291109c291180,291185
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
308907c308983
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
308908a308985,308986
> **** BinaryExp:checkOI:nxtt =/= none
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
309148c309226
< **** INV:check:i=1 rec:nxtt label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:nxtt =/= none
309224,309229c309302
< 
< if (nxtt =/= none) :then 
<    current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
---
> (nxtt =/= none)
309272c309345
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
309451,309452d309523
< **** INV:check:i=2 rec:=/= none label: ObjectInvocation_Binary
< **   OGS: [0:Set]
309456,309458c309527,309532
< %basic 57
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
313790c313864
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
313791a313866,313867
> **** BinaryExp:checkOI:nxt =/= none
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
314036c314112
< **** INV:check:i=1 rec:nxt label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:nxt =/= none
314112,314118c314188
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
---
> (nxt =/= none)
314161c314231
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
314340,314341d314409
< **** INV:check:i=2 rec:=/= none label: ObjectInvocation_Binary
< **   OGS: [0:Set]
314345,314347c314413,314418
< %basic 57
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
319297c319368
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
319298a319370,319371
> **** BinaryExp:checkOI:current == e
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
319739c319812
< **** INV:check:i=1 rec:current label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:current == e
319823,319828c319896
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
---
> (current == e)
319849c319917
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
320007,320008d320074
< **** INV:check:i=2 rec:== e label: ObjectInvocation_Binary
< **   OGS: [0:Set,Collection&]
320012,320014c320078,320083
< %basic 56
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
324691c324760
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
324692a324762,324763
> **** BinaryExp:checkOI:head == none
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
324894c324965
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
324924c324995
< **** INV:check:i=1 rec:head label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:head == none
325001c325072
<    B := head == none
---
> B := head == none
325044c325115
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
325223,325224d325293
< **** INV:check:i=2 rec:== none label: ObjectInvocation_Binary
< **   OGS: [0:Set]
325228,325230c325297,325302
< %basic 56
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
326781c326853
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
326782a326855,326856
> **** BinaryExp:checkOI:N + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
326980c327054
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
327086c327160
< **** INV:check:i=1 rec:N label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:N + 1
327179,327181c327253
< 
< scan
<    N := N + 1
---
> N := N + 1
327202c327274
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
327434,327435d327505
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:Set,nest(scan$0)]
327439,327441c327509,327514
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
336726c336799
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
336727a336801,336802
> **** BinaryExp:checkOI:B && pred(current)
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
336941c337016
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
337010c337085
< **** INV:check:i=1 rec:B label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:B && pred(current)
337103,337105c337178
< 
< scan
<    B := B && pred(current)
---
> B := B && pred(current)
337126c337199
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
337284,337285d337356
< **** INV:check:i=2 rec:&& pred(current) label: ObjectInvocation_Binary
< **   OGS: [0:Set,nest(scan$0)]
337289,337291c337360,337365
< %basic 70
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
357195c357269
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
357196a357271,357272
> **** BinaryExp:checkOI:current.ch = 'b'
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
357528,357529d357603
< **** INV:check:i=1 rec:current label: ObjectInvocation_Unary
< **   OGS: [0:scan$0,nest(L&),Set]
357597c357671
< **   father: current.ch = 'b'
---
> **   father: current.ch
357599,357605c357673
< 
< if (current.ch = 'b') :then 
<    put('[')
<    scanTail
<       current.print
<    put(']')
< ...
---
> (current.ch = 'b')
357757c357825
< **** INV:check:i=2 rec:ch label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:current.ch = 'b'
357881,357887c357949
< 
< if (current.ch = 'b') :then 
<    put('[')
<    scanTail
<       current.print
<    put(']')
< ...
---
> (current.ch = 'b')
358013c358075
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
358205,358206d358266
< **** INV:check:i=3 rec:= 'b' label: ObjectInvocation_Binary
< **   OGS: [0:scan$0,nest(L&)]
358210,358213c358270,358275
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
364129c364191
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
364130a364193,364194
> **** BinaryExp:checkOI:head == none
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
364891c364955
< **** INV:check:i=1 rec:head label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:head == none
364977,364981c365041
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
---
> (head == none)
365039c365099
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
365236,365237d365295
< **** INV:check:i=2 rec:== none label: ObjectInvocation_Binary
< **   OGS: [0:Map]
365241,365243c365299,365304
< %basic 56
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
368083c368144
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
368084a368146,368147
> **** BinaryExp:checkOI:nxt =/= none
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
368333c368396
< **** INV:check:i=1 rec:nxt label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:nxt =/= none
368420,368426c368483
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
---
> (nxt =/= none)
368484c368541
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
368681,368682d368737
< **** INV:check:i=2 rec:=/= none label: ObjectInvocation_Binary
< **   OGS: [0:Map]
368686,368688c368741,368746
< %basic 57
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
373770c373828
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
373771a373830,373831
> **** BinaryExp:checkOI:V == current.inx
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
374108c374168
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V == current.inx
374192,374195c374252
< 
< if (V == current.inx) :then 
<    R := current.elm
<    leave(lookup)
---
> (V == current.inx)
374216c374273
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
374374,374375d374430
< **** INV:check:i=2 rec:== current.inx label: ObjectInvocation_Binary
< **   OGS: [0:Map&]
374379,374381c374434,374439
< %basic 56
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
383092c383150
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
383093a383152,383153
> **** BinaryExp:checkOI:B && pred(current)
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
383288c383348
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
383357c383417
< **** INV:check:i=1 rec:B label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:B && pred(current)
383450,383452c383510
< 
< scan
<    B := B && pred(current)
---
> B := B && pred(current)
383473c383531
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
383631,383632d383688
< **** INV:check:i=2 rec:&& pred(current) label: ObjectInvocation_Binary
< **   OGS: [0:Map,nest(scan$0)]
383636,383638c383692,383697
< %basic 70
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
430864c430923
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
430865a430925,430932
> **** BinaryExp:checkOI:
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
> ...
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
431089c431156
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
431115,431116d431181
< **** INV:check:i=1 rec:theSchedule label: ObjectInvocation_KeyWord
< **   OGS: [0:tinyY]
431191a431257,431260
>    E.elm.isEmpty.not)
> **   father.f.f.f.f:
> 
> B := theSchedule.forAll(
431196,431206d431264
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))
< **   father.f.f.f.f:
< 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
431259c431317
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
431402,431403c431460,431468
< **** INV:check:i=2 rec:forAll(
<    E.elm.isEmpty.not) label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
>       E.elm.exists(
>          in Ex: ref Expert
>          out R: var Boolean
>          R := Ex.quali.has(A.reqQuali))))
431550,431553c431615,431618
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
---
> B := theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
431588c431653
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
431752,431760d431816
< **** INV:check:i=3 rec:&& theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali)))) label: ObjectInvocation_Binary
< **   OGS: [0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
431770,431772c431826,431831
< %basic 70
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
431780,431789d431838
< **** Items:check:
< 
< **** basicScope:
< 
< out B: var Boolean
< B := theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
< ...
434498c434547
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
434499a434549,434550
> **** BinaryExp:checkOI:B && current.elm.isEmpty.not
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
434693c434744
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
434762c434813
< **** INV:check:i=1 rec:B label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:B && current.elm.isEmpty.not
434855,434857c434906
< 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
---
> B := B && current.elm.isEmpty.not
434878c434927
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
435036,435037d435084
< **** INV:check:i=2 rec:&& current.elm.isEmpty.not label: ObjectInvocation_Binary
< **   OGS: [0:Plant,nest(scan$0)]
435041,435043c435088,435093
< %basic 70
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
439948c439998
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
439949a440000,440001
> **** BinaryExp:checkOI:B && bbb
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
440304c440356
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
440373c440425
< **** INV:check:i=1 rec:B label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:B && bbb
440467,440471c440519,440523
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
---
> bbb: var Boolean
> bbb := current.elm.exists(
>    in E: ref Expert
>    out R: var Boolean
>    R := E.quali.has(A.reqQuali))
440493c440545
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
440651,440652d440702
< **** INV:check:i=2 rec:&& bbb label: ObjectInvocation_Binary
< **   OGS: [0:Plant,nest(scan$0)]
440656,440658c440706,440711
< %basic 70
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
457877c457930
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
457878a457932,457933
> **** BinaryExp:checkOI:#= = 
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
458080c458135
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
458237c458292
< **** INV:check:i=1 rec:#= label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:#= = 
458473c458528
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
458665,458666d458719
< **** INV:check:i=2 rec:=  label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
458670,458673c458723,458728
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
460958c461013
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
460959a461015,461016
> **** BinaryExp:checkOI:L + S.length
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
461178c461235
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
461284c461341
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L + S.length
461398c461455
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
461630,461631d461686
< **** INV:check:i=2 rec:+ S.length label: ObjectInvocation_Binary
< **   OGS: [0:String,nest(doplus)]
461635,461637c461690,461695
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
467426c467484
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
467427a467486,467487
> **** BinaryExp:checkOI:L + inx
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
467779c467839
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
467885c467945
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:L + inx
467980,467981c468040,468041
<    i := L + inx
<    T.put(e):at[i]
---
> i := L + inx
> T.put(e):at[i]
468002c468062
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
468234,468235d468293
< **** INV:check:i=2 rec:+ inx label: ObjectInvocation_Binary
< **   OGS: [0:String,nest(repeat$0)]
468239,468241c468297,468302
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
475982c476043
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
475983a476045,476046
> **** BinaryExp:checkOI:c1 <> c2
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
476356c476419
< **** INV:check:i=1 rec:c1 label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:c1 <> c2
476456,476459c476519
< 
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
---
> (c1 <> c2)
476480c476540
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
476638,476639d476697
< **** INV:check:i=2 rec:<> c2 label: ObjectInvocation_Binary
< **   OGS: [0:=,nest(repeat$0)]
476643,476645c476701,476706
< %basic 55
< in V: var char
< out B: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
487574c487635
< **** INV:check:i=0 rec:none label: Char:
---
> **** INV:check:i=0 rec:none label: BinOp
487576c487637,487639
< **** INV:check:i=1 rec:'0' label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:'0' + V /% 10
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:'0' + V /% 10
487663c487726
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
487855,487856d487917
< **** INV:check:i=2 rec:+ V /% 10 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
487860,487862c487921,487926
< %basic 61
< in V: var char
< out R: var char
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
495845c495909
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
495846a495911,495912
> **** BinaryExp:checkOI:V = x.get[inx]
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
496320c496386
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V = x.get[inx]
496439,496442c496505
< 
< if (V = x.get[inx]) :then 
<    inner(case)
<    leave(switch)
---
> (V = x.get[inx])
496568c496631
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
496760,496761d496822
< **** INV:check:i=2 rec:= x.get[inx] label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
496765,496768c496826,496831
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
499289c499352
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
499290a499354,499355
> **** BinaryExp:checkOI:V == x.get[inx]
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
499735c499800
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V == x.get[inx]
499819,499822c499884
< 
< if (V == x.get[inx]) :then 
<    inner(case)
<    leave(rswitch)
---
> (V == x.get[inx])
499843c499905
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
500001,500002d500062
< **** INV:check:i=2 rec:== x.get[inx] label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
500006,500008c500066,500071
< %basic 56
< in objx: ref Object
< out V: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
501761c501824
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
501762a501826,501827
> **** BinaryExp:checkOI:ch <= 'z'
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
501964c502029
< **** INV:check:i=1 rec:ch label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:ch <= 'z'
502197c502262
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
502388,502389d502452
< **** INV:check:i=2 rec:<= 'z' label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
502393,502395c502456,502461
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
502425c502491
< **** INV:check:i=0 rec:none label: BracketedExp
---
> **** INV:check:i=0 rec:none label: BinOp
502426a502493,502494
> **** BinaryExp:checkOI:('A' <= ch) && (ch <= 'Z')
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
502433c502501
< **** INV:check:i=0 rec:none label: Char:
---
> **** INV:check:i=0 rec:none label: BinOp
502435c502503,502505
< **** INV:check:i=1 rec:'A' label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:'A' <= ch
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:'A' <= ch
502649c502719
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
502840,502842c502910
< **** INV:check:i=2 rec:<= ch label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** INV:check:i=1 rec:('A' <= ch) label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:('A' <= ch) && (ch <= 'Z')
502929c502997
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
503087,503088d503154
< **** INV:check:i=2 rec:&& (ch <= 'Z') label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
503092,503094c503158,503163
< %basic 70
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
503320c503389
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
503321a503391,503392
> **** BinaryExp:checkOI:ch <= '9'
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
503511c503582
< **** INV:check:i=1 rec:ch label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:ch <= '9'
503744c503815
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
503935,503936d504005
< **** INV:check:i=2 rec:<= '9' label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
503940,503942c504009,504014
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
504694c504766
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
504695a504768,504769
> **** BinaryExp:checkOI:V /% 10
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
504994c505068
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
505100c505174
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V /% 10
505190c505264
< D.put(V /% 10):at[L]
---
> put(V /% 10):at[L]
505211c505285
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
505443,505444d505516
< **** INV:check:i=2 rec:/% 10 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
505448,505450c505520,505525
< %basic 69
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
507977a508053,508058
> **** INV:check:i=0 rec:none label: BinOp
> **   OGS: none
> **** BinaryExp:checkOI:L + 1 - inx
> **   leftRec.label:BinOp M.label: ObjectInvocation_Binary  OGS: none
> **** Invocation:checkOI:L
> **** Invocation:check: L
508359c508440
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BinOp [savedOGS <> none and IT.isDecl: ]
508465,508467c508546
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** ObjectInvocation:checkOI: + 1 - inx  isFirst:False
---
> **** ObjectInvocation:checkOI: + 1  isFirst:False
508476c508555
< **** ObjectInvocation:check: + 1 - inx
---
> **** ObjectInvocation:check: + 1
508511a508591,508910
> **   OGS: none
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> 
> **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
> **   encOG: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> 
> **** OI:getVqual:initial:+ 1
> **   encOG:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   OGs:[0:integer]
> **   ATd: 
> +  : 
>    %basic 61
>    in V: var integer
>    out R: var integer
> **** Pattern:getVqual: +   :isVirtual:False
> [0:integer]
> 
> **** getVqual:initial:afterATd:+ 1
> **   OGSx:[0:integer]
> **** savedOGS:save:False[0:integer]
> **   OI: + 1
> **   OI:getQual:savedOI:+ 1
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:integer]
> **   OGS:[0:integer]
> **** DataItem:getVqual: out R: var integer
> [0:integer,nest(+)]
> **** ObjectGenerator:getVqual: integer
> **   hasVirtualArgs: False
> **** INV:getVqual:integer
> **   OGs: [0:integer,nest(+)]
> 
> **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:integer,nest(+)]
> **   encOG: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** koks: integer on: 2 Items 
> **   father: integer
> **   father.f.f.f.f:
> 
> %basic 61
>    in V: var integer
>    out R: var integer
> **** ENC:OI.getVqual:[1:integer,nest(+)]
> **   ENC:result:[1:integer]
> **** ENC:OI.getVqual:[2:integer]
> **   ENC:result:[2:BETA]
> 
> **** getVqual:B2:
> [0:BETA]
> ---
> 
> integer: value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** Pattern:getVqual: integer :isVirtual:False
> [0:BETA]
> 
> **** getVqual:cont:afterATd:qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: integer
> **   OI:getQual:savedOI:integer
> **   IT: var [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
> **** OI:getVqual:end: integer
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** OI:getVqual:return: out R: var integer
> **   qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> [0:BETA]
> **** OI:getVqual:end: + 1
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: +
> **** qual:
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> **** OGS:
> [0:BETA]
> **** checkOI:after:getVqual:OF: + qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** OGS:
> [0:BETA]
> **** next:basicScope:from:+
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   BinaryExp:checkOI:after:left:L + 1 - inx
> **   OGS: [0:BETA]
> **** ObjectInvocation:checkOI: - inx  isFirst:False
> **** basicScope:A:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** ObjectInvocation:check: - inx
> **** Items:search: "-" isFirst:False
> **   in: 
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> 
> **** Items:localSearch: -
> **   in:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   isChecked: True
> **   Items:localSearch:Decls: -
> Try: "_thisBasicValue"
> Try: "+"
> Try: "-"
> **** Items:localSearch:end: -
> **** Items:search:end: -
> **** Found: "-" on=0 pn=0 Decl: "-  " visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** computing:encOG:BS.father=encOG:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** encOG:False
508521c508920
< **** OI:getVqual: + 1 - inx on=0 pn=0 isNest=True getRtnQual=False
---
> **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
508547c508946
< **** koks: + 1 - inx on: 0 Items 
---
> **** koks: - inx on: 0 Items 
508552,508554c508951,508953
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
---
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
508560,508561c508959,508960
< +  : 
<    %basic 61
---
> -  : 
>    %basic 62
508564c508963
< **** Pattern:getVqual: +   :isVirtual:False
---
> **** Pattern:getVqual: -   :isVirtual:False
508568c508967
< %basic 61
---
> %basic 62
508573,508575c508972,508974
< **   OI: + 1 - inx
< **   OI:getQual:savedOI:+ 1 - inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   OI: - inx
> **   OI:getQual:savedOI:- inx
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
508579c508978
< [0:BETA,nest(integer),nest(+)]
---
> [0:BETA,nest(integer),nest(-)]
508583c508982
< **   OGs: [0:BETA,nest(integer),nest(+)]
---
> **   OGs: [0:BETA,nest(integer),nest(-)]
508586c508985
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
---
> **   OGS:continued:[0:BETA,nest(integer),nest(-)]
508598c508997
< %basic 61
---
> %basic 62
508601c509000
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
---
> **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(-)]
508704c509103
< **** OI:getVqual:end: + 1 - inx
---
> **** OI:getVqual:end: - inx
508714c509113
< **** checkOI:checkOI:after:getVqual: +
---
> **** checkOI:checkOI:after:getVqual: -
508783c509182
< **** checkOI:after:getVqual:OF: + qual:
---
> **** checkOI:after:getVqual:OF: - qual:
508799c509198
< **** next:basicScope:from:+
---
> **** next:basicScope:from:-
508807,508808d509205
< **** INV:check:i=2 rec:+ 1 - inx label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
508812,508814c509209,509214
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
509302c509702
< **** INV:check:i=0 rec:none label: Char:
---
> **** INV:check:i=0 rec:none label: BinOp
509304c509704,509706
< **** INV:check:i=1 rec:'0' label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:'0' + D.get[i]
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:'0' + D.get[i]
509391c509793
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
509583,509584d509984
< **** INV:check:i=2 rec:+ D.get[i] label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
509588,509590c509988,509993
< %basic 61
< in V: var char
< out R: var char
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
510793c511196
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
510794a511198,511199
> **** BinaryExp:checkOI:V /% 10
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
511004c511409
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
511110c511515
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V /% 10
511200c511605
< D.put(V /% 10):at[L]
---
> put(V /% 10):at[L]
511221c511626
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
511453,511454d511857
< **** INV:check:i=2 rec:/% 10 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
511458,511460c511861,511866
< %basic 69
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
513239a513646,513651
> **** INV:check:i=0 rec:none label: BinOp
> **   OGS: none
> **** BinaryExp:checkOI:L + 1 - inx
> **   leftRec.label:BinOp M.label: ObjectInvocation_Binary  OGS: none
> **** Invocation:checkOI:L
> **** Invocation:check: L
513523c513935
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BinOp [savedOGS <> none and IT.isDecl: ]
513629,513631c514041
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** ObjectInvocation:checkOI: + 1 - inx  isFirst:False
---
> **** ObjectInvocation:checkOI: + 1  isFirst:False
513640c514050
< **** ObjectInvocation:check: + 1 - inx
---
> **** ObjectInvocation:check: + 1
513675a514086,514405
> **   OGS: none
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> 
> **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
> **   encOG: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> 
> **** OI:getVqual:initial:+ 1
> **   encOG:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   OGs:[0:integer]
> **   ATd: 
> +  : 
>    %basic 61
>    in V: var integer
>    out R: var integer
> **** Pattern:getVqual: +   :isVirtual:False
> [0:integer]
> 
> **** getVqual:initial:afterATd:+ 1
> **   OGSx:[0:integer]
> **** savedOGS:save:False[0:integer]
> **   OI: + 1
> **   OI:getQual:savedOI:+ 1
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:integer]
> **   OGS:[0:integer]
> **** DataItem:getVqual: out R: var integer
> [0:integer,nest(+)]
> **** ObjectGenerator:getVqual: integer
> **   hasVirtualArgs: False
> **** INV:getVqual:integer
> **   OGs: [0:integer,nest(+)]
> 
> **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:integer,nest(+)]
> **   encOG: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** koks: integer on: 2 Items 
> **   father: integer
> **   father.f.f.f.f:
> 
> %basic 61
>    in V: var integer
>    out R: var integer
> **** ENC:OI.getVqual:[1:integer,nest(+)]
> **   ENC:result:[1:integer]
> **** ENC:OI.getVqual:[2:integer]
> **   ENC:result:[2:BETA]
> 
> **** getVqual:B2:
> [0:BETA]
> ---
> 
> integer: value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** Pattern:getVqual: integer :isVirtual:False
> [0:BETA]
> 
> **** getVqual:cont:afterATd:qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: integer
> **   OI:getQual:savedOI:integer
> **   IT: var [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
> **** OI:getVqual:end: integer
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** OI:getVqual:return: out R: var integer
> **   qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> [0:BETA]
> **** OI:getVqual:end: + 1
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: +
> **** qual:
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> **** OGS:
> [0:BETA]
> **** checkOI:after:getVqual:OF: + qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** OGS:
> [0:BETA]
> **** next:basicScope:from:+
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   BinaryExp:checkOI:after:left:L + 1 - inx
> **   OGS: [0:BETA]
> **** ObjectInvocation:checkOI: - inx  isFirst:False
> **** basicScope:A:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** ObjectInvocation:check: - inx
> **** Items:search: "-" isFirst:False
> **   in: 
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> 
> **** Items:localSearch: -
> **   in:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   isChecked: True
> **   Items:localSearch:Decls: -
> Try: "_thisBasicValue"
> Try: "+"
> Try: "-"
> **** Items:localSearch:end: -
> **** Items:search:end: -
> **** Found: "-" on=0 pn=0 Decl: "-  " visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** computing:encOG:BS.father=encOG:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** encOG:False
513685c514415
< **** OI:getVqual: + 1 - inx on=0 pn=0 isNest=True getRtnQual=False
---
> **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
513711c514441
< **** koks: + 1 - inx on: 0 Items 
---
> **** koks: - inx on: 0 Items 
513716,513717c514446,514447
<    i := L + 1 - inx
<    put('0' + D.get[i])
---
> i := L + 1 - inx
> put('0' + D.get[i])
513723,513724c514453,514454
< +  : 
<    %basic 61
---
> -  : 
>    %basic 62
513727c514457
< **** Pattern:getVqual: +   :isVirtual:False
---
> **** Pattern:getVqual: -   :isVirtual:False
513731c514461
< %basic 61
---
> %basic 62
513736,513738c514466,514468
< **   OI: + 1 - inx
< **   OI:getQual:savedOI:+ 1 - inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   OI: - inx
> **   OI:getQual:savedOI:- inx
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
513742c514472
< [0:BETA,nest(integer),nest(+)]
---
> [0:BETA,nest(integer),nest(-)]
513746c514476
< **   OGs: [0:BETA,nest(integer),nest(+)]
---
> **   OGs: [0:BETA,nest(integer),nest(-)]
513749c514479
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
---
> **   OGS:continued:[0:BETA,nest(integer),nest(-)]
513761c514491
< %basic 61
---
> %basic 62
513764c514494
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
---
> **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(-)]
513867c514597
< **** OI:getVqual:end: + 1 - inx
---
> **** OI:getVqual:end: - inx
513877c514607
< **** checkOI:checkOI:after:getVqual: +
---
> **** checkOI:checkOI:after:getVqual: -
513946c514676
< **** checkOI:after:getVqual:OF: + qual:
---
> **** checkOI:after:getVqual:OF: - qual:
513962c514692
< **** next:basicScope:from:+
---
> **** next:basicScope:from:-
513970,513971d514699
< **** INV:check:i=2 rec:+ 1 - inx label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
513975,513977c514703,514708
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
514454c515185
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
514455a515187,515188
> **** BinaryExp:checkOI:n - 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
514650c515383
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
514756c515489
< **** INV:check:i=1 rec:n label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:n - 1
514866c515599
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
515098,515099d515830
< **** INV:check:i=2 rec:- 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
515103,515105c515834,515839
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
515559c516293
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
515560a516295,516296
> **** BinaryExp:checkOI:R * F
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
515883c516619
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
515979c516715
< **** INV:check:i=1 rec:R label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:R * F
516087c516823
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
516299,516300d517034
< **** INV:check:i=2 rec:* F label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
516304,516306c517038,517043
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
516720c517457
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
516721a517459,517460
> **** BinaryExp:checkOI:n - 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
516932c517671
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
517038c517777
< **** INV:check:i=1 rec:n label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:n - 1
517148c517887
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
517380,517381d518118
< **** INV:check:i=2 rec:- 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
517385,517387c518122,518127
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
517853c518593
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
517854a518595,518596
> **** BinaryExp:checkOI:R * F
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
518185c518927
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
518281c519023
< **** INV:check:i=1 rec:R label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:R * F
518389c519131
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
518601,518602d519342
< **** INV:check:i=2 rec:* F label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
518606,518608c519346,519351
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
519862c520605
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
519863a520607,520608
> **** BinaryExp:checkOI:rest * 10.0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
520153c520898
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
520249c520994
< **** INV:check:i=1 rec:rest label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:rest * 10.0
520338,520340c521083,521085
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
---
> Irest := rest
> if (Irest = 0) :then 
>    lz := lz + 1
520361c521106
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
520573,520574d521317
< **** INV:check:i=2 rec:* 10.0 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
520578,520580c521321,521326
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
521444c522190
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
521445a522192,522193
> **** BinaryExp:checkOI:Irest = 0
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
521842c522590
< **** INV:check:i=1 rec:Irest label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:Irest = 0
521961,521963c522709
< 
< if (Irest = 0) :then 
<    lz := lz + 1
---
> (Irest = 0)
522089c522835
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
522281,522282d523026
< **** INV:check:i=2 rec:= 0 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
522286,522289c523030,523035
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
522773c523519
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
522774a523521,523522
> **** BinaryExp:checkOI:lz + 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
523107c523855
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
523213c523961
< **** INV:check:i=1 rec:lz label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:lz + 1
523319c524067
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
523551,523552d524298
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
523556,523558c524302,524307
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
527188c527937
< **** INV:check:i=0 rec:none label: BracketedExp
---
> **** INV:check:i=0 rec:none label: BinOp
527189a527939,527940
> **** BinaryExp:checkOI:(ch > '0') || (inx = S.length)
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
527197c527948
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
527198a527950,527951
> **** BinaryExp:checkOI:ch > '0'
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
527664c528417
< **** INV:check:i=1 rec:ch label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:ch > '0'
527754c528507
< ((ch > '0') || (inx = S.length))
---
> (ch > '0') || (inx = S.length)
527775c528528
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
527933,527935c528686
< **** INV:check:i=2 rec:> '0' label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** INV:check:i=1 rec:(ch > '0') label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:(ch > '0') || (inx = S.length)
528023c528774
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
528181,528182d528931
< **** INV:check:i=2 rec:|| (inx = S.length) label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
528186,528188c528935,528940
< %basic 63
< in B: var boolean
< out R: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
528797a529550,529555
> **** INV:check:i=0 rec:none label: BinOp
> **   OGS: none
> **** BinaryExp:checkOI:S.length - inx + 1
> **   leftRec.label:BinOp M.label: ObjectInvocation_Binary  OGS: none
> **** Invocation:checkOI:S.length
> **** Invocation:check: S.length
529382c530140
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BinOp [savedOGS <> none and IT.isDecl: ]
529627c530385
< **   father: S.length - inx + 1
---
> **   father: S.length
529629,529631c530387
< 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
---
> S.length - inx + 1
529650c530406
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BinOp [savedOGS <> none and IT.isDecl: ]
529877c530633
< **** INV:check:i=2 rec:length label: ObjectInvocation_Binary
---
> **** INV:check:i=2 rec:length label: ObjectInvocation_Unary
529879c530635
< **** ObjectInvocation:checkOI: - inx + 1  isFirst:False
---
> **** ObjectInvocation:checkOI: - inx  isFirst:False
529888c530644
< **** ObjectInvocation:check: - inx + 1
---
> **** ObjectInvocation:check: - inx
529925c530681
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **   OGS: none
529934,529935c530690
< **** OI:getVqual: - inx + 1 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
529943c530698,530699
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> 
> **** OI:getVqual:initial:- inx
529951,529952c530707,530733
< **   OI:getVqual:findEnc:i=2 OGSz:[0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **   encOG:
---
> **   OGs:[0:integer]
> **   ATd: 
> -  : 
>    %basic 62
>    in V: var integer
>    out R: var integer
> **** Pattern:getVqual: -   :isVirtual:False
> [0:integer]
> 
> **** getVqual:initial:afterATd:- inx
> **   OGSx:[0:integer]
> **** savedOGS:save:False[0:integer]
> **   OI: - inx
> **   OI:getQual:savedOI:- inx
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:integer]
> **   OGS:[0:integer]
> **** DataItem:getVqual: out R: var integer
> [0:integer,nest(-)]
> **** ObjectGenerator:getVqual: integer
> **   hasVirtualArgs: False
> **** INV:getVqual:integer
> **   OGs: [0:integer,nest(-)]
> 
> **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:integer,nest(-)]
> **   encOG: 
529959,529960c530740,530765
< **   OI:getVqual:findEnc:i=3 OGSz:[0:BETAworld,nest(LIB),nest(StringLib)]
< **   encOG:
---
> **** koks: integer on: 2 Items 
> **   father: integer
> **   father.f.f.f.f:
> 
> %basic 62
>    in V: var integer
>    out R: var integer
> **** ENC:OI.getVqual:[1:integer,nest(-)]
> **   ENC:result:[1:integer]
> **** ENC:OI.getVqual:[2:integer]
> **   ENC:result:[2:BETA]
> 
> **** getVqual:B2:
> [0:BETA]
> ---
> 
> integer: value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** Pattern:getVqual: integer :isVirtual:False
> [0:BETA]
> 
> **** getVqual:cont:afterATd:qual:
529967,529968c530772,531011
< **   OI:getVqual:findEnc:i=4 OGSz:[0:BETAworld,nest(LIB)]
< **   encOG:
---
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: integer
> **   OI:getQual:savedOI:integer
> **   IT: var [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
> **** OI:getVqual:end: integer
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** OI:getVqual:return: out R: var integer
> **   qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> [0:BETA]
> **** OI:getVqual:end: - inx
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: -
> **** qual:
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> **** OGS:
> [0:BETA]
> **** checkOI:after:getVqual:OF: - qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** OGS:
> [0:BETA]
> **** next:basicScope:from:-
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   BinaryExp:checkOI:after:left:S.length - inx + 1
> **   OGS: [0:BETA]
> **** ObjectInvocation:checkOI: + 1  isFirst:False
> **** basicScope:A:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** ObjectInvocation:check: + 1
> **** Items:search: "+" isFirst:False
> **   in: 
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> 
> **** Items:localSearch: +
> **   in:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   isChecked: True
> **   Items:localSearch:Decls: +
> Try: "_thisBasicValue"
> Try: "+"
> **** Items:localSearch:end: +
> **** Items:search:end: +
> **** Found: "+" on=0 pn=0 Decl: "+  " visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** computing:encOG:BS.father=encOG:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** encOG:False
> **   OGS: [0:BETA]
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> 
> **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
> **   OGS:continued:[0:BETA]
> **   encOG: 
529975c531018
< **   OI:getVqual:findEnc:i=5 OGSz:[0:BETAworld]
---
> **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
529991,529992c531034,531035
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** koks: - inx + 1 on: 0 Items 
---
> [0:BETA,nest(integer)]
> **** koks: + 1 on: 0 Items 
529997c531040
<    leave(elimTrailingBlanks)
---
> leave(elimTrailingBlanks)
530000c531043
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
---
> [0:BETA,nest(integer)]
530003,530004c531046,531047
< -  : 
<    %basic 62
---
> +  : 
>    %basic 61
530007,530008c531050,531051
< **** Pattern:getVqual: -   :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
---
> **** Pattern:getVqual: +   :isVirtual:False
> [0:BETA,nest(integer)]
530011c531054
< %basic 62
---
> %basic 61
530014,530020c531057,531063
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   OI: - inx + 1
< **   OI:getQual:savedOI:- inx + 1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
---
> [0:BETA,nest(integer)]
> **** savedOGS:save:False[0:BETA,nest(integer)]
> **   OI: + 1
> **   OI:getQual:savedOI:+ 1
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA,nest(integer)]
> **   OGS:[0:BETA,nest(integer)]
530022c531065
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
---
> [0:BETA,nest(integer),nest(+)]
530026c531069
< **   OGs: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
---
> **   OGs: [0:BETA,nest(integer),nest(+)]
530029c531072
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
---
> **   OGS:continued:[0:BETA,nest(integer),nest(+)]
530041c531084
< %basic 62
---
> %basic 61
530044,530047c531087,531090
< **** ENC:OI.getVqual:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   ENC:result:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** ENC:OI.getVqual:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   ENC:result:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
> **   ENC:result:[1:BETA,nest(integer)]
> **** ENC:OI.getVqual:[2:BETA,nest(integer)]
> **   ENC:result:[2:BETA]
530050c531093
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> [0:BETA]
530060c531103
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> [0:BETA]
530069,530070c531112,531113
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
530074,530075c531117,531118
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
530085c531128
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **   OGS:[0:BETA]
530146,530147c531189,531190
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** OI:getVqual:end: - inx + 1
---
> [0:BETA]
> **** OI:getVqual:end: + 1
530156,530157c531199,531200
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** checkOI:checkOI:after:getVqual: -
---
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: +
530225,530226c531268,531269
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** checkOI:after:getVqual:OF: - qual:
---
> [0:BETA]
> **** checkOI:after:getVqual:OF: + qual:
530241,530242c531284,531285
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** next:basicScope:from:-
---
> [0:BETA]
> **** next:basicScope:from:+
530250,530251d531292
< **** INV:check:i=3 rec:- inx + 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
530255,530257c531296,531301
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
537639c538683
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
537640a538685,538686
> **** BinaryExp:checkOI:exp - 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
537822c538868
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
537928c538974
< **** INV:check:i=1 rec:exp label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:exp - 1
538046c539092
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
538278,538279d539323
< **** INV:check:i=2 rec:- 1 label: ObjectInvocation_Binary
< **   OGS: [0:Unit,nest($0)]
538283,538285c539327,539332
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
539052c540099
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
539053a540101,540102
> **** BinaryExp:checkOI:R.magnitude * magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
539405c540454
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
539522,539523d540570
< **** INV:check:i=1 rec:R label: ObjectInvocation_Unary
< **   OGS: [0:Unit&]
539604c540651
< **   father: R.magnitude * magnitude
---
> **   father: R.magnitude
539684c540731
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
539780c540827
< **** INV:check:i=2 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:R.magnitude * magnitude
539898c540945
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
540110,540111d541156
< **** INV:check:i=3 rec:* magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Unit&]
540115,540117c541160,541165
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
540522c541570
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
540523a541572,541573
> **** BinaryExp:checkOI:exp - 1
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
540725c541775
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
540831c541881
< **** INV:check:i=1 rec:exp label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:exp - 1
540949c541999
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
541181,541182d542230
< **** INV:check:i=2 rec:- 1 label: ObjectInvocation_Binary
< **   OGS: [0:Unit,nest($0)]
541186,541188c542234,542239
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
541967c543018
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
541968a543020,543021
> **** BinaryExp:checkOI:R.magnitude * magnitude
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
542328c543381
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
542445,542446d543497
< **** INV:check:i=1 rec:R label: ObjectInvocation_Unary
< **   OGS: [0:Unit&]
542527c543578
< **   father: R.magnitude * magnitude
---
> **   father: R.magnitude
542607c543658
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
542703c543754
< **** INV:check:i=2 rec:magnitude label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:R.magnitude * magnitude
542821c543872
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
543033,543034d544083
< **** INV:check:i=3 rec:* magnitude label: ObjectInvocation_Binary
< **   OGS: [0:Unit&]
543038,543040c544087,544092
< %basic 112
< in V: var float
< out R: var float
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
571529c572581
< **   ENC:result:[2:&&$0]
---
> **   ENC:result:[2:emptyOG]
571531c572583
< **** PRE: [1:&&$0]
---
> **** PRE: [1:emptyOG]
571547,571549c572599,572611
< **   pathToSuper:DOG.super.scanSons:i=1:E:theSchedule :isImplSuper=False
< *** got:innerDOG:2 E.elm.isEmpty.not**   pathToSuper:E:"
< forAll(
---
> **** pathToSuper:got:BinaryExp:
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
>       E.elm.exists(
>          in Ex: ref Expert
>          out R: var Boolean
>          R := Ex.quali.has(A.reqQuali))))
> **** innerDog: E.elm.isEmpty.not
> **   leftRef:son: theSchedule
> **   leftRef:son: forAll(
571551c572613,572623
< " E.on=0 E.pn=1 DOG.super.pn=0 isR=True
---
> **   leftRef:arg:X: name: forAll
> **   leftRef:arg:X: name: (
> **   leftRef:arg:X: ObjectGenerator E.elm.isEmpty.not
> *** got:innerDOG:leftRec:1 E.elm.isEmpty.not**   pathToSuper:E:"
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
> ...
> " E.on=0 E.pn=0 DOG.super.pn=0 isR=False
571553,571560c572625,572629
< forAll(
<    E.elm.isEmpty.not)
< " :on=0:pn=1:isR=True:ptn.isVirt=False ptn:
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
---
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
571562c572631,572638
< **   PRE:onx,pnx,isR:0,1,True OGx:
---
> " :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
> Object: 
>    %ID Object
>    %basic 64
>    %public
>    ==  : 
> ...
> **   PRE:onx,pnx,isR:0,0,False OGx:
571564,571568c572640,572644
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
571570,571574c572646,572649
< **   PRE:result:[1:&&$0,r:forAll]
< **   ENC:result:[1:&&$0,r:forAll]
< **** ENC:OI.getVqual:[2:&&$0,r:forAll]
< **** Remote:[2:&&$0]
< **   DOGx: 
---
> **   PRE:result:[1:emptyOG,Object]
> **   ENC:result:[1:emptyOG,Object]
> **** ENC:OI.getVqual:[2:emptyOG,Object]
> **** pathToSuper: "
571581,571600c572656,572661
< **   remote:scanSons:E:"theSchedule" E.ATd.label:ref E.on: 1 E.pn: 0 E.ATd:
< in theSchedule: ref Schedule
< **   remote:first:
< **** ENC:remote:[3:&&$0]
< **   ENC:result:[3:PlantInvA]
< **** append:label: ref dcl: in theSchedule: ref Schedule
< **   isEmpty: True
< **   hasVargs: True
< **   append:scan:E: "Schedule" on=1 E.pn=0 E.ATd.OG: "
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** ENC:append:[3:PlantInvA]
< **   ENC:result:[3:Plant]
< **   append:END:
< **** remote:got:superDOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
---
> " of:DOG:
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
571602,571604c572663,572720
< remote:[2:Plant,nest(Schedule)]
< **** remote:END[2:Plant,nest(Schedule)]
< **   ENC:result:[2:Plant,nest(Schedule)]
---
> **   innerDOG: E.elm.isEmpty.not
> **** pathToSuper:got:BinaryExp:
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
>       E.elm.exists(
>          in Ex: ref Expert
>          out R: var Boolean
>          R := Ex.quali.has(A.reqQuali))))
> **** innerDog: E.elm.isEmpty.not
> **   leftRef:son: theSchedule
> **   leftRef:son: forAll(
>    E.elm.isEmpty.not)
> **   leftRef:arg:X: name: forAll
> **   leftRef:arg:X: name: (
> **   leftRef:arg:X: ObjectGenerator E.elm.isEmpty.not
> *** got:innerDOG:leftRec:1 E.elm.isEmpty.not**   pathToSuper:E:"
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
> ...
> " E.on=0 E.pn=0 DOG.super.pn=0 isR=False
> **   pathToSuper:end:super.last: "
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
> ...
> " :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
> Object: 
>    %ID Object
>    %basic 64
>    %public
>    ==  : 
> ...
> **   ENC:pred:  pred.DOG: 
> theSchedule.forAll(
>    E.elm.isEmpty.not) && theAlarms.forAll(
>    in A: ref Alarm
>    out BB: var Boolean
>    BB := theSchedule.forAll(
> ...
> **   OGsuper: 
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
> **** ENC:OI.getVqual:[3:emptyOG]
> **   ENC:result:[3:PlantInvA]
> **   ENC:[pnx=0]oENC[onx=0]
> **   ENC:result:[2:PlantInvA]
571607c572723
< [0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
571614c572730
< [0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
571619,571620c572735,572736
< [0:Plant,nest(Schedule)]
< **** savedOGS:save:False[0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
> **** savedOGS:save:False[0:PlantInvA]
571624,571625c572740,572741
< **   savedOGS: [0:Plant,nest(Schedule)]
< **   OGS:[0:Plant,nest(Schedule)]
---
> **   savedOGS: [0:PlantInvA]
> **   OGS:[0:PlantInvA]
571631c572747
< **   OGS:[0:Plant,nest(Schedule)]
---
> **   OGS:[0:PlantInvA]
571634,571635c572750,572751
< **   OGSx:[0:Plant,nest(Schedule)]
< **** savedOGS:save:False[0:Plant,nest(Schedule)]
---
> **   OGSx:[0:PlantInvA]
> **** savedOGS:save:False[0:PlantInvA]
571639,571640c572755,572756
< **   savedOGS: [0:Plant,nest(Schedule)]
< **   OGS:[0:Plant,nest(Schedule)]
---
> **   savedOGS: [0:PlantInvA]
> **   OGS:[0:PlantInvA]
571646c572762
< **   OGS:[0:Plant,nest(Schedule)]
---
> **   OGS:[0:PlantInvA]
571655c572771
< [0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
571663c572779
< [0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
571669c572785
< **   OGS: [0:Plant,nest(Schedule)]
---
> **   OGS: [0:PlantInvA]
571699c572815
< **   OGS: [0:Plant,nest(Schedule)]
---
> **   OGS: [0:PlantInvA]
571705c572821
< **   OGS:continued:[0:Plant,nest(Schedule)]
---
> **   OGS:continued:[0:PlantInvA]
571709,571713c572825
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Plant,nest(Schedule)]
< **   encOG:
< in inx: ref Domain
<    in elm: ref Range
< **   OI:getVqual:findEnc:i=2 OGSz:[0:Plant]
---
> **   OI:getVqual:findEnc:i=1 OGSz:[0:PlantInvA]
571721c572833
< [0:Plant,nest(Schedule),nest(Entry)]
---
> [0:PlantInvA,nest(Entry)]
571730c572842
< [0:Plant,nest(Schedule),nest(Entry)]
---
> [0:PlantInvA,nest(Entry)]
571734c572846
< [0:Plant,nest(Schedule),nest(Entry)]
---
> [0:PlantInvA,nest(Entry)]
571738c572850
< **   OGs: [0:Plant,nest(Schedule),nest(Entry)]
---
> **   OGs: [0:PlantInvA,nest(Entry)]
571741c572853
< **   OGS:continued:[0:Plant,nest(Schedule),nest(Entry)]
---
> **   OGS:continued:[0:PlantInvA,nest(Entry)]
571751,571752c572863,572864
< **** ENC:OI.getVqual:[1:Plant,nest(Schedule),nest(Entry)]
< **   ENC:result:[1:Plant,nest(Schedule)]
---
> **** ENC:OI.getVqual:[1:PlantInvA,nest(Entry)]
> **   ENC:result:[1:PlantInvA]
571755c572867
< [0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
571759c572871
< [0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
571761c572873
< [0:Plant,nest(Schedule)]
---
> [0:PlantInvA]
571764,571767c572876,572883
< [0:Plant,nest(Schedule)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
---
> [0:PlantInvA]
> **   checkDOG: PlantInvA 
> out B: var Boolean
>    B := theSchedule.forAll(
>       E.elm.isEmpty.not) && theAlarms.forAll(
>       in A: ref Alarm
>       out BB: var Boolean
> ...
571769,571771c572885,572891
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
---
> PlantInvA: 
>    out B: var Boolean
>    B := theSchedule.forAll(
>       E.elm.isEmpty.not) && theAlarms.forAll(
>       in A: ref Alarm
> ...
> **   Ex: 
571774,571778c572894,572898
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
571780,571790c572900
< **   currentArg: in Domain:< Object
< **   currentArg: in Range:< Object
< **   superArg: ObjectGenerator #Experts
< 
< ==== FOUND BINDING IN ARG: 
< #Experts
< **** newFindBinding:found: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> !!!! No binding found in OGsequence! Use: in Range:< Object
571792,571795c572902,572907
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
571798,571803c572910,572917
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:Plant,nest(Schedule&)]
< **** savedOGS:save:False[0:Plant,nest(Schedule&)]
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
> [0:PlantInvA]
> **** savedOGS:save:False[0:PlantInvA]
571807,571808c572921,572922
< **   savedOGS: [0:Plant,nest(Schedule&)]
< **   OGS:[0:Plant,nest(Schedule&)]
---
> **   savedOGS: [0:PlantInvA]
> **   OGS:[0:PlantInvA]
571811,571814c572925,572930
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
571816c572932
< **   OGS:[0:Plant,nest(Schedule&)]
---
> **   OGS:[0:PlantInvA]
571819,571824c572935,572942
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:Plant,nest(Schedule&)]
< **** savedOGS:save:False[0:Plant,nest(Schedule&)]
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
> [0:PlantInvA]
> **** savedOGS:save:False[0:PlantInvA]
571828,571829c572946,572947
< **   savedOGS: [0:Plant,nest(Schedule&)]
< **   OGS:[0:Plant,nest(Schedule&)]
---
> **   savedOGS: [0:PlantInvA]
> **   OGS:[0:PlantInvA]
571832,571835c572950,572955
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
571837c572957
< **   OGS:[0:Plant,nest(Schedule&)]
---
> **   OGS:[0:PlantInvA]
571841,571848c572961,572995
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
>       in objx: ref Object
>       out V: var boolean
>    =/=  : 
>       %basic 57
>       in objx: ref Object
>       out V: var boolean
>    suspend: 
>       %basic 111
>    attach: 
>       %basic 10
>       in V: var integer
>    call: 
>       %basic 113
>    onResume: 
>       %basic 119
>    onSuspend: 
>       %basic 120
>    dumpObj: 
>       %basic 140
>       out R: ref Indexed
>    X_asString:<  -- does not wokr, problem with virtual in Object
>       out S: var LIB.StringLib.String
>       inner(X_asString)
>    inner(Object)
571850c572997
< [0:Plant,nest(Schedule&)]
---
> [0:PlantInvA]
571852,571855c572999,573004
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
571857,571859c573006,573011
< print: 
<    scan
<       current.print
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
571861c573013
< [0:Plant,nest(Schedule&)]
---
> [0:PlantInvA]
571864,571866c573016,573021
< print: 
<    scan
<       current.print
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
571868c573023
< **   OGS: [0:Plant,nest(Schedule&)]
---
> **   OGS: [0:PlantInvA]
571872,571874c573027,573032
< print: 
<    scan
<       current.print
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
571879,571881c573037,573042
< print: 
<    scan
<       current.print
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
571886,571888c573047,573052
< print: 
<    scan
<       current.print
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
571891,571892c573055,573064
< Try: "print"
< **** Signature:localSearch: isEmpty in: Experts
---
> Try: "=="
> Try: "=/="
> Try: "suspend"
> Try: "attach"
> Try: "call"
> Try: "onResume"
> Try: "onSuspend"
> Try: "dumpObj"
> Try: "X_asString"
> **** Signature:localSearch: isEmpty in: Object
571900,571902c573072,573075
< **   Items:localSearch:trySuper:
< **** Items:localSearch: isEmpty
< **   in:
---
> **** Items:localSearch:end: isEmpty
> **** Items:searchEmbodied: isEmpty
> **   Items:searchEmbodied:end:
> **** Items:searchIncludeProp: isEmpty in: 
571904,571908c573077,573081
< %globals
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
571910,571915c573083,573091
< **   isChecked: True
< **   Items:localSearch:Decls: isEmpty
< Try: "has"
< Try: "isEmpty"
< **** Items:localSearch:end: isEmpty
< **** Items:localSearch:end: isEmpty
---
> **   origin: 
> 
> %ID BETA
> %OSDvisibility disguised
> %module LIB, LIB.StringLib
> %public
> Object: 
> ...
> **** Items:searchIncludeProp:end: isEmpty
571917,571918c573093,573103
< **** Found: "isEmpty" on=0 pn=1 Decl: "isEmpty" visibility: "public"
< **   encModule: "workspace" domainModule: "BETAworld"
---
> **** checkIfOneBasicDecl: isEmpty
> 
> Semantic error in module: "tinyY"
> 
>       PlantInvA: 
>          out B: var Boolean
>          B := theSchedule.forAll(
>             E.elm.isEmpty.not) && theAlarms.forAll(
> 
> **** Did NOT find a declaration of: "isEmpty"
> 
571920,571923c573105,573110
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
571925c573112
< **   OGS: [0:Plant,nest(Schedule&)]
---
> **   OGS: [0:PlantInvA]
571927,571930c573114,573119
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
571932,571933c573121,573122
< **** OI:getVqual: isEmpty on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:Plant,nest(Schedule&)]
---
> **** OI:getVqual: isEmpty on=0 pn=0 isNest=True getRtnQual=False
> **   OGS:continued:[0:PlantInvA]
571935,571939c573124,573130
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Plant,nest(Schedule&)]
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
> **   OI:getVqual:findEnc:i=1 OGSz:[0:PlantInvA]
571941,571944c573132,573137
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
571947,571951c573140,573146
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:Plant,nest(Schedule&),nest(Experts)]
---
> %ID Object
>    %basic 64
>    %public
>    ==  : 
>       %basic 56
> ...
> [0:PlantInvA,nest(Object)]
571958,571982d573152
< **** PRE: [0:Plant,nest(Schedule&),nest(Experts)]
< **** pathToSuper: "SetLib.Set(#Expert)" of:DOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Expert) :isImplSuper=False
< **   pathToSuper:E:"Set(#Expert)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Expert)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:Plant,nest(Schedule&),nest(Experts),r:Set]
571985c573155
< [0:Plant,nest(Schedule&),nest(Experts),r:Set]
---
> [0:PlantInvA,nest(Object)]
571988,571992c573158,573161
< isEmpty: 
<    out B: var Boolean
<    B := head == none
< **** Pattern:getVqual: isEmpty :isVirtual:False
< [0:Plant,nest(Schedule&),nest(Experts),r:Set]
---
> error: 
>    %basic 999
> **** Pattern:getVqual: error :isVirtual:False
> [0:PlantInvA,nest(Object)]
571994,571998c573163,573165
< **** getVqual:cont:afterATd:qual:
< out B: var Boolean
<    B := head == none
< [0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **** savedOGS:save:False[0:Plant,nest(Schedule&),nest(Experts),r:Set]
---
> **** getVqual:cont:afterATd:qual:%basic 999
> [0:PlantInvA,nest(Object)]
> **** savedOGS:save:False[0:PlantInvA,nest(Object)]
572002,572081c573169,573170
< **   savedOGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **** DataItem:getVqual: out B: var Boolean
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(isEmpty)]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(isEmpty)]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(isEmpty)]
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(isEmpty)]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(isEmpty)]
< **** ENC:OI.viaInclude:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(isEmpty)]
< **   ENC:result:[0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **** viaInclude:GOT:
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **** savedOGS:save:False[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **** OI:getVqual:return: out B: var Boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
---
> **   savedOGS: [0:PlantInvA,nest(Object)]
> **   OGS:[0:PlantInvA,nest(Object)]
572083,572089c573172
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
---
> **   qual: %basic 999
572091c573174
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
---
> **   OGS:[0:PlantInvA,nest(Object)]
572094,572121c573177,573178
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
---
> %basic 999
> %basic 999
572123,572137c573180,573182
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **** checkOI:after:getVqual:OF: isEmpty qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   basicScope: 
< %id "Boolean"
< %globals inSub
< %basic 4, 8
< %public
< _thisBasicValue: var Universal
< ...
---
> [0:PlantInvA,nest(Object)]
> **** checkOI:after:getVqual:OF: isEmpty qual:%basic 999
> **   basicScope: %basic 999
572139c573184
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
---
> [0:PlantInvA,nest(Object)]
572141,572147c573186
< **   basicScope: 
< %id "Boolean"
< %globals inSub
< %basic 4, 8
< %public
< _thisBasicValue: var Universal
< ...
---
> **   basicScope: %basic 999
572149c573188
< **   OGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
---
> **   OGS: [0:PlantInvA,nest(Object)]
572152,572158c573191
< 
< %id "Boolean"
< %globals inSub
< %basic 4, 8
< %public
< _thisBasicValue: var Universal
< ...
---
> %basic 999
572161a573195,573203
> %basic 999
> **** Items:localSearch: not
> **   in:
> %basic 999
> **   isChecked: True
> **   Items:localSearch:Decls: not
> **** Signature:localSearch: not in: error
> **** Items:localSearch: not
> **   in:
572163,572169c573205,573209
< %id "Boolean"
< %globals inSub
< %basic 4, 8
< %public
< _thisBasicValue: var Universal
< ...
< 
---
> **   isChecked: True
> **   Items:localSearch:Decls: not
> **** Items:localSearch:end: not
> **** Signature:localSearch:end: not
> **   Items:localSearch:trySuper:
572173,572175c573213,573214
< %id "Boolean"
< %globals inSub
< %basic 4, 8
---
> %ID Object
> %basic 64
572177c573216,573217
< _thisBasicValue: var Universal
---
> ==  : 
>    %basic 56
572181,572185c573221,573235
< Try: "_thisBasicValue"
< Try: "&&"
< Try: "||"
< Try: "=?"
< Try: "not"
---
> Try: "=="
> Try: "=/="
> Try: "suspend"
> Try: "attach"
> Try: "call"
> Try: "onResume"
> Try: "onSuspend"
> Try: "dumpObj"
> Try: "X_asString"
> **** Signature:localSearch: not in: Object
> **** Items:localSearch: not
> **   in:
> 
> **   isChecked: True
> **   Items:localSearch:Decls: not
572187,572198c573237,573243
< **** Items:search:end: not
< **** Found: "not" on=0 pn=0 Decl: "not" visibility: "public"
< **   encModule: "workspace" domainModule: "BETAworld"
< **** computing:encOG:BS.father=encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** encOG:False
< **   OGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
---
> **** Signature:localSearch:end: not
> **** Items:localSearch:end: not
> **** Items:localSearch:end: not
> **** Items:searchEmbodied: not
> **   Items:searchEmbodied:end:
> **** Items:searchIncludeProp: not in: 
> %basic 999**   origin: 
572200,572204c573245,573249
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
---
> %id "BETAworld"
> %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
> error: 
>    %basic 999
> --BETA
572205a573251,573253
> **** Items:searchIncludeProp:end: not
> **** Items:search:end: not
> **** checkIfOneBasicDecl: not
572207,572249c573255
< **** OI:getVqual: not on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(Experts)]
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   OI:getVqual:findEnc:i=3 OGSz:[0:Plant,nest(Schedule&),nest(Experts)]
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   OI:getVqual:findEnc:i=4 OGSz:[0:Plant,nest(Schedule&)]
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ***** OI:getVqual:findEnc:match!:
< [0:Plant,nest(Schedule&)]
---
> Semantic error in module: "tinyY"
572251,572258c573257,573275
< **** getVqual:added:isNest:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Plant,nest(Schedule&),nest(Boolean)]
---
>       PlantInvA: 
>          out B: var Boolean
>          B := theSchedule.forAll(
>             E.elm.isEmpty.not) && theAlarms.forAll(
> 
> **** Did NOT find a declaration of: "not"
> 
> **** computing:encOG:BS.father=encOG:%basic 999
> **** encOG:False
> **   OGS: [0:PlantInvA,nest(Object)]
> %basic 999
> 
> **** OI:getVqual: not on=0 pn=0 isNest=True getRtnQual=False
> **   OGS:continued:[0:PlantInvA,nest(Object)]
> **   encOG: %basic 999
> **   OI:getVqual:findEnc:i=1 OGSz:[0:PlantInvA,nest(Object)]
> **   encOG:%basic 999**   OI:getVqual:findEnc:i=2 OGSz:[0:PlantInvA]
> **   encOG:%basic 999
> **** getVqual:added:isNest:%basic 999[0:PlantInvA,nest(Object),nest(error)]
572267c573284
< [0:Plant,nest(Schedule&),nest(Boolean)]
---
> [0:PlantInvA,nest(Object),nest(error)]
572270,572274c573287,573290
< not: 
<    %basic 65
<    out R: var boolean
< **** Pattern:getVqual: not :isVirtual:False
< [0:Plant,nest(Schedule&),nest(Boolean)]
---
> error: 
>    %basic 999
> **** Pattern:getVqual: error :isVirtual:False
> [0:PlantInvA,nest(Object),nest(error)]
572276,572280c573292,573294
< **** getVqual:cont:afterATd:qual:
< %basic 65
<    out R: var boolean
< [0:Plant,nest(Schedule&),nest(Boolean)]
< **** savedOGS:save:False[0:Plant,nest(Schedule&),nest(Boolean)]
---
> **** getVqual:cont:afterATd:qual:%basic 999
> [0:PlantInvA,nest(Object),nest(error)]
> **** savedOGS:save:False[0:PlantInvA,nest(Object),nest(error)]
572284,572373c573298,573299
< **   savedOGS: [0:Plant,nest(Schedule&),nest(Boolean)]
< **   OGS:[0:Plant,nest(Schedule&),nest(Boolean)]
< **** DataItem:getVqual: out R: var boolean
< [0:Plant,nest(Schedule&),nest(Boolean),nest(not)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Plant,nest(Schedule&),nest(Boolean),nest(not)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant,nest(Schedule&),nest(Boolean),nest(not)]
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 65
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Plant,nest(Schedule&),nest(Boolean),nest(not)]
< **   ENC:result:[1:Plant,nest(Schedule&),nest(Boolean)]
< **** ENC:OI.getVqual:[2:Plant,nest(Schedule&),nest(Boolean)]
< **   ENC:result:[2:Plant,nest(Schedule&)]
< 
< **** getVqual:B2:
< [0:Plant,nest(Schedule&)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(Schedule&)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Plant,nest(Schedule&)]
< **** savedOGS:save:False[0:Plant,nest(Schedule&)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(Schedule&)]
< **   OGS:[0:Plant,nest(Schedule&)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(Schedule&)]
< **** OI:getVqual:return: out R: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Plant,nest(Schedule&)]
---
> **   savedOGS: [0:PlantInvA,nest(Object),nest(error)]
> **   OGS:[0:PlantInvA,nest(Object),nest(error)]
572375,572381c573301
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
---
> **   qual: %basic 999
572383c573303
< **   OGS:[0:Plant,nest(Schedule&)]
---
> **   OGS:[0:PlantInvA,nest(Object),nest(error)]
572386,572413c573306,573307
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
---
> %basic 999
> %basic 999
572415,572429c573309,573311
< [0:Plant,nest(Schedule&)]
< **** checkOI:after:getVqual:OF: not qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   basicScope: 
< %id "Boolean"
< %globals inSub
< %basic 4, 8
< %public
< _thisBasicValue: var Universal
< ...
---
> [0:PlantInvA,nest(Object),nest(error)]
> **** checkOI:after:getVqual:OF: not qual:%basic 999
> **   basicScope: %basic 999
572431c573313
< [0:Plant,nest(Schedule&)]
---
> [0:PlantInvA,nest(Object),nest(error)]
572433,572439c573315
< **   basicScope: 
< %id "Boolean"
< %globals inSub
< %basic 4, 8
< %public
< _thisBasicValue: var Universal
< ...
---
> **   basicScope: %basic 999
572441c573317
< **   OGS: [0:Plant,nest(Schedule&)]
---
> **   OGS: [0:PlantInvA,nest(Object),nest(error)]
572444,572447c573320
< 
< %basic 65
< out R: var boolean
< **   OG:  E.elm.isEmpty.not
---
> %basic 999**   OG:  E.elm.isEmpty.not
592483c593356
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
592484a593358,593359
> **** BinaryExp:checkOI:V /% 10
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
592686c593561
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
592792c593667
< **** INV:check:i=1 rec:V label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:V /% 10
592890c593765
< '0' + V /% 10
---
> + V /% 10
592911c593786
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
593143,593144d594017
< **** INV:check:i=2 rec:/% 10 label: ObjectInvocation_Binary
< **   OGS: [0:StringLib,nest(loop)]
593148,593150c594021,594026
< %basic 69
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
598260c599136
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
598261a599138,599139
> **** BinaryExp:checkOI:ch <= 'Z'
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
598463c599341
< **** INV:check:i=1 rec:ch label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:ch <= 'Z'
598696c599574
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
598887,598888d599764
< **** INV:check:i=2 rec:<= 'Z' label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
598892,598894c599768,599773
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
598956c599835
< 1 - inx
---
> 1
598963,598964c599842,599843
< **** Arguments:check:1 - inx
< **** ObjectGenerator:check:1 - inx
---
> **** Arguments:check:1
> **** ObjectGenerator:check:1
598971c599850
< **** OG:check:super:1 - inx
---
> **** OG:check:super:1
598977c599856
< **** Invocation:check: 1 - inx
---
> **** Invocation:check: 1
598980,598983c599859,599860
< **** INV:check:i=1 rec:1 label: ObjectInvocation_Binary
< **   OGS: none
< **** ObjectInvocation:checkOI: - inx  isFirst:False
< **** basicScope:A:
---
> **** check:super:end: 1
> **** superDesc:
598991,598992c599868,599902
< **** ObjectInvocation:check: - inx
< **** Items:search: "-" isFirst:False
---
> **   OG:  1
> **** argBuf:check:
> inx
> **** **   scope::
> 
> i: var integer
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
> **** Arguments:check:inx
> **** ObjectGenerator:check:inx
> ****  basicScope:
> 
> i: var integer
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
> **** OG:check:super:inx
> **   basicScope: 
> i: var integer
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
> **** Invocation:check: inx
> **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
> **   OGS: none
> **** ObjectInvocation:checkOI: inx  isFirst:True
> **** basicScope:A:
> 
> i: var integer
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
> **** ObjectInvocation:check: inx
> **** Items:search: "inx" isFirst:True
598995,599000c599905,599908
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
---
> i: var integer
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
599002c599910
< **** Items:localSearch: -
---
> **** Items:localSearch: inx
599005,599007c599913,599925
< %ID integer
< %basic 1, 32
< %globals
---
> i: var integer
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> Try: "i"
> **   Items:localSearch:trySuper:
> **** Items:localSearch: inx
> **   in:
> 
> %ID Object
> %basic 64
599009c599927,599928
< _thisBasicValue: var Universal
---
> ==  : 
>    %basic 56
599012,599028c599931,599943
< **   Items:localSearch:Decls: -
< Try: "_thisBasicValue"
< Try: "+"
< Try: "-"
< **** Items:localSearch:end: -
< **** Items:search:end: -
< **** Found: "-" on=0 pn=0 Decl: "-  " visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** computing:encOG:BS.father=encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** encOG:False
< **   OGS: none
---
> **   Items:localSearch:Decls: inx
> Try: "=="
> Try: "=/="
> Try: "suspend"
> Try: "attach"
> Try: "call"
> Try: "onResume"
> Try: "onSuspend"
> Try: "dumpObj"
> Try: "X_asString"
> **** Signature:localSearch: inx in: Object
> **** Items:localSearch: inx
> **   in:
599030,599035c599945,599953
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
---
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> **** Items:localSearch:end: inx
> **** Signature:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:searchEmbodied: inx
> **   Items:searchEmbodied:end:
> **** Items:searchIncludeProp: inx in: 
599037,599044c599955,599962
< **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
---
> i: var integer
> i := L + 1 - inx
> ch := '0' + D.get[i]
> inner(int2chars)
> **   origin: 
> **** Items:searchIncludeProp:end: inx
> **** Items:search: "inx" isFirst:True
> **   in: 
599046,599061c599964,599965
< **** OI:getVqual:initial:- inx
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGs:[0:integer]
< **   ATd: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: -   :isVirtual:False
< [0:integer]
---
> **** Items:localSearch: inx
> **   in:
599063,599076c599967,599971
< **** getVqual:initial:afterATd:- inx
< **   OGSx:[0:integer]
< **** savedOGS:save:False[0:integer]
< **   OI: - inx
< **   OI:getQual:savedOI:- inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:integer]
< **   OGS:[0:integer]
< **** DataItem:getVqual: out R: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
---
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> **   Items:localSearch:trySuper:
> **** Items:localSearch: inx
> **   in:
599078,599085c599973,599977
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> %OSDvisibility skipInternal
> %globals inSub
> inx: var integer
> inx := first
> _doIt: do 
599087,599101c599979,599985
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
---
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> Try: "inx"
> **** Items:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:search:end: inx
> >>> on + 1 = 1 found!: "inx"! ATd.father:Items
599103,599107c599987,599991
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> %OSDvisibility skipInternal
> %globals inSub
> inx: var integer
> inx := first
> _doIt: do 
599109,599110c599993,599997
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
---
> **** Items:search:end: inx
> **** Found: "inx" on=1 pn=1 Decl: "inx" visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** encOG:True
> **   OGS: none
599112,599127c599999,600178
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
---
> i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> 
> **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
> **   encOG: 
> i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> **** PRE: [0:for:to:repeat$0]
> **** pathToSuper: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> " of:DOG:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> **   pathToSuper:DOG.super.scanSons:i=1:E:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
>  :isImplSuper=False
> **   pathToSuper:E:"
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
> **   pathToSuper:end:super.last: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
> for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
>    %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
> ...
> **   PRE:onx,pnx,isR:2,0,False OGx:
> 
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
> ...
> **   PRE:result:[0:for:to:repeat$0,for:to:repeat]
> 
> **** OI:getVqual:initial:inx
> **   encOG:
> i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> **   OGs:[0:for:to:repeat$0,for:to:repeat]
> **   ATd: inx: var integer
> **** DataItem:getVqual: inx: var integer
> [0:for:to:repeat$0,for:to:repeat]
> **** ObjectGenerator:getVqual: integer
> **   hasVirtualArgs: False
> **** INV:getVqual:integer
> **   OGs: [0:for:to:repeat$0,for:to:repeat]
> 
> **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:for:to:repeat$0,for:to:repeat]
> **   encOG: 
> i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> **** koks: integer on: 1 Items 
> **   father: integer
> **   father.f.f.f.f:
> 
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
> ...
> **** ENC:OI.getVqual:[1:for:to:repeat$0,for:to:repeat]
> **** pathToSuper: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> " of:DOG:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> **   pathToSuper:DOG.super.scanSons:i=1:E:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
>  :isImplSuper=False
> **   pathToSuper:E:"
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
> **   pathToSuper:end:super.last: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
> for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
>    %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
> ...
> **   ENC:pred:  pred.DOG: 
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    ch := '0' + D.get[i]
>    inner(int2chars)
> ...
> **   OGsuper: 
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
> ...
> **** ENC:OI.getVqual:[2:for:to:repeat$0]
> **   ENC:result:[2:doit]
> **   ENC:[pnx=0]oENC[onx=2]
> **** ENC:OI.getVqual:[2:doit]
> **   ENC:result:[2:int2chars]
> **** ENC:OI.getVqual:[3:int2chars]
> **   ENC:result:[3:BETA]
> **   ENC:result:[1:BETA]
> 
> **** getVqual:B2:
> [0:BETA]
> ---
> 
> integer: value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** Pattern:getVqual: integer :isVirtual:False
> [0:BETA]
> 
> **** getVqual:cont:afterATd:qual:
599134c600185,600190
< ObjectGenerator
---
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: integer
> **   OI:getQual:savedOI:integer
> **   IT: var [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
599136,599137c600192,600193
< **** OI:getVqual:return: out R: var integer
< **   qual:
---
> **** OI:getVqual:end: integer
> **   qual: 
599143,599197c600199,600211
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: - inx
---
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> 
> **** getVqual:initial:afterATd:inx
> **   OGSx:[0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: inx
> **   OI:getQual:savedOI:inx
> **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
> **** OI:getVqual:end: inx
599207c600221
< **** checkOI:checkOI:after:getVqual: -
---
> **** checkOI:checkOI:after:getVqual: inx
599276c600290
< **** checkOI:after:getVqual:OF: - qual:
---
> **** checkOI:after:getVqual:OF: inx qual:
599292c600306
< **** next:basicScope:from:-
---
> **** next:basicScope:from:inx
599300,599302c600314
< **** INV:check:i=2 rec:- inx label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** check:super:end: 1 - inx
---
> **** check:super:end: inx
599305,599308c600317,600323
< %basic 62
< in V: var integer
< out R: var integer
< **   OG:  1 - inx
---
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   OG:  inx
600817c601832
< 1 - inx
---
> 1
600823,600824c601838,601839
< **** Arguments:check:1 - inx
< **** ObjectGenerator:check:1 - inx
---
> **** Arguments:check:1
> **** ObjectGenerator:check:1
600830c601845
< **** OG:check:super:1 - inx
---
> **** OG:check:super:1
600835c601850
< **** Invocation:check: 1 - inx
---
> **** Invocation:check: 1
600838,600841c601853,601854
< **** INV:check:i=1 rec:1 label: ObjectInvocation_Binary
< **   OGS: none
< **** ObjectInvocation:checkOI: - inx  isFirst:False
< **** basicScope:A:
---
> **** check:super:end: 1
> **** superDesc:
600849,600850c601862,601892
< **** ObjectInvocation:check: - inx
< **** Items:search: "-" isFirst:False
---
> **   OG:  1
> **** argBuf:check:
> inx
> **** **   scope::
> 
> i: var integer
> i := L + 1 - inx
> put('0' + D.get[i])
> **** Arguments:check:inx
> **** ObjectGenerator:check:inx
> ****  basicScope:
> 
> i: var integer
> i := L + 1 - inx
> put('0' + D.get[i])
> **** OG:check:super:inx
> **   basicScope: 
> i: var integer
> i := L + 1 - inx
> put('0' + D.get[i])
> **** Invocation:check: inx
> **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
> **   OGS: none
> **** ObjectInvocation:checkOI: inx  isFirst:True
> **** basicScope:A:
> 
> i: var integer
> i := L + 1 - inx
> put('0' + D.get[i])
> **** ObjectInvocation:check: inx
> **** Items:search: "inx" isFirst:True
600853,600855c601895,601913
< %ID integer
< %basic 1, 32
< %globals
---
> i: var integer
> i := L + 1 - inx
> put('0' + D.get[i])
> 
> **** Items:localSearch: inx
> **   in:
> 
> i: var integer
> i := L + 1 - inx
> put('0' + D.get[i])
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> Try: "i"
> **   Items:localSearch:trySuper:
> **** Items:localSearch: inx
> **   in:
> 
> %ID Object
> %basic 64
600857c601915,601916
< _thisBasicValue: var Universal
---
> ==  : 
>    %basic 56
600858a601918,601931
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> Try: "=="
> Try: "=/="
> Try: "suspend"
> Try: "attach"
> Try: "call"
> Try: "onResume"
> Try: "onSuspend"
> Try: "dumpObj"
> Try: "X_asString"
> **** Signature:localSearch: inx in: Object
> **** Items:localSearch: inx
> **   in:
600860c601933,601951
< **** Items:localSearch: -
---
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> **** Items:localSearch:end: inx
> **** Signature:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:searchEmbodied: inx
> **   Items:searchEmbodied:end:
> **** Items:searchIncludeProp: inx in: 
> 
> i: var integer
> i := L + 1 - inx
> put('0' + D.get[i])
> **   origin: 
> **** Items:searchIncludeProp:end: inx
> **** Items:search: "inx" isFirst:True
> **   in: 
> 
> **** Items:localSearch: inx
600863,600867c601954,601964
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
---
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> **   Items:localSearch:trySuper:
> **** Items:localSearch: inx
> **   in:
> 
> %OSDvisibility skipInternal
> %globals inSub
> inx: var integer
> inx := first
> _doIt: do 
600870,600883c601967,601978
< **   Items:localSearch:Decls: -
< Try: "_thisBasicValue"
< Try: "+"
< Try: "-"
< **** Items:localSearch:end: -
< **** Items:search:end: -
< **** Found: "-" on=0 pn=0 Decl: "-  " visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** computing:encOG:BS.father=encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> **   Items:localSearch:Decls: inx
> Try: "inx"
> **** Items:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:search:end: inx
> >>> on + 1 = 1 found!: "inx"! ATd.father:Items
> 
> %OSDvisibility skipInternal
> %globals inSub
> inx: var integer
> inx := first
> _doIt: do 
600885c601980,601983
< **** encOG:False
---
> **** Items:search:end: inx
> **** Found: "inx" on=1 pn=1 Decl: "inx" visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** encOG:True
600888,600893c601986,601988
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
---
> i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
600895c601990
< **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
---
> **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
600897,600901c601992,602033
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> **** PRE: [0:for:to:repeat$0]
> **** pathToSuper: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> " of:DOG:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> **   pathToSuper:DOG.super.scanSons:i=1:E:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
>  :isImplSuper=False
> **   pathToSuper:E:"
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> " E.on=1 E.pn=0 DOG.super.pn=0 isR=False
> **   pathToSuper:end:super.last: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> " :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
> for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
>    %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
600902a602035
> **   PRE:onx,pnx,isR:1,0,False OGx:
600904,600910c602037,602041
< **** OI:getVqual:initial:- inx
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
600912,600919c602043
< **   OGs:[0:integer]
< **   ATd: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: -   :isVirtual:False
< [0:integer]
---
> **   PRE:result:[0:for:to:repeat$0,for:to:repeat]
600921,600930c602045,602053
< **** getVqual:initial:afterATd:- inx
< **   OGSx:[0:integer]
< **** savedOGS:save:False[0:integer]
< **   OI: - inx
< **   OI:getQual:savedOI:- inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:integer]
< **   OGS:[0:integer]
< **** DataItem:getVqual: out R: var integer
< [0:integer,nest(-)]
---
> **** OI:getVqual:initial:inx
> **   encOG:
> i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> **   OGs:[0:for:to:repeat$0,for:to:repeat]
> **   ATd: inx: var integer
> **** DataItem:getVqual: inx: var integer
> [0:for:to:repeat$0,for:to:repeat]
600934c602057
< **   OGs: [0:integer,nest(-)]
---
> **   OGs: [0:for:to:repeat$0,for:to:repeat]
600936,600937c602059,602060
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
---
> **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:for:to:repeat$0,for:to:repeat]
600939,600945c602062,602065
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
---
> i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> **** koks: integer on: 1 Items 
600949,600954c602069,602131
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
---
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
> ...
> **** ENC:OI.getVqual:[1:for:to:repeat$0,for:to:repeat]
> **** pathToSuper: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> " of:DOG:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> **   pathToSuper:DOG.super.scanSons:i=1:E:
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
>  :isImplSuper=False
> **   pathToSuper:E:"
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> " E.on=1 E.pn=0 DOG.super.pn=0 isR=False
> **   pathToSuper:end:super.last: "
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> " :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
> for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
>    %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
> ...
> **   ENC:pred:  pred.DOG: 
> for(1):to(L):repeat
>    i: var integer
>    i := L + 1 - inx
>    put('0' + D.get[i])
> 
> **   OGsuper: 
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
> ...
> **** ENC:OI.getVqual:[2:for:to:repeat$0]
> **   ENC:result:[2:putint]
> **   ENC:[pnx=0]oENC[onx=1]
> **** ENC:OI.getVqual:[2:putint]
600955a602133
> **   ENC:result:[1:BETA]
600994,601055c602172,602181
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: - inx
---
> 
> **** getVqual:initial:afterATd:inx
> **   OGSx:[0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: inx
> **   OI:getQual:savedOI:inx
> **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
> **** OI:getVqual:end: inx
601065c602191
< **** checkOI:checkOI:after:getVqual: -
---
> **** checkOI:checkOI:after:getVqual: inx
601134c602260
< **** checkOI:after:getVqual:OF: - qual:
---
> **** checkOI:after:getVqual:OF: inx qual:
601150c602276
< **** next:basicScope:from:-
---
> **** next:basicScope:from:inx
601158,601160c602284
< **** INV:check:i=2 rec:- inx label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** check:super:end: 1 - inx
---
> **** check:super:end: inx
601163,601166c602287,602293
< %basic 62
< in V: var integer
< out R: var integer
< **   OG:  1 - inx
---
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   OG:  inx
601187c602314
< **** INV:check:i=0 rec:none label: Char:
---
> **** INV:check:i=0 rec:none label: BinOp
601189c602316,602318
< **** INV:check:i=1 rec:'0' label: ObjectInvocation_Binary
---
> **** BinaryExp:checkOI:'0' + D.get[i]
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
> **   BinaryExp:checkOI:after:left:'0' + D.get[i]
601276c602405
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
601468,601469d602596
< **** INV:check:i=2 rec:+ D.get[i] label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
601473,601475c602600,602605
< %basic 61
< in V: var char
< out R: var char
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
602572a603703,603708
> **** INV:check:i=0 rec:none label: BinOp
> **   OGS: none
> **** BinaryExp:checkOI:S.length - inx + 1
> **   leftRec.label:BinOp M.label: ObjectInvocation_Binary  OGS: none
> **** Invocation:checkOI:S.length
> **** Invocation:check: S.length
603095c604231
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BinOp [savedOGS <> none and IT.isDecl: ]
603340c604476
< **   father: S.length - inx + 1
---
> **   father: S.length
603342c604478
< get[(S.length - inx + 1)]
---
> (S.length - inx + 1)
603361c604497
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BinOp [savedOGS <> none and IT.isDecl: ]
603588c604724
< **** INV:check:i=2 rec:length label: ObjectInvocation_Binary
---
> **** INV:check:i=2 rec:length label: ObjectInvocation_Unary
603590c604726
< **** ObjectInvocation:checkOI: - inx + 1  isFirst:False
---
> **** ObjectInvocation:checkOI: - inx  isFirst:False
603599c604735
< **** ObjectInvocation:check: - inx + 1
---
> **** ObjectInvocation:check: - inx
603636c604772
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **   OGS: none
603645,603646c604781
< **** OI:getVqual: - inx + 1 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
603654c604789,604790
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> 
> **** OI:getVqual:initial:- inx
603662,603663c604798,604824
< **   OI:getVqual:findEnc:i=2 OGSz:[0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **   encOG:
---
> **   OGs:[0:integer]
> **   ATd: 
> -  : 
>    %basic 62
>    in V: var integer
>    out R: var integer
> **** Pattern:getVqual: -   :isVirtual:False
> [0:integer]
> 
> **** getVqual:initial:afterATd:- inx
> **   OGSx:[0:integer]
> **** savedOGS:save:False[0:integer]
> **   OI: - inx
> **   OI:getQual:savedOI:- inx
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:integer]
> **   OGS:[0:integer]
> **** DataItem:getVqual: out R: var integer
> [0:integer,nest(-)]
> **** ObjectGenerator:getVqual: integer
> **   hasVirtualArgs: False
> **** INV:getVqual:integer
> **   OGs: [0:integer,nest(-)]
> 
> **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:integer,nest(-)]
> **   encOG: 
603670,603671c604831,604856
< **   OI:getVqual:findEnc:i=3 OGSz:[0:BETAworld,nest(LIB),nest(StringLib)]
< **   encOG:
---
> **** koks: integer on: 2 Items 
> **   father: integer
> **   father.f.f.f.f:
> 
> %basic 62
>    in V: var integer
>    out R: var integer
> **** ENC:OI.getVqual:[1:integer,nest(-)]
> **   ENC:result:[1:integer]
> **** ENC:OI.getVqual:[2:integer]
> **   ENC:result:[2:BETA]
> 
> **** getVqual:B2:
> [0:BETA]
> ---
> 
> integer: value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** Pattern:getVqual: integer :isVirtual:False
> [0:BETA]
> 
> **** getVqual:cont:afterATd:qual:
603678,603679c604863,605102
< **   OI:getVqual:findEnc:i=4 OGSz:[0:BETAworld,nest(LIB)]
< **   encOG:
---
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: integer
> **   OI:getQual:savedOI:integer
> **   IT: var [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
> **** OI:getVqual:end: integer
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** OI:getVqual:return: out R: var integer
> **   qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> [0:BETA]
> **** OI:getVqual:end: - inx
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: -
> **** qual:
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> **** OGS:
> [0:BETA]
> **** checkOI:after:getVqual:OF: - qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** OGS:
> [0:BETA]
> **** next:basicScope:from:-
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   BinaryExp:checkOI:after:left:S.length - inx + 1
> **   OGS: [0:BETA]
> **** ObjectInvocation:checkOI: + 1  isFirst:False
> **** basicScope:A:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** ObjectInvocation:check: + 1
> **** Items:search: "+" isFirst:False
> **   in: 
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> 
> **** Items:localSearch: +
> **   in:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   isChecked: True
> **   Items:localSearch:Decls: +
> Try: "_thisBasicValue"
> Try: "+"
> **** Items:localSearch:end: +
> **** Items:search:end: +
> **** Found: "+" on=0 pn=0 Decl: "+  " visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** computing:encOG:BS.father=encOG:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** encOG:False
> **   OGS: [0:BETA]
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> 
> **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
> **   OGS:continued:[0:BETA]
> **   encOG: 
603686c605109
< **   OI:getVqual:findEnc:i=5 OGSz:[0:BETAworld]
---
> **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
603702,603703c605125,605126
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** koks: - inx + 1 on: 0 Items 
---
> [0:BETA,nest(integer)]
> **** koks: + 1 on: 0 Items 
603706c605129
< get[(S.length - inx + 1)]
---
> (S.length - inx + 1)
603709c605132
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
---
> [0:BETA,nest(integer)]
603712,603713c605135,605136
< -  : 
<    %basic 62
---
> +  : 
>    %basic 61
603716,603717c605139,605140
< **** Pattern:getVqual: -   :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
---
> **** Pattern:getVqual: +   :isVirtual:False
> [0:BETA,nest(integer)]
603720c605143
< %basic 62
---
> %basic 61
603723,603729c605146,605152
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   OI: - inx + 1
< **   OI:getQual:savedOI:- inx + 1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
---
> [0:BETA,nest(integer)]
> **** savedOGS:save:False[0:BETA,nest(integer)]
> **   OI: + 1
> **   OI:getQual:savedOI:+ 1
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA,nest(integer)]
> **   OGS:[0:BETA,nest(integer)]
603731c605154
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
---
> [0:BETA,nest(integer),nest(+)]
603735c605158
< **   OGs: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
---
> **   OGs: [0:BETA,nest(integer),nest(+)]
603738c605161
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
---
> **   OGS:continued:[0:BETA,nest(integer),nest(+)]
603750c605173
< %basic 62
---
> %basic 61
603753,603756c605176,605179
< **** ENC:OI.getVqual:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   ENC:result:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** ENC:OI.getVqual:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   ENC:result:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
> **   ENC:result:[1:BETA,nest(integer)]
> **** ENC:OI.getVqual:[2:BETA,nest(integer)]
> **   ENC:result:[2:BETA]
603759c605182
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> [0:BETA]
603769c605192
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> [0:BETA]
603778,603779c605201,605202
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
603783,603784c605206,605207
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
603794c605217
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
---
> **   OGS:[0:BETA]
603855,603856c605278,605279
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** OI:getVqual:end: - inx + 1
---
> [0:BETA]
> **** OI:getVqual:end: + 1
603865,603866c605288,605289
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** checkOI:checkOI:after:getVqual: -
---
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: +
603934,603935c605357,605358
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** checkOI:after:getVqual:OF: - qual:
---
> [0:BETA]
> **** checkOI:after:getVqual:OF: + qual:
603950,603951c605373,605374
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** next:basicScope:from:-
---
> [0:BETA]
> **** next:basicScope:from:+
603959,603960d605381
< **** INV:check:i=3 rec:- inx + 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
603964,603966c605385,605390
< %basic 62
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
604035c605459
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
---
> **** INV:check:i=0 rec:none label: BinOp
604036a605461,605462
> **** BinaryExp:checkOI:inx = S.length
> **   leftRec.label:Invocation M.label: ObjectInvocation_Binary  OGS: none
604458c605884
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
---
> **   BinaryExp:checkOI:after:left:inx = S.length
604703c606129
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BracketedExp [savedOGS <> none and IT.isDecl: ]
604895,604896d606320
< **** INV:check:i=2 rec:= S.length label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
604900,604903c606324,606329
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
604906c606332
< inx + 1
---
> inx
604911,604912c606337,606338
< **** Arguments:check:inx + 1
< **** ObjectGenerator:check:inx + 1
---
> **** Arguments:check:inx
> **** ObjectGenerator:check:inx
604917c606343
< **** OG:check:super:inx + 1
---
> **** OG:check:super:inx
604921c606347
< **** Invocation:check: inx + 1
---
> **** Invocation:check: inx
605401,605424c606827,606828
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** ObjectInvocation:checkOI: + 1  isFirst:False
< **** basicScope:A:
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** ObjectInvocation:check: + 1
< **** Items:search: "+" isFirst:False
< **   in: 
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< 
< **** Items:localSearch: +
< **   in:
---
> **** check:super:end: inx
> **** superDesc:
605432,605549c606836,606839
< **   isChecked: True
< **   Items:localSearch:Decls: +
< Try: "_thisBasicValue"
< Try: "+"
< **** Items:localSearch:end: +
< **** Items:search:end: +
< **** Found: "+" on=0 pn=0 Decl: "+  " visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** computing:encOG:BS.father=encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** encOG:False
< **   OGS: [0:BETA]
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: + 1 on: 0 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< S.length - inx + 1
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:BETA,nest(integer)]
< **** savedOGS:save:False[0:BETA,nest(integer)]
< **   OI: + 1
< **   OI:getQual:savedOI:+ 1
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA,nest(integer)]
< **** DataItem:getVqual: out R: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
---
> **   OG:  inx
> **** argBuf:check:
> 1
> **** **   scope::
605551,605647c606841,606845
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: + 1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** checkOI:checkOI:after:getVqual: +
< **** qual:
---
> ix := S.length - inx + 1
> leave(elimTrailingBlanks)
> **** Arguments:check:1
> **** ObjectGenerator:check:1
> ****  basicScope:
605649,605731c606847,606849
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< **** OGS:
< [0:BETA]
< **** checkOI:after:getVqual:OF: + qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** OGS:
< [0:BETA]
< **** next:basicScope:from:+
---
> ix := S.length - inx + 1
> leave(elimTrailingBlanks)
> **** OG:check:super:1
605732a606851,606858
> ix := S.length - inx + 1
> leave(elimTrailingBlanks)
> **** Invocation:check: 1
> **** INV:check:i=0 rec:none label: ConstLiteral
> **   OGS: none
> **** check:super:end: 1
> **** superDesc:
> 
605739,605747c606865
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** check:super:end: inx + 1
< **** superDesc:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   OG:  inx + 1
---
> **   OG:  1
613274a614393,614398
> **** INV:check:i=0 rec:none label: BinOp
> **   OGS: none
> **** BinaryExp:checkOI:L + 1 - inx
> **   leftRec.label:BinOp M.label: ObjectInvocation_Binary  OGS: none
> **** Invocation:checkOI:L
> **** Invocation:check: L
613515c614639
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
---
> **   IT: BinOp [savedOGS <> none and IT.isDecl: ]
613621,613623c614745
< **** INV:check:i=1 rec:L label: ObjectInvocation_Binary
< **   OGS: [0:StringLib,nest(repeat$0)]
< **** ObjectInvocation:checkOI: + 1 - inx  isFirst:False
---
> **** ObjectInvocation:checkOI: + 1  isFirst:False
613632c614754
< **** ObjectInvocation:check: + 1 - inx
---
> **** ObjectInvocation:check: + 1
613668c614790
< **   OGS: [0:StringLib,nest(repeat$0)]
---
> **   OGS: none
613677,613678c614799
< **** OI:getVqual: + 1 - inx on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(repeat$0)]
---
> **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
613686c614807,614808
< **   OI:getVqual:findEnc:i=1 OGSz:[0:StringLib,nest(repeat$0)]
---
> 
> **** OI:getVqual:initial:+ 1
613694c614816,615128
< **   OI:getVqual:findEnc:i=2 OGSz:[0:StringLib]
---
> **   OGs:[0:integer]
> **   ATd: 
> +  : 
>    %basic 61
>    in V: var integer
>    out R: var integer
> **** Pattern:getVqual: +   :isVirtual:False
> [0:integer]
> 
> **** getVqual:initial:afterATd:+ 1
> **   OGSx:[0:integer]
> **** savedOGS:save:False[0:integer]
> **   OI: + 1
> **   OI:getQual:savedOI:+ 1
> **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:integer]
> **   OGS:[0:integer]
> **** DataItem:getVqual: out R: var integer
> [0:integer,nest(+)]
> **** ObjectGenerator:getVqual: integer
> **   hasVirtualArgs: False
> **** INV:getVqual:integer
> **   OGs: [0:integer,nest(+)]
> 
> **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:integer,nest(+)]
> **   encOG: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** koks: integer on: 2 Items 
> **   father: integer
> **   father.f.f.f.f:
> 
> %basic 61
>    in V: var integer
>    out R: var integer
> **** ENC:OI.getVqual:[1:integer,nest(+)]
> **   ENC:result:[1:integer]
> **** ENC:OI.getVqual:[2:integer]
> **   ENC:result:[2:BETA]
> 
> **** getVqual:B2:
> [0:BETA]
> ---
> 
> integer: value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** Pattern:getVqual: integer :isVirtual:False
> [0:BETA]
> 
> **** getVqual:cont:afterATd:qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
> **   OI: integer
> **   OI:getQual:savedOI:integer
> **   IT: var [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
> **** OI:getVqual:end: integer
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** OI:getVqual:return: out R: var integer
> **   qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> [0:BETA]
> **** OI:getVqual:end: + 1
> **   qual: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> ObjectGenerator
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: +
> **** qual:
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
>    _thisBasicValue: var Universal
>    +  : 
>       %basic 61
>       in V: var integer
>       out R: var integer
>    -  : 
>       %basic 62
>       in V: var integer
>       out R: var integer
>    *  : 
>       %basic 66
>       in V: var integer
>       out R: var integer
>    /  : 
>       %basic 67
>       in V: var integer
>       out R: var integer
>    //  : 
>       %basic 68
>       in V: var integer
>       out B: var integer
>    /%  : 
>       %basic 69
>       in V: var integer
>       out R: var integer
>    =?  : 
>       %basic 50
>       in V: var integer
>       out B: var boolean
>    <  : 
>       %basic 51
>       in V: var integer
>       out B: var boolean
>    <=?  : 
>       %basic 52
>       in V: var integer
>       out B: var boolean
>    >  : 
>       %basic 53
>       in V: var integer
>       out B: var boolean
>    >=  : 
>       %basic 54
>       in V: var integer
>       out B: var boolean
>    <>  : 
>       %basic 55
>       in V: var integer
>       out B: var boolean
>    cmpAndSwap: 
>       %basic 14
>       in V: var integer
>       out res: var integer
> **** OGS:
> [0:BETA]
> **** checkOI:after:getVqual:OF: + qual:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** OGS:
> [0:BETA]
> **** next:basicScope:from:+
> **   basicScope: 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   BinaryExp:checkOI:after:left:L + 1 - inx
> **   OGS: [0:BETA]
> **** ObjectInvocation:checkOI: - inx  isFirst:False
> **** basicScope:A:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **** ObjectInvocation:check: - inx
> **** Items:search: "-" isFirst:False
> **   in: 
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> 
> **** Items:localSearch: -
> **   in:
> 
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   isChecked: True
> **   Items:localSearch:Decls: -
> Try: "_thisBasicValue"
> Try: "+"
> Try: "-"
> **** Items:localSearch:end: -
> **** Items:search:end: -
> **** Found: "-" on=0 pn=0 Decl: "-  " visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** computing:encOG:BS.father=encOG:
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **** encOG:False
> **   OGS: [0:BETA]
> 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> 
> **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
> **   OGS:continued:[0:BETA]
> **   encOG: 
> value
>    %ID integer
>    %basic 1, 32
>    %globals
>    %public
> ...
> **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
613710,613711c615144,615145
< [0:StringLib,nest(repeat$0),nest(integer)]
< **** koks: + 1 - inx on: 0 Items 
---
> [0:BETA,nest(integer)]
> **** koks: - inx on: 0 Items 
613714c615148
< D.get[L + 1 - inx]
---
> get[L + 1 - inx]
613717c615151
< [0:StringLib,nest(repeat$0),nest(integer)]
---
> [0:BETA,nest(integer)]
613720,613721c615154,615155
< +  : 
<    %basic 61
---
> -  : 
>    %basic 62
613724,613725c615158,615159
< **** Pattern:getVqual: +   :isVirtual:False
< [0:StringLib,nest(repeat$0),nest(integer)]
---
> **** Pattern:getVqual: -   :isVirtual:False
> [0:BETA,nest(integer)]
613728c615162
< %basic 61
---
> %basic 62
613731,613737c615165,615171
< [0:StringLib,nest(repeat$0),nest(integer)]
< **** savedOGS:save:False[0:StringLib,nest(repeat$0),nest(integer)]
< **   OI: + 1 - inx
< **   OI:getQual:savedOI:+ 1 - inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(repeat$0),nest(integer)]
< **   OGS:[0:StringLib,nest(repeat$0),nest(integer)]
---
> [0:BETA,nest(integer)]
> **** savedOGS:save:False[0:BETA,nest(integer)]
> **   OI: - inx
> **   OI:getQual:savedOI:- inx
> **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:BETA,nest(integer)]
> **   OGS:[0:BETA,nest(integer)]
613739c615173
< [0:StringLib,nest(repeat$0),nest(integer),nest(+)]
---
> [0:BETA,nest(integer),nest(-)]
613743c615177
< **   OGs: [0:StringLib,nest(repeat$0),nest(integer),nest(+)]
---
> **   OGs: [0:BETA,nest(integer),nest(-)]
613746c615180
< **   OGS:continued:[0:StringLib,nest(repeat$0),nest(integer),nest(+)]
---
> **   OGS:continued:[0:BETA,nest(integer),nest(-)]
613758c615192
< %basic 61
---
> %basic 62
613761,613764c615195,615198
< **** ENC:OI.getVqual:[1:StringLib,nest(repeat$0),nest(integer),nest(+)]
< **   ENC:result:[1:StringLib,nest(repeat$0),nest(integer)]
< **** ENC:OI.getVqual:[2:StringLib,nest(repeat$0),nest(integer)]
< **   ENC:result:[2:StringLib,nest(repeat$0)]
---
> **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(-)]
> **   ENC:result:[1:BETA,nest(integer)]
> **** ENC:OI.getVqual:[2:BETA,nest(integer)]
> **   ENC:result:[2:BETA]
613767c615201
< [0:StringLib,nest(repeat$0)]
---
> [0:BETA]
613777c615211
< [0:StringLib,nest(repeat$0)]
---
> [0:BETA]
613786,613787c615220,615221
< [0:StringLib,nest(repeat$0)]
< **** savedOGS:save:False[0:StringLib,nest(repeat$0)]
---
> [0:BETA]
> **** savedOGS:save:False[0:BETA]
613791,613792c615225,615226
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **   OGS:[0:StringLib,nest(repeat$0)]
---
> **   savedOGS: [0:BETA]
> **   OGS:[0:BETA]
613802c615236
< **   OGS:[0:StringLib,nest(repeat$0)]
---
> **   OGS:[0:BETA]
613863,613864c615297,615298
< [0:StringLib,nest(repeat$0)]
< **** OI:getVqual:end: + 1 - inx
---
> [0:BETA]
> **** OI:getVqual:end: - inx
613873,613874c615307,615308
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** checkOI:checkOI:after:getVqual: +
---
> **   OGS:[0:BETA]
> **** checkOI:checkOI:after:getVqual: -
613942,613943c615376,615377
< [0:StringLib,nest(repeat$0)]
< **** checkOI:after:getVqual:OF: + qual:
---
> [0:BETA]
> **** checkOI:after:getVqual:OF: - qual:
613958,613959c615392,615393
< [0:StringLib,nest(repeat$0)]
< **** next:basicScope:from:+
---
> [0:BETA]
> **** next:basicScope:from:-
613967,613968d615400
< **** INV:check:i=2 rec:+ 1 - inx label: ObjectInvocation_Binary
< **   OGS: [0:StringLib,nest(repeat$0)]
613972,613974c615404,615409
< %basic 61
< in V: var integer
< out R: var integer
---
> %ID Object
> %basic 64
> %public
> ==  : 
>    %basic 56
> ...
614890,615344d616324
< inx
< **** **   scope::
< 
< i: var integer
< i := L + 1 - inx
< ch := '0' + D.get[i]
< inner(int2chars)
< **** Arguments:check:inx
< **** ObjectGenerator:check:inx
< ****  basicScope:
< 
< i: var integer
< i := L + 1 - inx
< ch := '0' + D.get[i]
< inner(int2chars)
< **** OG:check:super:inx
< **   basicScope: 
< i: var integer
< i := L + 1 - inx
< ch := '0' + D.get[i]
< inner(int2chars)
< **** Invocation:check: inx
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
< **   OGS: none
< **** ObjectInvocation:checkOI: inx  isFirst:True
< **** basicScope:A:
< 
< i: var integer
< i := L + 1 - inx
< ch := '0' + D.get[i]
< inner(int2chars)
< **** ObjectInvocation:check: inx
< **** Items:search: "inx" isFirst:True
< **   in: 
< 
< i: var integer
< i := L + 1 - inx
< ch := '0' + D.get[i]
< inner(int2chars)
< 
< **** Items:localSearch: inx
< **   in:
< 
< i: var integer
< i := L + 1 - inx
< ch := '0' + D.get[i]
< inner(int2chars)
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "i"
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "=="
< Try: "=/="
< Try: "suspend"
< Try: "attach"
< Try: "call"
< Try: "onResume"
< Try: "onSuspend"
< Try: "dumpObj"
< Try: "X_asString"
< **** Signature:localSearch: inx in: Object
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Items:localSearch:end: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:searchEmbodied: inx
< **   Items:searchEmbodied:end:
< **** Items:searchIncludeProp: inx in: 
< 
< i: var integer
< i := L + 1 - inx
< ch := '0' + D.get[i]
< inner(int2chars)
< **   origin: 
< **** Items:searchIncludeProp:end: inx
< **** Items:search: "inx" isFirst:True
< **   in: 
< 
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:search:end: inx
< >>> on + 1 = 1 found!: "inx"! ATd.father:Items
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **** Items:search:end: inx
< **** Found: "inx" on=1 pn=1 Decl: "inx" visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** encOG:True
< **   OGS: none
< 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** PRE: [0:for:to:repeat$0]
< **** pathToSuper: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< " of:DOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
<  :isImplSuper=False
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:2,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$0,for:to:repeat]
< 
< **** OI:getVqual:initial:inx
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   OGs:[0:for:to:repeat$0,for:to:repeat]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$0,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$0,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$0,for:to:repeat]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$0,for:to:repeat]
< **** pathToSuper: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< " of:DOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
<  :isImplSuper=False
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$0]
< **   ENC:result:[2:doit]
< **   ENC:[pnx=0]oENC[onx=2]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:int2chars]
< **** ENC:OI.getVqual:[3:int2chars]
< **   ENC:result:[3:BETA]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** checkOI:checkOI:after:getVqual: inx
< **** qual:
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< **** OGS:
< [0:BETA]
< **** checkOI:after:getVqual:OF: inx qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** OGS:
< [0:BETA]
< **** next:basicScope:from:inx
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** check:super:end: inx
< **** superDesc:
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **   OG:  inx
< **** argBuf:check:
615621,616051d616600
< inx
< **** **   scope::
< 
< i: var integer
< i := L + 1 - inx
< put('0' + D.get[i])
< **** Arguments:check:inx
< **** ObjectGenerator:check:inx
< ****  basicScope:
< 
< i: var integer
< i := L + 1 - inx
< put('0' + D.get[i])
< **** OG:check:super:inx
< **   basicScope: 
< i: var integer
< i := L + 1 - inx
< put('0' + D.get[i])
< **** Invocation:check: inx
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
< **   OGS: none
< **** ObjectInvocation:checkOI: inx  isFirst:True
< **** basicScope:A:
< 
< i: var integer
< i := L + 1 - inx
< put('0' + D.get[i])
< **** ObjectInvocation:check: inx
< **** Items:search: "inx" isFirst:True
< **   in: 
< 
< i: var integer
< i := L + 1 - inx
< put('0' + D.get[i])
< 
< **** Items:localSearch: inx
< **   in:
< 
< i: var integer
< i := L + 1 - inx
< put('0' + D.get[i])
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "i"
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "=="
< Try: "=/="
< Try: "suspend"
< Try: "attach"
< Try: "call"
< Try: "onResume"
< Try: "onSuspend"
< Try: "dumpObj"
< Try: "X_asString"
< **** Signature:localSearch: inx in: Object
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Items:localSearch:end: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:searchEmbodied: inx
< **   Items:searchEmbodied:end:
< **** Items:searchIncludeProp: inx in: 
< 
< i: var integer
< i := L + 1 - inx
< put('0' + D.get[i])
< **   origin: 
< **** Items:searchIncludeProp:end: inx
< **** Items:search: "inx" isFirst:True
< **   in: 
< 
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:search:end: inx
< >>> on + 1 = 1 found!: "inx"! ATd.father:Items
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **** Items:search:end: inx
< **** Found: "inx" on=1 pn=1 Decl: "inx" visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** encOG:True
< **   OGS: none
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** PRE: [0:for:to:repeat$0]
< **** pathToSuper: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " of:DOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   pathToSuper:DOG.super.scanSons:i=1:E:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
<  :isImplSuper=False
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$0,for:to:repeat]
< 
< **** OI:getVqual:initial:inx
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   OGs:[0:for:to:repeat$0,for:to:repeat]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$0,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$0,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$0,for:to:repeat]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$0,for:to:repeat]
< **** pathToSuper: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " of:DOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   pathToSuper:DOG.super.scanSons:i=1:E:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
<  :isImplSuper=False
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$0]
< **   ENC:result:[2:putint]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:putint]
< **   ENC:result:[2:BETA]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** checkOI:checkOI:after:getVqual: inx
< **** qual:
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< **** OGS:
< [0:BETA]
< **** checkOI:after:getVqual:OF: inx qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** OGS:
< [0:BETA]
< **** next:basicScope:from:inx
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** check:super:end: inx
< **** superDesc:
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **   OG:  inx
< **** argBuf:check:
616846c617395
< inx + 1
---
> inx
616853,616854c617402,617403
< **** Arguments:check:inx + 1
< **** ObjectGenerator:check:inx + 1
---
> **** Arguments:check:inx
> **** ObjectGenerator:check:inx
616861c617410
< **** OG:check:super:inx + 1
---
> **** OG:check:super:inx
616867c617416
< **** Invocation:check: inx + 1
---
> **** Invocation:check: inx
617291,617314c617840,617841
< **** INV:check:i=1 rec:inx label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** ObjectInvocation:checkOI: + 1  isFirst:False
< **** basicScope:A:
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** ObjectInvocation:check: + 1
< **** Items:search: "+" isFirst:False
< **   in: 
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< 
< **** Items:localSearch: +
< **   in:
---
> **** check:super:end: inx
> **** superDesc:
617322,617439c617849,617852
< **   isChecked: True
< **   Items:localSearch:Decls: +
< Try: "_thisBasicValue"
< Try: "+"
< **** Items:localSearch:end: +
< **** Items:search:end: +
< **** Found: "+" on=0 pn=0 Decl: "+  " visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** computing:encOG:BS.father=encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** encOG:False
< **   OGS: [0:BETA]
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: + 1 on: 0 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< S.length - inx + 1
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:BETA,nest(integer)]
< **** savedOGS:save:False[0:BETA,nest(integer)]
< **   OI: + 1
< **   OI:getQual:savedOI:+ 1
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA,nest(integer)]
< **** DataItem:getVqual: out R: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
---
> **   OG:  inx
> **** argBuf:check:
> 1
> **** **   scope::
617441,617537c617854,617860
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: + 1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** checkOI:checkOI:after:getVqual: +
< **** qual:
---
> ch := S.get[(S.length - inx + 1)]
> if ((ch > '0') || (inx = S.length)) :then 
>    ix := S.length - inx + 1
>    leave(elimTrailingBlanks)
> **** Arguments:check:1
> **** ObjectGenerator:check:1
> ****  basicScope:
617539,617621c617862,617866
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< **** OGS:
< [0:BETA]
< **** checkOI:after:getVqual:OF: + qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** OGS:
< [0:BETA]
< **** next:basicScope:from:+
---
> ch := S.get[(S.length - inx + 1)]
> if ((ch > '0') || (inx = S.length)) :then 
>    ix := S.length - inx + 1
>    leave(elimTrailingBlanks)
> **** OG:check:super:1
617622a617868,617877
> ch := S.get[(S.length - inx + 1)]
> if ((ch > '0') || (inx = S.length)) :then 
>    ix := S.length - inx + 1
>    leave(elimTrailingBlanks)
> **** Invocation:check: 1
> **** INV:check:i=0 rec:none label: ConstLiteral
> **   OGS: none
> **** check:super:end: 1
> **** superDesc:
> 
617629,617637c617884
< **** INV:check:i=2 rec:+ 1 label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** check:super:end: inx + 1
< **** superDesc:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   OG:  inx + 1
---
> **   OG:  1
618685,618713d618931
< 1
< **** **   scope::
< 
< ix := S.length - inx + 1
< leave(elimTrailingBlanks)
< **** Arguments:check:1
< **** ObjectGenerator:check:1
< ****  basicScope:
< 
< ix := S.length - inx + 1
< leave(elimTrailingBlanks)
< **** OG:check:super:1
< **   basicScope: 
< ix := S.length - inx + 1
< leave(elimTrailingBlanks)
< **** Invocation:check: 1
< **** INV:check:i=0 rec:none label: ConstLiteral
< **   OGS: none
< **** check:super:end: 1
< **** superDesc:
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **   OG:  1
< **** argBuf:check:
620034c620252
< 1 - inx
---
> 1
620036,620037c620254,620255
< D2.put(D.get[L + 1 - inx]):at[inx]**** Arguments:check:1 - inx
< **** ObjectGenerator:check:1 - inx
---
> D2.put(D.get[L + 1 - inx]):at[inx]**** Arguments:check:1
> **** ObjectGenerator:check:1
620039c620257
< D2.put(D.get[L + 1 - inx]):at[inx]**** OG:check:super:1 - inx
---
> D2.put(D.get[L + 1 - inx]):at[inx]**** OG:check:super:1
620041c620259
< **** Invocation:check: 1 - inx
---
> **** Invocation:check: 1
620044,620047c620262,620263
< **** INV:check:i=1 rec:1 label: ObjectInvocation_Binary
< **   OGS: none
< **** ObjectInvocation:checkOI: - inx  isFirst:False
< **** basicScope:A:
---
> **** check:super:end: 1
> **** superDesc:
620055,620056c620271,620287
< **** ObjectInvocation:check: - inx
< **** Items:search: "-" isFirst:False
---
> **   OG:  1
> **** argBuf:check:
> inx
> **** **   scope::
> D2.put(D.get[L + 1 - inx]):at[inx]**** Arguments:check:inx
> **** ObjectGenerator:check:inx
> ****  basicScope:
> D2.put(D.get[L + 1 - inx]):at[inx]**** OG:check:super:inx
> **   basicScope: D2.put(D.get[L + 1 - inx]):at[inx]
> **** Invocation:check: inx
> **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
> **   OGS: none
> **** ObjectInvocation:checkOI: inx  isFirst:True
> **** basicScope:A:
> D2.put(D.get[L + 1 - inx]):at[inx]
> **** ObjectInvocation:check: inx
> **** Items:search: "inx" isFirst:True
620057a620289,620297
> D2.put(D.get[L + 1 - inx]):at[inx]
> **** Items:localSearch: inx
> **   in:
> D2.put(D.get[L + 1 - inx]):at[inx]
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> **   Items:localSearch:trySuper:
> **** Items:localSearch: inx
> **   in:
620059,620061c620299,620300
< %ID integer
< %basic 1, 32
< %globals
---
> %ID Object
> %basic 64
620063c620302,620303
< _thisBasicValue: var Universal
---
> ==  : 
>    %basic 56
620064a620305,620318
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> Try: "=="
> Try: "=/="
> Try: "suspend"
> Try: "attach"
> Try: "call"
> Try: "onResume"
> Try: "onSuspend"
> Try: "dumpObj"
> Try: "X_asString"
> **** Signature:localSearch: inx in: Object
> **** Items:localSearch: inx
> **   in:
620066c620320,620334
< **** Items:localSearch: -
---
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> **** Items:localSearch:end: inx
> **** Signature:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:searchEmbodied: inx
> **   Items:searchEmbodied:end:
> **** Items:searchIncludeProp: inx in: 
> D2.put(D.get[L + 1 - inx]):at[inx]**   origin: 
> **** Items:searchIncludeProp:end: inx
> **** Items:search: "inx" isFirst:True
> **   in: 
> 
> **** Items:localSearch: inx
620069,620073c620337,620347
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
---
> **   isChecked: True
> **   Items:localSearch:Decls: inx
> **   Items:localSearch:trySuper:
> **** Items:localSearch: inx
> **   in:
> 
> %OSDvisibility skipInternal
> %globals inSub
> inx: var integer
> inx := first
> _doIt: do 
620076,620089c620350,620361
< **   Items:localSearch:Decls: -
< Try: "_thisBasicValue"
< Try: "+"
< Try: "-"
< **** Items:localSearch:end: -
< **** Items:search:end: -
< **** Found: "-" on=0 pn=0 Decl: "-  " visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** computing:encOG:BS.father=encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> **   Items:localSearch:Decls: inx
> Try: "inx"
> **** Items:localSearch:end: inx
> **** Items:localSearch:end: inx
> **** Items:search:end: inx
> >>> on + 1 = 1 found!: "inx"! ATd.father:Items
> 
> %OSDvisibility skipInternal
> %globals inSub
> inx: var integer
> inx := first
> _doIt: do 
620091c620363,620366
< **** encOG:False
---
> **** Items:search:end: inx
> **** Found: "inx" on=1 pn=1 Decl: "inx" visibility: "public"
> **   encModule: "BETAworld" domainModule: "BETAworld"
> **** encOG:True
620092a620368
> D2.put(D.get[L + 1 - inx]):at[inx]
620094,620099c620370,620375
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
---
> **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
> **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
> **** PRE: [0:for:to:repeat$0]
> **** pathToSuper: "
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
620101,620107c620377,620400
< **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> " of:DOG:
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> **   pathToSuper:DOG.super.scanSons:i=1:E:
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
>  :isImplSuper=False
> **   pathToSuper:E:"
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
> **   pathToSuper:end:super.last: "
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
> for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
>    %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
620108a620402
> **   PRE:onx,pnx,isR:2,0,False OGx:
620110,620116c620404,620408
< **** OI:getVqual:initial:- inx
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
---
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
620118,620125c620410
< **   OGs:[0:integer]
< **   ATd: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: -   :isVirtual:False
< [0:integer]
---
> **   PRE:result:[0:for:to:repeat$0,for:to:repeat]
620127,620136c620412,620417
< **** getVqual:initial:afterATd:- inx
< **   OGSx:[0:integer]
< **** savedOGS:save:False[0:integer]
< **   OI: - inx
< **   OI:getQual:savedOI:- inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:integer]
< **   OGS:[0:integer]
< **** DataItem:getVqual: out R: var integer
< [0:integer,nest(-)]
---
> **** OI:getVqual:initial:inx
> **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
> **   OGs:[0:for:to:repeat$0,for:to:repeat]
> **   ATd: inx: var integer
> **** DataItem:getVqual: inx: var integer
> [0:for:to:repeat$0,for:to:repeat]
620140c620421
< **   OGs: [0:integer,nest(-)]
---
> **   OGs: [0:for:to:repeat$0,for:to:repeat]
620142,620151c620423,620426
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
---
> **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
> **   OGS:continued:[0:for:to:repeat$0,for:to:repeat]
> **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
> **** koks: integer on: 1 Items 
620155,620161c620430,620484
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
---
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
> ...
> **** ENC:OI.getVqual:[1:for:to:repeat$0,for:to:repeat]
> **** pathToSuper: "
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> " of:DOG:
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> **   pathToSuper:DOG.super.scanSons:i=1:E:
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
>  :isImplSuper=False
> **   pathToSuper:E:"
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
> **   pathToSuper:end:super.last: "
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
> for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
>    %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
> ...
> **   ENC:pred:  pred.DOG: 
> for(1):to(L):repeat
>    D2.put(D.get[L + 1 - inx]):at[inx]
> 
> **   OGsuper: 
> %OSDvisibility skipInternal
>    %globals inSub
>    inx: var integer
>    inx := first
>    _doIt: do 
> ...
> **** ENC:OI.getVqual:[2:for:to:repeat$0]
> **   ENC:result:[2:I2S]
> **   ENC:[pnx=0]oENC[onx=2]
> **** ENC:OI.getVqual:[2:I2S]
> **   ENC:result:[2:StringLib]
> **** ENC:OI.getVqual:[3:StringLib]
> **   ENC:result:[3:LIB]
> **   ENC:result:[1:LIB]
620164c620487
< [0:BETA]
---
> [0:LIB]
620174c620497
< [0:BETA]
---
> [0:LIB]
620183,620184c620506,620507
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
---
> [0:LIB]
> **** savedOGS:save:False[0:LIB]
620188,620189c620511,620512
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
---
> **   savedOGS: [0:LIB]
> **   OGS:[0:LIB]
620199,620261c620522,620532
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: - inx
---
> **   OGS:[0:LIB]
> 
> **** getVqual:initial:afterATd:inx
> **   OGSx:[0:LIB]
> **** savedOGS:save:False[0:LIB]
> **   OI: inx
> **   OI:getQual:savedOI:inx
> **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
> **   savedOGS: [0:LIB]
> **   OGS:[0:LIB]
> **** OI:getVqual:end: inx
620270,620271c620541,620542
< **   OGS:[0:BETA]
< **** checkOI:checkOI:after:getVqual: -
---
> **   OGS:[0:LIB]
> **** checkOI:checkOI:after:getVqual: inx
620339,620340c620610,620611
< [0:BETA]
< **** checkOI:after:getVqual:OF: - qual:
---
> [0:LIB]
> **** checkOI:after:getVqual:OF: inx qual:
620355,620356c620626,620627
< [0:BETA]
< **** next:basicScope:from:-
---
> [0:LIB]
> **** next:basicScope:from:inx
620364,620366c620635
< **** INV:check:i=2 rec:- inx label: ObjectInvocation_Binary
< **   OGS: [0:BETA]
< **** check:super:end: 1 - inx
---
> **** check:super:end: inx
620369,620372c620638,620644
< %basic 62
< in V: var integer
< out R: var integer
< **   OG:  1 - inx
---
> %ID integer
> %basic 1, 32
> %globals
> %public
> _thisBasicValue: var Universal
> ...
> **   OG:  inx
620636,620670d620907
< 1
< **** **   scope::
< 
< ch := S.get[(S.length - inx + 1)]
< if ((ch > '0') || (inx = S.length)) :then 
<    ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** Arguments:check:1
< **** ObjectGenerator:check:1
< ****  basicScope:
< 
< ch := S.get[(S.length - inx + 1)]
< if ((ch > '0') || (inx = S.length)) :then 
<    ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** OG:check:super:1
< **   basicScope: 
< ch := S.get[(S.length - inx + 1)]
< if ((ch > '0') || (inx = S.length)) :then 
<    ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** Invocation:check: 1
< **** INV:check:i=0 rec:none label: ConstLiteral
< **   OGS: none
< **** check:super:end: 1
< **** superDesc:
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **   OG:  1
< **** argBuf:check:
623816,624188d624052
< inx
< **** **   scope::
< D2.put(D.get[L + 1 - inx]):at[inx]**** Arguments:check:inx
< **** ObjectGenerator:check:inx
< ****  basicScope:
< D2.put(D.get[L + 1 - inx]):at[inx]**** OG:check:super:inx
< **   basicScope: D2.put(D.get[L + 1 - inx]):at[inx]
< **** Invocation:check: inx
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
< **   OGS: none
< **** ObjectInvocation:checkOI: inx  isFirst:True
< **** basicScope:A:
< D2.put(D.get[L + 1 - inx]):at[inx]
< **** ObjectInvocation:check: inx
< **** Items:search: "inx" isFirst:True
< **   in: 
< D2.put(D.get[L + 1 - inx]):at[inx]
< **** Items:localSearch: inx
< **   in:
< D2.put(D.get[L + 1 - inx]):at[inx]
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "=="
< Try: "=/="
< Try: "suspend"
< Try: "attach"
< Try: "call"
< Try: "onResume"
< Try: "onSuspend"
< Try: "dumpObj"
< Try: "X_asString"
< **** Signature:localSearch: inx in: Object
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Items:localSearch:end: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:searchEmbodied: inx
< **   Items:searchEmbodied:end:
< **** Items:searchIncludeProp: inx in: 
< D2.put(D.get[L + 1 - inx]):at[inx]**   origin: 
< **** Items:searchIncludeProp:end: inx
< **** Items:search: "inx" isFirst:True
< **   in: 
< 
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **** Items:search:end: inx
< >>> on + 1 = 1 found!: "inx"! ATd.father:Items
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **** Items:search:end: inx
< **** Found: "inx" on=1 pn=1 Decl: "inx" visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** encOG:True
< **   OGS: none
< D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** PRE: [0:for:to:repeat$0]
< **** pathToSuper: "
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< " of:DOG:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   pathToSuper:DOG.super.scanSons:i=1:E:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
<  :isImplSuper=False
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:2,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$0,for:to:repeat]
< 
< **** OI:getVqual:initial:inx
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   OGs:[0:for:to:repeat$0,for:to:repeat]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$0,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$0,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$0,for:to:repeat]
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$0,for:to:repeat]
< **** pathToSuper: "
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< " of:DOG:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   pathToSuper:DOG.super.scanSons:i=1:E:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
<  :isImplSuper=False
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< " E.on=2 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< " :on=2:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$0]
< **   ENC:result:[2:I2S]
< **   ENC:[pnx=0]oENC[onx=2]
< **** ENC:OI.getVqual:[2:I2S]
< **   ENC:result:[2:StringLib]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** checkOI:checkOI:after:getVqual: inx
< **** qual:
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< **** OGS:
< [0:LIB]
< **** checkOI:after:getVqual:OF: inx qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** OGS:
< [0:LIB]
< **** next:basicScope:from:inx
< **   basicScope: 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **** check:super:end: inx
< **** superDesc:
< 
< %ID integer
< %basic 1, 32
< %globals
< %public
< _thisBasicValue: var Universal
< ...
< **   OG:  inx
< **** argBuf:check:
624958,625136d624821
< **** OG:semCheck:
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** Invocation:semCheck: BETA
< **   encOG:
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< 
< **** OI:semCheck: "BETA" rec: "%modules"
< **   encOG:
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< 
< **** Invocation:semCheck: LIB
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** OI:semCheck: "LIB" rec: "BETA"
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** Invocation:semCheck: LIB.StringLib
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "LIB" rec: "LIB"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "StringLib" rec: "LIB"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** Invocation:semCheck: LIB.BasicIo
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** OI:semCheck: "LIB" rec: "LIB.StringLib"
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** OI:semCheck: "BasicIo" rec: "LIB"
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** OG:semCheck:%basic 999
< **   encOG: %basic 999
< **** Invocation:semCheck: 
< **   encOG:%basic 999
< **** Invocation:semCheck: 999
< **   encOG:%basic 999
< **** OG:semcheck:IS not empty:eOG: 
< %basic 999
< **** OG:semCheck:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   encOG: 
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< 
< **** Invocation:semCheck: disguised
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** OI:semCheck: "disguised" rec: "%OSDvisibility"
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** Pattern:checkActualArgs:
< disguised: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **** Invocation:semCheck: LIB
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** OI:semCheck: "LIB" rec: "%module"
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
625138,625145c624823
< **** Invocation:semCheck: LIB.StringLib
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
---
> ***** Semantic errors: compilation stops
625147,781283d624824
< **** OI:semCheck: "LIB" rec: "LIB"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "StringLib" rec: "LIB"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OG:semCheck:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** Invocation:semCheck: 64
< **   encOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OG:semCheck:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   encOG: 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< 
< **** Invocation:semCheck: 56
< **   encOG:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   encOG: 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< 
< **** Invocation:semCheck: 57
< **   encOG:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:%basic 111
< **   encOG: %basic 111
< **** Invocation:semCheck: 
< **   encOG:%basic 111
< **** Invocation:semCheck: 111
< **   encOG:%basic 111
< **** OG:semcheck:IS not empty:eOG: 
< %basic 111
< **** OG:semCheck:
< %basic 10
<    in V: var integer
< **   encOG: 
< %basic 10
<    in V: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 10
<    in V: var integer
< 
< **** Invocation:semCheck: 10
< **   encOG:
< %basic 10
<    in V: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 10
<    in V: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 10
<    in V: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 10
<    in V: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 10
<    in V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 10
<    in V: var integer
< **** OG:semCheck:%basic 113
< **   encOG: %basic 113
< **** Invocation:semCheck: 
< **   encOG:%basic 113
< **** Invocation:semCheck: 113
< **   encOG:%basic 113
< **** OG:semcheck:IS not empty:eOG: 
< %basic 113
< **** OG:semCheck:%basic 119
< **   encOG: %basic 119
< **** Invocation:semCheck: 
< **   encOG:%basic 119
< **** Invocation:semCheck: 119
< **   encOG:%basic 119
< **** OG:semcheck:IS not empty:eOG: 
< %basic 119
< **** OG:semCheck:%basic 120
< **   encOG: %basic 120
< **** Invocation:semCheck: 
< **   encOG:%basic 120
< **** Invocation:semCheck: 120
< **   encOG:%basic 120
< **** OG:semcheck:IS not empty:eOG: 
< %basic 120
< **** OG:semCheck:
< %basic 140
<    out R: ref Indexed
< **   encOG: 
< %basic 140
<    out R: ref Indexed
< **** Invocation:semCheck: 
< **   encOG:
< %basic 140
<    out R: ref Indexed
< 
< **** Invocation:semCheck: 140
< **   encOG:
< %basic 140
<    out R: ref Indexed
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 140
<    out R: ref Indexed
< **** OG:returnDecl: out R: ref Indexed
< **** OG:semCheck:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **   encOG: 
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** Invocation:semCheck: -- does not wokr, problem with virtual in Object
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** OG:semCheck:LIB.StringLib.String
< **   encOG: 
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** Invocation:semCheck: LIB.StringLib.String
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** OI:semCheck: "LIB" rec: "none"
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** OI:semCheck: "StringLib" rec: "LIB"
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** OI:semCheck: "String" rec: "StringLib"
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** Pattern:checkActualArgs:
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:semCheck:inner(X_asString)
< **   encOG: 
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** Invocation:semCheck: inner(X_asString)
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** OI:semCheck: "inner(X_asString)" rec: "none"
< **   encOG:
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** OG:returnDecl: out S: var LIB.StringLib.String
< **** OG:semCheck:inner(Object)
< **   encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: inner(Object)
< **   encOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OI:semCheck: "inner(Object)" rec: "none"
< **   encOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   encOG: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< 
< **** Invocation:semCheck: 21
< **   encOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< 
< **** OG:semCheck:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   encOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Invocation:semCheck: 
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** Invocation:semCheck: 50
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OG:semCheck:this(Value)
< **   encOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Invocation:semCheck: this(Value)
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OI:semCheck: "this(Value)" rec: "none"
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:inner(#= = )
< **   encOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Invocation:semCheck: inner(#= = )
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OI:semCheck: "inner(#= = )" rec: "none"
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   encOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** Invocation:semCheck: 52
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** OG:semCheck:this(Value)
< **   encOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Invocation:semCheck: this(Value)
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** OI:semCheck: "this(Value)" rec: "none"
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** OG:semCheck:
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **   encOG: 
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **** Invocation:semCheck: Value
< **   encOG:
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< 
< **** OI:semCheck: "Value" rec: "universal"
< **   encOG:
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< 
< **** Invocation:semCheck: 1
< **   encOG:
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< 
< **** Invocation:semCheck: 32
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OG:semCheck:
< %basic 61
<    in V: var integer
<    out R: var integer
< **   encOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** Invocation:semCheck: 61
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** OG:returnDecl: out R: var integer
< **** OG:semCheck:
< %basic 62
<    in V: var integer
<    out R: var integer
< **   encOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** Invocation:semCheck: 62
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **** OG:semCheck:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: value
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:semCheck: "value" rec: "integer"
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** Invocation:semCheck: 1
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** Invocation:semCheck: 32
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OG:semCheck:Universal
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: Universal
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:semCheck: "Universal" rec: "none"
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** Pattern:checkActualArgs:
< universal: Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **** OG:semCheck:
< %basic 61
<    in V: var integer
<    out R: var integer
< **   encOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** Invocation:semCheck: 61
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 61
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** OG:returnDecl: out R: var integer
< **** OG:semCheck:
< %basic 62
<    in V: var integer
<    out R: var integer
< **   encOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** Invocation:semCheck: 62
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 62
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** OG:returnDecl: out R: var integer
< **** OG:semCheck:
< %basic 66
<    in V: var integer
<    out R: var integer
< **   encOG: 
< %basic 66
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< 
< **** Invocation:semCheck: 66
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 66
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 66
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 66
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 66
<    in V: var integer
<    out R: var integer
< **** OG:returnDecl: out R: var integer
< **** OG:semCheck:
< %basic 67
<    in V: var integer
<    out R: var integer
< **   encOG: 
< %basic 67
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< 
< **** Invocation:semCheck: 67
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 67
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 67
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 67
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 67
<    in V: var integer
<    out R: var integer
< **** OG:returnDecl: out R: var integer
< **** OG:semCheck:
< %basic 68
<    in V: var integer
<    out B: var integer
< **   encOG: 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< 
< **** Invocation:semCheck: 68
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 68
<    in V: var integer
<    out B: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** OG:returnDecl: out B: var integer
< **** OG:semCheck:
< %basic 69
<    in V: var integer
<    out R: var integer
< **   encOG: 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< 
< **** Invocation:semCheck: 69
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 69
<    in V: var integer
<    out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** OG:returnDecl: out R: var integer
< **** OG:semCheck:
< %basic 50
<    in V: var integer
<    out B: var boolean
< **   encOG: 
< %basic 50
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< 
< **** Invocation:semCheck: 50
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 50
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 50
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 50
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 50
<    in V: var integer
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   encOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< 
< **** Invocation:semCheck: 51
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 52
<    in V: var integer
<    out B: var boolean
< **   encOG: 
< %basic 52
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< 
< **** Invocation:semCheck: 52
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 52
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 52
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 52
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 52
<    in V: var integer
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   encOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< 
< **** Invocation:semCheck: 53
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 54
<    in V: var integer
<    out B: var boolean
< **   encOG: 
< %basic 54
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< 
< **** Invocation:semCheck: 54
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 54
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 54
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 54
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 54
<    in V: var integer
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 55
<    in V: var integer
<    out B: var boolean
< **   encOG: 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< 
< **** Invocation:semCheck: 55
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 14
<    in V: var integer
<    out res: var integer
< **   encOG: 
< %basic 14
<    in V: var integer
<    out res: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< 
< **** Invocation:semCheck: 14
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 14
<    in V: var integer
<    out res: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 14
<    in V: var integer
<    out res: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 14
<    in V: var integer
<    out res: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 14
<    in V: var integer
<    out res: var integer
< **** OG:returnDecl: out res: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: value
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OI:semCheck: "value" rec: "Boolean"
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** Invocation:semCheck: inSub
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OI:semCheck: "inSub" rec: "%globals"
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** Pattern:checkActualArgs:
< inSub: 
<    %basic 7
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 4
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** Invocation:semCheck: 8
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OG:semCheck:Universal
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: Universal
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OI:semCheck: "Universal" rec: "none"
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** Pattern:checkActualArgs:
< universal: Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **** OG:semCheck:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   encOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< 
< **** Invocation:semCheck: 70
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** OG:returnDecl: out R: var boolean
< **** OG:semCheck:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **   encOG: 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< 
< **** Invocation:semCheck: 63
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** OG:returnDecl: out R: var boolean
< **** OG:semCheck:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< **   encOG: 
< %basic 50
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< 
< **** Invocation:semCheck: 50
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 50
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 50
<    in B: var boolean
<    out R: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 50
<    in B: var boolean
<    out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 50
<    in B: var boolean
<    out R: var boolean
< **** OG:returnDecl: out R: var boolean
< **** OG:semCheck:
< %basic 65
<    out R: var boolean
< **   encOG: 
< %basic 65
<    out R: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 65
<    out R: var boolean
< 
< **** Invocation:semCheck: 65
< **   encOG:
< %basic 65
<    out R: var boolean
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 65
<    out R: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 65
<    out R: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 65
<    out R: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 65
<    out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 65
<    out R: var boolean
< **** OG:returnDecl: out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< %globals
<    out B: var boolean
<    B := 0
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 0
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    out B: var boolean
<    B := 0
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 0
< **** Invocation:semCheck: boolean
< **   encOG:
< %globals
<    out B: var boolean
<    B := 0
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %globals
<    out B: var boolean
<    B := 0
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    out B: var boolean
<    B := 0
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:0
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 0
< **** Invocation:semCheck: 0
< **   encOG:
< %globals
<    out B: var boolean
<    B := 0
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 0
< 
< **** OI:getVqual:initial:B
< **   encOG:
< %globals
<    out B: var boolean
<    B := 0
< **   OGs:[0:False]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:False]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:False]
< 
< **** OI:getVqual: boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:False]
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 0
< **** koks: boolean on: 1 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %globals
<    out B: var boolean
<    B := 0
< **** ENC:OI.getVqual:[1:False]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    out B: var boolean
<    B := 0
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %globals
<    out B: var boolean
<    B := 1
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 1
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    out B: var boolean
<    B := 1
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 1
< **** Invocation:semCheck: boolean
< **   encOG:
< %globals
<    out B: var boolean
<    B := 1
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %globals
<    out B: var boolean
<    B := 1
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    out B: var boolean
<    B := 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:1
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 1
< **** Invocation:semCheck: 1
< **   encOG:
< %globals
<    out B: var boolean
<    B := 1
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 1
< 
< **** OI:getVqual:initial:B
< **   encOG:
< %globals
<    out B: var boolean
<    B := 1
< **   OGs:[0:True]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:True]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:True]
< 
< **** OI:getVqual: boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:True]
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 1
< **** koks: boolean on: 1 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %globals
<    out B: var boolean
<    B := 1
< **** ENC:OI.getVqual:[1:True]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    out B: var boolean
<    B := 1
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Invocation:semCheck: value
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** OI:semCheck: "value" rec: "char"
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** Invocation:semCheck: 3
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** Invocation:semCheck: 16
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OG:semCheck:Universal
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Invocation:semCheck: Universal
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** OI:semCheck: "Universal" rec: "none"
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** Pattern:checkActualArgs:
< universal: Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %ID universal
<    %basic 1, 32
<    %globals
<    +  : 
< ...
< **** OG:semCheck:
< %basic 61
<    in V: var char
<    out R: var char
< **   encOG: 
< %basic 61
<    in V: var char
<    out R: var char
< **** Invocation:semCheck: 
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< 
< **** Invocation:semCheck: 61
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 61
<    in V: var char
<    out R: var char
< **** Invocation:semCheck: char
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< %basic 61
<    in V: var char
<    out R: var char
< **** Invocation:semCheck: char
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 61
<    in V: var char
<    out R: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 61
<    in V: var char
<    out R: var char
< **** OG:returnDecl: out R: var char
< **** OG:semCheck:
< %basic 62
<    in V: var char
<    out R: var char
< **   encOG: 
< %basic 62
<    in V: var char
<    out R: var char
< **** Invocation:semCheck: 
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< 
< **** Invocation:semCheck: 62
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 62
<    in V: var char
<    out R: var char
< **** Invocation:semCheck: char
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< %basic 62
<    in V: var char
<    out R: var char
< **** Invocation:semCheck: char
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 62
<    in V: var char
<    out R: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 62
<    in V: var char
<    out R: var char
< **** OG:returnDecl: out R: var char
< **** OG:semCheck:
< %basic 50
<    in V: var char
<    out B: var boolean
< **   encOG: 
< %basic 50
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< 
< **** Invocation:semCheck: 50
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 50
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: char
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 50
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 50
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 50
<    in V: var char
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 51
<    in V: var char
<    out B: var boolean
< **   encOG: 
< %basic 51
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< 
< **** Invocation:semCheck: 51
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 51
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: char
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 51
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 51
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 51
<    in V: var char
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 52
<    in V: var char
<    out B: var boolean
< **   encOG: 
< %basic 52
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< 
< **** Invocation:semCheck: 52
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 52
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: char
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 52
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 52
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 52
<    in V: var char
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 53
<    in V: var char
<    out B: var boolean
< **   encOG: 
< %basic 53
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< 
< **** Invocation:semCheck: 53
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 53
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: char
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 53
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 53
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 53
<    in V: var char
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 54
<    in V: var char
<    out B: var boolean
< **   encOG: 
< %basic 54
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< 
< **** Invocation:semCheck: 54
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 54
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: char
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 54
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 54
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 54
<    in V: var char
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 55
<    in V: var char
<    out B: var boolean
< **   encOG: 
< %basic 55
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< 
< **** Invocation:semCheck: 55
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 55
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: char
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 55
<    in V: var char
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 55
<    in V: var char
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 55
<    in V: var char
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:
< value
<    %basic 9
<    %globals
<    +  : 
<       %basic 109
< ...
< **   encOG: 
< value
<    %basic 9
<    %globals
<    +  : 
<       %basic 109
< ...
< **** Invocation:semCheck: value
< **   encOG:
< value
<    %basic 9
<    %globals
<    +  : 
<       %basic 109
< ...
< 
< **** OI:semCheck: "value" rec: "universalFloat"
< **   encOG:
< value
<    %basic 9
<    %globals
<    +  : 
<       %basic 109
< ...
< 
< **** Invocation:semCheck: 9
< **   encOG:
< value
<    %basic 9
<    %globals
<    +  : 
<       %basic 109
< ...
< 
< **** OG:semCheck:
< %basic 109
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 109
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 109
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 110
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 110
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 110
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 112
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 112
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 121
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 121
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 121
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %basic 9
<    %globals
<    +  : 
<       %basic 109
< ...
< **** OG:semCheck:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   encOG: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Invocation:semCheck: Value
< **   encOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:semCheck: "Value" rec: "float"
< **   encOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** Invocation:semCheck: 9
< **   encOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OG:semCheck:Float
< **   encOG: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Invocation:semCheck: Float
< **   encOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:
< %basic 109
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 109
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 109
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 109
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 110
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 110
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 110
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 110
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 112
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 112
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 112
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 121
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 121
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 121
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 121
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:%basic 122
< **   encOG: %basic 122
< **** Invocation:semCheck: 
< **   encOG:%basic 122
< **** Invocation:semCheck: 122
< **   encOG:%basic 122
< **** OG:semcheck:IS not empty:eOG: 
< %basic 122
< **** OG:semCheck:
< %basic 123
<    in V: var float
<    out B: var boolean
< **   encOG: 
< %basic 123
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< 
< **** Invocation:semCheck: 123
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 123
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: float
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 123
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 123
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 123
<    in V: var float
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 124
<    in V: var float
<    out B: var boolean
< **   encOG: 
< %basic 124
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< 
< **** Invocation:semCheck: 124
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 124
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: float
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 124
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 124
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 124
<    in V: var float
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 125
<    in V: var float
<    out B: var boolean
< **   encOG: 
< %basic 125
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< 
< **** Invocation:semCheck: 125
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 125
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: float
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 125
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 125
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 125
<    in V: var float
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 126
<    in V: var float
<    out B: var boolean
< **   encOG: 
< %basic 126
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< 
< **** Invocation:semCheck: 126
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 126
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: float
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 126
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 126
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 126
<    in V: var float
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 127
<    in V: var float
<    out B: var boolean
< **   encOG: 
< %basic 127
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< 
< **** Invocation:semCheck: 127
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 127
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: float
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %basic 127
<    in V: var float
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 127
<    in V: var float
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 127
<    in V: var float
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< **   encOG: 
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< **** Invocation:semCheck: 
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< 
< **** Invocation:semCheck: 136
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< Float
< --R := exp(_thisBasicValue,n)
< **   encOG: 
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< **** Invocation:semCheck: Float
< --R := exp(_thisBasicValue,n)
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< 
< **** OI:semCheck: "Float
< --R := exp(_thisBasicValue,n)" rec: "none"
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: --R := exp(_thisBasicValue,n)
< **   fArgs()
< 
< **   encOG:
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 136
<    in n: var integer
<    out R: var Float
<    --R := exp(_thisBasicValue,n)
< **** OG:returnDecl: out R: var Float
< --R := exp(_thisBasicValue,n)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   encOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** Invocation:semCheck: -- to be eliminated
< **   encOG:
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< 
< **** Invocation:semCheck: 2
< **   encOG:
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< 
< **** OG:semCheck:char
< **   encOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** Invocation:semCheck: char
< **   encOG:
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:
< %globals
<    %basic 2
<    in ch: var char
< **   encOG: 
< %globals
<    %basic 2
<    in ch: var char
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    %basic 2
<    in ch: var char
< 
< **** Invocation:semCheck: 2
< **   encOG:
< %globals
<    %basic 2
<    in ch: var char
< 
< **** OG:semCheck:char
< **   encOG: 
< %globals
<    %basic 2
<    in ch: var char
< **** Invocation:semCheck: char
< **   encOG:
< %globals
<    %basic 2
<    in ch: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %globals
<    %basic 2
<    in ch: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    %basic 2
<    in ch: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 2
<    in ch: var char
< **** OG:semCheck:
< %basic 23
<    out c: var char
< **   encOG: 
< %basic 23
<    out c: var char
< **** Invocation:semCheck: 
< **   encOG:
< %basic 23
<    out c: var char
< 
< **** Invocation:semCheck: 23
< **   encOG:
< %basic 23
<    out c: var char
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 23
<    out c: var char
< **** Invocation:semCheck: char
< **   encOG:
< %basic 23
<    out c: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 23
<    out c: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 23
<    out c: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 23
<    out c: var char
< **** OG:returnDecl: out c: var char
< **** OG:semCheck:
< %external 4
<    out ch: var char
< **   encOG: 
< %external 4
<    out ch: var char
< **** Invocation:semCheck: 
< **   encOG:
< %external 4
<    out ch: var char
< 
< **** Invocation:semCheck: 4
< **   encOG:
< %external 4
<    out ch: var char
< 
< **** OG:semCheck:char
< **   encOG: 
< %external 4
<    out ch: var char
< **** Invocation:semCheck: char
< **   encOG:
< %external 4
<    out ch: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %external 4
<    out ch: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %external 4
<    out ch: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %external 4
<    out ch: var char
< **** OG:returnDecl: out ch: var char
< **** OG:semCheck:
< %external 5
<    out B: var boolean
< **   encOG: 
< %external 5
<    out B: var boolean
< **** Invocation:semCheck: 
< **   encOG:
< %external 5
<    out B: var boolean
< 
< **** Invocation:semCheck: 5
< **   encOG:
< %external 5
<    out B: var boolean
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %external 5
<    out B: var boolean
< **** Invocation:semCheck: boolean
< **   encOG:
< %external 5
<    out B: var boolean
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %external 5
<    out B: var boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %external 5
<    out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %external 5
<    out B: var boolean
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< %basic 19
<    none_x: var integer
< **   encOG: 
< %basic 19
<    none_x: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 19
<    none_x: var integer
< 
< **** Invocation:semCheck: 19
< **   encOG:
< %basic 19
<    none_x: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 19
<    none_x: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 19
<    none_x: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 19
<    none_x: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 19
<    none_x: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< **** OG:semCheck:
< %basic 20
<    inner(immutable)
< **   encOG: 
< %basic 20
<    inner(immutable)
< **** Invocation:semCheck: 
< **   encOG:
< %basic 20
<    inner(immutable)
< 
< **** Invocation:semCheck: 20
< **   encOG:
< %basic 20
<    inner(immutable)
< 
< **** OG:semCheck:inner(immutable)
< **   encOG: 
< %basic 20
<    inner(immutable)
< **** Invocation:semCheck: inner(immutable)
< **   encOG:
< %basic 20
<    inner(immutable)
< 
< **** OI:semCheck: "inner(immutable)" rec: "none"
< **   encOG:
< %basic 20
<    inner(immutable)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 20
<    inner(immutable)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 20
<    inner(immutable)
< **** OG:semCheck:inner(unique)
< **   encOG: inner(unique)
< **** Invocation:semCheck: 
< **   encOG:inner(unique)
< **** OG:semCheck:inner(unique)
< **   encOG: inner(unique)
< **** Invocation:semCheck: inner(unique)
< **   encOG:inner(unique)
< **** OI:semCheck: "inner(unique)" rec: "none"
< **   encOG:inner(unique)
< **** OG:semcheck:IS not empty:eOG: 
< inner(unique)
< **** OG:semcheck:IS not empty:eOG: 
< inner(unique)
< **** OG:semCheck:
< %basic 101
<    in inner: ref Object
< **   encOG: 
< %basic 101
<    in inner: ref Object
< **** Invocation:semCheck: 
< **   encOG:
< %basic 101
<    in inner: ref Object
< 
< **** Invocation:semCheck: 101
< **   encOG:
< %basic 101
<    in inner: ref Object
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 101
<    in inner: ref Object
< **** OG:semCheck:
< %basic 18
<    in this: ref Object
< **   encOG: 
< %basic 18
<    in this: ref Object
< **** Invocation:semCheck: 
< **   encOG:
< %basic 18
<    in this: ref Object
< 
< **** Invocation:semCheck: 18
< **   encOG:
< %basic 18
<    in this: ref Object
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 18
<    in this: ref Object
< **** OG:semCheck:%basic 11
< **   encOG: %basic 11
< **** Invocation:semCheck: 
< **   encOG:%basic 11
< **** Invocation:semCheck: 11
< **   encOG:%basic 11
< **** OG:semcheck:IS not empty:eOG: 
< %basic 11
< **** OG:semCheck:%basic 12
< **   encOG: %basic 12
< **** Invocation:semCheck: 
< **   encOG:%basic 12
< **** Invocation:semCheck: 12
< **   encOG:%basic 12
< **** OG:semcheck:IS not empty:eOG: 
< %basic 12
< **** OG:semCheck:
< %basic 13
<    in S: ref Object
< **   encOG: 
< %basic 13
<    in S: ref Object
< **** Invocation:semCheck: 
< **   encOG:
< %basic 13
<    in S: ref Object
< 
< **** Invocation:semCheck: 13
< **   encOG:
< %basic 13
<    in S: ref Object
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 13
<    in S: ref Object
< **** OG:semCheck:
< %basic 15
<    in V: var integer
< **   encOG: 
< %basic 15
<    in V: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 15
<    in V: var integer
< 
< **** Invocation:semCheck: 15
< **   encOG:
< %basic 15
<    in V: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 15
<    in V: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 15
<    in V: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 15
<    in V: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 15
<    in V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 15
<    in V: var integer
< **** OG:semCheck:
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< **   encOG: 
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< **** Invocation:semCheck: 
< **   encOG:
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< 
< **** Invocation:semCheck: 16
< **   encOG:
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< 
< **** OG:semCheck:inner(SuperCore)
< **   encOG: 
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< **** Invocation:semCheck: inner(SuperCore)
< **   encOG:
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< 
< **** OI:semCheck: "inner(SuperCore)" rec: "none"
< **   encOG:
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< **** OG:semCheck:
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< **   encOG: 
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< **** Invocation:semCheck: 
< **   encOG:
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< 
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "thisScheduler"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:GeneralProcess
< **   encOG: GeneralProcess
< **** Invocation:semCheck: GeneralProcess
< **   encOG:GeneralProcess
< **** OI:semCheck: "GeneralProcess" rec: "ProcessType"
< **   encOG:GeneralProcess
< **** OG:semcheck:IS not empty:eOG: 
< 
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **** OG:semCheck:inner(SuperScheduler)
< **   encOG: 
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< **** Invocation:semCheck: inner(SuperScheduler)
< **   encOG:
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< 
< **** OI:semCheck: "inner(SuperScheduler)" rec: "none"
< **   encOG:
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< **** OG:semcheck:IS not empty:eOG: 
< 
< thisScheduler:< Object
<    ProcessType:< GeneralProcess
<    active: ref ProcessType
<    inner(SuperScheduler)
< **** Invocation:semCheck: "("
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< 
< **** Invocation:semCheck: ")"
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< 
< **** OG:semCheck:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **   encOG: 
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< 
< **** OG:semCheck:inner(start)
< **   encOG: inner(start)
< **** Invocation:semCheck: 
< **   encOG:inner(start)
< **** OG:semCheck:inner(start)
< **   encOG: inner(start)
< **** Invocation:semCheck: inner(start)
< **   encOG:inner(start)
< **** OI:semCheck: "inner(start)" rec: "none"
< **   encOG:inner(start)
< **** OG:semcheck:IS not empty:eOG: 
< inner(start)
< **** OG:semcheck:IS not empty:eOG: 
< inner(start)
< **** OG:semCheck:inner(mkActive)
< **   encOG: inner(mkActive)
< **** Invocation:semCheck: 
< **   encOG:inner(mkActive)
< **** OG:semCheck:inner(mkActive)
< **   encOG: inner(mkActive)
< **** Invocation:semCheck: inner(mkActive)
< **   encOG:inner(mkActive)
< **** OI:semCheck: "inner(mkActive)" rec: "none"
< **   encOG:inner(mkActive)
< **** OG:semcheck:IS not empty:eOG: 
< inner(mkActive)
< **** OG:semcheck:IS not empty:eOG: 
< inner(mkActive)
< **** OG:semCheck:
< --put('q')inner(addWaiting)
<    --put('R')
< **   encOG: 
< --put('q')inner(addWaiting)
<    --put('R')
< **** Invocation:semCheck: 
< **   encOG:
< --put('q')inner(addWaiting)
<    --put('R')
< 
< **** OG:semCheck:
< inner(addWaiting)
< --put('R')
< **   encOG: 
< --put('q')inner(addWaiting)
<    --put('R')
< **** Invocation:semCheck: inner(addWaiting)
< --put('R')
< **   encOG:
< --put('q')inner(addWaiting)
<    --put('R')
< 
< **** OI:semCheck: "inner(addWaiting)" rec: "none"
< **   encOG:
< --put('q')inner(addWaiting)
<    --put('R')
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< --put('q')inner(addWaiting)
<    --put('R')
< **** OG:semcheck:IS not empty:eOG: 
< 
< --put('q')inner(addWaiting)
<    --put('R')
< **** OG:semCheck:inner(dcrWaiting)
< **   encOG: inner(dcrWaiting)
< **** Invocation:semCheck: 
< **   encOG:inner(dcrWaiting)
< **** OG:semCheck:inner(dcrWaiting)
< **   encOG: inner(dcrWaiting)
< **** Invocation:semCheck: inner(dcrWaiting)
< **   encOG:inner(dcrWaiting)
< **** OI:semCheck: "inner(dcrWaiting)" rec: "none"
< **   encOG:inner(dcrWaiting)
< **** OG:semcheck:IS not empty:eOG: 
< inner(dcrWaiting)
< **** OG:semcheck:IS not empty:eOG: 
< inner(dcrWaiting)
< **** OG:semCheck:
< "\n---GP:---".print
<    inner(display)
< **   encOG: 
< "\n---GP:---".print
<    inner(display)
< **** Invocation:semCheck: 
< **   encOG:
< "\n---GP:---".print
<    inner(display)
< 
< **** OG:semCheck:"\n---GP:---".print
< **   encOG: 
< "\n---GP:---".print
<    inner(display)
< **** Invocation:semCheck: "\n---GP:---".print
< **   encOG:
< "\n---GP:---".print
<    inner(display)
< 
< **** OI:semCheck: "print" rec: ""\n---GP:---""
< **   encOG:
< "\n---GP:---".print
<    inner(display)
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "\n---GP:---".print
<    inner(display)
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:inner(display)
< **   encOG: 
< "\n---GP:---".print
<    inner(display)
< **** Invocation:semCheck: inner(display)
< **   encOG:
< "\n---GP:---".print
<    inner(display)
< 
< **** OI:semCheck: "inner(display)" rec: "none"
< **   encOG:
< "\n---GP:---".print
<    inner(display)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< "\n---GP:---".print
<    inner(display)
< **** OG:semcheck:IS not empty:eOG: 
< 
< "\n---GP:---".print
<    inner(display)
< **** OG:semCheck:integer
< **   encOG: 
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:inner(GeneralProcess)
< **   encOG: 
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **** Invocation:semCheck: inner(GeneralProcess)
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< 
< **** OI:semCheck: "inner(GeneralProcess)" rec: "none"
< **   encOG:
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< start:< 
<       inner(start)
<    mkActive:< 
<       inner(mkActive)
<    addWaiting:< 
< ...
< **** OG:semCheck:
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< **   encOG: 
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< **** Invocation:semCheck: 
< **   encOG:
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< 
< **** Invocation:semCheck: 22
< **   encOG:
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- perhaps never used and/or implemented i betaVM?%basic 22
<    outV: var integer
< **** OG:semCheck:
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **   encOG: 
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **** Invocation:semCheck: 
< **   encOG:
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< 
< **** Invocation:semCheck: 17
< **   encOG:
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< 
< **** OG:semCheck:SuperCore
< **   encOG: 
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **** Invocation:semCheck: SuperCore
< **   encOG:
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< 
< **** OI:semCheck: "SuperCore" rec: "C"
< **   encOG:
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< 
< **** Pattern:checkActualArgs:
< SuperCore: 
<    %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **** OG:semcheck:IS not empty:eOG: 
< 
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< 
< **** OI:getVqual: C on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< 
< **** OI:getVqual:initial:C
< **   encOG:
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **   OGs:[0:thisCore]
< **   ATd: out C: ref SuperCore
< **** DataItem:getVqual: out C: ref SuperCore
< [0:thisCore]
< **** ObjectGenerator:getVqual: SuperCore
< **   hasVirtualArgs: False
< **** INV:getVqual:SuperCore
< **   OGs: [0:thisCore]
< 
< **** OI:getVqual: SuperCore on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:thisCore]
< **   encOG: 
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **** koks: SuperCore on: 1 Items 
< **   father: SuperCore
< **   father.f.f.f.f:
< 
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **** ENC:OI.getVqual:[1:thisCore]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< SuperCore: 
<    %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< **** Pattern:getVqual: SuperCore :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: SuperCore
< **   OI:getQual:savedOI:SuperCore
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: SuperCore
< **   qual: 
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:C
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: C
< **   OI:getQual:savedOI:C
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: C
< **   qual: 
< %core 16
<    main: ref SuperScheduler
<    inner(SuperCore)
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- BasicSystem:: Core should be moved to here!%basic 17
<    out C: ref SuperCore
<    C := SuperCore
< **** OG:returnDecl: out C: ref SuperCore
< **** OG:semCheck:%basic 7
< **   encOG: %basic 7
< **** Invocation:semCheck: 
< **   encOG:%basic 7
< **** Invocation:semCheck: 7
< **   encOG:%basic 7
< **** OG:semcheck:IS not empty:eOG: 
< %basic 7
< **** OG:semCheck:dummy: var integer -- to handle %kind method, but not implememnted
< **   encOG: dummy: var integer -- to handle %kind method, but not implememnted
< **** Invocation:semCheck: 
< **   encOG:dummy: var integer -- to handle %kind method, but not implememnted
< **** OG:semCheck:integer -- to handle %kind method, but not implememnted
< **   encOG: dummy: var integer -- to handle %kind method, but not implememnted
< **** Invocation:semCheck: integer -- to handle %kind method, but not implememnted
< **   encOG:dummy: var integer -- to handle %kind method, but not implememnted
< **** OI:semCheck: "integer -- to handle %kind method, but not implememnted" rec: "none"
< **   encOG:dummy: var integer -- to handle %kind method, but not implememnted
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: -- to handle %kind method, but not implememnted
< **   fArgs()
< 
< **   encOG:dummy: var integer -- to handle %kind method, but not implememnted**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< dummy: var integer -- to handle %kind method, but not implememnted
< **** OG:semCheck:dummy: var integer -- const for OSDvisibility
< **   encOG: dummy: var integer -- const for OSDvisibility
< **** Invocation:semCheck: 
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** OG:semCheck:integer -- const for OSDvisibility
< **   encOG: dummy: var integer -- const for OSDvisibility
< **** Invocation:semCheck: integer -- const for OSDvisibility
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** OI:semCheck: "integer -- const for OSDvisibility" rec: "none"
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: -- const for OSDvisibility
< **   fArgs()
< 
< **   encOG:dummy: var integer -- const for OSDvisibility**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< dummy: var integer -- const for OSDvisibility
< **** OG:semCheck:dummy: var integer -- const for OSDvisibility
< **   encOG: dummy: var integer -- const for OSDvisibility
< **** Invocation:semCheck: 
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** OG:semCheck:integer -- const for OSDvisibility
< **   encOG: dummy: var integer -- const for OSDvisibility
< **** Invocation:semCheck: integer -- const for OSDvisibility
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** OI:semCheck: "integer -- const for OSDvisibility" rec: "none"
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: -- const for OSDvisibility
< **   fArgs()
< 
< **   encOG:dummy: var integer -- const for OSDvisibility**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< dummy: var integer -- const for OSDvisibility
< **** OG:semCheck:dummy: var integer -- const for OSDvisibility
< **   encOG: dummy: var integer -- const for OSDvisibility
< **** Invocation:semCheck: 
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** OG:semCheck:integer -- const for OSDvisibility
< **   encOG: dummy: var integer -- const for OSDvisibility
< **** Invocation:semCheck: integer -- const for OSDvisibility
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** OI:semCheck: "integer -- const for OSDvisibility" rec: "none"
< **   encOG:dummy: var integer -- const for OSDvisibility
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: -- const for OSDvisibility
< **   fArgs()
< 
< **   encOG:dummy: var integer -- const for OSDvisibility**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< dummy: var integer -- const for OSDvisibility
< **** Invocation:semCheck: "("
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: ","
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< 
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "elm"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: ")"
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< 
< **** OG:semCheck:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< 
< **** Invocation:semCheck: 114
< **   encOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< 
< **** OG:semCheck:
< out res: var integer
<    res := get[0]
<    in at: var integer
< **   encOG: 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** Invocation:semCheck: 
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:get[0]
< **   encOG: 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** Invocation:semCheck: get[0]
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** OI:semCheck: "get[0]" rec: "res"
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   actualArgs: get[0]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< **   argAtInx: 1 in:PTN:
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   theOI: get[0]
< **   fArg: inx: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< get[0]
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< **   savedOGS: [0:Array]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   theOI: get[0]
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 116
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: get[inx: var integer] -> V: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Array]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **   After:[0:Array,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: %basic 116**   OGS: [0:Array,nest(get)]
< **   theFargOG:
< %basic 116
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Array,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:Array,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Array,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Array,nest(get)]
< **   encOG: 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer] -> V: var integer
< **** ENC:OI.getVqual:[1:Array,nest(get)]
< **   ENC:result:[1:Array]
< **** ENC:OI.getVqual:[2:Array]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: get[0]
< **** Invocation:semCheck: 0
< **   encOG:get[0]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: V: var integer
< 
< **** OI:getVqual: res on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** OI:getVqual:initial:res
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< **   OGs:[0:length]
< **   ATd: out res: var integer
< **** DataItem:getVqual: out res: var integer
< [0:length]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:length]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:length]
< **   encOG: 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** ENC:OI.getVqual:[1:length]
< **   ENC:result:[1:Array]
< **** ENC:OI.getVqual:[2:Array]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:res
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: res
< **   OI:getQual:savedOI:res
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: res
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:integer
< **   encOG: 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< out res: var integer
<    res := get[0]
<    in at: var integer
< **** OG:returnDecl: out res: var integer
< **** Invocation:semCheck: "("
< **   encOG:%basic 115
< **** OG:semCheck:integer
< **   encOG: %basic 115
< **** Invocation:semCheck: integer
< **   encOG:%basic 115
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 115
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 115**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "):at["
< **   encOG:%basic 115
< **** OG:semCheck:integer
< **   encOG: %basic 115
< **** Invocation:semCheck: integer
< **   encOG:%basic 115
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 115
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 115**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "]"
< **   encOG:%basic 115
< **** OG:semCheck:%basic 115
< **   encOG: %basic 115
< **** Invocation:semCheck: 
< **   encOG:%basic 115
< **** Invocation:semCheck: 115
< **   encOG:%basic 115
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** Invocation:semCheck: "["
< **   encOG:%basic 116
< **** OG:semCheck:integer
< **   encOG: %basic 116
< **** Invocation:semCheck: integer
< **   encOG:%basic 116
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 116
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 116**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "]"
< **   encOG:%basic 116
< **** OG:semCheck:integer
< **   encOG: %basic 116
< **** Invocation:semCheck: integer
< **   encOG:%basic 116
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 116
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 116**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:%basic 116
< **   encOG: %basic 116
< **** Invocation:semCheck: 
< **   encOG:%basic 116
< **** Invocation:semCheck: 116
< **   encOG:%basic 116
< **** OG:semcheck:IS not empty:eOG: 
< %basic 116
< **** OG:returnDecl: V: var integer
< **** Invocation:semCheck: "("
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** OG:semCheck:integer
< **   encOG: 
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** Invocation:semCheck: integer
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: ")"
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** Invocation:semCheck: Boolean
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **   encOG: 
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** Invocation:semCheck: 
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** OG:semCheck:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< **   encOG: 
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** Invocation:semCheck: scan
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** OG:semCheck:
< if (V = current) :then 
<    B := true
<    leave(has)
< **   encOG: 
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< **** Invocation:semCheck: if (V = current) :then 
<    B := true
<    leave(has)
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< 
< **** OG:semCheck:(V = current)
< **   encOG: 
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< **** Invocation:semCheck: (V = current)
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< 
< **** Invocation:semCheck: V = current
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< 
< **** OI:semCheck: "= current" rec: "V"
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: current
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = current
< **   fArg: in Veq: var this(Value)
< **   aArg: current
< **   theOI.f.f:label: BracketedExp
< (V = current)
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = current
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:current
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:BETA,nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:current
< **   encOG: (V = current)
< **** Invocation:semCheck: current
< **   encOG:(V = current)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:(V = current)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< B := true
<    leave(has)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:true
< **   encOG: 
< B := true
<    leave(has)
< **** Invocation:semCheck: true
< **   encOG:
< B := true
<    leave(has)
< 
< **** OI:semCheck: "true" rec: "B"
< **   encOG:
< B := true
<    leave(has)
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< B := true
<    leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< B := true
<    leave(has)
< 
< **** OI:getVqual:initial:B
< **   encOG:
< B := true
<    leave(has)
< **   OGs:[0:has]
< **   ATd: B: var Boolean
< **** DataItem:getVqual: B: var Boolean
< [0:has]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:has]
< 
< **** OI:getVqual: Boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has]
< **   encOG: 
< B := true
<    leave(has)
< **** koks: Boolean on: 2 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< has(V: var integer) -> B: var Boolean
< **** ENC:OI.getVqual:[1:has]
< **   ENC:result:[1:Array]
< **** ENC:OI.getVqual:[2:Array]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:leave(has)
< **   encOG: 
< B := true
<    leave(has)
< **** Invocation:semCheck: leave(has)
< **   encOG:
< B := true
<    leave(has)
< 
< **** OI:semCheck: "leave(has)" rec: "none"
< **   encOG:
< B := true
<    leave(has)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    if (V = current) :then 
<       B := true
<       leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<       if (V = current) :then 
<          B := true
<          leave(has)
< **** OG:returnDecl: B: var Boolean
< **** OG:semCheck:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **   encOG: 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:integer
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:i + 1
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: i + 1
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "i" rec: "i"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "+ 1" rec: "i"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< i + 1
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: i + 1
< **** Invocation:semCheck: 1
< **   encOG:i + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: i on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:getVqual:initial:i
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   OGs:[0:loop]
< **   ATd: i: var integer
< **** DataItem:getVqual: i: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** koks: integer on: 3 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:scan]
< **** ENC:OI.getVqual:[2:scan]
< **   ENC:result:[2:Array]
< **** ENC:OI.getVqual:[3:Array]
< **   ENC:result:[3:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:i
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (i <= get[0]) :then 
<    current := get[i]
<    inner(scan)
<    restart(loop)
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: if (i <= get[0]) :then 
<    current := get[i]
<    inner(scan)
<    restart(loop)
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OG:semCheck:(i <= get[0])
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: (i <= get[0])
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Invocation:semCheck: i <= get[0]
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "i" rec: "none"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "<= get[0]" rec: "i"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: get[0]
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= get[0]
< **   fArg: in Veq: var this(Value)
< **   aArg: get[0]
< **   theOI.f.f:label: BracketedExp
< (i <= get[0])
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= get[0]
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:BETA,nest(integer),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(<=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:get[0]
< **   encOG: (i <= get[0])
< **** Invocation:semCheck: get[0]
< **   encOG:(i <= get[0])
< **** OI:semCheck: "get[0]" rec: "none"
< **   encOG:(i <= get[0])
< **** Pattern:checkActualArgs:
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   actualArgs: get[0]
< **   fArgs(inx: var integer,)
< 
< **   encOG:(i <= get[0])**   argAtInx: 1 in:PTN:
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   theOI: get[0]
< **   fArg: inx: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< get[0]
< **   encOG:(i <= get[0])
< **   savedOGS: [0:Array]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   theOI: get[0]
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 116
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: get[inx: var integer] -> V: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Array]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **   After:[0:Array,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: %basic 116**   OGS: [0:Array,nest(get)]
< **   theFargOG:
< %basic 116
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Array,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:Array,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Array,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Array,nest(get)]
< **   encOG: (i <= get[0])
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer] -> V: var integer
< **** ENC:OI.getVqual:[1:Array,nest(get)]
< **   ENC:result:[1:Array]
< **** ENC:OI.getVqual:[2:Array]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: get[0]
< **** Invocation:semCheck: 0
< **   encOG:get[0]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:get[i]
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** Invocation:semCheck: get[i]
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:semCheck: "get[i]" rec: "current"
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   actualArgs: get[i]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   argAtInx: 1 in:PTN:
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   theOI: get[i]
< **   fArg: inx: var integer
< **   aArg: i
< **   theOI.f.f:label: ObjectGenerator
< get[i]
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   savedOGS: [0:Array]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer] -> V: var integer: 
<    %basic 116
< **   theOI: get[i]
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 116
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: get[inx: var integer] -> V: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Array]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **   After:[0:Array,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[i]
< **   fArgs.origin.OG=theFargsOG: %basic 116**   OGS: [0:Array,nest(get)]
< **   theFargOG:
< %basic 116
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Array,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:Array,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Array,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Array,nest(get)]
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer] -> V: var integer
< **** ENC:OI.getVqual:[1:Array,nest(get)]
< **   ENC:result:[1:Array]
< **** ENC:OI.getVqual:[2:Array]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:i
< **   encOG: get[i]
< **** Invocation:semCheck: i
< **   encOG:get[i]
< **** OI:semCheck: "i" rec: "none"
< **   encOG:get[i]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: V: var integer
< 
< **** OI:getVqual: current on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:getVqual:initial:current
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   OGs:[0:scan]
< **   ATd: current: var integer
< **** DataItem:getVqual: current: var integer
< [0:scan]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:scan]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Array]
< **** ENC:OI.getVqual:[2:Array]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:current
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: current
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:inner(scan)
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** Invocation:semCheck: inner(scan)
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:semCheck: "inner(scan)" rec: "none"
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semCheck:restart(loop)
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** OG:semCheck:
< %basic 118
<    out S: var LIB.StringLib.String
< **   encOG: 
< %basic 118
<    out S: var LIB.StringLib.String
< **** Invocation:semCheck: 
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** Invocation:semCheck: 118
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** OG:semCheck:LIB.StringLib.String
< **   encOG: 
< %basic 118
<    out S: var LIB.StringLib.String
< **** Invocation:semCheck: LIB.StringLib.String
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** OI:semCheck: "LIB" rec: "none"
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** OI:semCheck: "StringLib" rec: "LIB"
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** OI:semCheck: "String" rec: "StringLib"
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** Pattern:checkActualArgs:
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 118
<    out S: var LIB.StringLib.String
< **** OG:returnDecl: out S: var LIB.StringLib.String
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    length: 
<       out res: var integer
< ...
< **** OG:semCheck:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** Invocation:semCheck: 114
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** OG:semCheck:Integer
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** Invocation:semCheck: Integer
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** OI:semCheck: "Integer" rec: "none"
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "elm"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< out res: var integer
<    res := get[0]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** Invocation:semCheck: 
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** OG:semCheck:integer
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** Invocation:semCheck: integer
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out res: var integer
<    res := get[0]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:get[0]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** Invocation:semCheck: get[0]
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** OI:semCheck: "get[0]" rec: "res"
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   actualArgs: get[0]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< out res: var integer
<    res := get[0]
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[0]
< **   fArg: inx: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< get[0]
< **   encOG:
< out res: var integer
<    res := get[0]
< **   savedOGS: [0:Indexed]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[0]
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Indexed]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:Indexed,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: var integer
< **   OGS: [0:Indexed,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Indexed,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:Indexed,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Indexed,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Indexed,nest(get)]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:Indexed,nest(get)]
< **   ENC:result:[1:Indexed]
< **** ENC:OI.getVqual:[2:Indexed]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: get[0]
< **** Invocation:semCheck: 0
< **   encOG:get[0]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< 
< **** OI:getVqual: res on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out res: var integer
<    res := get[0]
< 
< **** OI:getVqual:initial:res
< **   encOG:
< out res: var integer
<    res := get[0]
< **   OGs:[0:length]
< **   ATd: out res: var integer
< **** DataItem:getVqual: out res: var integer
< [0:length]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:length]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:length]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< out res: var integer
<    res := get[0]
< **** ENC:OI.getVqual:[1:length]
< **   ENC:result:[1:Indexed]
< **** ENC:OI.getVqual:[2:Indexed]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:res
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: res
< **   OI:getQual:savedOI:res
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: res
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< out res: var integer
<    res := get[0]
< **** OG:returnDecl: out res: var integer
< **** Invocation:semCheck: "("
< **   encOG:%basic 115
< **** OG:semCheck:integer
< **   encOG: %basic 115
< **** Invocation:semCheck: integer
< **   encOG:%basic 115
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 115
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 115**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "):at["
< **   encOG:%basic 115
< **** OG:semCheck:integer
< **   encOG: %basic 115
< **** Invocation:semCheck: integer
< **   encOG:%basic 115
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 115
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 115**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "]"
< **   encOG:%basic 115
< **** OG:semCheck:%basic 115
< **   encOG: %basic 115
< **** Invocation:semCheck: 
< **   encOG:%basic 115
< **** Invocation:semCheck: 115
< **   encOG:%basic 115
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** Invocation:semCheck: "["
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 116
<    out V: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 116
<    out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "]"
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** OG:semCheck:
< %basic 116
<    out V: var integer
< **   encOG: 
< %basic 116
<    out V: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** Invocation:semCheck: 116
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 116
<    out V: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 116
<    out V: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 116
<    out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 116
<    out V: var integer
< **** OG:returnDecl: out V: var integer
< **** Invocation:semCheck: "("
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: ")"
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< 
< **** OG:semCheck:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **   encOG: 
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **** Invocation:semCheck: 
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< scan
<       if (V = current) :then 
<          B := true
<          leave(L)
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< **   encOG: 
< scan
<       if (V = current) :then 
<          B := true
<          leave(L)
< **** Invocation:semCheck: scan
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(L)
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(L)
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       if (V = current) :then 
<          B := true
<          leave(L)
< **** OG:semCheck:
< if (V = current) :then 
<    B := true
<    leave(L)
< **   encOG: 
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< **** Invocation:semCheck: if (V = current) :then 
<    B := true
<    leave(L)
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< 
< **** OG:semCheck:(V = current)
< **   encOG: 
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< **** Invocation:semCheck: (V = current)
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< 
< **** Invocation:semCheck: V = current
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< 
< **** OI:semCheck: "= current" rec: "V"
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: current
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = current
< **   fArg: in Veq: var this(Value)
< **   aArg: current
< **   theOI.f.f:label: BracketedExp
< (V = current)
< **   encOG:
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = current
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:current
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:BETA,nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:current
< **   encOG: (V = current)
< **** Invocation:semCheck: current
< **   encOG:(V = current)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:(V = current)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< B := true
<    leave(L)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:true
< **   encOG: 
< B := true
<    leave(L)
< **** Invocation:semCheck: true
< **   encOG:
< B := true
<    leave(L)
< 
< **** OI:semCheck: "true" rec: "B"
< **   encOG:
< B := true
<    leave(L)
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< B := true
<    leave(L)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=3 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< B := true
<    leave(L)
< 
< **** OI:getVqual:initial:B
< **   encOG:
< B := true
<    leave(L)
< **   OGs:[0:has]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:has]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:has]
< 
< **** OI:getVqual: Boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has]
< **   encOG: 
< B := true
<    leave(L)
< **** koks: Boolean on: 2 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **** ENC:OI.getVqual:[1:has]
< **   ENC:result:[1:Indexed]
< **** ENC:OI.getVqual:[2:Indexed]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:leave(L)
< **   encOG: 
< B := true
<    leave(L)
< **** Invocation:semCheck: leave(L)
< **   encOG:
< B := true
<    leave(L)
< 
< **** OI:semCheck: "leave(L)" rec: "none"
< **   encOG:
< B := true
<    leave(L)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(L)
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(L)
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(L)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    if (V = current) :then 
<       B := true
<       leave(L)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<       if (V = current) :then 
<          B := true
<          leave(L)
< **** OG:semcheck:IS not empty:eOG: 
< 
< out B: var Boolean
<    L: do 
<       scan
<          if (V = current) :then 
<             B := true
< ...
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **   encOG: 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:integer
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:i + 1
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: i + 1
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "i" rec: "i"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "+ 1" rec: "i"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< i + 1
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: i + 1
< **** Invocation:semCheck: 1
< **   encOG:i + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: i on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:getVqual:initial:i
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   OGs:[0:loop]
< **   ATd: i: var integer
< **** DataItem:getVqual: i: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** koks: integer on: 3 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:scan]
< **** ENC:OI.getVqual:[2:scan]
< **   ENC:result:[2:Indexed]
< **** ENC:OI.getVqual:[3:Indexed]
< **   ENC:result:[3:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:i
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (i <= get[0]) :then 
<    current := get[i]
<    inner(scan)
<    restart(loop)
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: if (i <= get[0]) :then 
<    current := get[i]
<    inner(scan)
<    restart(loop)
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OG:semCheck:(i <= get[0])
< **   encOG: 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** Invocation:semCheck: (i <= get[0])
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Invocation:semCheck: i <= get[0]
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "i" rec: "none"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "<= get[0]" rec: "i"
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: get[0]
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= get[0]
< **   fArg: in Veq: var this(Value)
< **   aArg: get[0]
< **   theOI.f.f:label: BracketedExp
< (i <= get[0])
< **   encOG:
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= get[0]
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:BETA,nest(integer),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(<=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:get[0]
< **   encOG: (i <= get[0])
< **** Invocation:semCheck: get[0]
< **   encOG:(i <= get[0])
< **** OI:semCheck: "get[0]" rec: "none"
< **   encOG:(i <= get[0])
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   actualArgs: get[0]
< **   fArgs(inx: var integer,)
< 
< **   encOG:(i <= get[0])**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[0]
< **   fArg: inx: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< get[0]
< **   encOG:(i <= get[0])
< **   savedOGS: [0:Indexed]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[0]
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Indexed]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:Indexed,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: var integer
< **   OGS: [0:Indexed,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Indexed,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:Indexed,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Indexed,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Indexed,nest(get)]
< **   encOG: (i <= get[0])
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:Indexed,nest(get)]
< **   ENC:result:[1:Indexed]
< **** ENC:OI.getVqual:[2:Indexed]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: get[0]
< **** Invocation:semCheck: 0
< **   encOG:get[0]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:get[i]
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** Invocation:semCheck: get[i]
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:semCheck: "get[i]" rec: "current"
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   actualArgs: get[i]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[i]
< **   fArg: inx: var integer
< **   aArg: i
< **   theOI.f.f:label: ObjectGenerator
< get[i]
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   savedOGS: [0:Indexed]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[i]
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Indexed]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:Indexed,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[i]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: var integer
< **   OGS: [0:Indexed,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Indexed,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:Indexed,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Indexed,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Indexed,nest(get)]
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:Indexed,nest(get)]
< **   ENC:result:[1:Indexed]
< **** ENC:OI.getVqual:[2:Indexed]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:i
< **   encOG: get[i]
< **** Invocation:semCheck: i
< **   encOG:get[i]
< **** OI:semCheck: "i" rec: "none"
< **   encOG:get[i]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< 
< **** OI:getVqual: current on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:getVqual:initial:current
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< **   OGs:[0:scan]
< **   ATd: current: var integer
< **** DataItem:getVqual: current: var integer
< [0:scan]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:scan]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Indexed]
< **** ENC:OI.getVqual:[2:Indexed]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:current
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: current
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:inner(scan)
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** Invocation:semCheck: inner(scan)
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:semCheck: "inner(scan)" rec: "none"
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semCheck:restart(loop)
< **   encOG: 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:
< current := get[i]
<    inner(scan)
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[i]
<    inner(scan)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< i: var integer
<    i := i + 1
<    if (i <= get[0]) :then 
<       current := get[i]
<       inner(scan)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< current: var integer
<    loop: do 
<       i: var integer
<       i := i + 1
<       if (i <= get[0]) :then 
< ...
< **** OG:semCheck:
< %basic 118
<    out S: var LIB.StringLib.String
< **   encOG: 
< %basic 118
<    out S: var LIB.StringLib.String
< **** Invocation:semCheck: 
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** Invocation:semCheck: 118
< **   encOG:
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 118
<    out S: var LIB.StringLib.String
< **** OG:returnDecl: out S: var LIB.StringLib.String
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   encOG: 
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** Invocation:semCheck: 160
< **   encOG:
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** OG:semCheck:Integer
< **   encOG: 
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** Invocation:semCheck: Integer
< **   encOG:
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** OI:semCheck: "Integer" rec: "none"
< **   encOG:
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "elm"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< out res: var integer
<    res := get[0]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** Invocation:semCheck: 
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** OG:semCheck:integer
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** Invocation:semCheck: integer
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out res: var integer
<    res := get[0]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:get[0]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** Invocation:semCheck: get[0]
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** OI:semCheck: "get[0]" rec: "res"
< **   encOG:
< out res: var integer
<    res := get[0]
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: ref elm
< **   actualArgs: get[0]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< out res: var integer
<    res := get[0]
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: ref elm
< **   theOI: get[0]
< **   fArg: inx: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< get[0]
< **   encOG:
< out res: var integer
<    res := get[0]
< **   savedOGS: [0:IndexedRef&]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: ref elm
< **   theOI: get[0]
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: ref elm
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:IndexedRef&]
< **   OGS.DOG:
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:IndexedRef&,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: ref elm
< **   OGS: [0:IndexedRef&,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: ref elm
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:IndexedRef&,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:IndexedRef&,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:IndexedRef&,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:IndexedRef&,nest(get)]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:IndexedRef&,nest(get)]
< **   ENC:result:[1:IndexedRef&]
< **** ENC:OI.getVqual:[2:IndexedRef&]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: get[0]
< **** Invocation:semCheck: 0
< **   encOG:get[0]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:returnDecl: out V: ref elm
< 
< **** OI:getVqual: res on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out res: var integer
<    res := get[0]
< 
< **** OI:getVqual:initial:res
< **   encOG:
< out res: var integer
<    res := get[0]
< **   OGs:[0:length]
< **   ATd: out res: var integer
< **** DataItem:getVqual: out res: var integer
< [0:length]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:length]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:length]
< **   encOG: 
< out res: var integer
<    res := get[0]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< out res: var integer
<    res := get[0]
< **** ENC:OI.getVqual:[1:length]
< **   ENC:result:[1:IndexedRef]
< **** ENC:OI.getVqual:[2:IndexedRef]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:res
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: res
< **   OI:getQual:savedOI:res
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: res
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< out res: var integer
<    res := get[0]
< **** OG:returnDecl: out res: var integer
< **** Invocation:semCheck: "("
< **   encOG:%basic 115
< **** Invocation:semCheck: "):at["
< **   encOG:%basic 115
< **** OG:semCheck:integer
< **   encOG: %basic 115
< **** Invocation:semCheck: integer
< **   encOG:%basic 115
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 115
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 115**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "]"
< **   encOG:%basic 115
< **** OG:semCheck:%basic 115
< **   encOG: %basic 115
< **** Invocation:semCheck: 
< **   encOG:%basic 115
< **** Invocation:semCheck: 115
< **   encOG:%basic 115
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** Invocation:semCheck: "["
< **   encOG:
< %basic 116
<    out V: ref elm
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 116
<    out V: ref elm
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 116
<    out V: ref elm
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 116
<    out V: ref elm
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 116
<    out V: ref elm
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "]"
< **   encOG:
< %basic 116
<    out V: ref elm
< 
< **** OG:semCheck:
< %basic 116
<    out V: ref elm
< **   encOG: 
< %basic 116
<    out V: ref elm
< **** Invocation:semCheck: 
< **   encOG:
< %basic 116
<    out V: ref elm
< 
< **** Invocation:semCheck: 116
< **   encOG:
< %basic 116
<    out V: ref elm
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 116
<    out V: ref elm
< **** OG:returnDecl: out V: ref elm
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 160
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** Invocation:semCheck: "("
< **   encOG:
< -- odd parameter type!
<    %basic 102
< 
< **** OG:semCheck:integer
< **   encOG: 
< -- odd parameter type!
<    %basic 102
< **** Invocation:semCheck: integer
< **   encOG:
< -- odd parameter type!
<    %basic 102
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< -- odd parameter type!
<    %basic 102
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- odd parameter type!
<    %basic 102
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: ")"
< **   encOG:
< -- odd parameter type!
<    %basic 102
< 
< **** OG:semCheck:
< -- odd parameter type!
<    %basic 102
< **   encOG: 
< -- odd parameter type!
<    %basic 102
< **** Invocation:semCheck: -- odd parameter type!
< **   encOG:
< -- odd parameter type!
<    %basic 102
< 
< **** Invocation:semCheck: 102
< **   encOG:
< -- odd parameter type!
<    %basic 102
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- odd parameter type!
<    %basic 102
< **** Invocation:semCheck: "("
< **   encOG:%basic 103
< **** OG:semCheck:integer
< **   encOG: %basic 103
< **** Invocation:semCheck: integer
< **   encOG:%basic 103
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:%basic 103
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:%basic 103**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: ")"
< **   encOG:%basic 103
< **** OG:semCheck:%basic 103
< **   encOG: %basic 103
< **** Invocation:semCheck: 
< **   encOG:%basic 103
< **** Invocation:semCheck: 103
< **   encOG:%basic 103
< **** OG:semcheck:IS not empty:eOG: 
< %basic 103
< **** Invocation:semCheck: "("
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< **** Invocation:semCheck: boolean
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: "):then{"
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** OG:semCheck:object
< **   encOG: object
< **** Invocation:semCheck: object
< **   encOG:object
< **** OI:semCheck: "object" rec: "thenPart"
< **   encOG:object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: "}"
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** OG:semCheck:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< **   encOG: 
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< **** Invocation:semCheck: 
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** Invocation:semCheck: skipInternal
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** OI:semCheck: "skipInternal" rec: "%OSDvisibility"
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** Pattern:checkActualArgs:
< SkipInternal: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< **** Invocation:semCheck: 100
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** Invocation:semCheck: inSub
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** OI:semCheck: "inSub" rec: "%globals"
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< 
< **** Pattern:checkActualArgs:
< inSub: 
<    %basic 7
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %basic 100
<    %globals inSub
< **** Invocation:semCheck: "("
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OG:semCheck:boolean
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: boolean
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: "):then{"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OG:semCheck:object
< **   encOG: object
< **** Invocation:semCheck: object
< **   encOG:object
< **** OI:semCheck: "object" rec: "thenPart"
< **   encOG:object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: "}:else{"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "elsePart"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: "}"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OG:semCheck:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Invocation:semCheck: skipInternal
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OI:semCheck: "skipInternal" rec: "%OSDvisibility"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Pattern:checkActualArgs:
< SkipInternal: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: inSub
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OI:semCheck: "inSub" rec: "%globals"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Pattern:checkActualArgs:
< inSub: 
<    %basic 7
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** OG:semCheck:boolean
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: boolean
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< if (cond) :then 
<    thenPart
<    done := true
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: if (cond) :then 
<    thenPart
<    done := true
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OG:semCheck:(cond)
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: (cond)
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Invocation:semCheck: cond
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OI:semCheck: "cond" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< thenPart
<    done := true
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:thenPart
< **   encOG: 
< thenPart
<    done := true
< **** Invocation:semCheck: thenPart
< **   encOG:
< thenPart
<    done := true
< 
< **** OI:semCheck: "thenPart" rec: "none"
< **   encOG:
< thenPart
<    done := true
< 
< **** Pattern:checkActualArgs:thenPart:< object**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< thenPart
<    done := true
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:true
< **   encOG: 
< thenPart
<    done := true
< **** Invocation:semCheck: true
< **   encOG:
< thenPart
<    done := true
< 
< **** OI:semCheck: "true" rec: "done"
< **   encOG:
< thenPart
<    done := true
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< thenPart
<    done := true
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: done on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< thenPart
<    done := true
< 
< **** OI:getVqual:initial:done
< **   encOG:
< thenPart
<    done := true
< **   OGs:[0:if:then:else]
< **   ATd: done: var boolean
< **** DataItem:getVqual: done: var boolean
< [0:if:then:else]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:if:then:else]
< 
< **** OI:getVqual: boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:if:then:else]
< **   encOG: 
< thenPart
<    done := true
< **** koks: boolean on: 1 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** ENC:OI.getVqual:[1:if:then:else]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:done
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: done
< **   OI:getQual:savedOI:done
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: done
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< thenPart
<    done := true
< **** OG:semcheck:IS not empty:eOG: 
< 
< thenPart
<    done := true
< **** OG:semCheck:
< if (done.not) :then 
<    elsePart -- if not local to this if:then, then %globals warning
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: if (done.not) :then 
<    elsePart -- if not local to this if:then, then %globals warning
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OG:semCheck:(done.not)
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** Invocation:semCheck: (done.not)
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Invocation:semCheck: done.not
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OI:semCheck: "done" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** OI:semCheck: "not" rec: "done"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< 
< **** Pattern:checkActualArgs:
< not: 
<    %basic 65
<    out R: var boolean
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< **** OG:semCheck:elsePart -- if not local to this if:then, then %globals warning
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:elsePart -- if not local to this if:then, then %globals warning
< **   encOG: elsePart -- if not local to this if:then, then %globals warning
< **** Invocation:semCheck: elsePart -- if not local to this if:then, then %globals warning
< **   encOG:elsePart -- if not local to this if:then, then %globals warning
< **** OI:semCheck: "elsePart" rec: "none"
< **   encOG:elsePart -- if not local to this if:then, then %globals warning
< **** Pattern:checkActualArgs:elsePart:< Object**   actualArgs: 
< **   fArgs()
< 
< **   encOG:elsePart -- if not local to this if:then, then %globals warning**** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< elsePart -- if not local to this if:then, then %globals warning
< **** OG:semcheck:IS not empty:eOG: 
< elsePart -- if not local to this if:then, then %globals warning
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    done: var boolean
<    if (cond) :then 
<       thenPart
< ...
< **** OG:semCheck:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** Invocation:semCheck: 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** Invocation:semCheck: skipInternal
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** OI:semCheck: "skipInternal" rec: "%OSDvisibility"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** Pattern:checkActualArgs:
< SkipInternal: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** Invocation:semCheck: inSub
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** OI:semCheck: "inSub" rec: "%globals"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** Pattern:checkActualArgs:
< inSub: 
<    %basic 7
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** OG:semCheck:inner(cycle)
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** Invocation:semCheck: inner(cycle)
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** OI:semCheck: "inner(cycle)" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** OG:semCheck:restart(cycle)
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** Invocation:semCheck: restart(cycle)
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** OI:semCheck: "restart(cycle)" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inner(cycle)
<    restart(cycle)
< **** Invocation:semCheck: "("
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "):to("
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "):repeat{"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OG:semCheck:object
< **   encOG: object
< **** Invocation:semCheck: object
< **   encOG:object
< **** OI:semCheck: "object" rec: "repeat"
< **   encOG:object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: "}"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OG:semCheck:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** Invocation:semCheck: skipInternal
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:semCheck: "skipInternal" rec: "%OSDvisibility"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** Pattern:checkActualArgs:
< SkipInternal: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** Invocation:semCheck: inSub
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:semCheck: "inSub" rec: "%globals"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** Pattern:checkActualArgs:
< inSub: 
<    %basic 7
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:first
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** Invocation:semCheck: first
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:semCheck: "first" rec: "inx"
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: inx on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:getVqual:initial:inx
< **   encOG:
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGs:[0:for:to:repeat]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** Invocation:semCheck: if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
<    inx := inx
< **   encOG:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** OG:semCheck:(inx <= last)
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** Invocation:semCheck: (inx <= last)
< **   encOG:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** Invocation:semCheck: inx <= last
< **   encOG:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** OI:semCheck: "<= last" rec: "inx"
< **   encOG:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: last
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= last
< **   fArg: in Veq: var this(Value)
< **   aArg: last
< **   theOI.f.f:label: BracketedExp
< (inx <= last)
< **   encOG:
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= last
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:last
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:BETA,nest(integer),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(<=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:last
< **   encOG: (inx <= last)
< **** Invocation:semCheck: last
< **   encOG:(inx <= last)
< **** OI:semCheck: "last" rec: "none"
< **   encOG:(inx <= last)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:repeat
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** Invocation:semCheck: repeat
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:semCheck: "repeat" rec: "none"
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** Pattern:checkActualArgs:repeat:< object**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:inx + 1
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** Invocation:semCheck: inx + 1
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:semCheck: "inx" rec: "inx"
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:semCheck: "+ 1" rec: "inx"
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< inx + 1
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: inx + 1
< **** Invocation:semCheck: 1
< **   encOG:inx + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:getVqual:initial:inx
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **   OGs:[0:for:to:repeat]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:restart(_doIt)
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** Invocation:semCheck: restart(_doIt)
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:semCheck: "restart(_doIt)" rec: "none"
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** OG:semcheck:IS not empty:eOG: 
< 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** OG:semCheck:inx := inx
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** Invocation:semCheck: 
< **   encOG:
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OG:semCheck:inx
< **   encOG: inx := inx
< **** Invocation:semCheck: inx
< **   encOG:inx := inx
< **** OI:semCheck: "inx" rec: "inx"
< **   encOG:inx := inx
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: inx := inx
< 
< **** OI:getVqual:initial:inx
< **   encOG:inx := inx
< **   OGs:[0:for:to:repeat]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: inx := inx
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< inx := inx
< **** OG:semcheck:IS not empty:eOG: 
< inx := inx
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **   encOG: 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** Invocation:semCheck: 
< **   encOG:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< 
< **** OG:semCheck:
< inner
<    out B: var Boolean
< **   encOG: 
< inner
<    out B: var Boolean
< **** Invocation:semCheck: inner
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** OI:semCheck: "inner" rec: "innerBool"
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< inner
<    out B: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< inner
<    out B: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner
<    out B: var Boolean
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:Boolean
< **   encOG: 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** Invocation:semCheck: Boolean
< **   encOG:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:innerBool
< **   encOG: 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** Invocation:semCheck: innerBool
< **   encOG:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< 
< **** OI:semCheck: "innerBool" rec: "BBB"
< **   encOG:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** OG:returnDecl: out B: var Boolean
< 
< **** OI:getVqual: BBB on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< 
< **** OI:getVqual:initial:BBB
< **   encOG:
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **   OGs:[0:Condition]
< **   ATd: out BBB: var Boolean
< **** DataItem:getVqual: out BBB: var Boolean
< [0:Condition]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:Condition]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Condition]
< **   encOG: 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** ENC:OI.getVqual:[1:Condition]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:BBB
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: BBB
< **   OI:getQual:savedOI:BBB
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: BBB
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< innerBool: inner
<       out B: var Boolean
<    out BBB: var Boolean
<    BBB := innerBool
< **** OG:returnDecl: out BBB: var Boolean
< **** Invocation:semCheck: "("
< **   encOG:
< loop: do 
<       if (cond) :then 
<          doPart
<          restart(loop)
< 
< **** OG:semCheck:Condition
< **   encOG: Condition
< **** Invocation:semCheck: Condition
< **   encOG:Condition
< **** OI:semCheck: "Condition" rec: "cond"
< **   encOG:Condition
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out BBB: var Boolean
< **** Invocation:semCheck: "):repeat{"
< **   encOG:
< loop: do 
<       if (cond) :then 
<          doPart
<          restart(loop)
< 
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "doPart"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** Invocation:semCheck: "}"
< **   encOG:
< loop: do 
<       if (cond) :then 
<          doPart
<          restart(loop)
< 
< **** OG:semCheck:
< loop: do 
<       if (cond) :then 
<          doPart
<          restart(loop)
< **   encOG: 
< loop: do 
<       if (cond) :then 
<          doPart
<          restart(loop)
< **** Invocation:semCheck: 
< **   encOG:
< loop: do 
<       if (cond) :then 
<          doPart
<          restart(loop)
< 
< **** OG:semCheck:
< if (cond) :then 
<       doPart
<       restart(loop)
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:
< if (cond) :then 
<    doPart
<    restart(loop)
< **   encOG: 
< if (cond) :then 
<       doPart
<       restart(loop)
< **** Invocation:semCheck: if (cond) :then 
<    doPart
<    restart(loop)
< **   encOG:
< if (cond) :then 
<       doPart
<       restart(loop)
< 
< **** OG:semCheck:(cond)
< **   encOG: 
< if (cond) :then 
<       doPart
<       restart(loop)
< **** Invocation:semCheck: (cond)
< **   encOG:
< if (cond) :then 
<       doPart
<       restart(loop)
< 
< **** Invocation:semCheck: cond
< **   encOG:
< if (cond) :then 
<       doPart
<       restart(loop)
< 
< **** OI:semCheck: "cond" rec: "none"
< **   encOG:
< if (cond) :then 
<       doPart
<       restart(loop)
< 
< **** Pattern:checkActualArgs:cond:< Condition**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< if (cond) :then 
<       doPart
<       restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out BBB: var Boolean
< **** OG:semCheck:
< doPart
<    restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:doPart
< **   encOG: 
< doPart
<    restart(loop)
< **** Invocation:semCheck: doPart
< **   encOG:
< doPart
<    restart(loop)
< 
< **** OI:semCheck: "doPart" rec: "none"
< **   encOG:
< doPart
<    restart(loop)
< 
< **** Pattern:checkActualArgs:doPart:< Object**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< doPart
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:restart(loop)
< **   encOG: 
< doPart
<    restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:
< doPart
<    restart(loop)
< 
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:
< doPart
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< doPart
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< doPart
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< doPart
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (cond) :then 
<       doPart
<       restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< loop: do 
<       if (cond) :then 
<          doPart
<          restart(loop)
< **** OG:semCheck:
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< **   encOG: 
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **   encOG: 
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< 
< **** OG:semCheck:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   encOG: 
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **** Invocation:semCheck: for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   encOG:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< 
< **** OI:semCheck: "for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< " rec: "none"
< **   encOG:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   encOG:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   fArg: last: var integer
< **   aArg: x.length
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   encOG:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:x.length
< **   encOG: 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** Invocation:semCheck: x.length
< **   encOG:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< 
< **** OI:semCheck: "x" rec: "none"
< **   encOG:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< 
< **** OI:semCheck: "length" rec: "x"
< **   encOG:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< 
< **** Pattern:checkActualArgs:
< length: 
<    out res: var integer
<    res := get[0]
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out res: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   fArg: repeat:< object
< **   aArg: 
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   encOG:
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< **   encOG: 
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(x.length):repeat
<    if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< 
< **** OG:semCheck:
< if (V = x.get[inx]) :then 
<    inner(case)
<    leave(switch)
< **   encOG: 
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< **** Invocation:semCheck: if (V = x.get[inx]) :then 
<    inner(case)
<    leave(switch)
< **   encOG:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** OG:semCheck:(V = x.get[inx])
< **   encOG: 
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< **** Invocation:semCheck: (V = x.get[inx])
< **   encOG:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** Invocation:semCheck: V = x.get[inx]
< **   encOG:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** OI:semCheck: "= x.get[inx]" rec: "V"
< **   encOG:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: x.get[inx]
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = x.get[inx]
< **   fArg: in Veq: var this(Value)
< **   aArg: x.get[inx]
< **   theOI.f.f:label: BracketedExp
< (V = x.get[inx])
< **   encOG:
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = x.get[inx]
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:x.get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:BETA,nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:x.get[inx]
< **   encOG: (V = x.get[inx])
< **** Invocation:semCheck: x.get[inx]
< **   encOG:(V = x.get[inx])
< **** OI:semCheck: "x" rec: "none"
< **   encOG:(V = x.get[inx])
< **** OI:semCheck: "get[inx]" rec: "x"
< **   encOG:(V = x.get[inx])
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:(V = x.get[inx])**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< x.get[inx]
< **   encOG:(V = x.get[inx])
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: var integer
< **   OGS: [0:BETA,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:BETA,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(get)]
< **   encOG: (V = x.get[inx])
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(get)]
< **   ENC:result:[1:BETA]
< **** ENC:OI.getVqual:[2:BETA]
< **   ENC:result:[2:BETAworld]
< 
< **** getVqual:B2:
< [0:BETAworld]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETAworld]
< **** savedOGS:save:False[0:BETAworld]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld]
< **   OGS:[0:BETAworld]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld]
< **** OG:semCheck:inx
< **   encOG: x.get[inx]
< **** Invocation:semCheck: inx
< **   encOG:x.get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:x.get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< inner(case)
<    leave(switch)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:inner(case)
< **   encOG: 
< inner(case)
<    leave(switch)
< **** Invocation:semCheck: inner(case)
< **   encOG:
< inner(case)
<    leave(switch)
< 
< **** OI:semCheck: "inner(case)" rec: "none"
< **   encOG:
< inner(case)
<    leave(switch)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(switch)
< **** OG:semCheck:leave(switch)
< **   encOG: 
< inner(case)
<    leave(switch)
< **** Invocation:semCheck: leave(switch)
< **   encOG:
< inner(case)
<    leave(switch)
< 
< **** OI:semCheck: "leave(switch)" rec: "none"
< **   encOG:
< inner(case)
<    leave(switch)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(switch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(switch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(switch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (V = x.get[inx]) :then 
<       inner(case)
<       leave(switch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in x: ref Indexed(1,#Integer)
<    for(1):to(x.length):repeat
<       if (V = x.get[inx]) :then 
<          inner(case)
<          leave(switch)
< ...
< **** OG:semCheck:inner(switch)
< **   encOG: 
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< **** Invocation:semCheck: inner(switch)
< **   encOG:
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< 
< **** OI:semCheck: "inner(switch)" rec: "none"
< **   encOG:
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var integer
<    %public
<    case: 
<       in x: ref Indexed(1,#Integer)
<       for(1):to(x.length):repeat
< ...
< **** OG:semCheck:
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< **   encOG: 
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< 
< **** OG:semCheck:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **   encOG: 
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< 
< **** OG:semCheck:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **   encOG: 
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **** Invocation:semCheck: for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **   encOG:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< 
< **** OI:semCheck: "for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< " rec: "none"
< **   encOG:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **   encOG:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   fArg: last: var integer
< **   aArg: x.length
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **   encOG:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:x.length
< **   encOG: 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **** Invocation:semCheck: x.length
< **   encOG:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< 
< **** OI:semCheck: "x" rec: "none"
< **   encOG:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< 
< **** OI:semCheck: "length" rec: "x"
< **   encOG:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< 
< **** Pattern:checkActualArgs:
< length: 
<    out res: var integer
<    res := get[0]
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out res: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   fArg: repeat:< object
< **   aArg: 
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **   encOG:
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **   encOG: 
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(x.length):repeat
<    if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< --#LIB.StringLib.string)
< 
< **** OG:semCheck:
< if (V == x.get[inx]) :then 
<    inner(case)
<    leave(rswitch)
< **   encOG: 
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **** Invocation:semCheck: if (V == x.get[inx]) :then 
<    inner(case)
<    leave(rswitch)
< **   encOG:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **** OG:semCheck:(V == x.get[inx])
< **   encOG: 
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **** Invocation:semCheck: (V == x.get[inx])
< **   encOG:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **** Invocation:semCheck: V == x.get[inx]
< **   encOG:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **** OI:semCheck: "== x.get[inx]" rec: "V"
< **   encOG:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< 
< **** Pattern:checkActualArgs:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: x.get[inx]
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **   argAtInx: 1 in:PTN:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == x.get[inx]
< **   fArg: in objx: ref Object
< **   aArg: x.get[inx]
< **   theOI.f.f:label: BracketedExp
< (V == x.get[inx])
< **   encOG:
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **   savedOGS: [0:BETA,nest(Object)]
< **** PTN:getOGsequenceOfArg: 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == x.get[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 56
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(Object)]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:BETA,nest(Object),nest(==)]
< **   getOGsequenceOfArg:aArgs:x.get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:BETA,nest(Object),nest(==)]
< **   theFargOG:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Object),nest(==)]
< **** DataItem:getVqual: in objx: ref Object
< [0:BETA,nest(Object),nest(==)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:BETA,nest(Object),nest(==)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Object),nest(==)]
< **   encOG: 
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(Object),nest(==)]
< **   ENC:result:[1:BETA,nest(Object)]
< **** ENC:OI.getVqual:[2:BETA,nest(Object)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:x.get[inx]
< **   encOG: (V == x.get[inx])
< **** Invocation:semCheck: x.get[inx]
< **   encOG:(V == x.get[inx])
< **** OI:semCheck: "x" rec: "none"
< **   encOG:(V == x.get[inx])
< **** OI:semCheck: "get[inx]" rec: "x"
< **   encOG:(V == x.get[inx])
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: ref elm
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:(V == x.get[inx])**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: ref elm
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< x.get[inx]
< **   encOG:(V == x.get[inx])
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: ref elm
< **   theOI: get[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: ref elm
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: ref elm
< **   OGS: [0:BETA,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: ref elm
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:BETA,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(get)]
< **   encOG: (V == x.get[inx])
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(get)]
< **   ENC:result:[1:BETA]
< **** ENC:OI.getVqual:[2:BETA]
< **   ENC:result:[2:BETAworld]
< 
< **** getVqual:B2:
< [0:BETAworld]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETAworld]
< **** savedOGS:save:False[0:BETAworld]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld]
< **   OGS:[0:BETAworld]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld]
< **** OG:semCheck:inx
< **   encOG: x.get[inx]
< **** Invocation:semCheck: inx
< **   encOG:x.get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:x.get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:returnDecl: out V: ref elm
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:
< inner(case)
<    leave(rswitch)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:inner(case)
< **   encOG: 
< inner(case)
<    leave(rswitch)
< **** Invocation:semCheck: inner(case)
< **   encOG:
< inner(case)
<    leave(rswitch)
< 
< **** OI:semCheck: "inner(case)" rec: "none"
< **   encOG:
< inner(case)
<    leave(rswitch)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(rswitch)
< **** OG:semCheck:leave(rswitch)
< **   encOG: 
< inner(case)
<    leave(rswitch)
< **** Invocation:semCheck: leave(rswitch)
< **   encOG:
< inner(case)
<    leave(rswitch)
< 
< **** OI:semCheck: "leave(rswitch)" rec: "none"
< **   encOG:
< inner(case)
<    leave(rswitch)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(rswitch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(rswitch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner(case)
<    leave(rswitch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (V == x.get[inx]) :then 
<       inner(case)
<       leave(rswitch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in x: ref IndexedRef(1,#Object)
<    for(1):to(x.length):repeat
<       if (V == x.get[inx]) :then 
<          inner(case)
<          leave(rswitch)
< ...
< **** OG:semCheck:inner(rswitch)
< **   encOG: 
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< **** Invocation:semCheck: inner(rswitch)
< **   encOG:
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< 
< **** OI:semCheck: "inner(rswitch)" rec: "none"
< **   encOG:
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: ref object
<    %public
<    case: 
<       in x: ref IndexedRef(1,#Object)
<       for(1):to(x.length):repeat
< ...
< **** OG:semCheck:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **   encOG: 
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** OG:semCheck:
< msg1:  -- obj
<       _put('F')
<       asciiBar.msg2
< **   encOG: 
< msg1:  -- obj
<       _put('F')
<       asciiBar.msg2
< **** Invocation:semCheck: 
< **   encOG:
< msg1:  -- obj
<       _put('F')
<       asciiBar.msg2
< 
< **** OG:semCheck:
< -- obj
<    _put('F')
<    asciiBar.msg2
< **   encOG: 
< -- obj
<    _put('F')
<    asciiBar.msg2
< **** Invocation:semCheck: -- obj
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< 
< **** OG:semCheck:_put('F')
< **   encOG: 
< -- obj
<    _put('F')
<    asciiBar.msg2
< **** Invocation:semCheck: _put('F')
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< 
< **** OI:semCheck: "_put('F')" rec: "none"
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< 
< **** Pattern:checkActualArgs:
< _put: 
<    %globals
<    %basic 2
<    in ch: var char
< **   actualArgs: _put('F')
< **   fArgs(in ch: var char,)
< 
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< **   argAtInx: 1 in:PTN:
< _put: 
<    %globals
<    %basic 2
<    in ch: var char
< **   theOI: _put('F')
< **   fArg: in ch: var char
< **   aArg: 'F'
< **   theOI.f.f:label: ObjectGenerator
< _put('F')
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< _put: 
<    %globals
<    %basic 2
<    in ch: var char
< **   theOI: _put('F')
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: var char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(_put)]
< **   getOGsequenceOfArg:aArgs:_put('F')
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 2
<    in ch: var char
< **   OGS: [0:BETA,nest(_put)]
< **   theFargOG:
< 
< %globals
<    %basic 2
<    in ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(_put)]
< **** DataItem:getVqual: in ch: var char
< [0:BETA,nest(_put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(_put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(_put)]
< **   encOG: 
< -- obj
<    _put('F')
<    asciiBar.msg2
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %globals
<    %basic 2
<    in ch: var char
< **** ENC:OI.getVqual:[1:BETA,nest(_put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'F'
< **   encOG: _put('F')
< **** Invocation:semCheck: 'F'
< **   encOG:_put('F')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 2
<    in ch: var char
< **** OG:semCheck:asciiBar.msg2
< **   encOG: 
< -- obj
<    _put('F')
<    asciiBar.msg2
< **** Invocation:semCheck: asciiBar.msg2
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< 
< **** OI:semCheck: "asciiBar" rec: "none"
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< 
< **** Pattern:checkActualArgs:
< asciiBar:  -- obj
<    msg2: 
<       _put('B')
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< **** OI:semCheck: "msg2" rec: "asciiBar"
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< 
< **** Pattern:checkActualArgs:
< msg2: 
<    _put('B')
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- obj
<    _put('F')
<    asciiBar.msg2
< **** OG:semcheck:IS not empty:eOG: 
< _put('B')
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- obj
<    _put('F')
<    asciiBar.msg2
< **** OG:semcheck:IS not empty:eOG: 
< 
< msg1:  -- obj
<       _put('F')
<       asciiBar.msg2
< **** OG:semCheck:
< -- obj
<    msg2: 
<       _put('B')
< **   encOG: 
< -- obj
<    msg2: 
<       _put('B')
< **** Invocation:semCheck: -- obj
< **   encOG:
< -- obj
<    msg2: 
<       _put('B')
< 
< **** OG:semCheck:_put('B')
< **   encOG: _put('B')
< **** Invocation:semCheck: 
< **   encOG:_put('B')
< **** OG:semCheck:_put('B')
< **   encOG: _put('B')
< **** Invocation:semCheck: _put('B')
< **   encOG:_put('B')
< **** OI:semCheck: "_put('B')" rec: "none"
< **   encOG:_put('B')
< **** Pattern:checkActualArgs:
< _put: 
<    %globals
<    %basic 2
<    in ch: var char
< **   actualArgs: _put('B')
< **   fArgs(in ch: var char,)
< 
< **   encOG:_put('B')**   argAtInx: 1 in:PTN:
< _put: 
<    %globals
<    %basic 2
<    in ch: var char
< **   theOI: _put('B')
< **   fArg: in ch: var char
< **   aArg: 'B'
< **   theOI.f.f:label: ObjectGenerator
< _put('B')
< **   encOG:_put('B')
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< _put: 
<    %globals
<    %basic 2
<    in ch: var char
< **   theOI: _put('B')
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: var char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(_put)]
< **   getOGsequenceOfArg:aArgs:_put('B')
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 2
<    in ch: var char
< **   OGS: [0:BETA,nest(_put)]
< **   theFargOG:
< 
< %globals
<    %basic 2
<    in ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(_put)]
< **** DataItem:getVqual: in ch: var char
< [0:BETA,nest(_put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(_put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(_put)]
< **   encOG: _put('B')
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %globals
<    %basic 2
<    in ch: var char
< **** ENC:OI.getVqual:[1:BETA,nest(_put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'B'
< **   encOG: _put('B')
< **** Invocation:semCheck: 'B'
< **   encOG:_put('B')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 2
<    in ch: var char
< **** OG:semcheck:IS not empty:eOG: 
< _put('B')
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- obj
<    msg2: 
<       _put('B')
< **** OG:semCheck:10
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** Invocation:semCheck: 10
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:13
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** Invocation:semCheck: 13
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:0
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** Invocation:semCheck: 0
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** Invocation:semCheck: char
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: 
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** OG:semCheck:char
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: char
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: Boolean
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Invocation:semCheck: (('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z'))
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Invocation:semCheck: ('a' <= ch) && (ch <= 'z')
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Invocation:semCheck: 'a' <= ch
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** OI:semCheck: "<= ch" rec: "'a'"
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: ch
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= ch
< **   fArg: in Veq: var this(Value)
< **   aArg: ch
< **   theOI.f.f:label: BracketedExp
< ('a' <= ch)
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   savedOGS: [0:char,Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= ch
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:char,Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:char,Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:ch
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:char,Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:char,Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:char,Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:char,Value&,nest(<=)]
< **** getOGstart: 
< [0:char,Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:ch
< **   encOG: ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: ch
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OI:semCheck: "&& (ch <= 'z')" rec: "('a' <= ch)"
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: (ch <= 'z')
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && (ch <= 'z')
< **   fArg: in B: var boolean
< **   aArg: (ch <= 'z')
< **   theOI.f.f:label: BracketedExp
< (('a' <= ch) && (ch <= 'z'))
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   savedOGS: [0:Boolean]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && (ch <= 'z')
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Boolean]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Boolean,nest(&&)]
< **   getOGsequenceOfArg:aArgs:(ch <= 'z')
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Boolean,nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Boolean,nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:Boolean,nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Boolean,nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Boolean,nest(&&)]
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Boolean,nest(&&)]
< **   ENC:result:[1:Boolean]
< **** ENC:OI.getVqual:[2:Boolean]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:(ch <= 'z')
< **   encOG: ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: (ch <= 'z')
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: ch <= 'z'
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OI:semCheck: "<= 'z'" rec: "ch"
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: 'z'
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))**   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= 'z'
< **   fArg: in Veq: var this(Value)
< **   aArg: 'z'
< **   theOI.f.f:label: BracketedExp
< (ch <= 'z')
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   savedOGS: [0:BETA,nest(char),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= 'z'
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(char),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(char),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:'z'
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:BETA,nest(char),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(char),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(char),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(char),Value&,nest(<=)]
< **** getOGstart: 
< [0:BETA,nest(char),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:'z'
< **   encOG: (ch <= 'z')
< **** Invocation:semCheck: 'z'
< **   encOG:(ch <= 'z')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OI:semCheck: "|| (('A' <= ch) && (ch <= 'Z'))" rec: "(('a' <= ch) && (ch <= 'z'))"
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** Pattern:checkActualArgs:
< ||  : 
<    %basic 63
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: (('A' <= ch) && (ch <= 'Z'))
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   argAtInx: 1 in:PTN:
< ||  : 
<    %basic 63
<    in B: var boolean
<    out R: var boolean
< **   theOI: || (('A' <= ch) && (ch <= 'Z'))
< **   fArg: in B: var boolean
< **   aArg: (('A' <= ch) && (ch <= 'Z'))
< **   theOI.f.f:label: BracketedExp
< ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   savedOGS: [0:Boolean]
< **** PTN:getOGsequenceOfArg: 
< ||  : 
<    %basic 63
<    in B: var boolean
<    out R: var boolean
< **   theOI: || (('A' <= ch) && (ch <= 'Z'))
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 63
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Boolean]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Boolean,nest(||)]
< **   getOGsequenceOfArg:aArgs:(('A' <= ch) && (ch <= 'Z'))
< **   fArgs.origin.OG=theFargsOG: 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Boolean,nest(||)]
< **   theFargOG:
< 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Boolean,nest(||)]
< **** DataItem:getVqual: in B: var boolean
< [0:Boolean,nest(||)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Boolean,nest(||)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Boolean,nest(||)]
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Boolean,nest(||)]
< **   ENC:result:[1:Boolean]
< **** ENC:OI.getVqual:[2:Boolean]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:(('A' <= ch) && (ch <= 'Z'))
< **   encOG: ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: (('A' <= ch) && (ch <= 'Z'))
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: ('A' <= ch) && (ch <= 'Z')
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Invocation:semCheck: 'A' <= ch
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OI:semCheck: "<= ch" rec: "'A'"
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: ch
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))**   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= ch
< **   fArg: in Veq: var this(Value)
< **   aArg: ch
< **   theOI.f.f:label: BracketedExp
< ('A' <= ch)
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   savedOGS: [0:char,Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= ch
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:char,Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:char,Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:ch
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:char,Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:char,Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:char,Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:char,Value&,nest(<=)]
< **** getOGstart: 
< [0:char,Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:ch
< **   encOG: (('A' <= ch) && (ch <= 'Z'))
< **** Invocation:semCheck: ch
< **   encOG:(('A' <= ch) && (ch <= 'Z'))
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:(('A' <= ch) && (ch <= 'Z'))
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OI:semCheck: "&& (ch <= 'Z')" rec: "('A' <= ch)"
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: (ch <= 'Z')
< **   fArgs(in B: var boolean,)
< 
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))**   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && (ch <= 'Z')
< **   fArg: in B: var boolean
< **   aArg: (ch <= 'Z')
< **   theOI.f.f:label: BracketedExp
< (('A' <= ch) && (ch <= 'Z'))
< **   encOG:((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   savedOGS: [0:Boolean]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && (ch <= 'Z')
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Boolean]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Boolean,nest(&&)]
< **   getOGsequenceOfArg:aArgs:(ch <= 'Z')
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Boolean,nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Boolean,nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:Boolean,nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Boolean,nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Boolean,nest(&&)]
< **   encOG: ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Boolean,nest(&&)]
< **   ENC:result:[1:Boolean]
< **** ENC:OI.getVqual:[2:Boolean]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:(ch <= 'Z')
< **   encOG: (('A' <= ch) && (ch <= 'Z'))
< **** Invocation:semCheck: (ch <= 'Z')
< **   encOG:(('A' <= ch) && (ch <= 'Z'))
< **** Invocation:semCheck: ch <= 'Z'
< **   encOG:(('A' <= ch) && (ch <= 'Z'))
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:(('A' <= ch) && (ch <= 'Z'))
< **** OI:semCheck: "<= 'Z'" rec: "ch"
< **   encOG:(('A' <= ch) && (ch <= 'Z'))
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: 'Z'
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:(('A' <= ch) && (ch <= 'Z'))**   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= 'Z'
< **   fArg: in Veq: var this(Value)
< **   aArg: 'Z'
< **   theOI.f.f:label: BracketedExp
< (ch <= 'Z')
< **   encOG:(('A' <= ch) && (ch <= 'Z'))
< **   savedOGS: [0:BETA,nest(char),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= 'Z'
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(char),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(char),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:'Z'
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:BETA,nest(char),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(char),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(char),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(char),Value&,nest(<=)]
< **** getOGstart: 
< [0:BETA,nest(char),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:'Z'
< **   encOG: (ch <= 'Z')
< **** Invocation:semCheck: 'Z'
< **   encOG:(ch <= 'Z')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< 
< **** OI:getVqual:initial:B
< **   encOG:
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **   OGs:[0:isLetter]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:isLetter]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:isLetter]
< 
< **** OI:getVqual: Boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isLetter]
< **   encOG: 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** koks: Boolean on: 2 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** ENC:OI.getVqual:[1:isLetter]
< **   ENC:result:[1:ascii]
< **** ENC:OI.getVqual:[2:ascii]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in ch: var char
<    out B: var Boolean
<    B := ((('a' <= ch) && (ch <= 'z')) || (('A' <= ch) && (ch <= 'Z')))
< **** OG:returnDecl: out B: var Boolean
< **** Invocation:semCheck: "("
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** OG:semCheck:Char
< **   encOG: B := (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: Char
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** OI:semCheck: "Char" rec: "none"
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:B := (('0' <= ch) && (ch <= '9'))**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Invocation:semCheck: ")"
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** OG:semCheck:Boolean
< **   encOG: B := (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: Boolean
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:B := (('0' <= ch) && (ch <= '9'))**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:B := (('0' <= ch) && (ch <= '9'))
< **   encOG: B := (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: 
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** OG:semCheck:(('0' <= ch) && (ch <= '9'))
< **   encOG: B := (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: (('0' <= ch) && (ch <= '9'))
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: ('0' <= ch) && (ch <= '9')
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: '0' <= ch
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** OI:semCheck: "<= ch" rec: "'0'"
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: ch
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:B := (('0' <= ch) && (ch <= '9'))**   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= ch
< **   fArg: in Veq: var this(Value)
< **   aArg: ch
< **   theOI.f.f:label: BracketedExp
< ('0' <= ch)
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **   savedOGS: [0:char,Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= ch
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:char,Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:char,Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:ch
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:char,Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:char,Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:char,Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:char,Value&,nest(<=)]
< **** getOGstart: 
< [0:char,Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:ch
< **   encOG: (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: ch
< **   encOG:(('0' <= ch) && (ch <= '9'))
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:(('0' <= ch) && (ch <= '9'))
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OI:semCheck: "&& (ch <= '9')" rec: "('0' <= ch)"
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: (ch <= '9')
< **   fArgs(in B: var boolean,)
< 
< **   encOG:B := (('0' <= ch) && (ch <= '9'))**   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && (ch <= '9')
< **   fArg: in B: var boolean
< **   aArg: (ch <= '9')
< **   theOI.f.f:label: BracketedExp
< (('0' <= ch) && (ch <= '9'))
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **   savedOGS: [0:Boolean]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && (ch <= '9')
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Boolean]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Boolean,nest(&&)]
< **   getOGsequenceOfArg:aArgs:(ch <= '9')
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Boolean,nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Boolean,nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:Boolean,nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Boolean,nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Boolean,nest(&&)]
< **   encOG: B := (('0' <= ch) && (ch <= '9'))
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Boolean,nest(&&)]
< **   ENC:result:[1:Boolean]
< **** ENC:OI.getVqual:[2:Boolean]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:(ch <= '9')
< **   encOG: (('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: (ch <= '9')
< **   encOG:(('0' <= ch) && (ch <= '9'))
< **** Invocation:semCheck: ch <= '9'
< **   encOG:(('0' <= ch) && (ch <= '9'))
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:(('0' <= ch) && (ch <= '9'))
< **** OI:semCheck: "<= '9'" rec: "ch"
< **   encOG:(('0' <= ch) && (ch <= '9'))
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: '9'
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:(('0' <= ch) && (ch <= '9'))**   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= '9'
< **   fArg: in Veq: var this(Value)
< **   aArg: '9'
< **   theOI.f.f:label: BracketedExp
< (ch <= '9')
< **   encOG:(('0' <= ch) && (ch <= '9'))
< **   savedOGS: [0:BETA,nest(char),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= '9'
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(char),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(char),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:'9'
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:BETA,nest(char),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(char),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(char),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(char),Value&,nest(<=)]
< **** getOGstart: 
< [0:BETA,nest(char),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:'9'
< **   encOG: (ch <= '9')
< **** Invocation:semCheck: '9'
< **   encOG:(ch <= '9')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: B := (('0' <= ch) && (ch <= '9'))
< 
< **** OI:getVqual:initial:B
< **   encOG:B := (('0' <= ch) && (ch <= '9'))
< **   OGs:[0:isDigit]
< **   ATd: B: var Boolean
< **** DataItem:getVqual: B: var Boolean
< [0:isDigit]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:isDigit]
< 
< **** OI:getVqual: Boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isDigit]
< **   encOG: B := (('0' <= ch) && (ch <= '9'))
< **** koks: Boolean on: 2 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< isDigit(ch: var Char) -> B: var Boolean
< **** ENC:OI.getVqual:[1:isDigit]
< **   ENC:result:[1:ascii]
< **** ENC:OI.getVqual:[2:ascii]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< B := (('0' <= ch) && (ch <= '9'))
< **** OG:returnDecl: B: var Boolean
< **** OG:semCheck:
< nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
< --asciiFoo.msg1
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** Invocation:semCheck: nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
< --asciiFoo.msg1
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OI:semCheck: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>
< --asciiFoo.msg1" rec: "newline"
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: newline on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OI:getVqual:initial:newline
< **   encOG:
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **   OGs:[0:ascii]
< **   ATd: newline: var char
< **** DataItem:getVqual: newline: var char
< [0:ascii]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:ascii]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:ascii]
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** ENC:OI.getVqual:[1:ascii]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:newline
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: newline
< **   OI:getQual:savedOI:newline
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: newline
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** OG:semCheck:
< %globals
<    put(10)
< **   encOG: 
< %globals
<    put(10)
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    put(10)
< 
< **** OG:semCheck:put(10)
< **   encOG: 
< %globals
<    put(10)
< **** Invocation:semCheck: put(10)
< **   encOG:
< %globals
<    put(10)
< 
< **** OI:semCheck: "put(10)" rec: "none"
< **   encOG:
< %globals
<    put(10)
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(10)
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< %globals
<    put(10)
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(10)
< **   fArg: in ch: val char
< **   aArg: 10
< **   theOI.f.f:label: ObjectGenerator
< put(10)
< **   encOG:
< %globals
<    put(10)
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(10)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(put)]
< **   getOGsequenceOfArg:aArgs:put(10)
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:BETA,nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:BETA,nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(put)]
< **   encOG: 
< %globals
<    put(10)
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:BETA,nest(put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:10
< **   encOG: put(10)
< **** Invocation:semCheck: 10
< **   encOG:put(10)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    put(10)
< **** OG:semCheck:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Invocation:semCheck: inSub
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "inSub" rec: "%globals"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< inSub: 
<    %basic 7
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: char
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:Indexed(20,#integer)
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: Indexed(20,#integer)
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "Indexed(20,#integer)" rec: "none"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   actualArgs: (20,#integer)
< **   fArgs(in range: var Integer,in elm:< Object,)
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   argAtInx: 1 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   fArg: in range: var Integer
< **   aArg: 20
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,#integer)
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in range: var Integer
< **** Items:localSearch: range
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: range
< Try: "range"
< **** Items:localSearch:end: range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,#integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:BETA,nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed)]
< **** DataItem:getVqual: in range: var Integer
< [0:BETA,nest(Indexed)]
< **** ObjectGenerator:getVqual: Integer
< **   hasVirtualArgs: False
< **** INV:getVqual:Integer
< **   OGs: [0:BETA,nest(Indexed)]
< 
< **** OI:getVqual: Integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Indexed)]
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** koks: Integer on: 1 Items 
< **   father: Integer
< **   father.f.f.f.f:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** ENC:OI.getVqual:[1:BETA,nest(Indexed)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Integer
< **   OI:getQual:savedOI:Integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:20
< **   encOG: Indexed(20,#integer)
< **** Invocation:semCheck: 20
< **   encOG:Indexed(20,#integer)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   fArg: in elm:< Object
< **   aArg: #integer
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,#integer)
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "range"
< Try: "elm"
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,#integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:BETA,nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed)]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:BETA,nest(Indexed)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(Indexed)]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:BETA,nest(Indexed)]
< **   checkDOG: Indexed 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< father:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#integer
< **   encOG: Indexed(20,#integer)
< **** Invocation:semCheck: #integer
< **   encOG:Indexed(20,#integer)
< **** OI:semCheck: "#integer" rec: "none"
< **   encOG:Indexed(20,#integer)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:V < 0
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: V < 0
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "V" rec: "isNeg"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "< 0" rec: "V"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   argAtInx: 1 in:PTN:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< V < 0
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 51
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(<)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:BETA,nest(integer),nest(<)]
< **   theFargOG:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(<)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(<)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(<)]
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(<)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: V < 0
< **** Invocation:semCheck: 0
< **   encOG:V < 0
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:getVqual:initial:isNeg
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   OGs:[0:int2chars]
< **   ATd: isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:int2chars]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:int2chars]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:int2chars]
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** ENC:OI.getVqual:[1:int2chars]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:isNeg
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (isNeg) :then 
<    V := 0 - V
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: if (isNeg) :then 
<    V := 0 - V
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OG:semCheck:(isNeg)
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: (isNeg)
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Invocation:semCheck: isNeg
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "isNeg" rec: "none"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:V := 0 - V
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:0 - V
< **   encOG: V := 0 - V
< **** Invocation:semCheck: 0 - V
< **   encOG:V := 0 - V
< **** OI:semCheck: "- V" rec: "0"
< **   encOG:V := 0 - V
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: V
< **   fArgs(in V: var integer,)
< 
< **   encOG:V := 0 - V**   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - V
< **   fArg: in V: var integer
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< 0 - V
< **   encOG:V := 0 - V
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - V
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:V
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: V := 0 - V
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:V
< **   encOG: 0 - V
< **** Invocation:semCheck: V
< **   encOG:0 - V
< **** OI:semCheck: "V" rec: "none"
< **   encOG:0 - V
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: V := 0 - V
< 
< **** OI:getVqual:initial:V
< **   encOG:V := 0 - V
< **   OGs:[0:int2chars]
< **   ATd: in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:int2chars]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:int2chars]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:int2chars]
< **   encOG: V := 0 - V
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** ENC:OI.getVqual:[1:int2chars]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< V := 0 - V
< **** OG:semcheck:IS not empty:eOG: 
< V := 0 - V
< **** OG:semCheck:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **   encOG: 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** OG:semCheck:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   encOG: 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** OG:semCheck:L + 1
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: L + 1
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "L" rec: "L"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "+ 1" rec: "L"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< L + 1
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: L + 1
< **** Invocation:semCheck: 1
< **   encOG:L + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: L on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual:initial:L
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGs:[0:int2chars]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:int2chars]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:int2chars]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:int2chars]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** ENC:OI.getVqual:[1:int2chars]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:D.put(V /% 10):at[L]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: D.put(V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "D" rec: "none"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "put(V /% 10):at[L]" rec: "D"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put(V /% 10):at[L]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   fArg: V: var integer
< **   aArg: V /% 10
< **   theOI.f.f:label: ObjectGenerator
< D.put(V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:BETA,nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(V /% 10):at[L]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:BETA,nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:BETA,nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Indexed),nest(put:at)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(Indexed),nest(put:at)]
< **   ENC:result:[1:BETA,nest(Indexed)]
< **** ENC:OI.getVqual:[2:BETA,nest(Indexed)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:V /% 10
< **   encOG: D.put(V /% 10):at[L]
< **** Invocation:semCheck: V /% 10
< **   encOG:D.put(V /% 10):at[L]
< **** OI:semCheck: "V" rec: "none"
< **   encOG:D.put(V /% 10):at[L]
< **** OI:semCheck: "/% 10" rec: "V"
< **   encOG:D.put(V /% 10):at[L]
< **** Pattern:checkActualArgs:
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   actualArgs: 10
< **   fArgs(in V: var integer,)
< 
< **   encOG:D.put(V /% 10):at[L]**   argAtInx: 1 in:PTN:
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   theOI: /% 10
< **   fArg: in V: var integer
< **   aArg: 10
< **   theOI.f.f:label: ObjectGenerator
< V /% 10
< **   encOG:D.put(V /% 10):at[L]
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   theOI: /% 10
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 69
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(/%)]
< **   getOGsequenceOfArg:aArgs:10
< **   fArgs.origin.OG=theFargsOG: 
< %basic 69
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(/%)]
< **   theFargOG:
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(/%)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(/%)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(/%)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(/%)]
< **   encOG: D.put(V /% 10):at[L]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(/%)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:10
< **   encOG: V /% 10
< **** Invocation:semCheck: 10
< **   encOG:V /% 10
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   fArg: inx: var integer
< **   aArg: L
< **   theOI.f.f:label: ObjectGenerator
< D.put(V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:BETA,nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(V /% 10):at[L]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:BETA,nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:BETA,nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Indexed),nest(put:at)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(Indexed),nest(put:at)]
< **   ENC:result:[1:BETA,nest(Indexed)]
< **** ENC:OI.getVqual:[2:BETA,nest(Indexed)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:L
< **   encOG: D.put(V /% 10):at[L]
< **** Invocation:semCheck: L
< **   encOG:D.put(V /% 10):at[L]
< **** OI:semCheck: "L" rec: "none"
< **   encOG:D.put(V /% 10):at[L]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semCheck:V // 10
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: V // 10
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "V" rec: "V"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "// 10" rec: "V"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   actualArgs: 10
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   theOI: // 10
< **   fArg: in V: var integer
< **   aArg: 10
< **   theOI.f.f:label: ObjectGenerator
< V // 10
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   theOI: // 10
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 68
< in V: var integer
< out B: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(//)]
< **   getOGsequenceOfArg:aArgs:10
< **   fArgs.origin.OG=theFargsOG: 
< %basic 68
<    in V: var integer
<    out B: var integer
< **   OGS: [0:BETA,nest(integer),nest(//)]
< **   theFargOG:
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(//)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(//)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(//)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(//)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(//)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:10
< **   encOG: V // 10
< **** Invocation:semCheck: 10
< **   encOG:V // 10
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out B: var integer
< 
< **** OI:getVqual: V on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual:initial:V
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGs:[0:int2chars]
< **   ATd: in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:int2chars]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:int2chars]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:int2chars]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** ENC:OI.getVqual:[1:int2chars]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (V > 0) :then 
<    restart(loop)
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: if (V > 0) :then 
<    restart(loop)
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OG:semCheck:(V > 0)
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: (V > 0)
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Invocation:semCheck: V > 0
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "> 0" rec: "V"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (V > 0)
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 53
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(>)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:BETA,nest(integer),nest(>)]
< **   theFargOG:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(>)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(>)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(>)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(>)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(>)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: (V > 0)
< **** Invocation:semCheck: 0
< **   encOG:(V > 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:restart(loop)
< **   encOG: restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:restart(loop)
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** OG:semCheck:
< if (isNeg) :then 
<    ch := '-'
<    inner(int2chars)
< **   encOG: 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** Invocation:semCheck: if (isNeg) :then 
<    ch := '-'
<    inner(int2chars)
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** OG:semCheck:(isNeg)
< **   encOG: 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** Invocation:semCheck: (isNeg)
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** Invocation:semCheck: isNeg
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** OI:semCheck: "isNeg" rec: "none"
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< ch := '-'
<    inner(int2chars)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:'-'
< **   encOG: 
< ch := '-'
<    inner(int2chars)
< **** Invocation:semCheck: '-'
< **   encOG:
< ch := '-'
<    inner(int2chars)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** OI:getVqual: ch on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< ch := '-'
<    inner(int2chars)
< 
< **** OI:getVqual:initial:ch
< **   encOG:
< ch := '-'
<    inner(int2chars)
< **   OGs:[0:int2chars]
< **   ATd: ch: var char
< **** DataItem:getVqual: ch: var char
< [0:int2chars]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:int2chars]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:int2chars]
< **   encOG: 
< ch := '-'
<    inner(int2chars)
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** ENC:OI.getVqual:[1:int2chars]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:ch
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: ch
< **   OI:getQual:savedOI:ch
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: ch
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:inner(int2chars)
< **   encOG: 
< ch := '-'
<    inner(int2chars)
< **** Invocation:semCheck: inner(int2chars)
< **   encOG:
< ch := '-'
<    inner(int2chars)
< 
< **** OI:semCheck: "inner(int2chars)" rec: "none"
< **   encOG:
< ch := '-'
<    inner(int2chars)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< ch := '-'
<    inner(int2chars)
< **** OG:semcheck:IS not empty:eOG: 
< 
< ch := '-'
<    inner(int2chars)
< **** OG:semcheck:IS not empty:eOG: 
< 
< ch := '-'
<    inner(int2chars)
< **** OG:semCheck:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   encOG: 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** Invocation:semCheck: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** OI:semCheck: "for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< " rec: "none"
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   fArg: last: var integer
< **   aArg: L
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:L
< **   encOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **** Invocation:semCheck: L
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   fArg: repeat:< object
< **   aArg: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   encOG:
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   encOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** Invocation:semCheck: integer
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:L + 1 - inx
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** Invocation:semCheck: L + 1 - inx
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:semCheck: "L" rec: "i"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:semCheck: "+ 1 - inx" rec: "L"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1 - inx
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1 - inx
< **   fArg: in V: var integer
< **   aArg: 1 - inx
< **   theOI.f.f:label: ObjectGenerator
< L + 1 - inx
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1 - inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1 - inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1 - inx
< **   encOG: L + 1 - inx
< **** Invocation:semCheck: 1 - inx
< **   encOG:L + 1 - inx
< **** OI:semCheck: "- inx" rec: "1"
< **   encOG:L + 1 - inx
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: inx
< **   fArgs(in V: var integer,)
< 
< **   encOG:L + 1 - inx**   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx
< **   fArg: in V: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< 1 - inx
< **   encOG:L + 1 - inx
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: L + 1 - inx
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:inx
< **   encOG: 1 - inx
< **** Invocation:semCheck: inx
< **   encOG:1 - inx
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:1 - inx
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: i on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:getVqual:initial:i
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   OGs:[0:repeat$0]
< **   ATd: i: var integer
< **** DataItem:getVqual: i: var integer
< [0:repeat$0]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:repeat$0]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$0]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** koks: integer on: 4 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** ENC:OI.getVqual:[1:repeat$0]
< **   ENC:result:[1:for:to:repeat$0]
< **** ENC:OI.getVqual:[2:for:to:repeat$0]
< **   ENC:result:[2:doit]
< **** ENC:OI.getVqual:[3:doit]
< **   ENC:result:[3:int2chars]
< **** ENC:OI.getVqual:[4:int2chars]
< **   ENC:result:[4:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:i
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'0' + D.get[i]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** Invocation:semCheck: '0' + D.get[i]
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:semCheck: "+ D.get[i]" rec: "'0'"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   actualArgs: D.get[i]
< **   fArgs(in V: var char,)
< 
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   theOI: + D.get[i]
< **   fArg: in V: var char
< **   aArg: D.get[i]
< **   theOI.f.f:label: ObjectGenerator
< '0' + D.get[i]
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   savedOGS: [0:char]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   theOI: + D.get[i]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var char
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var char
< out R: var char
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:char]
< **   OGS.DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   After:[0:char,nest(+)]
< **   getOGsequenceOfArg:aArgs:D.get[i]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var char
<    out R: var char
< **   OGS: [0:char,nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var char
<    out R: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:char,nest(+)]
< **** DataItem:getVqual: in V: var char
< [0:char,nest(+)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:char,nest(+)]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:char,nest(+)]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var char
<    out R: var char
< **** ENC:OI.getVqual:[1:char,nest(+)]
< **   ENC:result:[1:char]
< **** ENC:OI.getVqual:[2:char]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:D.get[i]
< **   encOG: '0' + D.get[i]
< **** Invocation:semCheck: D.get[i]
< **   encOG:'0' + D.get[i]
< **** OI:semCheck: "D" rec: "none"
< **   encOG:'0' + D.get[i]
< **** OI:semCheck: "get[i]" rec: "D"
< **   encOG:'0' + D.get[i]
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   actualArgs: get[i]
< **   fArgs(inx: var integer,)
< 
< **   encOG:'0' + D.get[i]**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[i]
< **   fArg: inx: var integer
< **   aArg: i
< **   theOI.f.f:label: ObjectGenerator
< D.get[i]
< **   encOG:'0' + D.get[i]
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[i]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[i]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: var integer
< **   OGS: [0:BETA,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:BETA,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(get)]
< **   encOG: '0' + D.get[i]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(get)]
< **   ENC:result:[1:BETA]
< **** ENC:OI.getVqual:[2:BETA]
< **   ENC:result:[2:BETAworld]
< 
< **** getVqual:B2:
< [0:BETAworld]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETAworld]
< **** savedOGS:save:False[0:BETAworld]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld]
< **   OGS:[0:BETAworld]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld]
< **** OG:semCheck:i
< **   encOG: D.get[i]
< **** Invocation:semCheck: i
< **   encOG:D.get[i]
< **** OI:semCheck: "i" rec: "none"
< **   encOG:D.get[i]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out R: var char
< 
< **** OI:getVqual: ch on=3 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:getVqual:initial:ch
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **   OGs:[0:int2chars]
< **   ATd: ch: var char
< **** DataItem:getVqual: ch: var char
< [0:int2chars]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:int2chars]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:int2chars]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** ENC:OI.getVqual:[1:int2chars]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:ch
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: ch
< **   OI:getQual:savedOI:ch
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: ch
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:inner(int2chars)
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** Invocation:semCheck: inner(int2chars)
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OI:semCheck: "inner(int2chars)" rec: "none"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** OG:semcheck:IS not empty:eOG: 
< 
< i: var integer
<    i := L + 1 - inx
<    ch := '0' + D.get[i]
<    inner(int2chars)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** OG:semCheck:doit
< **   encOG: 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** Invocation:semCheck: doit
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** OI:semCheck: "doit" rec: "none"
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< doit: 
<    loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< loop: obj 
<       L := L + 1
<       D.put(V /% 10):at[L]
<       V := V // 10
<       if (V > 0) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals inSub
<    in V: var integer
<    ch: var char
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **** OG:semCheck:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Indexed(20,#integer)
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: Indexed(20,#integer)
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "Indexed(20,#integer)" rec: "none"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   actualArgs: (20,#integer)
< **   fArgs(in range: var Integer,in elm:< Object,)
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   argAtInx: 1 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   fArg: in range: var Integer
< **   aArg: 20
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,#integer)
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in range: var Integer
< **** Items:localSearch: range
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: range
< Try: "range"
< **** Items:localSearch:end: range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,#integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:BETA,nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed)]
< **** DataItem:getVqual: in range: var Integer
< [0:BETA,nest(Indexed)]
< **** ObjectGenerator:getVqual: Integer
< **   hasVirtualArgs: False
< **** INV:getVqual:Integer
< **   OGs: [0:BETA,nest(Indexed)]
< 
< **** OI:getVqual: Integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Indexed)]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: Integer on: 1 Items 
< **   father: Integer
< **   father.f.f.f.f:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** ENC:OI.getVqual:[1:BETA,nest(Indexed)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Integer
< **   OI:getQual:savedOI:Integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:20
< **   encOG: Indexed(20,#integer)
< **** Invocation:semCheck: 20
< **   encOG:Indexed(20,#integer)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   fArg: in elm:< Object
< **   aArg: #integer
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,#integer)
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,#integer)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "range"
< Try: "elm"
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,#integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:BETA,nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed)]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:BETA,nest(Indexed)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(Indexed)]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:BETA,nest(Indexed)]
< **   checkDOG: Indexed 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< father:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#integer
< **   encOG: Indexed(20,#integer)
< **** Invocation:semCheck: #integer
< **   encOG:Indexed(20,#integer)
< **** OI:semCheck: "#integer" rec: "none"
< **   encOG:Indexed(20,#integer)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:V < 0
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: V < 0
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "V" rec: "isNeg"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "< 0" rec: "V"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   argAtInx: 1 in:PTN:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< V < 0
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 51
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(<)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:BETA,nest(integer),nest(<)]
< **   theFargOG:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(<)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(<)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(<)]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(<)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: V < 0
< **** Invocation:semCheck: 0
< **   encOG:V < 0
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual:initial:isNeg
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   OGs:[0:putint]
< **   ATd: isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:putint]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:isNeg
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (isNeg) :then 
<    V := 0 - V
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: if (isNeg) :then 
<    V := 0 - V
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OG:semCheck:(isNeg)
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: (isNeg)
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Invocation:semCheck: isNeg
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "isNeg" rec: "none"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:V := 0 - V
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:0 - V
< **   encOG: V := 0 - V
< **** Invocation:semCheck: 0 - V
< **   encOG:V := 0 - V
< **** OI:semCheck: "- V" rec: "0"
< **   encOG:V := 0 - V
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: V
< **   fArgs(in V: var integer,)
< 
< **   encOG:V := 0 - V**   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - V
< **   fArg: in V: var integer
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< 0 - V
< **   encOG:V := 0 - V
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - V
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:V
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: V := 0 - V
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:V
< **   encOG: 0 - V
< **** Invocation:semCheck: V
< **   encOG:0 - V
< **** OI:semCheck: "V" rec: "none"
< **   encOG:0 - V
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: V := 0 - V
< 
< **** OI:getVqual:initial:V
< **   encOG:V := 0 - V
< **   OGs:[0:putint]
< **   ATd: in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: V := 0 - V
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< V := 0 - V
< **** OG:semcheck:IS not empty:eOG: 
< V := 0 - V
< **** OG:semCheck:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:L + 1
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: L + 1
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "L" rec: "L"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "+ 1" rec: "L"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< L + 1
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: L + 1
< **** Invocation:semCheck: 1
< **   encOG:L + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: L on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual:initial:L
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGs:[0:putint]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:D.put(V /% 10):at[L]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: D.put(V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "D" rec: "none"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "put(V /% 10):at[L]" rec: "D"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put(V /% 10):at[L]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   fArg: V: var integer
< **   aArg: V /% 10
< **   theOI.f.f:label: ObjectGenerator
< D.put(V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:BETA,nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(V /% 10):at[L]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:BETA,nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:BETA,nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Indexed),nest(put:at)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(Indexed),nest(put:at)]
< **   ENC:result:[1:BETA,nest(Indexed)]
< **** ENC:OI.getVqual:[2:BETA,nest(Indexed)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:V /% 10
< **   encOG: D.put(V /% 10):at[L]
< **** Invocation:semCheck: V /% 10
< **   encOG:D.put(V /% 10):at[L]
< **** OI:semCheck: "V" rec: "none"
< **   encOG:D.put(V /% 10):at[L]
< **** OI:semCheck: "/% 10" rec: "V"
< **   encOG:D.put(V /% 10):at[L]
< **** Pattern:checkActualArgs:
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   actualArgs: 10
< **   fArgs(in V: var integer,)
< 
< **   encOG:D.put(V /% 10):at[L]**   argAtInx: 1 in:PTN:
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   theOI: /% 10
< **   fArg: in V: var integer
< **   aArg: 10
< **   theOI.f.f:label: ObjectGenerator
< V /% 10
< **   encOG:D.put(V /% 10):at[L]
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   theOI: /% 10
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 69
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(/%)]
< **   getOGsequenceOfArg:aArgs:10
< **   fArgs.origin.OG=theFargsOG: 
< %basic 69
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(/%)]
< **   theFargOG:
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(/%)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(/%)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(/%)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(/%)]
< **   encOG: D.put(V /% 10):at[L]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(/%)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:10
< **   encOG: V /% 10
< **** Invocation:semCheck: 10
< **   encOG:V /% 10
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   fArg: inx: var integer
< **   aArg: L
< **   theOI.f.f:label: ObjectGenerator
< D.put(V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(V /% 10):at[L]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:BETA,nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(V /% 10):at[L]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:BETA,nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:BETA,nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Indexed),nest(put:at)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(Indexed),nest(put:at)]
< **   ENC:result:[1:BETA,nest(Indexed)]
< **** ENC:OI.getVqual:[2:BETA,nest(Indexed)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:L
< **   encOG: D.put(V /% 10):at[L]
< **** Invocation:semCheck: L
< **   encOG:D.put(V /% 10):at[L]
< **** OI:semCheck: "L" rec: "none"
< **   encOG:D.put(V /% 10):at[L]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semCheck:V // 10
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: V // 10
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "V" rec: "V"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "// 10" rec: "V"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   actualArgs: 10
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   theOI: // 10
< **   fArg: in V: var integer
< **   aArg: 10
< **   theOI.f.f:label: ObjectGenerator
< V // 10
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   theOI: // 10
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 68
< in V: var integer
< out B: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(//)]
< **   getOGsequenceOfArg:aArgs:10
< **   fArgs.origin.OG=theFargsOG: 
< %basic 68
<    in V: var integer
<    out B: var integer
< **   OGS: [0:BETA,nest(integer),nest(//)]
< **   theFargOG:
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(//)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(//)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(//)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(//)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(//)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:10
< **   encOG: V // 10
< **** Invocation:semCheck: 10
< **   encOG:V // 10
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out B: var integer
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual:initial:V
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGs:[0:putint]
< **   ATd: in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (V > 0) :then 
<    restart(loop)
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: if (V > 0) :then 
<    restart(loop)
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OG:semCheck:(V > 0)
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: (V > 0)
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Invocation:semCheck: V > 0
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "> 0" rec: "V"
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (V > 0)
< **   encOG:
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 53
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(>)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:BETA,nest(integer),nest(>)]
< **   theFargOG:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(>)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(>)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(>)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(>)]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(>)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: (V > 0)
< **** Invocation:semCheck: 0
< **   encOG:(V > 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:restart(loop)
< **   encOG: restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:restart(loop)
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** OG:semCheck:
< if (isNeg) :then 
<    put('-')
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: if (isNeg) :then 
<    put('-')
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OG:semCheck:(isNeg)
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: (isNeg)
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Invocation:semCheck: isNeg
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "isNeg" rec: "none"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:put('-')
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:put('-')
< **   encOG: put('-')
< **** Invocation:semCheck: put('-')
< **   encOG:put('-')
< **** OI:semCheck: "put('-')" rec: "none"
< **   encOG:put('-')
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('-')
< **   fArgs(in ch: val char,)
< 
< **   encOG:put('-')**   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('-')
< **   fArg: in ch: val char
< **   aArg: '-'
< **   theOI.f.f:label: ObjectGenerator
< put('-')
< **   encOG:put('-')
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('-')
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(put)]
< **   getOGsequenceOfArg:aArgs:put('-')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:BETA,nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:BETA,nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(put)]
< **   encOG: put('-')
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:BETA,nest(put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'-'
< **   encOG: put('-')
< **** Invocation:semCheck: '-'
< **   encOG:put('-')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< put('-')
< **** OG:semcheck:IS not empty:eOG: 
< put('-')
< **** OG:semCheck:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** Invocation:semCheck: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:semCheck: "for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< " rec: "none"
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   fArg: last: var integer
< **   aArg: L
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:L
< **   encOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** Invocation:semCheck: L
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   fArg: repeat:< object
< **   aArg: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   encOG:
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   encOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< 
< **** OG:semCheck:integer
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** Invocation:semCheck: integer
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:L + 1 - inx
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** Invocation:semCheck: L + 1 - inx
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:semCheck: "L" rec: "i"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:semCheck: "+ 1 - inx" rec: "L"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1 - inx
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1 - inx
< **   fArg: in V: var integer
< **   aArg: 1 - inx
< **   theOI.f.f:label: ObjectGenerator
< L + 1 - inx
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1 - inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1 - inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1 - inx
< **   encOG: L + 1 - inx
< **** Invocation:semCheck: 1 - inx
< **   encOG:L + 1 - inx
< **** OI:semCheck: "- inx" rec: "1"
< **   encOG:L + 1 - inx
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: inx
< **   fArgs(in V: var integer,)
< 
< **   encOG:L + 1 - inx**   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx
< **   fArg: in V: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< 1 - inx
< **   encOG:L + 1 - inx
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: L + 1 - inx
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:inx
< **   encOG: 1 - inx
< **** Invocation:semCheck: inx
< **   encOG:1 - inx
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:1 - inx
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: i on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual:initial:i
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   OGs:[0:repeat$0]
< **   ATd: i: var integer
< **** DataItem:getVqual: i: var integer
< [0:repeat$0]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:repeat$0]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$0]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 3 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** ENC:OI.getVqual:[1:repeat$0]
< **   ENC:result:[1:for:to:repeat$0]
< **** ENC:OI.getVqual:[2:for:to:repeat$0]
< **   ENC:result:[2:putint]
< **** ENC:OI.getVqual:[3:putint]
< **   ENC:result:[3:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:i
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:put('0' + D.get[i])
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** Invocation:semCheck: put('0' + D.get[i])
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:semCheck: "put('0' + D.get[i])" rec: "none"
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('0' + D.get[i])
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('0' + D.get[i])
< **   fArg: in ch: val char
< **   aArg: '0' + D.get[i]
< **   theOI.f.f:label: ObjectGenerator
< put('0' + D.get[i])
< **   encOG:
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('0' + D.get[i])
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(put)]
< **   getOGsequenceOfArg:aArgs:put('0' + D.get[i])
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:BETA,nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:BETA,nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(put)]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:BETA,nest(put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'0' + D.get[i]
< **   encOG: put('0' + D.get[i])
< **** Invocation:semCheck: '0' + D.get[i]
< **   encOG:put('0' + D.get[i])
< **** OI:semCheck: "+ D.get[i]" rec: "'0'"
< **   encOG:put('0' + D.get[i])
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   actualArgs: D.get[i]
< **   fArgs(in V: var char,)
< 
< **   encOG:put('0' + D.get[i])**   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   theOI: + D.get[i]
< **   fArg: in V: var char
< **   aArg: D.get[i]
< **   theOI.f.f:label: ObjectGenerator
< '0' + D.get[i]
< **   encOG:put('0' + D.get[i])
< **   savedOGS: [0:char]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   theOI: + D.get[i]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var char
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var char
< out R: var char
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:char]
< **   OGS.DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   After:[0:char,nest(+)]
< **   getOGsequenceOfArg:aArgs:D.get[i]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var char
<    out R: var char
< **   OGS: [0:char,nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var char
<    out R: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:char,nest(+)]
< **** DataItem:getVqual: in V: var char
< [0:char,nest(+)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:char,nest(+)]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:char,nest(+)]
< **   encOG: put('0' + D.get[i])
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var char
<    out R: var char
< **** ENC:OI.getVqual:[1:char,nest(+)]
< **   ENC:result:[1:char]
< **** ENC:OI.getVqual:[2:char]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:D.get[i]
< **   encOG: '0' + D.get[i]
< **** Invocation:semCheck: D.get[i]
< **   encOG:'0' + D.get[i]
< **** OI:semCheck: "D" rec: "none"
< **   encOG:'0' + D.get[i]
< **** OI:semCheck: "get[i]" rec: "D"
< **   encOG:'0' + D.get[i]
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   actualArgs: get[i]
< **   fArgs(inx: var integer,)
< 
< **   encOG:'0' + D.get[i]**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[i]
< **   fArg: inx: var integer
< **   aArg: i
< **   theOI.f.f:label: ObjectGenerator
< D.get[i]
< **   encOG:'0' + D.get[i]
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[i]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[i]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: var integer
< **   OGS: [0:BETA,nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:BETA,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(get)]
< **   encOG: '0' + D.get[i]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:BETA,nest(get)]
< **   ENC:result:[1:BETA]
< **** ENC:OI.getVqual:[2:BETA]
< **   ENC:result:[2:BETAworld]
< 
< **** getVqual:B2:
< [0:BETAworld]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETAworld]
< **** savedOGS:save:False[0:BETAworld]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld]
< **   OGS:[0:BETAworld]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld]
< **** OG:semCheck:i
< **   encOG: D.get[i]
< **** Invocation:semCheck: i
< **   encOG:D.get[i]
< **** OI:semCheck: "i" rec: "none"
< **   encOG:D.get[i]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out R: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semCheck:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OG:semCheck:Float
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** Invocation:semCheck: Float
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Float
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** Invocation:semCheck: Float
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:F
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** Invocation:semCheck: F
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OI:semCheck: "F" rec: "R"
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: R on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OI:getVqual:initial:R
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **   OGs:[0:exp]
< **   ATd: out R: var Float
< **** DataItem:getVqual: out R: var Float
< [0:exp]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:exp]
< 
< **** OI:getVqual: Float on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:exp]
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** koks: Float on: 1 Items 
< **   father: Float
< **   father.f.f.f.f:
< 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** ENC:OI.getVqual:[1:exp]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (n > 0) :then 
<    for(1):to(n - 1):repeat
<       R := R * F
<    
< :else 
< ...
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** Invocation:semCheck: if (n > 0) :then 
<    for(1):to(n - 1):repeat
<       R := R * F
<    
< :else 
<    n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OG:semCheck:(n > 0)
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** Invocation:semCheck: (n > 0)
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** Invocation:semCheck: n > 0
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OI:semCheck: "n" rec: "none"
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** OI:semCheck: "> 0" rec: "n"
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< 
< **** Pattern:checkActualArgs:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **   argAtInx: 1 in:PTN:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (n > 0)
< **   encOG:
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 53
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(>)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:BETA,nest(integer),nest(>)]
< **   theFargOG:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(>)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(>)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(>)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(>)]
< **   encOG: 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(>)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:0
< **   encOG: (n > 0)
< **** Invocation:semCheck: 0
< **   encOG:(n > 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG: 
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **** Invocation:semCheck: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< 
< **** OI:semCheck: "for(1):to(n - 1):repeat
<    R := R * F
< " rec: "none"
< **   encOG:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArg: last: var integer
< **   aArg: n - 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:n - 1
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** Invocation:semCheck: n - 1
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OI:semCheck: "n" rec: "none"
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OI:semCheck: "- 1" rec: "n"
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< n - 1
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(-)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(-)]
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(-)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: n - 1
< **** Invocation:semCheck: 1
< **   encOG:n - 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArg: repeat:< object
< **   aArg: R := R * F
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:R := R * F
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OG:semCheck:R * F
< **   encOG: R := R * F
< **** Invocation:semCheck: R * F
< **   encOG:R := R * F
< **** OI:semCheck: "R" rec: "R"
< **   encOG:R := R * F
< **** OI:semCheck: "* F" rec: "R"
< **   encOG:R := R * F
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: F
< **   fArgs(in V: var float,)
< 
< **   encOG:R := R * F**   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * F
< **   fArg: in V: var float
< **   aArg: F
< **   theOI.f.f:label: ObjectGenerator
< R * F
< **   encOG:R := R * F
< **   savedOGS: [0:BETA,nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * F
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:BETA,nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:F
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:BETA,nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:BETA,nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:BETA,nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(float),nest(*)]
< **   encOG: R := R * F
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:BETA,nest(float),nest(*)]
< **   ENC:result:[1:BETA,nest(float)]
< **** ENC:OI.getVqual:[2:BETA,nest(float)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:F
< **   encOG: R * F
< **** Invocation:semCheck: F
< **   encOG:R * F
< **** OI:semCheck: "F" rec: "none"
< **   encOG:R * F
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: R on=3 pn=0 isNest=True getRtnQual=False
< **   encOG: R := R * F
< 
< **** OI:getVqual:initial:R
< **   encOG:R := R * F
< **   OGs:[0:exp]
< **   ATd: out R: var Float
< **** DataItem:getVqual: out R: var Float
< [0:exp]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:exp]
< 
< **** OI:getVqual: Float on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:exp]
< **   encOG: R := R * F
< **** koks: Float on: 1 Items 
< **   father: Float
< **   father.f.f.f.f:
< 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** ENC:OI.getVqual:[1:exp]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< R := R * F
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **** OG:semCheck:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   encOG: 
< for(1):to(n - 1):repeat
<       R := R * F
<    
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(n - 1):repeat
<       R := R * F
<    
< 
< **** OG:semCheck:(0 - n)
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** Invocation:semCheck: (0 - n)
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** Invocation:semCheck: 0 - n
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** OI:semCheck: "- n" rec: "0"
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: n
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - n
< **   fArg: in V: var integer
< **   aArg: n
< **   theOI.f.f:label: BracketedExp
< (0 - n)
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - n
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:n
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:n
< **   encOG: (0 - n)
< **** Invocation:semCheck: n
< **   encOG:(0 - n)
< **** OI:semCheck: "n" rec: "none"
< **   encOG:(0 - n)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: n on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** OI:getVqual:initial:n
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   OGs:[0:exp]
< **   ATd: in n: var integer
< **** DataItem:getVqual: in n: var integer
< [0:exp]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:exp]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:exp]
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** ENC:OI.getVqual:[1:exp]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:n
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: n
< **   OI:getQual:savedOI:n
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: n
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** Invocation:semCheck: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** OI:semCheck: "for(1):to(n - 1):repeat
<    R := R * F
< " rec: "none"
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArg: last: var integer
< **   aArg: n - 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:n - 1
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** Invocation:semCheck: n - 1
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OI:semCheck: "n" rec: "none"
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OI:semCheck: "- 1" rec: "n"
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< n - 1
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(-)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(-)]
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(-)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: n - 1
< **** Invocation:semCheck: 1
< **   encOG:n - 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArg: repeat:< object
< **   aArg: R := R * F
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(n - 1):repeat
<    R := R * F
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:R := R * F
< **   encOG: 
< for(1):to(n - 1):repeat
<    R := R * F
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(n - 1):repeat
<    R := R * F
< 
< 
< **** OG:semCheck:R * F
< **   encOG: R := R * F
< **** Invocation:semCheck: R * F
< **   encOG:R := R * F
< **** OI:semCheck: "R" rec: "R"
< **   encOG:R := R * F
< **** OI:semCheck: "* F" rec: "R"
< **   encOG:R := R * F
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: F
< **   fArgs(in V: var float,)
< 
< **   encOG:R := R * F**   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * F
< **   fArg: in V: var float
< **   aArg: F
< **   theOI.f.f:label: ObjectGenerator
< R * F
< **   encOG:R := R * F
< **   savedOGS: [0:BETA,nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * F
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:BETA,nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:F
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:BETA,nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:BETA,nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:BETA,nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(float),nest(*)]
< **   encOG: R := R * F
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:BETA,nest(float),nest(*)]
< **   ENC:result:[1:BETA,nest(float)]
< **** ENC:OI.getVqual:[2:BETA,nest(float)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:F
< **   encOG: R * F
< **** Invocation:semCheck: F
< **   encOG:R * F
< **** OI:semCheck: "F" rec: "none"
< **   encOG:R * F
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: R on=3 pn=0 isNest=True getRtnQual=False
< **   encOG: R := R * F
< 
< **** OI:getVqual:initial:R
< **   encOG:R := R * F
< **   OGs:[0:exp]
< **   ATd: out R: var Float
< **** DataItem:getVqual: out R: var Float
< [0:exp]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:exp]
< 
< **** OI:getVqual: Float on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:exp]
< **   encOG: R := R * F
< **** koks: Float on: 1 Items 
< **   father: Float
< **   father.f.f.f.f:
< 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** ENC:OI.getVqual:[1:exp]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< R := R * F
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:1.0 / R
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** Invocation:semCheck: 1.0 / R
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** OI:semCheck: "/ R" rec: "1.0"
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** Pattern:checkActualArgs:
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   actualArgs: R
< **   fArgs(in V: var float,)
< 
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   argAtInx: 1 in:PTN:
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   theOI: / R
< **   fArg: in V: var float
< **   aArg: R
< **   theOI.f.f:label: ObjectGenerator
< 1.0 / R
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   savedOGS: [0:float]
< **** PTN:getOGsequenceOfArg: 
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   theOI: / R
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 121
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:float]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:float,nest(/)]
< **   getOGsequenceOfArg:aArgs:R
< **   fArgs.origin.OG=theFargsOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **   OGS: [0:float,nest(/)]
< **   theFargOG:
< 
< %basic 121
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:float,nest(/)]
< **** DataItem:getVqual: in V: var float
< [0:float,nest(/)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:float,nest(/)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:float,nest(/)]
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 121
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:float,nest(/)]
< **   ENC:result:[1:float]
< **** ENC:OI.getVqual:[2:float]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:R
< **   encOG: 1.0 / R
< **** Invocation:semCheck: R
< **   encOG:1.0 / R
< **** OI:semCheck: "R" rec: "none"
< **   encOG:1.0 / R
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: R on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< 
< **** OI:getVqual:initial:R
< **   encOG:
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **   OGs:[0:exp]
< **   ATd: out R: var Float
< **** DataItem:getVqual: out R: var Float
< [0:exp]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:exp]
< 
< **** OI:getVqual: Float on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:exp]
< **   encOG: 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** koks: Float on: 1 Items 
< **   father: Float
< **   father.f.f.f.f:
< 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** ENC:OI.getVqual:[1:exp]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** OG:semcheck:IS not empty:eOG: 
< 
< n := (0 - n)
<    for(1):to(n - 1):repeat
<       R := R * F
<    
<    R := 1.0 / R
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in F: var Float
<    in n: var integer
<    out R: var Float
<    R := F
< ...
< **** OG:returnDecl: out R: var Float
< **** OG:semCheck:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 143
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: "$"
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: "$^(1/2)"
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 143
<    %unit "$", "$^(1/2)"
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 144
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: "$"
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: "$^(1/3)"
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 144
<    %unit "$", "$^(1/3)"
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 141
<    in V: var float
<    out R: var float
< **   encOG: 
< %basic 141
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: 
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< 
< **** Invocation:semCheck: 141
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< 
< **** OG:semCheck:float
< **   encOG: 
< %basic 141
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %basic 141
<    in V: var float
<    out R: var float
< **** Invocation:semCheck: float
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 141
<    in V: var float
<    out R: var float
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 141
<    in V: var float
<    out R: var float
< **** OG:returnDecl: out R: var float
< **** OG:semCheck:
< %basic 142
<    in X: var Float
<    out V: var integer
< **   encOG: 
< %basic 142
<    in X: var Float
<    out V: var integer
< **** Invocation:semCheck: 
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< 
< **** Invocation:semCheck: 142
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< 
< **** OG:semCheck:Float
< **   encOG: 
< %basic 142
<    in X: var Float
<    out V: var integer
< **** Invocation:semCheck: Float
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %basic 142
<    in X: var Float
<    out V: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 142
<    in X: var Float
<    out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 142
<    in X: var Float
<    out V: var integer
< **** OG:returnDecl: out V: var integer
< **** OG:semCheck:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OG:semCheck:Float
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: Float
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: float
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:Float
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: Float
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:float
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: float
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: char
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:N
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: N
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "N" rec: "Y"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: Y on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:getVqual:initial:Y
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   OGs:[0:putFloatX]
< **   ATd: Y: var Float
< **** DataItem:getVqual: Y: var Float
< [0:putFloatX]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:putFloatX]
< 
< **** OI:getVqual: Float on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putFloatX]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: Float on: 1 Items 
< **   father: Float
< **   father.f.f.f.f:
< 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** ENC:OI.getVqual:[1:putFloatX]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:Y
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: Y
< **   OI:getQual:savedOI:Y
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: Y
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:V - Y
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: V - Y
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "V" rec: "rest"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "- Y" rec: "V"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 110
<    in V: var float
<    out R: var float
< **   actualArgs: Y
< **   fArgs(in V: var float,)
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 110
<    in V: var float
<    out R: var float
< **   theOI: - Y
< **   fArg: in V: var float
< **   aArg: Y
< **   theOI.f.f:label: ObjectGenerator
< V - Y
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA,nest(float)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 110
<    in V: var float
<    out R: var float
< **   theOI: - Y
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 110
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:BETA,nest(float),nest(-)]
< **   getOGsequenceOfArg:aArgs:Y
< **   fArgs.origin.OG=theFargsOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **   OGS: [0:BETA,nest(float),nest(-)]
< **   theFargOG:
< 
< %basic 110
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(float),nest(-)]
< **** DataItem:getVqual: in V: var float
< [0:BETA,nest(float),nest(-)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:BETA,nest(float),nest(-)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(float),nest(-)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 110
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:BETA,nest(float),nest(-)]
< **   ENC:result:[1:BETA,nest(float)]
< **** ENC:OI.getVqual:[2:BETA,nest(float)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:Y
< **   encOG: V - Y
< **** Invocation:semCheck: Y
< **   encOG:V - Y
< **** OI:semCheck: "Y" rec: "none"
< **   encOG:V - Y
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: rest on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:getVqual:initial:rest
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   OGs:[0:afterDot]
< **   ATd: rest: var float
< **** DataItem:getVqual: rest: var float
< [0:afterDot]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:afterDot]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:afterDot]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** ENC:OI.getVqual:[1:afterDot]
< **   ENC:result:[1:putFloatX]
< **** ENC:OI.getVqual:[2:putFloatX]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:rest
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: rest
< **   OI:getQual:savedOI:rest
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: rest
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< " rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   fArg: last: var integer
< **   aArg: 4
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:4
< **   encOG: 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **** Invocation:semCheck: 4
< **   encOG:
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   fArg: repeat:< object
< **   aArg: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   encOG: 
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(4):repeat
<    rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< ...
< 
< **** OG:semCheck:rest * 10.0
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** Invocation:semCheck: rest * 10.0
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OI:semCheck: "rest" rec: "rest"
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OI:semCheck: "* 10.0" rec: "rest"
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: 10.0
< **   fArgs(in V: var float,)
< 
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * 10.0
< **   fArg: in V: var float
< **   aArg: 10.0
< **   theOI.f.f:label: ObjectGenerator
< rest * 10.0
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   savedOGS: [0:BETA,nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * 10.0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:BETA,nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:10.0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:BETA,nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:BETA,nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:BETA,nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(float),nest(*)]
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:BETA,nest(float),nest(*)]
< **   ENC:result:[1:BETA,nest(float)]
< **** ENC:OI.getVqual:[2:BETA,nest(float)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:10.0
< **   encOG: rest * 10.0
< **** Invocation:semCheck: 10.0
< **   encOG:rest * 10.0
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: rest on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OI:getVqual:initial:rest
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   OGs:[0:afterDot]
< **   ATd: rest: var float
< **** DataItem:getVqual: rest: var float
< [0:afterDot]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:afterDot]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:afterDot]
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** ENC:OI.getVqual:[1:afterDot]
< **   ENC:result:[1:putFloatX]
< **** ENC:OI.getVqual:[2:putFloatX]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:rest
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: rest
< **   OI:getQual:savedOI:rest
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: rest
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:rest
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** Invocation:semCheck: rest
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OI:semCheck: "rest" rec: "Irest"
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: Irest on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OI:getVqual:initial:Irest
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   OGs:[0:afterDot]
< **   ATd: Irest: var integer
< **** DataItem:getVqual: Irest: var integer
< [0:afterDot]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:afterDot]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:afterDot]
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** ENC:OI.getVqual:[1:afterDot]
< **   ENC:result:[1:putFloatX]
< **** ENC:OI.getVqual:[2:putFloatX]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:Irest
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: Irest
< **   OI:getQual:savedOI:Irest
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: Irest
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if (Irest = 0) :then 
<    lz := lz + 1
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** Invocation:semCheck: if (Irest = 0) :then 
<    lz := lz + 1
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OG:semCheck:(Irest = 0)
< **   encOG: 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** Invocation:semCheck: (Irest = 0)
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** Invocation:semCheck: Irest = 0
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OI:semCheck: "Irest" rec: "none"
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** OI:semCheck: "= 0" rec: "Irest"
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: 0
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 0
< **   fArg: in Veq: var this(Value)
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (Irest = 0)
< **   encOG:
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 0
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:BETA,nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:0
< **   encOG: (Irest = 0)
< **** Invocation:semCheck: 0
< **   encOG:(Irest = 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:lz := lz + 1
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:lz + 1
< **   encOG: lz := lz + 1
< **** Invocation:semCheck: lz + 1
< **   encOG:lz := lz + 1
< **** OI:semCheck: "lz" rec: "lz"
< **   encOG:lz := lz + 1
< **** OI:semCheck: "+ 1" rec: "lz"
< **   encOG:lz := lz + 1
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:lz := lz + 1**   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< lz + 1
< **   encOG:lz := lz + 1
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: lz := lz + 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: lz + 1
< **** Invocation:semCheck: 1
< **   encOG:lz + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: lz on=3 pn=0 isNest=True getRtnQual=False
< **   encOG: lz := lz + 1
< 
< **** OI:getVqual:initial:lz
< **   encOG:lz := lz + 1
< **   OGs:[0:afterDot]
< **   ATd: lz: var integer
< **** DataItem:getVqual: lz: var integer
< [0:afterDot]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:afterDot]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:afterDot]
< **   encOG: lz := lz + 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** ENC:OI.getVqual:[1:afterDot]
< **   ENC:result:[1:putFloatX]
< **** ENC:OI.getVqual:[2:putFloatX]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:lz
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: lz
< **   OI:getQual:savedOI:lz
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: lz
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semcheck:IS not empty:eOG: 
< lz := lz + 1
< **** OG:semcheck:IS not empty:eOG: 
< lz := lz + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< rest := rest * 10.0
<    Irest := rest
<    if (Irest = 0) :then 
<       lz := lz + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:
< for(1):to(lz):repeat
<    put('0')
< 
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: for(1):to(lz):repeat
<    put('0')
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "for(1):to(lz):repeat
<    put('0')
< " rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(lz):repeat
<    put('0')
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(lz):repeat
<    put('0')
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(lz):repeat
<    put('0')
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(lz):repeat
<    put('0')
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(lz):repeat
<    put('0')
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(lz):repeat
<    put('0')
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(lz):repeat
<    put('0')
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(lz):repeat
<    put('0')
< 
< **   fArg: last: var integer
< **   aArg: lz
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(lz):repeat
<    put('0')
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(lz):repeat
<    put('0')
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(lz):repeat
<    put('0')
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:lz
< **   encOG: 
< for(1):to(lz):repeat
<    put('0')
< 
< **** Invocation:semCheck: lz
< **   encOG:
< for(1):to(lz):repeat
<    put('0')
< 
< 
< **** OI:semCheck: "lz" rec: "none"
< **   encOG:
< for(1):to(lz):repeat
<    put('0')
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(lz):repeat
<    put('0')
< 
< **   fArg: repeat:< object
< **   aArg: put('0')
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(lz):repeat
<    put('0')
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(lz):repeat
<    put('0')
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(lz):repeat
<    put('0')
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:put('0')
< **   encOG: 
< for(1):to(lz):repeat
<    put('0')
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(lz):repeat
<    put('0')
< 
< 
< **** OG:semCheck:put('0')
< **   encOG: put('0')
< **** Invocation:semCheck: put('0')
< **   encOG:put('0')
< **** OI:semCheck: "put('0')" rec: "none"
< **   encOG:put('0')
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('0')
< **   fArgs(in ch: val char,)
< 
< **   encOG:put('0')**   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('0')
< **   fArg: in ch: val char
< **   aArg: '0'
< **   theOI.f.f:label: ObjectGenerator
< put('0')
< **   encOG:put('0')
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('0')
< **   theOI.on:4,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(put)]
< **   getOGsequenceOfArg:aArgs:put('0')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:BETA,nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:BETA,nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(put)]
< **   encOG: put('0')
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:BETA,nest(put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'0'
< **   encOG: put('0')
< **** Invocation:semCheck: '0'
< **   encOG:put('0')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< put('0')
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:integer
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:LIB.StringLib.I2s(Irest)
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: LIB.StringLib.I2s(Irest)
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "LIB" rec: "S"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "StringLib" rec: "LIB"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "I2s(Irest)" rec: "StringLib"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< I2S: 
<    %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
< ...
< **   actualArgs: I2s(Irest)
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   argAtInx: 1 in:PTN:
< I2S: 
<    %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
< ...
< **   theOI: I2s(Irest)
< **   fArg: in V: var integer
< **   aArg: Irest
< **   theOI.f.f:label: ObjectGenerator
< LIB.StringLib.I2s(Irest)
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib)]
< **** PTN:getOGsequenceOfArg: 
< I2S: 
<    %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
< ...
< **   theOI: I2s(Irest)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %id "I2s"
< %OSDvisibility disguised
< %globals
< in V: var integer
< out Si2s: var String
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< **   OGS.DOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   After:[0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< **   getOGsequenceOfArg:aArgs:I2s(Irest)
< **   fArgs.origin.OG=theFargsOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< **   theFargOG:
< 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< **** DataItem:getVqual: in V: var integer
< [0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< **** ENC:OI.viaInclude:[0:BETAworld,nest(LIB),nest(StringLib),nest(I2S)]
< **   ENC:result:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** viaInclude:GOT:
< [0:BETAworld,nest(LIB),nest(StringLib),nest(afterDot)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib),nest(afterDot)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(afterDot)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(afterDot)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(afterDot)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(afterDot)]
< **** OG:semCheck:Irest
< **   encOG: LIB.StringLib.I2s(Irest)
< **** Invocation:semCheck: Irest
< **   encOG:LIB.StringLib.I2s(Irest)
< **** OI:semCheck: "Irest" rec: "none"
< **   encOG:LIB.StringLib.I2s(Irest)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:returnDecl: out Si2s: var String
< 
< **** OI:getVqual: S on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:getVqual:initial:S
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   OGs:[0:afterDot]
< **   ATd: S: var LIB.StringLib.String
< **** DataItem:getVqual: S: var LIB.StringLib.String
< [0:afterDot]
< **** ObjectGenerator:getVqual: LIB.StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:LIB.StringLib.String
< **   OGs: [0:afterDot]
< 
< **** OI:getVqual: LIB on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:afterDot]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: LIB on: 3 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** ENC:OI.getVqual:[1:afterDot]
< **   ENC:result:[1:putFloatX]
< **** ENC:OI.getVqual:[2:putFloatX]
< **   ENC:result:[2:BETA]
< **** ENC:OI.getVqual:[3:BETA]
< **   ENC:result:[3:BETAworld]
< 
< **** getVqual:B2:
< [0:BETAworld]
< ---
< 
< --LIB
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:BETAworld]
< **** savedOGS:save:False[0:BETAworld]
< **   OI: LIB
< **   OI:getQual:savedOI:LIB
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld]
< **   OGS:[0:BETAworld]
< **** OI:getVqual:end: LIB
< **   qual: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld]
< 
< **** OI:getVqual: StringLib on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld]
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld]
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** getVqual:added:isNest:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:BETAworld,nest(LIB)]
< **** koks: StringLib on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB)]
< ---
< 
< --StringLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:BETAworld,nest(LIB)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB)]
< **   OGS:[0:BETAworld,nest(LIB)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld,nest(LIB)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:BETAworld,nest(LIB),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:BETAworld,nest(LIB),nest(StringLib)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< 
< **** getVqual:initial:afterATd:S
< **   OGSx:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** savedOGS:save:was:[0:BETAworld,nest(LIB),nest(StringLib)]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib)]
< **   OGS: none
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** OG:semCheck:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **   encOG: 
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< 
< **** OG:semCheck:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   encOG: 
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **** Invocation:semCheck: for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **   encOG:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< 
< **** OI:semCheck: "for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< " rec: "none"
< **   encOG:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   encOG:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   fArg: last: var integer
< **   aArg: S.length
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   encOG:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:S.length
< **   encOG: 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **** Invocation:semCheck: S.length
< **   encOG:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< 
< **** OI:semCheck: "S" rec: "none"
< **   encOG:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< 
< **** OI:semCheck: "length" rec: "S"
< **   encOG:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   fArg: repeat:< object
< **   aArg: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   encOG:
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   encOG: 
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(S.length):repeat
<    ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< ...
< 
< **** OG:semCheck:S.get[(S.length - inx + 1)]
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** Invocation:semCheck: S.get[(S.length - inx + 1)]
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** OI:semCheck: "S" rec: "ch"
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** OI:semCheck: "get[(S.length - inx + 1)]" rec: "S"
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[(S.length - inx + 1)]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[(S.length - inx + 1)]
< **   fArg: inx: var integer
< **   aArg: (S.length - inx + 1)
< **   theOI.f.f:label: ObjectGenerator
< S.get[(S.length - inx + 1)]
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[(S.length - inx + 1)]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   getOGsequenceOfArg:aArgs:get[(S.length - inx + 1)]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   ENC:result:[0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **** viaInclude:GOT:
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(repeat$0)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(repeat$0)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(repeat$0)]
< **** OG:semCheck:(S.length - inx + 1)
< **   encOG: S.get[(S.length - inx + 1)]
< **** Invocation:semCheck: (S.length - inx + 1)
< **   encOG:S.get[(S.length - inx + 1)]
< **** Invocation:semCheck: S.length - inx + 1
< **   encOG:S.get[(S.length - inx + 1)]
< **** OI:semCheck: "S" rec: "none"
< **   encOG:S.get[(S.length - inx + 1)]
< **** OI:semCheck: "length" rec: "S"
< **   encOG:S.get[(S.length - inx + 1)]
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:S.get[(S.length - inx + 1)]**** OI:semCheck: "- inx + 1" rec: "length"
< **   encOG:S.get[(S.length - inx + 1)]
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: inx + 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:S.get[(S.length - inx + 1)]**   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx + 1
< **   fArg: in V: var integer
< **   aArg: inx + 1
< **   theOI.f.f:label: BracketedExp
< (S.length - inx + 1)
< **   encOG:S.get[(S.length - inx + 1)]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   getOGsequenceOfArg:aArgs:inx + 1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   encOG: S.get[(S.length - inx + 1)]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   ENC:result:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** ENC:OI.getVqual:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   ENC:result:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** OG:semCheck:inx + 1
< **   encOG: (S.length - inx + 1)
< **** Invocation:semCheck: inx + 1
< **   encOG:(S.length - inx + 1)
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:(S.length - inx + 1)
< **** OI:semCheck: "+ 1" rec: "inx"
< **   encOG:(S.length - inx + 1)
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:(S.length - inx + 1)**   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< inx + 1
< **   encOG:(S.length - inx + 1)
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: (S.length - inx + 1)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: inx + 1
< **** Invocation:semCheck: 1
< **   encOG:inx + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: ch on=3 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** OI:getVqual:initial:ch
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   OGs:[0:afterDot]
< **   ATd: ch: var char
< **** DataItem:getVqual: ch: var char
< [0:afterDot]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:afterDot]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:afterDot]
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** ENC:OI.getVqual:[1:afterDot]
< **   ENC:result:[1:putFloatX]
< **** ENC:OI.getVqual:[2:putFloatX]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:ch
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: ch
< **   OI:getQual:savedOI:ch
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: ch
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:
< if ((ch > '0') || (inx = S.length)) :then 
<    ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** Invocation:semCheck: if ((ch > '0') || (inx = S.length)) :then 
<    ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** OG:semCheck:((ch > '0') || (inx = S.length))
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** Invocation:semCheck: ((ch > '0') || (inx = S.length))
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** Invocation:semCheck: (ch > '0') || (inx = S.length)
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** Invocation:semCheck: ch > '0'
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** OI:semCheck: "> '0'" rec: "ch"
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** Pattern:checkActualArgs:
< >  : 
<    %basic 53
<    in V: var char
<    out B: var boolean
< **   actualArgs: '0'
< **   fArgs(in V: var char,)
< 
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   argAtInx: 1 in:PTN:
< >  : 
<    %basic 53
<    in V: var char
<    out B: var boolean
< **   theOI: > '0'
< **   fArg: in V: var char
< **   aArg: '0'
< **   theOI.f.f:label: BracketedExp
< (ch > '0')
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   savedOGS: [0:BETA,nest(char)]
< **** PTN:getOGsequenceOfArg: 
< >  : 
<    %basic 53
<    in V: var char
<    out B: var boolean
< **   theOI: > '0'
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var char
< **** Items:localSearch: V
< **   in:
< 
< %basic 53
< in V: var char
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(char)]
< **   OGS.DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   After:[0:BETA,nest(char),nest(>)]
< **   getOGsequenceOfArg:aArgs:'0'
< **   fArgs.origin.OG=theFargsOG: 
< %basic 53
<    in V: var char
<    out B: var boolean
< **   OGS: [0:BETA,nest(char),nest(>)]
< **   theFargOG:
< 
< %basic 53
<    in V: var char
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(char),nest(>)]
< **** DataItem:getVqual: in V: var char
< [0:BETA,nest(char),nest(>)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(char),nest(>)]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(char),nest(>)]
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var char
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(char),nest(>)]
< **   ENC:result:[1:BETA,nest(char)]
< **** ENC:OI.getVqual:[2:BETA,nest(char)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'0'
< **   encOG: ((ch > '0') || (inx = S.length))
< **** Invocation:semCheck: '0'
< **   encOG:((ch > '0') || (inx = S.length))
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OI:semCheck: "|| (inx = S.length)" rec: "(ch > '0')"
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< 
< **** Pattern:checkActualArgs:
< ||  : 
<    %basic 63
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: (inx = S.length)
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   argAtInx: 1 in:PTN:
< ||  : 
<    %basic 63
<    in B: var boolean
<    out R: var boolean
< **   theOI: || (inx = S.length)
< **   fArg: in B: var boolean
< **   aArg: (inx = S.length)
< **   theOI.f.f:label: BracketedExp
< ((ch > '0') || (inx = S.length))
< **   encOG:
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **   savedOGS: [0:Boolean]
< **** PTN:getOGsequenceOfArg: 
< ||  : 
<    %basic 63
<    in B: var boolean
<    out R: var boolean
< **   theOI: || (inx = S.length)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 63
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Boolean]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Boolean,nest(||)]
< **   getOGsequenceOfArg:aArgs:(inx = S.length)
< **   fArgs.origin.OG=theFargsOG: 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Boolean,nest(||)]
< **   theFargOG:
< 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Boolean,nest(||)]
< **** DataItem:getVqual: in B: var boolean
< [0:Boolean,nest(||)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Boolean,nest(||)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Boolean,nest(||)]
< **   encOG: 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 63
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Boolean,nest(||)]
< **   ENC:result:[1:Boolean]
< **** ENC:OI.getVqual:[2:Boolean]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:(inx = S.length)
< **   encOG: ((ch > '0') || (inx = S.length))
< **** Invocation:semCheck: (inx = S.length)
< **   encOG:((ch > '0') || (inx = S.length))
< **** Invocation:semCheck: inx = S.length
< **   encOG:((ch > '0') || (inx = S.length))
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:((ch > '0') || (inx = S.length))
< **** OI:semCheck: "= S.length" rec: "inx"
< **   encOG:((ch > '0') || (inx = S.length))
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: S.length
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:((ch > '0') || (inx = S.length))**   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = S.length
< **   fArg: in Veq: var this(Value)
< **   aArg: S.length
< **   theOI.f.f:label: BracketedExp
< (inx = S.length)
< **   encOG:((ch > '0') || (inx = S.length))
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = S.length
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:BETA,nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:S.length
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:BETA,nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:BETA,nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:BETA,nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:S.length
< **   encOG: (inx = S.length)
< **** Invocation:semCheck: S.length
< **   encOG:(inx = S.length)
< **** OI:semCheck: "S" rec: "none"
< **   encOG:(inx = S.length)
< **** OI:semCheck: "length" rec: "S"
< **   encOG:(inx = S.length)
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:(inx = S.length)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< **** OG:semCheck:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:S.length - inx + 1
< **   encOG: 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** Invocation:semCheck: S.length - inx + 1
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< 
< **** OI:semCheck: "S" rec: "ix"
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< 
< **** OI:semCheck: "length" rec: "S"
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** OI:semCheck: "- inx + 1" rec: "length"
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: inx + 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx + 1
< **   fArg: in V: var integer
< **   aArg: inx + 1
< **   theOI.f.f:label: ObjectGenerator
< S.length - inx + 1
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   getOGsequenceOfArg:aArgs:inx + 1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   encOG: 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer),nest(-)]
< **   ENC:result:[1:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **** ENC:OI.getVqual:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String),nest(integer)]
< **   ENC:result:[2:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(String)]
< **** OG:semCheck:inx + 1
< **   encOG: S.length - inx + 1
< **** Invocation:semCheck: inx + 1
< **   encOG:S.length - inx + 1
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:S.length - inx + 1
< **** OI:semCheck: "+ 1" rec: "inx"
< **   encOG:S.length - inx + 1
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:S.length - inx + 1**   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< inx + 1
< **   encOG:S.length - inx + 1
< **   savedOGS: [0:BETA,nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA,nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BETA,nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:BETA,nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: S.length - inx + 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: inx + 1
< **** Invocation:semCheck: 1
< **   encOG:inx + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: ix on=4 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< 
< **** OI:getVqual:initial:ix
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **   OGs:[0:afterDot]
< **   ATd: ix: var integer
< **** DataItem:getVqual: ix: var integer
< [0:afterDot]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:afterDot]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:afterDot]
< **   encOG: 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** ENC:OI.getVqual:[1:afterDot]
< **   ENC:result:[1:putFloatX]
< **** ENC:OI.getVqual:[2:putFloatX]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:ix
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: ix
< **   OI:getQual:savedOI:ix
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: ix
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:leave(elimTrailingBlanks)
< **   encOG: 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** Invocation:semCheck: leave(elimTrailingBlanks)
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< 
< **** OI:semCheck: "leave(elimTrailingBlanks)" rec: "none"
< **   encOG:
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** OG:semcheck:IS not empty:eOG: 
< 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** OG:semcheck:IS not empty:eOG: 
< 
< ix := S.length - inx + 1
<    leave(elimTrailingBlanks)
< **** OG:semcheck:IS not empty:eOG: 
< 
< ch := S.get[(S.length - inx + 1)]
<    if ((ch > '0') || (inx = S.length)) :then 
<       ix := S.length - inx + 1
<       leave(elimTrailingBlanks)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **** OG:semCheck:elimTrailingBlanks
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: elimTrailingBlanks
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "elimTrailingBlanks" rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< elimTrailingBlanks: 
<    for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< for(1):to(S.length):repeat
<       ch := S.get[(S.length - inx + 1)]
<       if ((ch > '0') || (inx = S.length)) :then 
<          ix := S.length - inx + 1
<          leave(elimTrailingBlanks)
< ...
< **** OG:semCheck:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** Invocation:semCheck: for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** OI:semCheck: "for(1):to(ix):repeat
<    put(S.get[inx])
< " rec: "none"
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   fArg: last: var integer
< **   aArg: ix
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:BETA,nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(for:to:repeat)]
< **   encOG: 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:BETA,nest(for:to:repeat)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:ix
< **   encOG: 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **** Invocation:semCheck: ix
< **   encOG:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< 
< **** OI:semCheck: "ix" rec: "none"
< **   encOG:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   fArg: repeat:< object
< **   aArg: put(S.get[inx])
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   encOG:
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:BETA,nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:BETA,nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:BETA,nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:put(S.get[inx])
< **   encOG: 
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(ix):repeat
<    put(S.get[inx])
< 
< 
< **** OG:semCheck:put(S.get[inx])
< **   encOG: put(S.get[inx])
< **** Invocation:semCheck: put(S.get[inx])
< **   encOG:put(S.get[inx])
< **** OI:semCheck: "put(S.get[inx])" rec: "none"
< **   encOG:put(S.get[inx])
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(S.get[inx])
< **   fArgs(in ch: val char,)
< 
< **   encOG:put(S.get[inx])**   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(S.get[inx])
< **   fArg: in ch: val char
< **   aArg: S.get[inx]
< **   theOI.f.f:label: ObjectGenerator
< put(S.get[inx])
< **   encOG:put(S.get[inx])
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(S.get[inx])
< **   theOI.on:4,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(put)]
< **   getOGsequenceOfArg:aArgs:put(S.get[inx])
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:BETA,nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:BETA,nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(put)]
< **   encOG: put(S.get[inx])
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:BETA,nest(put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:S.get[inx]
< **   encOG: put(S.get[inx])
< **** Invocation:semCheck: S.get[inx]
< **   encOG:put(S.get[inx])
< **** OI:semCheck: "S" rec: "none"
< **   encOG:put(S.get[inx])
< **** OI:semCheck: "get[inx]" rec: "S"
< **   encOG:put(S.get[inx])
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:put(S.get[inx])**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< S.get[inx]
< **   encOG:put(S.get[inx])
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   encOG: put(S.get[inx])
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: put(S.get[inx])
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: put(S.get[inx])
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(get)]
< **   ENC:result:[0:BETAworld,nest(LIB),nest(StringLib),nest(String)]
< **** viaInclude:GOT:
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(put)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(put)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(put)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(put)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(put)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib),nest(String),nest(put)]
< **** OG:semCheck:inx
< **   encOG: S.get[inx]
< **** Invocation:semCheck: inx
< **   encOG:S.get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:S.get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< put(S.get[inx])
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semCheck:V
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: V
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "V" rec: "N"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: N on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:getVqual:initial:N
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **   OGs:[0:putFloatX]
< **   ATd: N: var integer
< **** DataItem:getVqual: N: var integer
< [0:putFloatX]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putFloatX]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putFloatX]
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** ENC:OI.getVqual:[1:putFloatX]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:initial:afterATd:N
< **   OGSx:[0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: N
< **   OI:getQual:savedOI:N
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS: none
< **** OI:getVqual:end: N
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:putint(N)
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: putint(N)
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "putint(N)" rec: "none"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** Pattern:checkActualArgs:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   actualArgs: putint(N)
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **   argAtInx: 1 in:PTN:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(N)
< **   fArg: in V: var integer
< **   aArg: N
< **   theOI.f.f:label: ObjectGenerator
< putint(N)
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(N)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %globals
< in V: var integer
< D: obj Indexed(20,#integer)
< L: var integer
< isNeg: var Boolean
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(putint)]
< **   getOGsequenceOfArg:aArgs:putint(N)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   OGS: [0:BETA,nest(putint)]
< **   theFargOG:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(putint)]
< **** DataItem:getVqual: in V: var integer
< [0:BETA,nest(putint)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(putint)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(putint)]
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:BETA,nest(putint)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:N
< **   encOG: putint(N)
< **** Invocation:semCheck: N
< **   encOG:putint(N)
< **** OI:semCheck: "N" rec: "none"
< **   encOG:putint(N)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semCheck:put('.')
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: put('.')
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "put('.')" rec: "none"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('.')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('.')
< **   fArg: in ch: val char
< **   aArg: '.'
< **   theOI.f.f:label: ObjectGenerator
< put('.')
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **   savedOGS: [0:BETA]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('.')
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BETA]
< **   OGS.DOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **   After:[0:BETA,nest(put)]
< **   getOGsequenceOfArg:aArgs:put('.')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:BETA,nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BETA,nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:BETA,nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:BETA,nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(put)]
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:BETA,nest(put)]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:'.'
< **   encOG: put('.')
< **** Invocation:semCheck: '.'
< **   encOG:put('.')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:afterDot
< **   encOG: 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** Invocation:semCheck: afterDot
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** OI:semCheck: "afterDot" rec: "none"
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< 
< **** Pattern:checkActualArgs:
< afterDot: 
<    lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< lz: var integer
<    rest: var float
<    Irest: var integer
<    ch: var char
<    Y := N
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in V: var Float
<    N: var integer
<    X: var float
<    Y: var Float
< ...
< **** OG:semCheck:
< put:< 
<       ...
<    puttext(T: var LIB.StringLib.String):< 
<       inner(puttext)
<    putint(V: var Integer):< 
< ...
< **   encOG: 
< put:< 
<       ...
<    puttext(T: var LIB.StringLib.String):< 
<       inner(puttext)
<    putint(V: var Integer):< 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< put:< 
<       ...
<    puttext(T: var LIB.StringLib.String):< 
<       inner(puttext)
<    putint(V: var Integer):< 
< ...
< 
< **** OG:semCheck:...
< **   encOG: ...
< **** Invocation:semCheck: 
< **   encOG:...
< **** OG:semcheck:IS not empty:eOG: 
< ...
< **** Invocation:semCheck: "("
< **   encOG:inner(puttext)
< **** Invocation:semCheck: ")"
< **   encOG:inner(puttext)
< **** OG:semCheck:inner(puttext)
< **   encOG: inner(puttext)
< **** Invocation:semCheck: 
< **   encOG:inner(puttext)
< **** OG:semCheck:inner(puttext)
< **   encOG: inner(puttext)
< **** Invocation:semCheck: inner(puttext)
< **   encOG:inner(puttext)
< **** OI:semCheck: "inner(puttext)" rec: "none"
< **   encOG:inner(puttext)
< **** OG:semcheck:IS not empty:eOG: 
< inner(puttext)
< **** OG:semcheck:IS not empty:eOG: 
< inner(puttext)
< **** Invocation:semCheck: "("
< **   encOG:inner(putint)
< **** OG:semCheck:Integer
< **   encOG: inner(putint)
< **** Invocation:semCheck: Integer
< **   encOG:inner(putint)
< **** OI:semCheck: "Integer" rec: "none"
< **   encOG:inner(putint)
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:inner(putint)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: ")"
< **   encOG:inner(putint)
< **** OG:semCheck:inner(putint)
< **   encOG: inner(putint)
< **** Invocation:semCheck: 
< **   encOG:inner(putint)
< **** OG:semCheck:inner(putint)
< **   encOG: inner(putint)
< **** Invocation:semCheck: inner(putint)
< **   encOG:inner(putint)
< **** OI:semCheck: "inner(putint)" rec: "none"
< **   encOG:inner(putint)
< **** OG:semcheck:IS not empty:eOG: 
< inner(putint)
< **** OG:semcheck:IS not empty:eOG: 
< inner(putint)
< **** OG:semcheck:IS not empty:eOG: 
< 
< put:< 
<       ...
<    puttext(T: var LIB.StringLib.String):< 
<       inner(puttext)
<    putint(V: var Integer):< 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< **** OG:semCheck:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **   encOG: 
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< 
< **** Invocation:semCheck: BETA
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "BETA" rec: "%module"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** Invocation:semCheck: BETA
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "BETA" rec: "%Include"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** Invocation:semCheck: LIB.StringLib
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** OI:semCheck: "LIB" rec: "%module"
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** OI:semCheck: "StringLib" rec: "LIB"
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** OG:semCheck:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **   encOG: 
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **** Invocation:semCheck: 
< **   encOG:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:M := 0
< **   encOG: M := 0
< **** Invocation:semCheck: 
< **   encOG:M := 0
< **** OG:semCheck:0
< **   encOG: M := 0
< **** Invocation:semCheck: 0
< **   encOG:M := 0
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: M on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: M := 0
< 
< **** OI:getVqual:initial:M
< **   encOG:M := 0
< **   OGs:[0:Lock]
< **   ATd: M: var integer
< **** DataItem:getVqual: M: var integer
< [0:Lock]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Lock]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Lock]
< **   encOG: M := 0
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: integer
< **   encOG: M := 0
< **   OGS:[0:Lock]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: M := 0
< **   OGS:[0:Lock]
< **** ENC:OI.viaInclude:[0:Lock]
< **   ENC:result:[0:BasicIO]
< **** viaInclude:GOT:
< [0:BasicIO,nest(init)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BasicIO,nest(init)]
< **** savedOGS:save:False[0:BasicIO,nest(init)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BasicIO,nest(init)]
< **   OGS:[0:BasicIO,nest(init)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BasicIO,nest(init)]
< 
< **** getVqual:initial:afterATd:M
< **   OGSx:[0:BasicIO,nest(init)]
< **** savedOGS:save:was:[0:BasicIO,nest(init)]
< **   OI: M
< **   OI:getQual:savedOI:M
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BasicIO,nest(init)]
< **   OGS: none
< **** OI:getVqual:end: M
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BasicIO,nest(init)]
< **** OG:semcheck:IS not empty:eOG: 
< M := 0
< **** OG:semCheck:
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **   encOG: 
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   encOG: 
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< 
< **** OG:semCheck:disable
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** Invocation:semCheck: disable
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OI:semCheck: "disable" rec: "none"
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** Pattern:checkActualArgs:
< disable: 
<    %basic 11
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 11
< **** OG:semCheck:17
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** Invocation:semCheck: 17
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: res on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OI:getVqual:initial:res
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   OGs:[0:get]
< **   ATd: res: var integer
< **** DataItem:getVqual: res: var integer
< [0:get]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:get]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:get]
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   OGS:[0:get]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   OGS:[0:get]
< **** ENC:OI.viaInclude:[0:get]
< **   ENC:result:[0:Lock]
< **** viaInclude:GOT:
< [0:Lock,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Lock,nest(loop)]
< **** savedOGS:save:False[0:Lock,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Lock,nest(loop)]
< **   OGS:[0:Lock,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Lock,nest(loop)]
< 
< **** getVqual:initial:afterATd:res
< **   OGSx:[0:Lock,nest(loop)]
< **** savedOGS:save:was:[0:Lock,nest(loop)]
< **   OI: res
< **   OI:getQual:savedOI:res
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Lock,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: res
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Lock,nest(loop)]
< **** OG:semCheck:M.cmpAndSwap(1)
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** Invocation:semCheck: M.cmpAndSwap(1)
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OI:semCheck: "M" rec: "res"
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OI:semCheck: "cmpAndSwap(1)" rec: "M"
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** Pattern:checkActualArgs:
< cmpAndSwap: 
<    %basic 14
<    in V: var integer
<    out res: var integer
< **   actualArgs: cmpAndSwap(1)
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   argAtInx: 1 in:PTN:
< cmpAndSwap: 
<    %basic 14
<    in V: var integer
<    out res: var integer
< **   theOI: cmpAndSwap(1)
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< M.cmpAndSwap(1)
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   savedOGS: [0:BasicIO,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< cmpAndSwap: 
<    %basic 14
<    in V: var integer
<    out res: var integer
< **   theOI: cmpAndSwap(1)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 14
< in V: var integer
< out res: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:BasicIO,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:BasicIO,nest(loop),nest(integer),nest(cmpAndSwap)]
< **   getOGsequenceOfArg:aArgs:cmpAndSwap(1)
< **   fArgs.origin.OG=theFargsOG: 
< %basic 14
<    in V: var integer
<    out res: var integer
< **   OGS: [0:BasicIO,nest(loop),nest(integer),nest(cmpAndSwap)]
< **   theFargOG:
< 
< %basic 14
<    in V: var integer
<    out res: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:BasicIO,nest(loop),nest(integer),nest(cmpAndSwap)]
< **** DataItem:getVqual: in V: var integer
< [0:BasicIO,nest(loop),nest(integer),nest(cmpAndSwap)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BasicIO,nest(loop),nest(integer),nest(cmpAndSwap)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BasicIO,nest(loop),nest(integer),nest(cmpAndSwap)]
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 14
<    in V: var integer
<    out res: var integer
< **** ENC:OI.getVqual:[1:BasicIO,nest(loop),nest(integer),nest(cmpAndSwap)]
< **   ENC:result:[1:BasicIO,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:BasicIO,nest(loop),nest(integer)]
< **   ENC:result:[2:BasicIO,nest(loop)]
< 
< **** getVqual:B2:
< [0:BasicIO,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BasicIO,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BasicIO,nest(loop)]
< **** savedOGS:save:False[0:BasicIO,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BasicIO,nest(loop)]
< **   OGS:[0:BasicIO,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BasicIO,nest(loop)]
< **** OG:semCheck:1
< **   encOG: M.cmpAndSwap(1)
< **** Invocation:semCheck: 1
< **   encOG:M.cmpAndSwap(1)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out res: var integer
< 
< **** OI:getVqual: res on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OI:getVqual:initial:res
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   OGs:[0:get]
< **   ATd: res: var integer
< **** DataItem:getVqual: res: var integer
< [0:get]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:get]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:get]
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   OGS:[0:get]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   OGS:[0:get]
< **** ENC:OI.viaInclude:[0:get]
< **   ENC:result:[0:Lock]
< **** viaInclude:GOT:
< [0:Lock,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Lock,nest(loop)]
< **** savedOGS:save:False[0:Lock,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Lock,nest(loop)]
< **   OGS:[0:Lock,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Lock,nest(loop)]
< 
< **** getVqual:initial:afterATd:res
< **   OGSx:[0:Lock,nest(loop)]
< **** savedOGS:save:was:[0:Lock,nest(loop)]
< **   OI: res
< **   OI:getQual:savedOI:res
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Lock,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: res
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Lock,nest(loop)]
< **** OG:semCheck:
< if (res = 1) :then 
<    enable
<    sleep(50)
<    restart(loop)
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** Invocation:semCheck: if (res = 1) :then 
<    enable
<    sleep(50)
<    restart(loop)
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OG:semCheck:(res = 1)
< **   encOG: 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** Invocation:semCheck: (res = 1)
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** Invocation:semCheck: res = 1
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OI:semCheck: "res" rec: "none"
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** OI:semCheck: "= 1" rec: "res"
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: 1
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 1
< **   fArg: in Veq: var this(Value)
< **   aArg: 1
< **   theOI.f.f:label: BracketedExp
< (res = 1)
< **   encOG:
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **   savedOGS: [0:Lock,nest(loop),nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 1
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Lock,nest(loop),nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:Lock,nest(loop),nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:Lock,nest(loop),nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Lock,nest(loop),nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:Lock,nest(loop),nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:Lock,nest(loop),nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:Lock,nest(loop),nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:1
< **   encOG: (res = 1)
< **** Invocation:semCheck: 1
< **   encOG:(res = 1)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< enable
<    sleep(50)
<    restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:enable
< **   encOG: 
< enable
<    sleep(50)
<    restart(loop)
< **** Invocation:semCheck: enable
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< 
< **** OI:semCheck: "enable" rec: "none"
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< 
< **** Pattern:checkActualArgs:
< enable: 
<    %basic 12
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< %basic 12
< **** OG:semCheck:sleep(50)
< **   encOG: 
< enable
<    sleep(50)
<    restart(loop)
< **** Invocation:semCheck: sleep(50)
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< 
< **** OI:semCheck: "sleep(50)" rec: "none"
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< 
< **** Pattern:checkActualArgs:
< sleep: 
<    %basic 15
<    in V: var integer
< **   actualArgs: sleep(50)
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< **   argAtInx: 1 in:PTN:
< sleep: 
<    %basic 15
<    in V: var integer
< **   theOI: sleep(50)
< **   fArg: in V: var integer
< **   aArg: 50
< **   theOI.f.f:label: ObjectGenerator
< sleep(50)
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< **   savedOGS: [0:loop,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< sleep: 
<    %basic 15
<    in V: var integer
< **   theOI: sleep(50)
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 15
< in V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:loop,nest($0)]
< **   OGS.DOG:
< enable
<    sleep(50)
<    restart(loop)
< **   After:[0:loop,nest($0),nest(sleep)]
< **   getOGsequenceOfArg:aArgs:sleep(50)
< **   fArgs.origin.OG=theFargsOG: 
< %basic 15
<    in V: var integer
< **   OGS: [0:loop,nest($0),nest(sleep)]
< **   theFargOG:
< 
< %basic 15
<    in V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:loop,nest($0),nest(sleep)]
< **** DataItem:getVqual: in V: var integer
< [0:loop,nest($0),nest(sleep)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop,nest($0),nest(sleep)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest($0),nest(sleep)]
< **   encOG: 
< enable
<    sleep(50)
<    restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 15
<    in V: var integer
< **** ENC:OI.getVqual:[1:loop,nest($0),nest(sleep)]
< **   ENC:result:[1:loop,nest($0)]
< 
< **** getVqual:B2:
< [0:loop,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest($0)]
< **** savedOGS:save:False[0:loop,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($0)]
< **   OGS:[0:loop,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($0)]
< **** OG:semCheck:50
< **   encOG: sleep(50)
< **** Invocation:semCheck: 50
< **   encOG:sleep(50)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 15
<    in V: var integer
< **** OG:semCheck:restart(loop)
< **   encOG: 
< enable
<    sleep(50)
<    restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< 
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:
< enable
<    sleep(50)
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< enable
<    sleep(50)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< enable
<    sleep(50)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< enable
<    sleep(50)
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< disable
<    res := 17
<    res := M.cmpAndSwap(1)
<    if (res = 1) :then 
<       enable
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **** OG:semCheck:
< M := 0
<    enable
< **   encOG: 
< M := 0
<    enable
< **** Invocation:semCheck: 
< **   encOG:
< M := 0
<    enable
< 
< **** OG:semCheck:0
< **   encOG: 
< M := 0
<    enable
< **** Invocation:semCheck: 0
< **   encOG:
< M := 0
<    enable
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: M on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< M := 0
<    enable
< 
< **** OI:getVqual:initial:M
< **   encOG:
< M := 0
<    enable
< **   OGs:[0:Lock]
< **   ATd: M: var integer
< **** DataItem:getVqual: M: var integer
< [0:Lock]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Lock]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Lock]
< **   encOG: 
< M := 0
<    enable
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< M := 0
<    enable
< **   OGS:[0:Lock]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< M := 0
<    enable
< **   OGS:[0:Lock]
< **** ENC:OI.viaInclude:[0:Lock]
< **   ENC:result:[0:BasicIO]
< **** viaInclude:GOT:
< [0:BasicIO,nest(free)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BasicIO,nest(free)]
< **** savedOGS:save:False[0:BasicIO,nest(free)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BasicIO,nest(free)]
< **   OGS:[0:BasicIO,nest(free)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BasicIO,nest(free)]
< 
< **** getVqual:initial:afterATd:M
< **   OGSx:[0:BasicIO,nest(free)]
< **** savedOGS:save:was:[0:BasicIO,nest(free)]
< **   OI: M
< **   OI:getQual:savedOI:M
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BasicIO,nest(free)]
< **   OGS: none
< **** OI:getVqual:end: M
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BasicIO,nest(free)]
< **** OG:semCheck:enable
< **   encOG: 
< M := 0
<    enable
< **** Invocation:semCheck: enable
< **   encOG:
< M := 0
<    enable
< 
< **** OI:semCheck: "enable" rec: "none"
< **   encOG:
< M := 0
<    enable
< 
< **** Pattern:checkActualArgs:
< enable: 
<    %basic 12
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< M := 0
<    enable
< **** OG:semcheck:IS not empty:eOG: 
< %basic 12
< **** OG:semcheck:IS not empty:eOG: 
< 
< M := 0
<    enable
< **** OG:semcheck:IS not empty:eOG: 
< 
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **** OG:semCheck:
< %Public
<    readLine: 
<       out M: var LIB.StringLib.String
<       inx: var integer
<       msg: obj Indexed(30,integer)
< ...
< **   encOG: 
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** OG:semCheck:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** Invocation:semCheck: 
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Indexed(30,integer)
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** Invocation:semCheck: Indexed(30,integer)
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** OI:semCheck: "Indexed(30,integer)" rec: "none"
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** Pattern:checkActualArgs:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   actualArgs: (30,integer)
< **   fArgs(in range: var Integer,in elm:< Object,)
< 
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **   argAtInx: 1 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(30,integer)
< **   fArg: in range: var Integer
< **   aArg: 30
< **   theOI.f.f:label: ObjectGenerator
< Indexed(30,integer)
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **   savedOGS: [0:keyboard,nest(readLine)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(30,integer)
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in range: var Integer
< **** Items:localSearch: range
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: range
< Try: "range"
< **** Items:localSearch:end: range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:keyboard,nest(readLine)]
< **   OGS.DOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **   After:[0:keyboard,nest(readLine),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(30,integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:keyboard,nest(readLine),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:keyboard,nest(readLine),nest(Indexed)]
< **** DataItem:getVqual: in range: var Integer
< [0:keyboard,nest(readLine),nest(Indexed)]
< **** ObjectGenerator:getVqual: Integer
< **   hasVirtualArgs: False
< **** INV:getVqual:Integer
< **   OGs: [0:keyboard,nest(readLine),nest(Indexed)]
< 
< **** OI:getVqual: Integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:keyboard,nest(readLine),nest(Indexed)]
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** koks: Integer on: 1 Items 
< **   father: Integer
< **   father.f.f.f.f:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** ENC:OI.getVqual:[1:keyboard,nest(readLine),nest(Indexed)]
< **   ENC:result:[1:keyboard,nest(readLine)]
< 
< **** getVqual:B2:
< [0:keyboard,nest(readLine)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:keyboard,nest(readLine)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:keyboard,nest(readLine)]
< **** savedOGS:save:False[0:keyboard,nest(readLine)]
< **   OI: Integer
< **   OI:getQual:savedOI:Integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:keyboard,nest(readLine)]
< **   OGS:[0:keyboard,nest(readLine)]
< **** OI:getVqual:end: Integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:keyboard,nest(readLine)]
< **** OG:semCheck:30
< **   encOG: Indexed(30,integer)
< **** Invocation:semCheck: 30
< **   encOG:Indexed(30,integer)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(30,integer)
< **   fArg: in elm:< Object
< **   aArg: integer
< **   theOI.f.f:label: ObjectGenerator
< Indexed(30,integer)
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **   savedOGS: [0:keyboard,nest(readLine)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(30,integer)
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "range"
< Try: "elm"
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:0
< **   OGS:[0:keyboard,nest(readLine)]
< **   OGS.DOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **   After:[0:keyboard,nest(readLine),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(30,integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:keyboard,nest(readLine),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:keyboard,nest(readLine),nest(Indexed)]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:keyboard,nest(readLine),nest(Indexed)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:keyboard,nest(readLine),nest(Indexed)]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:keyboard,nest(readLine),nest(Indexed)]
< **   checkDOG: Indexed 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< father:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:integer
< **   encOG: Indexed(30,integer)
< **** Invocation:semCheck: integer
< **   encOG:Indexed(30,integer)
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:Indexed(30,integer)
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:Indexed(30,integer)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** Invocation:semCheck: 
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** OG:semCheck:Char
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: Char
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "Char" rec: "none"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:_iGet
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: _iGet
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "_iGet" rec: "ch"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** Pattern:checkActualArgs:
< _iget: 
<    %external 4
<    out ch: var char
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: ch on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:getVqual:initial:ch
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   OGs:[0:read]
< **   ATd: ch: var Char
< **** DataItem:getVqual: ch: var Char
< [0:read]
< **** ObjectGenerator:getVqual: Char
< **   hasVirtualArgs: False
< **** INV:getVqual:Char
< **   OGs: [0:read]
< 
< **** OI:getVqual: Char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:read]
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Char
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   OGS:[0:read]
< ***** viaInclude:notTop: Char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Char
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   OGS:[0:read]
< **** ENC:OI.viaInclude:[0:read]
< **   ENC:result:[0:readLine]
< **** viaInclude:GOT:
< [0:readLine,nest(read)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:readLine,nest(read)]
< **** savedOGS:save:False[0:readLine,nest(read)]
< **   OI: Char
< **   OI:getQual:savedOI:Char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:readLine,nest(read)]
< **   OGS:[0:readLine,nest(read)]
< **** OI:getVqual:end: Char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:readLine,nest(read)]
< 
< **** getVqual:initial:afterATd:ch
< **   OGSx:[0:readLine,nest(read)]
< **** savedOGS:save:was:[0:readLine,nest(read)]
< **   OI: ch
< **   OI:getQual:savedOI:ch
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:readLine,nest(read)]
< **   OGS: none
< **** OI:getVqual:end: ch
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:readLine,nest(read)]
< **** OG:semCheck:put(ch)
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: put(ch)
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "put(ch)" rec: "none"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(ch)
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(ch)
< **   fArg: in ch: val char
< **   aArg: ch
< **   theOI.f.f:label: ObjectGenerator
< put(ch)
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   savedOGS: [0:readLine,nest(read)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(ch)
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:readLine,nest(read)]
< **   OGS.DOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   After:[0:readLine,nest(read),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(ch)
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:readLine,nest(read),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:readLine,nest(read),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:readLine,nest(read),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:readLine,nest(read),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:readLine,nest(read),nest(put)]
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:readLine,nest(read),nest(put)]
< **   ENC:result:[1:readLine,nest(read)]
< 
< **** getVqual:B2:
< [0:readLine,nest(read)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:readLine,nest(read)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:readLine,nest(read)]
< **** savedOGS:save:False[0:readLine,nest(read)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:readLine,nest(read)]
< **   OGS:[0:readLine,nest(read)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:readLine,nest(read)]
< **** OG:semCheck:ch
< **   encOG: put(ch)
< **** Invocation:semCheck: ch
< **   encOG:put(ch)
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:
< if (ch = 13) :then  -- ch = ascii.newline fails!?
<    leave(read)
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: if (ch = 13) :then  -- ch = ascii.newline fails!?
<    leave(read)
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OG:semCheck:(ch = 13)
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: (ch = 13)
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** Invocation:semCheck: ch = 13
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "= 13" rec: "ch"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: 13
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 13
< **   fArg: in Veq: var this(Value)
< **   aArg: 13
< **   theOI.f.f:label: BracketedExp
< (ch = 13)
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   savedOGS: [0:readLine,nest(read),nest(char),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 13
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:readLine,nest(read),nest(char),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:readLine,nest(read),nest(char),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:13
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:readLine,nest(read),nest(char),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:readLine,nest(read),nest(char),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:readLine,nest(read),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:readLine,nest(read),nest(char),Value&,nest(=)]
< **** getOGstart: 
< [0:readLine,nest(read),nest(char),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:13
< **   encOG: (ch = 13)
< **** Invocation:semCheck: 13
< **   encOG:(ch = 13)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< -- ch = ascii.newline fails!?
<    leave(read)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: -- ch = ascii.newline fails!?
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:leave(read)
< **   encOG: 
< -- ch = ascii.newline fails!?
<    leave(read)
< **** Invocation:semCheck: leave(read)
< **   encOG:
< -- ch = ascii.newline fails!?
<    leave(read)
< 
< **** OI:semCheck: "leave(read)" rec: "none"
< **   encOG:
< -- ch = ascii.newline fails!?
<    leave(read)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- ch = ascii.newline fails!?
<    leave(read)
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- ch = ascii.newline fails!?
<    leave(read)
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- ch = ascii.newline fails!?
<    leave(read)
< **** OG:semCheck:inx + 1
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: inx + 1
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "inx" rec: "inx"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "+ 1" rec: "inx"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< inx + 1
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   savedOGS: [0:keyboard,nest(read),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:keyboard,nest(read),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:keyboard,nest(read),nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:keyboard,nest(read),nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:keyboard,nest(read),nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:keyboard,nest(read),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:keyboard,nest(read),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:keyboard,nest(read),nest(integer),nest(+)]
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:keyboard,nest(read),nest(integer),nest(+)]
< **   ENC:result:[1:keyboard,nest(read),nest(integer)]
< **** ENC:OI.getVqual:[2:keyboard,nest(read),nest(integer)]
< **   ENC:result:[2:keyboard,nest(read)]
< 
< **** getVqual:B2:
< [0:keyboard,nest(read)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:keyboard,nest(read)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:keyboard,nest(read)]
< **** savedOGS:save:False[0:keyboard,nest(read)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:keyboard,nest(read)]
< **   OGS:[0:keyboard,nest(read)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:keyboard,nest(read)]
< **** OG:semCheck:1
< **   encOG: inx + 1
< **** Invocation:semCheck: 1
< **   encOG:inx + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:getVqual:initial:inx
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   OGs:[0:readLine]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:readLine]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:readLine]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:readLine]
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   OGS:[0:readLine]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   OGS:[0:readLine]
< **** ENC:OI.viaInclude:[0:readLine]
< **   ENC:result:[0:keyboard]
< **** viaInclude:GOT:
< [0:keyboard,nest(read)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:keyboard,nest(read)]
< **** savedOGS:save:False[0:keyboard,nest(read)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:keyboard,nest(read)]
< **   OGS:[0:keyboard,nest(read)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:keyboard,nest(read)]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:keyboard,nest(read)]
< **** savedOGS:save:was:[0:keyboard,nest(read)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:keyboard,nest(read)]
< **   OGS: none
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:keyboard,nest(read)]
< **** OG:semCheck:msg.put(ch):at[inx]
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: msg.put(ch):at[inx]
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "msg" rec: "none"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "put(ch):at[inx]" rec: "msg"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put(ch):at[inx]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[inx]
< **   fArg: V: var integer
< **   aArg: ch
< **   theOI.f.f:label: ObjectGenerator
< msg.put(ch):at[inx]
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   savedOGS: [0:keyboard,nest(read),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:keyboard,nest(read),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(ch):at[inx]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:keyboard,nest(read),nest(Indexed)]
< **** ENC:OI.getVqual:[2:keyboard,nest(read),nest(Indexed)]
< **   ENC:result:[2:keyboard,nest(read)]
< 
< **** getVqual:B2:
< [0:keyboard,nest(read)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:keyboard,nest(read)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:keyboard,nest(read)]
< **** savedOGS:save:False[0:keyboard,nest(read)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:keyboard,nest(read)]
< **   OGS:[0:keyboard,nest(read)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:keyboard,nest(read)]
< **** OG:semCheck:ch
< **   encOG: msg.put(ch):at[inx]
< **** Invocation:semCheck: ch
< **   encOG:msg.put(ch):at[inx]
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:msg.put(ch):at[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< msg.put(ch):at[inx]
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **   savedOGS: [0:keyboard,nest(read),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:keyboard,nest(read),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(ch):at[inx]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:keyboard,nest(read),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:keyboard,nest(read),nest(Indexed)]
< **** ENC:OI.getVqual:[2:keyboard,nest(read),nest(Indexed)]
< **   ENC:result:[2:keyboard,nest(read)]
< 
< **** getVqual:B2:
< [0:keyboard,nest(read)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:keyboard,nest(read)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:keyboard,nest(read)]
< **** savedOGS:save:False[0:keyboard,nest(read)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:keyboard,nest(read)]
< **   OGS:[0:keyboard,nest(read)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:keyboard,nest(read)]
< **** OG:semCheck:inx
< **   encOG: msg.put(ch):at[inx]
< **** Invocation:semCheck: inx
< **   encOG:msg.put(ch):at[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:msg.put(ch):at[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semCheck:restart(read)
< **   encOG: 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** Invocation:semCheck: restart(read)
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OI:semCheck: "restart(read)" rec: "none"
< **   encOG:
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< ch: var Char
<    ch := _iGet
<    put(ch)
<    if (ch = 13) :then  -- ch = ascii.newline fails!?
<       leave(read)
< ...
< **** OG:semCheck:msg.asString
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** Invocation:semCheck: msg.asString
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** OI:semCheck: "msg" rec: "M"
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** OI:semCheck: "asString" rec: "msg"
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** Pattern:checkActualArgs:
< asString: 
<    %basic 118
<    out S: var LIB.StringLib.String
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:returnDecl: out S: var LIB.StringLib.String
< 
< **** OI:getVqual: M on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** OI:getVqual:initial:M
< **   encOG:
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **   OGs:[0:readLine]
< **   ATd: out M: var LIB.StringLib.String
< **** DataItem:getVqual: out M: var LIB.StringLib.String
< [0:readLine]
< **** ObjectGenerator:getVqual: LIB.StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:LIB.StringLib.String
< **   OGs: [0:readLine]
< 
< **** OI:getVqual: LIB on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:readLine]
< **   encOG: 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** koks: LIB on: 4 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** ENC:OI.getVqual:[1:readLine]
< **   ENC:result:[1:keyboard]
< **** ENC:OI.getVqual:[2:keyboard]
< **   ENC:result:[2:BasicIO]
< **** ENC:OI.getVqual:[3:BasicIO]
< **   ENC:result:[3:LIB]
< **** ENC:OI.getVqual:[4:LIB]
< **   ENC:result:[4:BETAworld]
< 
< **** getVqual:B2:
< [0:BETAworld]
< ---
< 
< --LIB
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:BETAworld]
< **** savedOGS:save:False[0:BETAworld]
< **   OI: LIB
< **   OI:getQual:savedOI:LIB
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld]
< **   OGS:[0:BETAworld]
< **** OI:getVqual:end: LIB
< **   qual: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld]
< 
< **** OI:getVqual: StringLib on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld]
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld]
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** getVqual:added:isNest:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:BETAworld,nest(LIB)]
< **** koks: StringLib on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB)]
< ---
< 
< --StringLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:BETAworld,nest(LIB)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB)]
< **   OGS:[0:BETAworld,nest(LIB)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld,nest(LIB)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:BETAworld,nest(LIB),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:BETAworld,nest(LIB),nest(StringLib)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< 
< **** getVqual:initial:afterATd:M
< **   OGSx:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** savedOGS:save:was:[0:BETAworld,nest(LIB),nest(StringLib)]
< **   OI: M
< **   OI:getQual:savedOI:M
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib)]
< **   OGS: none
< **** OI:getVqual:end: M
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< out M: var LIB.StringLib.String
<    inx: var integer
<    msg: obj Indexed(30,integer)
<    read: obj 
<       ch: var Char
< ...
< **** OG:returnDecl: out M: var LIB.StringLib.String
< **** OG:semcheck:IS not empty:eOG: 
< 
< %Public
<    readLine: 
<       out M: var LIB.StringLib.String
<       inx: var integer
<       msg: obj Indexed(30,integer)
< ...
< **** OG:semCheck:
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< **   encOG: 
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** OG:semCheck:Lock
< **   encOG: 
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< **** Invocation:semCheck: Lock
< **   encOG:
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< 
< **** OI:semCheck: "Lock" rec: "none"
< **   encOG:
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< 
< **** Pattern:checkActualArgs:
< Lock: 
<    dummy: var integer
<    %Public
<    M: var integer
<    init: 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< **** OG:semCheck:
< L.get
<    L.init
<    L.free
< **   encOG: 
< L.get
<    L.init
<    L.free
< **** Invocation:semCheck: 
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** OG:semCheck:L.get
< **   encOG: 
< L.get
<    L.init
<    L.free
< **** Invocation:semCheck: L.get
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** OI:semCheck: "get" rec: "L"
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** Pattern:checkActualArgs:
< get: 
<    res: var integer
<    loop: obj 
<       disable
<       res := 17
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< L.get
<    L.init
<    L.free
< **** OG:semcheck:IS not empty:eOG: 
< 
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **** OG:semCheck:L.init
< **   encOG: 
< L.get
<    L.init
<    L.free
< **** Invocation:semCheck: L.init
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** OI:semCheck: "init" rec: "L"
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** Pattern:checkActualArgs:
< init: 
<    M := 0
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< L.get
<    L.init
<    L.free
< **** OG:semcheck:IS not empty:eOG: 
< M := 0
< **** OG:semCheck:L.free
< **   encOG: 
< L.get
<    L.init
<    L.free
< **** Invocation:semCheck: L.free
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** OI:semCheck: "free" rec: "L"
< **   encOG:
< L.get
<    L.init
<    L.free
< 
< **** Pattern:checkActualArgs:
< free: 
<    M := 0
<    enable
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< L.get
<    L.init
<    L.free
< **** OG:semcheck:IS not empty:eOG: 
< 
< M := 0
<    enable
< **** OG:semcheck:IS not empty:eOG: 
< 
< L.get
<    L.init
<    L.free
< **** OG:semCheck:
< L.get
<    inner
<    L.free
< **   encOG: 
< L.get
<    inner
<    L.free
< **** Invocation:semCheck: 
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** OG:semCheck:L.get
< **   encOG: 
< L.get
<    inner
<    L.free
< **** Invocation:semCheck: L.get
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** OI:semCheck: "get" rec: "L"
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** Pattern:checkActualArgs:
< get: 
<    res: var integer
<    loop: obj 
<       disable
<       res := 17
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< L.get
<    inner
<    L.free
< **** OG:semcheck:IS not empty:eOG: 
< 
< res: var integer
<    loop: obj 
<       disable
<       res := 17
<       res := M.cmpAndSwap(1)
< ...
< **** OG:semCheck:inner
< **   encOG: 
< L.get
<    inner
<    L.free
< **** Invocation:semCheck: inner
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** OI:semCheck: "inner" rec: "none"
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< L.get
<    inner
<    L.free
< **** OG:semCheck:L.free
< **   encOG: 
< L.get
<    inner
<    L.free
< **** Invocation:semCheck: L.free
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** OI:semCheck: "free" rec: "L"
< **   encOG:
< L.get
<    inner
<    L.free
< 
< **** Pattern:checkActualArgs:
< free: 
<    M := 0
<    enable
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< L.get
<    inner
<    L.free
< **** OG:semcheck:IS not empty:eOG: 
< 
< M := 0
<    enable
< **** OG:semcheck:IS not empty:eOG: 
< 
< L.get
<    inner
<    L.free
< **** OG:semcheck:IS not empty:eOG: 
< 
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< **** OG:semCheck:
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** Invocation:semCheck: StringLib
< **   encOG:
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< 
< **** OI:semCheck: "StringLib" rec: "%visible"
< **   encOG:
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< 
< **** OG:semCheck:
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   encOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< 
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "elm"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   encOG: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** Invocation:semCheck: 
< **   encOG:
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< 
< **** Invocation:semCheck: skipInternal
< **   encOG:
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< 
< **** OI:semCheck: "skipInternal" rec: "%OSDvisibility"
< **   encOG:
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< 
< **** Pattern:checkActualArgs:
< SkipInternal: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** OG:semCheck:inner(scan)
< **   encOG: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** Invocation:semCheck: inner(scan)
< **   encOG:
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< 
< **** OI:semCheck: "inner(scan)" rec: "none"
< **   encOG:
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** OG:semCheck:
< in e: ref elm
<    inner(insert)
< **   encOG: 
< in e: ref elm
<    inner(insert)
< **** Invocation:semCheck: 
< **   encOG:
< in e: ref elm
<    inner(insert)
< 
< **** OG:semCheck:inner(insert)
< **   encOG: 
< in e: ref elm
<    inner(insert)
< **** Invocation:semCheck: inner(insert)
< **   encOG:
< in e: ref elm
<    inner(insert)
< 
< **** OI:semCheck: "inner(insert)" rec: "none"
< **   encOG:
< in e: ref elm
<    inner(insert)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    inner(insert)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    inner(insert)
< **** OG:semCheck:
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   encOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** Invocation:semCheck: 
< **   encOG:
< in E: ref elm
<    out B: var boolean
<    inner(has)
< 
< **** OG:semCheck:boolean
< **   encOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** Invocation:semCheck: boolean
< **   encOG:
< in E: ref elm
<    out B: var boolean
<    inner(has)
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< in E: ref elm
<    out B: var boolean
<    inner(has)
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:inner(has)
< **   encOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** Invocation:semCheck: inner(has)
< **   encOG:
< in E: ref elm
<    out B: var boolean
<    inner(has)
< 
< **** OI:semCheck: "inner(has)" rec: "none"
< **   encOG:
< in E: ref elm
<    out B: var boolean
<    inner(has)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< in E: ref elm
<    inner(remove)
< **   encOG: 
< in E: ref elm
<    inner(remove)
< **** Invocation:semCheck: 
< **   encOG:
< in E: ref elm
<    inner(remove)
< 
< **** OG:semCheck:inner(remove)
< **   encOG: 
< in E: ref elm
<    inner(remove)
< **** Invocation:semCheck: inner(remove)
< **   encOG:
< in E: ref elm
<    inner(remove)
< 
< **** OI:semCheck: "inner(remove)" rec: "none"
< **   encOG:
< in E: ref elm
<    inner(remove)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in E: ref elm
<    inner(remove)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in E: ref elm
<    inner(remove)
< **** OG:semCheck:inner(Collection)
< **   encOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** Invocation:semCheck: inner(Collection)
< **   encOG:
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< 
< **** OI:semCheck: "inner(Collection)" rec: "none"
< **   encOG:
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** OG:semCheck:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< **   encOG: 
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< 
< **** Invocation:semCheck: SetLib
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< 
< **** OI:semCheck: "SetLib" rec: "%requires"
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< 
< **** Invocation:semCheck: StringLib
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< 
< **** OI:semCheck: "StringLib" rec: "%include"
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< 
< **** OG:semCheck:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   encOG: 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "Domain"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:Object
< **   encOG: Object
< **** Invocation:semCheck: Object
< **   encOG:Object
< **** OI:semCheck: "Object" rec: "Range"
< **   encOG:Object
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< in inx: ref Domain
<    in elm: ref Range
< **   encOG: 
< in inx: ref Domain
<    in elm: ref Range
< **** Invocation:semCheck: 
< **   encOG:
< in inx: ref Domain
<    in elm: ref Range
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in inx: ref Domain
<    in elm: ref Range
< **** OG:semCheck:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OG:semCheck:
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** Invocation:semCheck: if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OG:semCheck:(head == none)
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** Invocation:semCheck: (head == none)
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** Invocation:semCheck: head == none
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OI:semCheck: "head" rec: "none"
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OI:semCheck: "== none" rec: "head"
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: none
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   argAtInx: 1 in:PTN:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == none
< **   fArg: in objx: ref Object
< **   aArg: none
< **   theOI.f.f:label: BracketedExp
< (head == none)
< **   encOG:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   savedOGS: [0:Map,nest(link),Entry,Object]
< **** PTN:getOGsequenceOfArg: 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == none
< **   theOI.on:0,pn:2 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 56
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Map,nest(link),Entry,Object]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:Map,nest(link),Entry,Object,nest(==)]
< **   getOGsequenceOfArg:aArgs:none
< **   fArgs.origin.OG=theFargsOG: 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:Map,nest(link),Entry,Object,nest(==)]
< **   theFargOG:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Map,nest(link),Entry,Object,nest(==)]
< **** DataItem:getVqual: in objx: ref Object
< [0:Map,nest(link),Entry,Object,nest(==)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:Map,nest(link),Entry,Object,nest(==)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry,Object,nest(==)]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry,Object,nest(==)]
< **   ENC:result:[1:Map,nest(link),Entry,Object]
< **** ENC:OI.getVqual:[2:Map,nest(link),Entry,Object]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[4:Map,nest(link)]
< **   ENC:result:[4:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[3:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semCheck:none
< **   encOG: (head == none)
< **** Invocation:semCheck: none
< **   encOG:(head == none)
< **** OI:semCheck: "none" rec: "none"
< **   encOG:(head == none)
< **** Pattern:checkActualArgs:
< none: 
<    %basic 19
<    none_x: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:(head == none)**** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:head := link(S,D,none)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:link(S,D,none)
< **   encOG: head := link(S,D,none)
< **** Invocation:semCheck: link(S,D,none)
< **   encOG:head := link(S,D,none)
< **** OI:semCheck: "link(S,D,none)" rec: "head"
< **   encOG:head := link(S,D,none)
< **** Pattern:checkActualArgs:
< link: Entry
<    in next: ref link
< **   actualArgs: (S,D,none)
< **   fArgs(in inx: ref Domain,in elm: ref Range,in next: ref link,)
< 
< **   encOG:head := link(S,D,none)**   argAtInx: 1 in:PTN:
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,none)
< **   fArg: in inx: ref Domain
< **   aArg: S
< **   theOI.f.f:label: ObjectGenerator
< link(S,D,none)
< **   encOG:head := link(S,D,none)
< **   savedOGS: [0:Map]
< **** PTN:getOGsequenceOfArg: 
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,none)
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in inx: ref Domain
< **** Items:localSearch: inx
< **   in:
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "next"
< **** Signature:localSearch: inx in: link
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Items:localSearch:end: inx
< **** Signature:localSearch:end: inx
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< in inx: ref Domain
< in elm: ref Range
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:1
< **   OGS:[0:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:Map,nest(link)]
< **   getOGsequenceOfArg:aArgs:(S,D,none)
< **   fArgs.origin.OG=theFargsOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGS: [0:Map,nest(link)]
< **   theFargOG:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** PRE: [0:Map,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map,nest(link),Entry]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:Map,nest(link),Entry]
< **** DataItem:getVqual: in inx: ref Domain
< [0:Map,nest(link),Entry]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:Map,nest(link),Entry]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry]
< **   encOG: head := link(S,D,none)
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[2:Map,nest(link)]
< **   ENC:result:[2:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Domain
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:S
< **   encOG: link(S,D,none)
< **** Invocation:semCheck: S
< **   encOG:link(S,D,none)
< **** OI:semCheck: "S" rec: "none"
< **   encOG:link(S,D,none)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   argAtInx: 2 in:PTN:
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,none)
< **   fArg: in elm: ref Range
< **   aArg: D
< **   theOI.f.f:label: ObjectGenerator
< link(S,D,none)
< **   encOG:head := link(S,D,none)
< **   savedOGS: [0:Map&]
< **** PTN:getOGsequenceOfArg: 
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,none)
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm: ref Range
< **** Items:localSearch: elm
< **   in:
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "next"
< **** Signature:localSearch: elm in: link
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< in inx: ref Domain
< in elm: ref Range
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "inx"
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:Map&]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:Map&,nest(link)]
< **   getOGsequenceOfArg:aArgs:(S,D,none)
< **   fArgs.origin.OG=theFargsOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGS: [0:Map&,nest(link)]
< **   theFargOG:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** PRE: [0:Map&,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map&,nest(link),Entry]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:Map&,nest(link),Entry]
< **** DataItem:getVqual: in elm: ref Range
< [0:Map&,nest(link),Entry]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:Map&,nest(link),Entry]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map&,nest(link),Entry]
< **   encOG: head := link(S,D,none)
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[1:Map&,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[2:Map&,nest(link)]
< **   ENC:result:[2:Map&]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[1:Map&]
< 
< **** getVqual:B2:
< [0:Map&]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:Map&]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map&]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:Map&]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Range
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:D
< **   encOG: link(S,D,none)
< **** Invocation:semCheck: D
< **   encOG:link(S,D,none)
< **** OI:semCheck: "D" rec: "none"
< **   encOG:link(S,D,none)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   argAtInx: 3 in:PTN:
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,none)
< **   fArg: in next: ref link
< **   aArg: none
< **   theOI.f.f:label: ObjectGenerator
< link(S,D,none)
< **   encOG:head := link(S,D,none)
< **   savedOGS: [0:Map&]
< **** PTN:getOGsequenceOfArg: 
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,none)
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in next: ref link
< **** Items:localSearch: next
< **   in:
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: next
< Try: "next"
< **** Items:localSearch:end: next
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Map&]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:Map&,nest(link)]
< **   getOGsequenceOfArg:aArgs:(S,D,none)
< **   fArgs.origin.OG=theFargsOG: 
< Entry
<    in next: ref link
< **   OGS: [0:Map&,nest(link)]
< **   theFargOG:
< 
< Entry
<    in next: ref link
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Map&,nest(link)]
< **** DataItem:getVqual: in next: ref link
< [0:Map&,nest(link)]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map&,nest(link)]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map&,nest(link)]
< **   encOG: head := link(S,D,none)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Entry
<    in next: ref link
< **** ENC:OI.getVqual:[1:Map&,nest(link)]
< **   ENC:result:[1:Map&]
< 
< **** getVqual:B2:
< [0:Map&]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:none
< **   encOG: link(S,D,none)
< **** Invocation:semCheck: none
< **   encOG:link(S,D,none)
< **** OI:semCheck: "none" rec: "none"
< **   encOG:link(S,D,none)
< **** Pattern:checkActualArgs:
< none: 
<    %basic 19
<    none_x: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:link(S,D,none)**** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< 
< **** OI:getVqual: head on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: head := link(S,D,none)
< 
< **** OI:getVqual:initial:head
< **   encOG:head := link(S,D,none)
< **   OGs:[0:Map]
< **   ATd: head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: head := link(S,D,none)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:initial:afterATd:head
< **   OGSx:[0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS: none
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semcheck:IS not empty:eOG: 
< head := link(S,D,none)
< **** OG:semCheck:head := link(S,D,head)
< **   encOG: head := link(S,D,none)
< **** Invocation:semCheck: 
< **   encOG:head := link(S,D,none)
< **** OG:semCheck:link(S,D,head)
< **   encOG: head := link(S,D,head)
< **** Invocation:semCheck: link(S,D,head)
< **   encOG:head := link(S,D,head)
< **** OI:semCheck: "link(S,D,head)" rec: "head"
< **   encOG:head := link(S,D,head)
< **** Pattern:checkActualArgs:
< link: Entry
<    in next: ref link
< **   actualArgs: (S,D,head)
< **   fArgs(in inx: ref Domain,in elm: ref Range,in next: ref link,)
< 
< **   encOG:head := link(S,D,head)**   argAtInx: 1 in:PTN:
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,head)
< **   fArg: in inx: ref Domain
< **   aArg: S
< **   theOI.f.f:label: ObjectGenerator
< link(S,D,head)
< **   encOG:head := link(S,D,head)
< **   savedOGS: [0:Map]
< **** PTN:getOGsequenceOfArg: 
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,head)
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in inx: ref Domain
< **** Items:localSearch: inx
< **   in:
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "next"
< **** Signature:localSearch: inx in: link
< **** Items:localSearch: inx
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Items:localSearch:end: inx
< **** Signature:localSearch:end: inx
< **   Items:localSearch:trySuper:
< **** Items:localSearch: inx
< **   in:
< 
< in inx: ref Domain
< in elm: ref Range
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:1
< **   OGS:[0:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:Map,nest(link)]
< **   getOGsequenceOfArg:aArgs:(S,D,head)
< **   fArgs.origin.OG=theFargsOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGS: [0:Map,nest(link)]
< **   theFargOG:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** PRE: [0:Map,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map,nest(link),Entry]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:Map,nest(link),Entry]
< **** DataItem:getVqual: in inx: ref Domain
< [0:Map,nest(link),Entry]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:Map,nest(link),Entry]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry]
< **   encOG: head := link(S,D,head)
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[2:Map,nest(link)]
< **   ENC:result:[2:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Domain
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:S
< **   encOG: link(S,D,head)
< **** Invocation:semCheck: S
< **   encOG:link(S,D,head)
< **** OI:semCheck: "S" rec: "none"
< **   encOG:link(S,D,head)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   argAtInx: 2 in:PTN:
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,head)
< **   fArg: in elm: ref Range
< **   aArg: D
< **   theOI.f.f:label: ObjectGenerator
< link(S,D,head)
< **   encOG:head := link(S,D,head)
< **   savedOGS: [0:Map&]
< **** PTN:getOGsequenceOfArg: 
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,head)
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm: ref Range
< **** Items:localSearch: elm
< **   in:
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "next"
< **** Signature:localSearch: elm in: link
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< in inx: ref Domain
< in elm: ref Range
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "inx"
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:Map&]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:Map&,nest(link)]
< **   getOGsequenceOfArg:aArgs:(S,D,head)
< **   fArgs.origin.OG=theFargsOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGS: [0:Map&,nest(link)]
< **   theFargOG:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** PRE: [0:Map&,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map&,nest(link),Entry]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:Map&,nest(link),Entry]
< **** DataItem:getVqual: in elm: ref Range
< [0:Map&,nest(link),Entry]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:Map&,nest(link),Entry]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map&,nest(link),Entry]
< **   encOG: head := link(S,D,head)
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[1:Map&,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[2:Map&,nest(link)]
< **   ENC:result:[2:Map&]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[1:Map&]
< 
< **** getVqual:B2:
< [0:Map&]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:Map&]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map&]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:Map&]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Range
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:D
< **   encOG: link(S,D,head)
< **** Invocation:semCheck: D
< **   encOG:link(S,D,head)
< **** OI:semCheck: "D" rec: "none"
< **   encOG:link(S,D,head)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   argAtInx: 3 in:PTN:
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,head)
< **   fArg: in next: ref link
< **   aArg: head
< **   theOI.f.f:label: ObjectGenerator
< link(S,D,head)
< **   encOG:head := link(S,D,head)
< **   savedOGS: [0:Map&]
< **** PTN:getOGsequenceOfArg: 
< link: Entry
<    in next: ref link
< **   theOI: link(S,D,head)
< **   theOI.on:2,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in next: ref link
< **** Items:localSearch: next
< **   in:
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: next
< Try: "next"
< **** Items:localSearch:end: next
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Map&]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:Map&,nest(link)]
< **   getOGsequenceOfArg:aArgs:(S,D,head)
< **   fArgs.origin.OG=theFargsOG: 
< Entry
<    in next: ref link
< **   OGS: [0:Map&,nest(link)]
< **   theFargOG:
< 
< Entry
<    in next: ref link
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Map&,nest(link)]
< **** DataItem:getVqual: in next: ref link
< [0:Map&,nest(link)]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map&,nest(link)]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map&,nest(link)]
< **   encOG: head := link(S,D,head)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Entry
<    in next: ref link
< **** ENC:OI.getVqual:[1:Map&,nest(link)]
< **   ENC:result:[1:Map&]
< 
< **** getVqual:B2:
< [0:Map&]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:head
< **   encOG: link(S,D,head)
< **** Invocation:semCheck: head
< **   encOG:link(S,D,head)
< **** OI:semCheck: "head" rec: "none"
< **   encOG:link(S,D,head)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< 
< **** OI:getVqual: head on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: head := link(S,D,head)
< 
< **** OI:getVqual:initial:head
< **   encOG:head := link(S,D,head)
< **   OGs:[0:Map]
< **   ATd: head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: head := link(S,D,head)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:initial:afterATd:head
< **   OGSx:[0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS: none
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semcheck:IS not empty:eOG: 
< head := link(S,D,head)
< **** OG:semcheck:IS not empty:eOG: 
< head := link(S,D,head)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** OG:semCheck:
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **   encOG: 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< 
< **** OG:semCheck:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< **   encOG: 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **** OG:semCheck:
< if (V == current.inx) :then 
<    R := current.elm
<    leave(lookup)
< **   encOG: 
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< **** Invocation:semCheck: if (V == current.inx) :then 
<    R := current.elm
<    leave(lookup)
< **   encOG:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< 
< **** OG:semCheck:(V == current.inx)
< **   encOG: 
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< **** Invocation:semCheck: (V == current.inx)
< **   encOG:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< 
< **** Invocation:semCheck: V == current.inx
< **   encOG:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< 
< **** OI:semCheck: "== current.inx" rec: "V"
< **   encOG:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< 
< **** Pattern:checkActualArgs:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: current.inx
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< **   argAtInx: 1 in:PTN:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == current.inx
< **   fArg: in objx: ref Object
< **   aArg: current.inx
< **   theOI.f.f:label: BracketedExp
< (V == current.inx)
< **   encOG:
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< **   savedOGS: [0:Map&,nest(Object)]
< **** PTN:getOGsequenceOfArg: 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == current.inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 56
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Map&,nest(Object)]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:Map&,nest(Object),nest(==)]
< **   getOGsequenceOfArg:aArgs:current.inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:Map&,nest(Object),nest(==)]
< **   theFargOG:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Map&,nest(Object),nest(==)]
< **** DataItem:getVqual: in objx: ref Object
< [0:Map&,nest(Object),nest(==)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:Map&,nest(Object),nest(==)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map&,nest(Object),nest(==)]
< **   encOG: 
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Map&,nest(Object),nest(==)]
< **   ENC:result:[1:Map&,nest(Object)]
< **** ENC:OI.getVqual:[2:Map&,nest(Object)]
< **   ENC:result:[2:Map&]
< 
< **** getVqual:B2:
< [0:Map&]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:current.inx
< **   encOG: (V == current.inx)
< **** Invocation:semCheck: current.inx
< **   encOG:(V == current.inx)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:(V == current.inx)
< **** OI:semCheck: "inx" rec: "current"
< **   encOG:(V == current.inx)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:
< R := current.elm
<    leave(lookup)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:current.elm
< **   encOG: 
< R := current.elm
<    leave(lookup)
< **** Invocation:semCheck: current.elm
< **   encOG:
< R := current.elm
<    leave(lookup)
< 
< **** OI:semCheck: "current" rec: "R"
< **   encOG:
< R := current.elm
<    leave(lookup)
< 
< **** OI:semCheck: "elm" rec: "current"
< **   encOG:
< R := current.elm
<    leave(lookup)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OI:getVqual: R on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< R := current.elm
<    leave(lookup)
< 
< **** OI:getVqual:initial:R
< **   encOG:
< R := current.elm
<    leave(lookup)
< **   OGs:[0:lookup]
< **   ATd: out R: ref Range
< **** DataItem:getVqual: out R: ref Range
< [0:lookup]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:lookup]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:lookup]
< **   encOG: 
< R := current.elm
<    leave(lookup)
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **** ENC:OI.getVqual:[1:lookup]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Range
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:leave(lookup)
< **   encOG: 
< R := current.elm
<    leave(lookup)
< **** Invocation:semCheck: leave(lookup)
< **   encOG:
< R := current.elm
<    leave(lookup)
< 
< **** OI:semCheck: "leave(lookup)" rec: "none"
< **   encOG:
< R := current.elm
<    leave(lookup)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< R := current.elm
<    leave(lookup)
< **** OG:semcheck:IS not empty:eOG: 
< 
< R := current.elm
<    leave(lookup)
< **** OG:semcheck:IS not empty:eOG: 
< 
< R := current.elm
<    leave(lookup)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    if (V == current.inx) :then 
<       R := current.elm
<       leave(lookup)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **** OG:returnDecl: out R: ref Range
< **** OG:semCheck:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** OG:semCheck:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **   encOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** Invocation:semCheck: 
< **   encOG:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** Invocation:semCheck: Boolean
< **   encOG:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< inner
<    out B: var Boolean
< **   encOG: 
< inner
<    out B: var Boolean
< **** Invocation:semCheck: inner
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** OI:semCheck: "inner" rec: "innerBool"
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< inner
<    out B: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< inner
<    out B: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< inner
<    out B: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< inner
<    out B: var Boolean
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:innerBool -- no innerBool(forAll)
< **   encOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** Invocation:semCheck: innerBool -- no innerBool(forAll)
< **   encOG:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< 
< **** OI:semCheck: "innerBool -- no innerBool(forAll)" rec: "return"
< **   encOG:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** OG:returnDecl: out B: var Boolean
< 
< **** OI:getVqual: return on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< 
< **** OI:getVqual:initial:return
< **   encOG:
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **   OGs:[0:pred]
< **   ATd: out return: var Boolean
< **** DataItem:getVqual: out return: var Boolean
< [0:pred]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:pred]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:pred]
< **   encOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **   OGS:[0:pred]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **   OGS:[0:pred]
< **** ENC:OI.viaInclude:[0:pred]
< **   ENC:result:[0:forAll]
< **** viaInclude:GOT:
< [0:forAll,nest(pred)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:forAll,nest(pred)]
< **** savedOGS:save:False[0:forAll,nest(pred)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAll,nest(pred)]
< **   OGS:[0:forAll,nest(pred)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:forAll,nest(pred)]
< 
< **** getVqual:initial:afterATd:return
< **   OGSx:[0:forAll,nest(pred)]
< **** savedOGS:save:was:[0:forAll,nest(pred)]
< **   OI: return
< **   OI:getQual:savedOI:return
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAll,nest(pred)]
< **   OGS: none
< **** OI:getVqual:end: return
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:forAll,nest(pred)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** OG:returnDecl: out return: var Boolean
< **** OG:semCheck:Boolean
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:true
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** Invocation:semCheck: true
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** OI:semCheck: "true" rec: "B"
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** OI:getVqual:initial:B
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   OGs:[0:forAll]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:forAll]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:forAll]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:forAll]
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   OGS:[0:forAll]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   OGS:[0:forAll]
< **** ENC:OI.viaInclude:[0:forAll]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(forAll)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map,nest(forAll)]
< **** savedOGS:save:False[0:Map,nest(forAll)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(forAll)]
< **   OGS:[0:Map,nest(forAll)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(forAll)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Map,nest(forAll)]
< **** savedOGS:save:was:[0:Map,nest(forAll)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(forAll)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(forAll)]
< **** OG:semCheck:
< scan
<    B := B && pred(current)
< **   encOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** OG:semCheck:B && pred(current)
< **   encOG: 
< scan
<    B := B && pred(current)
< **** Invocation:semCheck: B && pred(current)
< **   encOG:
< scan
<    B := B && pred(current)
< 
< **** OI:semCheck: "B" rec: "B"
< **   encOG:
< scan
<    B := B && pred(current)
< 
< **** OI:semCheck: "&& pred(current)" rec: "B"
< **   encOG:
< scan
<    B := B && pred(current)
< 
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: pred(current)
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< scan
<    B := B && pred(current)
< **   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && pred(current)
< **   fArg: in B: var boolean
< **   aArg: pred(current)
< **   theOI.f.f:label: ObjectGenerator
< B && pred(current)
< **   encOG:
< scan
<    B := B && pred(current)
< **   savedOGS: [0:Map,nest(scan$0),nest(Boolean)]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && pred(current)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Map,nest(scan$0),nest(Boolean)]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Map,nest(scan$0),nest(Boolean),nest(&&)]
< **   getOGsequenceOfArg:aArgs:pred(current)
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Map,nest(scan$0),nest(Boolean),nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Map,nest(scan$0),nest(Boolean),nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:Map,nest(scan$0),nest(Boolean),nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Map,nest(scan$0),nest(Boolean),nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(scan$0),nest(Boolean),nest(&&)]
< **   encOG: 
< scan
<    B := B && pred(current)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Map,nest(scan$0),nest(Boolean),nest(&&)]
< **   ENC:result:[1:Map,nest(scan$0),nest(Boolean)]
< **** ENC:OI.getVqual:[2:Map,nest(scan$0),nest(Boolean)]
< **   ENC:result:[2:Map,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:Map,nest(scan$0)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Map,nest(scan$0)]
< **** savedOGS:save:False[0:Map,nest(scan$0)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(scan$0)]
< **   OGS:[0:Map,nest(scan$0)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(scan$0)]
< **** OG:semCheck:pred(current)
< **   encOG: B && pred(current)
< **** Invocation:semCheck: pred(current)
< **   encOG:B && pred(current)
< **** OI:semCheck: "pred(current)" rec: "none"
< **   encOG:B && pred(current)
< **** Pattern:checkActualArgs:
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **   actualArgs: pred(current)
< **   fArgs(in E: ref Entry,)
< 
< **   encOG:B && pred(current)**   argAtInx: 1 in:PTN:
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **   theOI: pred(current)
< **   fArg: in E: ref Entry
< **   aArg: current
< **   theOI.f.f:label: ObjectGenerator
< pred(current)
< **   encOG:B && pred(current)
< **   savedOGS: [0:forAll&]
< **** PTN:getOGsequenceOfArg: 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **   theOI: pred(current)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in E: ref Entry
< **** Items:localSearch: E
< **   in:
< 
< in E: ref Entry
< out return: var Boolean
< innerBool: inner
<    out B: var Boolean
< return := innerBool -- no innerBool(forAll)
< **   isChecked: True
< **   Items:localSearch:Decls: E
< Try: "E"
< **** Items:localSearch:end: E
< **   pathTo:parDecl:pn:0
< **   OGS:[0:forAll&]
< **   OGS.DOG:
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   After:[0:forAll&,nest(pred)]
< **   getOGsequenceOfArg:aArgs:pred(current)
< **   fArgs.origin.OG=theFargsOG: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **   OGS: [0:forAll&,nest(pred)]
< **   theFargOG:
< 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:forAll&,nest(pred)]
< **** DataItem:getVqual: in E: ref Entry
< [0:forAll&,nest(pred)]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:forAll&,nest(pred)]
< 
< **** OI:getVqual: Entry on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:forAll&,nest(pred)]
< **   encOG: B && pred(current)
< **** koks: Entry on: 2 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** ENC:OI.getVqual:[1:forAll&,nest(pred)]
< **   ENC:result:[1:forAll&]
< **** ENC:OI.getVqual:[2:forAll&]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semCheck:current
< **   encOG: pred(current)
< **** Invocation:semCheck: current
< **   encOG:pred(current)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:pred(current)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in inx: ref Domain
<    in elm: ref Range
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out return: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< scan
<    B := B && pred(current)
< 
< **** OI:getVqual:initial:B
< **   encOG:
< scan
<    B := B && pred(current)
< **   OGs:[0:forAll]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:forAll]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:forAll]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:forAll]
< **   encOG: 
< scan
<    B := B && pred(current)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    B := B && pred(current)
< **   OGS:[0:forAll]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    B := B && pred(current)
< **   OGS:[0:forAll]
< **** ENC:OI.viaInclude:[0:forAll]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map,nest(scan$0)]
< **** savedOGS:save:False[0:Map,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(scan$0)]
< **   OGS:[0:Map,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Map,nest(scan$0)]
< **** savedOGS:save:was:[0:Map,nest(scan$0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(scan$0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    B := B && pred(current)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** Invocation:semCheck: 
< **   encOG:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OG:semCheck:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OG:semCheck:
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** Invocation:semCheck: if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< :else 
<    nxt := nxt
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OG:semCheck:(nxt =/= none)
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** Invocation:semCheck: (nxt =/= none)
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** Invocation:semCheck: nxt =/= none
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:semCheck: "nxt" rec: "none"
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:semCheck: "=/= none" rec: "nxt"
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** Pattern:checkActualArgs:
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: none
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   argAtInx: 1 in:PTN:
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   theOI: =/= none
< **   fArg: in objx: ref Object
< **   aArg: none
< **   theOI.f.f:label: BracketedExp
< (nxt =/= none)
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   savedOGS: [0:Map,nest(link),Entry,Object]
< **** PTN:getOGsequenceOfArg: 
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   theOI: =/= none
< **   theOI.on:0,pn:2 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 57
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Map,nest(link),Entry,Object]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:Map,nest(link),Entry,Object,nest(=/=)]
< **   getOGsequenceOfArg:aArgs:none
< **   fArgs.origin.OG=theFargsOG: 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:Map,nest(link),Entry,Object,nest(=/=)]
< **   theFargOG:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Map,nest(link),Entry,Object,nest(=/=)]
< **** DataItem:getVqual: in objx: ref Object
< [0:Map,nest(link),Entry,Object,nest(=/=)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:Map,nest(link),Entry,Object,nest(=/=)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry,Object,nest(=/=)]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry,Object,nest(=/=)]
< **   ENC:result:[1:Map,nest(link),Entry,Object]
< **** ENC:OI.getVqual:[2:Map,nest(link),Entry,Object]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[4:Map,nest(link)]
< **   ENC:result:[4:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[3:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semCheck:none
< **   encOG: (nxt =/= none)
< **** Invocation:semCheck: none
< **   encOG:(nxt =/= none)
< **** OI:semCheck: "none" rec: "none"
< **   encOG:(nxt =/= none)
< **** Pattern:checkActualArgs:
< none: 
<    %basic 19
<    none_x: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:(nxt =/= none)**** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:nxt
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: nxt
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "nxt" rec: "current"
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< 
< **** OI:getVqual: current on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual:initial:current
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGs:[0:scan]
< **   ATd: current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:initial:afterATd:current
< **   OGSx:[0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS: none
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semCheck:inner(scan)
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: inner(scan)
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "inner(scan)" rec: "none"
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OG:semCheck:nxt.next
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: nxt.next
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "nxt" rec: "nxt"
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "next" rec: "nxt"
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual:initial:nxt
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGs:[0:scan]
< **   ATd: nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:initial:afterATd:nxt
< **   OGSx:[0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS: none
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semCheck:restart(Loop)
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: restart(Loop)
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "restart(Loop)" rec: "none"
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OG:semCheck:nxt := nxt
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: 
< **   encOG:
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semCheck:nxt
< **   encOG: nxt := nxt
< **** Invocation:semCheck: nxt
< **   encOG:nxt := nxt
< **** OI:semCheck: "nxt" rec: "nxt"
< **   encOG:nxt := nxt
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: nxt := nxt
< 
< **** OI:getVqual:initial:nxt
< **   encOG:nxt := nxt
< **   OGs:[0:scan]
< **   ATd: nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: nxt := nxt
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:initial:afterATd:nxt
< **   OGSx:[0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS: none
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semcheck:IS not empty:eOG: 
< nxt := nxt
< **** OG:semcheck:IS not empty:eOG: 
< nxt := nxt
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** OG:semCheck:head
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** Invocation:semCheck: head
< **   encOG:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OI:semCheck: "head" rec: "nxt"
< **   encOG:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< 
< **** OI:getVqual: nxt on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OI:getVqual:initial:nxt
< **   encOG:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   OGs:[0:scan]
< **   ATd: nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:initial:afterATd:nxt
< **   OGSx:[0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS: none
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semCheck:loop
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** Invocation:semCheck: loop
< **   encOG:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OI:semCheck: "loop" rec: "none"
< **   encOG:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** Pattern:checkActualArgs:
< Loop: 
<    if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** OG:semCheck:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OG:semCheck:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   encOG: 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **** Invocation:semCheck: 
< **   encOG:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **** OG:returnDecl: out z: var Boolean
< **** OG:semCheck:Boolean
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:IV
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: IV
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "IV" rec: "V"
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OI:getVqual: V on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:getVqual:initial:V
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   OGs:[0:reduce]
< **   ATd: out V: var Boolean
< **** DataItem:getVqual: out V: var Boolean
< [0:reduce]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:reduce]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce]
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   OGS:[0:reduce]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   OGS:[0:reduce]
< **** ENC:OI.viaInclude:[0:reduce]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(reduce)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map,nest(reduce)]
< **** savedOGS:save:False[0:Map,nest(reduce)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(reduce)]
< **   OGS:[0:Map,nest(reduce)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(reduce)]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:Map,nest(reduce)]
< **** savedOGS:save:was:[0:Map,nest(reduce)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(reduce)]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(reduce)]
< **** OG:semCheck:
< scan
<    V := F(current,V)
< **   encOG: 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:semCheck:F(current,V)
< **   encOG: 
< scan
<    V := F(current,V)
< **** Invocation:semCheck: F(current,V)
< **   encOG:
< scan
<    V := F(current,V)
< 
< **** OI:semCheck: "F(current,V)" rec: "V"
< **   encOG:
< scan
<    V := F(current,V)
< 
< **** Pattern:checkActualArgs:
< in F:< 
<    in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   actualArgs: (current,V)
< **   fArgs(in x: ref Entry,in b: var Boolean,)
< 
< **   encOG:
< scan
<    V := F(current,V)
< **   argAtInx: 1 in:PTN:
< in F:< 
<    in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   fArg: in x: ref Entry
< **   aArg: current
< **   theOI.f.f:label: ObjectGenerator
< F(current,V)
< **   encOG:
< scan
<    V := F(current,V)
< **   savedOGS: [0:reduce&]
< **** PTN:getOGsequenceOfArg: 
< in F:< 
<    in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in x: ref Entry
< **** Items:localSearch: x
< **   in:
< 
< in x: ref Entry
< in b: var Boolean
< out z: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: x
< Try: "x"
< **** Items:localSearch:end: x
< **   pathTo:parDecl:pn:0
< **   OGS:[0:reduce&]
< **   OGS.DOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   After:[0:reduce&,nest(F)]
< **   getOGsequenceOfArg:aArgs:(current,V)
< **   fArgs.origin.OG=theFargsOG: 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   OGS: [0:reduce&,nest(F)]
< **   theFargOG:
< 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:reduce&,nest(F)]
< **** DataItem:getVqual: in x: ref Entry
< [0:reduce&,nest(F)]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:reduce&,nest(F)]
< 
< **** OI:getVqual: Entry on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce&,nest(F)]
< **   encOG: 
< scan
<    V := F(current,V)
< **** koks: Entry on: 2 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **** ENC:OI.getVqual:[1:reduce&,nest(F)]
< **   ENC:result:[1:reduce&]
< **** ENC:OI.getVqual:[2:reduce&]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OG:semCheck:current
< **   encOG: F(current,V)
< **** Invocation:semCheck: current
< **   encOG:F(current,V)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:F(current,V)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in inx: ref Domain
<    in elm: ref Range
< **   argAtInx: 2 in:PTN:
< in F:< 
<    in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   fArg: in b: var Boolean
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< F(current,V)
< **   encOG:
< scan
<    V := F(current,V)
< **   savedOGS: [0:reduce&]
< **** PTN:getOGsequenceOfArg: 
< in F:< 
<    in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in b: var Boolean
< **** Items:localSearch: b
< **   in:
< 
< in x: ref Entry
< in b: var Boolean
< out z: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: b
< Try: "x"
< Try: "b"
< **** Items:localSearch:end: b
< **   pathTo:parDecl:pn:0
< **   OGS:[0:reduce&]
< **   OGS.DOG:
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   After:[0:reduce&,nest(F)]
< **   getOGsequenceOfArg:aArgs:(current,V)
< **   fArgs.origin.OG=theFargsOG: 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   OGS: [0:reduce&,nest(F)]
< **   theFargOG:
< 
< in x: ref Entry
<    in b: var Boolean
<    out z: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:reduce&,nest(F)]
< **** DataItem:getVqual: in b: var Boolean
< [0:reduce&,nest(F)]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:reduce&,nest(F)]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce&,nest(F)]
< **   encOG: 
< scan
<    V := F(current,V)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce&,nest(F)]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce&,nest(F)]
< **** ENC:OI.viaInclude:[0:reduce&,nest(F)]
< **   ENC:result:[0:reduce&]
< **** viaInclude:GOT:
< [0:reduce&,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:reduce&,nest(scan$0)]
< **** savedOGS:save:False[0:reduce&,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:reduce&,nest(scan$0)]
< **   OGS:[0:reduce&,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:reduce&,nest(scan$0)]
< **** OG:semCheck:V
< **   encOG: F(current,V)
< **** Invocation:semCheck: V
< **   encOG:F(current,V)
< **** OI:semCheck: "V" rec: "none"
< **   encOG:F(current,V)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out z: var Boolean
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< scan
<    V := F(current,V)
< 
< **** OI:getVqual:initial:V
< **   encOG:
< scan
<    V := F(current,V)
< **   OGs:[0:reduce]
< **   ATd: out V: var Boolean
< **** DataItem:getVqual: out V: var Boolean
< [0:reduce]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:reduce]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce]
< **   encOG: 
< scan
<    V := F(current,V)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce]
< **** ENC:OI.viaInclude:[0:reduce]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map,nest(scan$0)]
< **** savedOGS:save:False[0:Map,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(scan$0)]
< **   OGS:[0:Map,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:Map,nest(scan$0)]
< **** savedOGS:save:was:[0:Map,nest(scan$0)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(scan$0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    V := F(current,V)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in F:< 
<       in x: ref Entry
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:returnDecl: out V: var Boolean
< **** OG:semCheck:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OG:semCheck:
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   encOG: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** Invocation:semCheck: 
< **   encOG:
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** OG:returnDecl: out V: var Boolean
< **** OG:semCheck:boolean -- inner(select) and done for test purposes
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** Invocation:semCheck: boolean -- inner(select) and done for test purposes
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:semCheck: "boolean -- inner(select) and done for test purposes" rec: "none"
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: -- inner(select) and done for test purposes
< **   fArgs()
< 
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:SetLib.Set(#Domain)
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** Invocation:semCheck: SetLib.Set(#Domain)
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:semCheck: "SetLib" rec: "R"
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:semCheck: "Set(#Domain)" rec: "SetLib"
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** Pattern:checkActualArgs:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   actualArgs: Set(#Domain)
< **   fArgs(in elm:< Object,)
< 
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   argAtInx: 1 in:PTN:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Domain)
< **   fArg: in elm:< Object
< **   aArg: #Domain
< **   theOI.f.f:label: ObjectGenerator
< SetLib.Set(#Domain)
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   savedOGS: [0:Collections,nest(SetLib)]
< **** PTN:getOGsequenceOfArg: 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Domain)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "has"
< Try: "isEmpty"
< Try: "insert"
< Try: "remove"
< Try: "card"
< Try: "clear"
< Try: "scan"
< Try: "forAllX"
< Try: "forAll"
< Try: "exists"
< Try: "reduce"
< Try: "link"
< Try: "head"
< **** Signature:localSearch: elm in: Set
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< %id "Collection"
< %globals
< in elm:< Object
< scan:< 
<    %OSDvisibility skipInternal
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:Collections,nest(SetLib)]
< **   OGS.DOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   After:[0:Collections,nest(SetLib),nest(Set)]
< **   getOGsequenceOfArg:aArgs:Set(#Domain)
< **   fArgs.origin.OG=theFargsOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS: [0:Collections,nest(SetLib),nest(Set)]
< **   theFargOG:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** PRE: [0:Collections,nest(SetLib),nest(Set)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Collections,nest(SetLib),nest(Set),Collection]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:Collections,nest(SetLib),nest(Set),Collection]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Collections,nest(SetLib),nest(Set),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Collections,nest(SetLib),nest(Set),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Collections,nest(SetLib),nest(Set),Collection]
< **** searchBinding: in elm:< Object
< [0:Collections,nest(SetLib),nest(Set)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Domain
< **   encOG: SetLib.Set(#Domain)
< **** Invocation:semCheck: #Domain
< **   encOG:SetLib.Set(#Domain)
< **** OI:semCheck: "#Domain" rec: "none"
< **   encOG:SetLib.Set(#Domain)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** OI:getVqual: R on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:getVqual:initial:R
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGs:[0:select]
< **   ATd: out R: ref SetLib.Set(#Domain)
< **** DataItem:getVqual: out R: ref SetLib.Set(#Domain)
< [0:select]
< **** ObjectGenerator:getVqual: SetLib.Set(#Domain)
< **   hasVirtualArgs: True
< **** INV:getVqual:SetLib.Set(#Domain)
< **   OGs: [0:select]
< 
< **** OI:getVqual: SetLib on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** koks: SetLib on: 3 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** ENC:OI.getVqual:[1:select]
< **   ENC:result:[1:Map]
< **** ENC:OI.getVqual:[2:Map]
< **   ENC:result:[2:MapLib]
< **** ENC:OI.getVqual:[3:MapLib]
< **   ENC:result:[3:Collections]
< 
< **** getVqual:B2:
< [0:Collections]
< ---
< 
< --SetLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections]
< **** savedOGS:save:False[0:Collections]
< **   OI: SetLib
< **   OI:getQual:savedOI:SetLib
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections]
< **   OGS:[0:Collections]
< **** OI:getVqual:end: SetLib
< **   qual: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections]
< 
< **** OI:getVqual: Set(#Domain) on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Collections]
< **   encOG: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Collections]
< **   encOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< 
< **** getVqual:added:isNest:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections,nest(SetLib)]
< **** koks: Set(#Domain) on: 0 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** getVqual:B2:
< [0:Collections,nest(SetLib)]
< ---
< 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** Pattern:getVqual: Set :isVirtual:False
< [0:Collections,nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib)]
< **** savedOGS:save:False[0:Collections,nest(SetLib)]
< **   OI: Set(#Domain)
< **   OI:getQual:savedOI:Set(#Domain)
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS:[0:Collections,nest(SetLib)]
< **** OI:getVqual:end: Set(#Domain)
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:Collections,nest(SetLib)]
< **** savedOGS:save:was:[0:Collections,nest(SetLib)]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< **** OG:semCheck:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OG:semCheck:
< if (pred(current.inx,current.elm)) :then 
<    R.insert(current.inx)
<    inner(select)
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** Invocation:semCheck: if (pred(current.inx,current.elm)) :then 
<    R.insert(current.inx)
<    inner(select)
< **   encOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OG:semCheck:(pred(current.inx,current.elm))
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** Invocation:semCheck: (pred(current.inx,current.elm))
< **   encOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** Invocation:semCheck: pred(current.inx,current.elm)
< **   encOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OI:semCheck: "pred(current.inx,current.elm)" rec: "none"
< **   encOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** Pattern:checkActualArgs:
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   actualArgs: (current.inx,current.elm)
< **   fArgs(in IX: ref Domain,in E: ref Range,)
< 
< **   encOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   argAtInx: 1 in:PTN:
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   theOI: pred(current.inx,current.elm)
< **   fArg: in IX: ref Domain
< **   aArg: current.inx
< **   theOI.f.f:label: BracketedExp
< (pred(current.inx,current.elm))
< **   encOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   savedOGS: [0:select&]
< **** PTN:getOGsequenceOfArg: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   theOI: pred(current.inx,current.elm)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in IX: ref Domain
< **** Items:localSearch: IX
< **   in:
< 
< in IX: ref Domain
< in E: ref Range
< out V: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: IX
< Try: "IX"
< **** Items:localSearch:end: IX
< **   pathTo:parDecl:pn:0
< **   OGS:[0:select&]
< **   OGS.DOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   After:[0:select&,nest(pred)]
< **   getOGsequenceOfArg:aArgs:(current.inx,current.elm)
< **   fArgs.origin.OG=theFargsOG: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   OGS: [0:select&,nest(pred)]
< **   theFargOG:
< 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:select&,nest(pred)]
< **** DataItem:getVqual: in IX: ref Domain
< [0:select&,nest(pred)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:select&,nest(pred)]
< 
< **** OI:getVqual: Domain on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select&,nest(pred)]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: Domain on: 2 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** ENC:OI.getVqual:[1:select&,nest(pred)]
< **   ENC:result:[1:select&]
< **** ENC:OI.getVqual:[2:select&]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Domain
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:current.inx
< **   encOG: (pred(current.inx,current.elm))
< **** Invocation:semCheck: current.inx
< **   encOG:(pred(current.inx,current.elm))
< **** OI:semCheck: "current" rec: "none"
< **   encOG:(pred(current.inx,current.elm))
< **** OI:semCheck: "inx" rec: "current"
< **   encOG:(pred(current.inx,current.elm))
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   argAtInx: 2 in:PTN:
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   theOI: pred(current.inx,current.elm)
< **   fArg: in E: ref Range
< **   aArg: current.elm
< **   theOI.f.f:label: BracketedExp
< (pred(current.inx,current.elm))
< **   encOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   savedOGS: [0:select&]
< **** PTN:getOGsequenceOfArg: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   theOI: pred(current.inx,current.elm)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in E: ref Range
< **** Items:localSearch: E
< **   in:
< 
< in IX: ref Domain
< in E: ref Range
< out V: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: E
< Try: "IX"
< Try: "E"
< **** Items:localSearch:end: E
< **   pathTo:parDecl:pn:0
< **   OGS:[0:select&]
< **   OGS.DOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   After:[0:select&,nest(pred)]
< **   getOGsequenceOfArg:aArgs:(current.inx,current.elm)
< **   fArgs.origin.OG=theFargsOG: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   OGS: [0:select&,nest(pred)]
< **   theFargOG:
< 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:select&,nest(pred)]
< **** DataItem:getVqual: in E: ref Range
< [0:select&,nest(pred)]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:select&,nest(pred)]
< 
< **** OI:getVqual: Range on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select&,nest(pred)]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: Range on: 2 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** ENC:OI.getVqual:[1:select&,nest(pred)]
< **   ENC:result:[1:select&]
< **** ENC:OI.getVqual:[2:select&]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Range
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OG:semCheck:current.elm
< **   encOG: (pred(current.inx,current.elm))
< **** Invocation:semCheck: current.elm
< **   encOG:(pred(current.inx,current.elm))
< **** OI:semCheck: "current" rec: "none"
< **   encOG:(pred(current.inx,current.elm))
< **** OI:semCheck: "elm" rec: "current"
< **   encOG:(pred(current.inx,current.elm))
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var Boolean
< **** OG:semCheck:
< R.insert(current.inx)
<    inner(select)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:R.insert(current.inx)
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** Invocation:semCheck: R.insert(current.inx)
< **   encOG:
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:semCheck: "R" rec: "none"
< **   encOG:
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:semCheck: "insert(current.inx)" rec: "R"
< **   encOG:
< R.insert(current.inx)
<    inner(select)
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(current.inx)
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< R.insert(current.inx)
<    inner(select)
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(current.inx)
< **   fArg: in e: ref elm
< **   aArg: current.inx
< **   theOI.f.f:label: ObjectGenerator
< R.insert(current.inx)
< **   encOG:
< R.insert(current.inx)
<    inner(select)
< **   savedOGS: [0:Collections,nest(SetLib),nest(Set&)]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(current.inx)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:Collections,nest(SetLib),nest(Set&)]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:Collections,nest(SetLib),nest(Set&),nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(current.inx)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:Collections,nest(SetLib),nest(Set&),nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:Collections,nest(SetLib),nest(Set&),nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:Collections,nest(SetLib),nest(Set&),nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:Collections,nest(SetLib),nest(Set&),nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:Collections,nest(SetLib),nest(Set&),nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:Collections,nest(SetLib),nest(Set&),nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Collections,nest(SetLib),nest(Set&),nest(insert),insert]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:Collections,nest(SetLib),nest(Set&),nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:Collections,nest(SetLib),nest(Set&),nest(insert)]
< **   ENC:result:[2:Collections,nest(SetLib),nest(Set&)]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Collections,nest(SetLib),nest(Set&)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Collections,nest(SetLib),nest(Set&),Collection]
< **   ENC:result:[1:Collections,nest(SetLib),nest(Set&),Collection]
< 
< **** getVqual:B2:
< [0:Collections,nest(SetLib),nest(Set&),Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Collections,nest(SetLib),nest(Set&),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Collections,nest(SetLib),nest(Set&),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Collections,nest(SetLib),nest(Set&),Collection]
< **** searchBinding: in elm:< Object
< [0:Collections,nest(SetLib),nest(Set&)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Collections,nest(SetLib),nest(Set&),Collection&]
< **** savedOGS:save:False[0:Collections,nest(SetLib),nest(Set&),Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib),nest(Set&),Collection&]
< **   OGS:[0:Collections,nest(SetLib),nest(Set&),Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib),nest(Set&),Collection&]
< **** OG:semCheck:current.inx
< **   encOG: R.insert(current.inx)
< **** Invocation:semCheck: current.inx
< **   encOG:R.insert(current.inx)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:R.insert(current.inx)
< **** OI:semCheck: "inx" rec: "current"
< **   encOG:R.insert(current.inx)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:inner(select)
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** Invocation:semCheck: inner(select)
< **   encOG:
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:semCheck: "inner(select)" rec: "none"
< **   encOG:
< R.insert(current.inx)
<    inner(select)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< R.insert(current.inx)
<    inner(select)
< **** OG:semcheck:IS not empty:eOG: 
< 
< R.insert(current.inx)
<    inner(select)
< **** OG:semcheck:IS not empty:eOG: 
< 
< R.insert(current.inx)
<    inner(select)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** OG:semCheck:true
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** Invocation:semCheck: true
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:semCheck: "true" rec: "done"
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: done on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:getVqual:initial:done
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGs:[0:select]
< **   ATd: done: var boolean -- inner(select) and done for test purposes
< **** DataItem:getVqual: done: var boolean -- inner(select) and done for test purposes
< [0:select]
< **** ObjectGenerator:getVqual: boolean -- inner(select) and done for test purposes
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean -- inner(select) and done for test purposes
< **   OGs: [0:select]
< 
< **** OI:getVqual: boolean -- inner(select) and done for test purposes on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: boolean -- inner(select) and done for test purposes
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGS:[0:select]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean -- inner(select) and done for test purposes
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGS:[0:select]
< **** ENC:OI.viaInclude:[0:select]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(select)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map,nest(select)]
< **** savedOGS:save:False[0:Map,nest(select)]
< **   OI: boolean -- inner(select) and done for test purposes
< **   OI:getQual:savedOI:boolean -- inner(select) and done for test purposes
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(select)]
< **   OGS:[0:Map,nest(select)]
< **** OI:getVqual:end: boolean -- inner(select) and done for test purposes
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(select)]
< 
< **** getVqual:initial:afterATd:done
< **   OGSx:[0:Map,nest(select)]
< **** savedOGS:save:was:[0:Map,nest(select)]
< **   OI: done
< **   OI:getQual:savedOI:done
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(select)]
< **   OGS: none
< **** OI:getVqual:end: done
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(select)]
< **** OG:semCheck:inner(select)
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** Invocation:semCheck: inner(select)
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:semCheck: "inner(select)" rec: "none"
< **   encOG:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OG:returnDecl: out R: ref SetLib.Set(#Domain)
< **** OG:semCheck:
< Entry
<    in next: ref link
< **   encOG: 
< Entry
<    in next: ref link
< **** Invocation:semCheck: Entry
< **   encOG:
< Entry
<    in next: ref link
< 
< **** OI:semCheck: "Entry" rec: "link"
< **   encOG:
< Entry
<    in next: ref link
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Entry
<    in next: ref link
< **** OG:semcheck:IS not empty:eOG: 
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< **** OG:semCheck:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   encOG: 
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< 
< **** OG:semCheck:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   encOG: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** Invocation:semCheck: Collection
< **   encOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** OI:semCheck: "Collection" rec: "Set"
< **   encOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** OG:semCheck:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** OG:semCheck:false
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** Invocation:semCheck: false
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** OI:semCheck: "false" rec: "B"
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** Pattern:checkActualArgs:
< False: 
<    %globals
<    out B: var boolean
<    B := 0
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=0 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** OI:getVqual:initial:B
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGs:[0:has,has]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:has,has]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGS:[0:has,has]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGS:[0:has,has]
< **** ENC:OI.viaInclude:[0:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.viaInclude:[1:has]
< **   ENC:result:[1:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< **   ENC:result:[0:Set,Collection]
< **** viaInclude:GOT:
< [0:Set,Collection,nest(has)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection,nest(has)]
< **** savedOGS:save:False[0:Set,Collection,nest(has)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest(has)]
< **   OGS:[0:Set,Collection,nest(has)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest(has)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,Collection,nest(has)]
< **** savedOGS:save:was:[0:Set,Collection,nest(has)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest(has)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest(has)]
< **** OG:semCheck:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** OG:semCheck:
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** Invocation:semCheck: if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< **   encOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** OG:semCheck:(current == e)
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** Invocation:semCheck: (current == e)
< **   encOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** Invocation:semCheck: current == e
< **   encOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** OI:semCheck: "== e" rec: "current"
< **   encOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: e
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   argAtInx: 1 in:PTN:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == e
< **   fArg: in objx: ref Object
< **   aArg: e
< **   theOI.f.f:label: BracketedExp
< (current == e)
< **   encOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   savedOGS: [0:Set,Collection&,nest(Object)]
< **** PTN:getOGsequenceOfArg: 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == e
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 56
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set,Collection&,nest(Object)]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:Set,Collection&,nest(Object),nest(==)]
< **   getOGsequenceOfArg:aArgs:e
< **   fArgs.origin.OG=theFargsOG: 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:Set,Collection&,nest(Object),nest(==)]
< **   theFargOG:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,Collection&,nest(Object),nest(==)]
< **** DataItem:getVqual: in objx: ref Object
< [0:Set,Collection&,nest(Object),nest(==)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:Set,Collection&,nest(Object),nest(==)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,Collection&,nest(Object),nest(==)]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,Collection&,nest(Object),nest(==)]
< **   ENC:result:[1:Set,Collection&,nest(Object)]
< **** ENC:OI.getVqual:[2:Set,Collection&,nest(Object)]
< **   ENC:result:[2:Set,Collection&]
< 
< **** getVqual:B2:
< [0:Set,Collection&]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OG:semCheck:e
< **   encOG: (current == e)
< **** Invocation:semCheck: e
< **   encOG:(current == e)
< **** OI:semCheck: "e" rec: "none"
< **   encOG:(current == e)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:
< B := true
<    leave(has)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:true
< **   encOG: 
< B := true
<    leave(has)
< **** Invocation:semCheck: true
< **   encOG:
< B := true
<    leave(has)
< 
< **** OI:semCheck: "true" rec: "B"
< **   encOG:
< B := true
<    leave(has)
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< B := true
<    leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=2 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< B := true
<    leave(has)
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** OI:getVqual:initial:B
< **   encOG:
< B := true
<    leave(has)
< **   OGs:[0:has,has]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:has,has]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: 
< B := true
<    leave(has)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: 
< B := true
<    leave(has)
< **   OGS:[0:has,has]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< B := true
<    leave(has)
< **   OGS:[0:has,has]
< **** ENC:OI.viaInclude:[0:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.viaInclude:[1:has]
< **   ENC:result:[1:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< **   ENC:result:[0:Set,Collection]
< **** viaInclude:GOT:
< [0:Set,Collection,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection,nest($0)]
< **** savedOGS:save:False[0:Set,Collection,nest($0)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($0)]
< **   OGS:[0:Set,Collection,nest($0)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,Collection,nest($0)]
< **** savedOGS:save:was:[0:Set,Collection,nest($0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($0)]
< **** OG:semCheck:leave(has)
< **   encOG: 
< B := true
<    leave(has)
< **** Invocation:semCheck: leave(has)
< **   encOG:
< B := true
<    leave(has)
< 
< **** OI:semCheck: "leave(has)" rec: "none"
< **   encOG:
< B := true
<    leave(has)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(has)
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(has)
< **** OG:semCheck:B := B
< **   encOG: 
< B := true
<    leave(has)
< **** Invocation:semCheck: 
< **   encOG:
< B := true
<    leave(has)
< 
< **** OG:semCheck:B
< **   encOG: B := B
< **** Invocation:semCheck: B
< **   encOG:B := B
< **** OI:semCheck: "B" rec: "B"
< **   encOG:B := B
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OI:getVqual: B on=2 pn=1 isNest=True getRtnQual=False
< **   encOG: B := B
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** OI:getVqual:initial:B
< **   encOG:B := B
< **   OGs:[0:has,has]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:has,has]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: B := B
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: B := B
< **   OGS:[0:has,has]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: B := B
< **   OGS:[0:has,has]
< **** ENC:OI.viaInclude:[0:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.viaInclude:[1:has]
< **   ENC:result:[1:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< **   ENC:result:[0:Set,Collection]
< **** viaInclude:GOT:
< [0:Set,Collection,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection,nest($0)]
< **** savedOGS:save:False[0:Set,Collection,nest($0)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($0)]
< **   OGS:[0:Set,Collection,nest($0)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,Collection,nest($0)]
< **** savedOGS:save:was:[0:Set,Collection,nest($0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< B := B
< **** OG:semcheck:IS not empty:eOG: 
< B := B
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< out B: var Boolean
<    B := head == none
< **   encOG: 
< out B: var Boolean
<    B := head == none
< **** Invocation:semCheck: 
< **   encOG:
< out B: var Boolean
<    B := head == none
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< out B: var Boolean
<    B := head == none
< **** Invocation:semCheck: Boolean
< **   encOG:
< out B: var Boolean
<    B := head == none
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< out B: var Boolean
<    B := head == none
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    B := head == none
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:head == none
< **   encOG: 
< out B: var Boolean
<    B := head == none
< **** Invocation:semCheck: head == none
< **   encOG:
< out B: var Boolean
<    B := head == none
< 
< **** OI:semCheck: "head" rec: "B"
< **   encOG:
< out B: var Boolean
<    B := head == none
< 
< **** OI:semCheck: "== none" rec: "head"
< **   encOG:
< out B: var Boolean
<    B := head == none
< 
< **** Pattern:checkActualArgs:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: none
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< out B: var Boolean
<    B := head == none
< **   argAtInx: 1 in:PTN:
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == none
< **   fArg: in objx: ref Object
< **   aArg: none
< **   theOI.f.f:label: ObjectGenerator
< head == none
< **   encOG:
< out B: var Boolean
<    B := head == none
< **   savedOGS: [0:Set,nest(link),Object]
< **** PTN:getOGsequenceOfArg: 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   theOI: == none
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 56
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set,nest(link),Object]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:Set,nest(link),Object,nest(==)]
< **   getOGsequenceOfArg:aArgs:none
< **   fArgs.origin.OG=theFargsOG: 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:Set,nest(link),Object,nest(==)]
< **   theFargOG:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,nest(link),Object,nest(==)]
< **** DataItem:getVqual: in objx: ref Object
< [0:Set,nest(link),Object,nest(==)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:Set,nest(link),Object,nest(==)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link),Object,nest(==)]
< **   encOG: 
< out B: var Boolean
<    B := head == none
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,nest(link),Object,nest(==)]
< **   ENC:result:[1:Set,nest(link),Object]
< **** ENC:OI.getVqual:[2:Set,nest(link),Object]
< **** pathToSuper: "" of:DOG:
< in e: ref elm
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in e: ref elm
<    in next: ref link
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Set,nest(link)]
< **   ENC:result:[3:Set]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:none
< **   encOG: head == none
< **** Invocation:semCheck: none
< **   encOG:head == none
< **** OI:semCheck: "none" rec: "none"
< **   encOG:head == none
< **** Pattern:checkActualArgs:
< none: 
<    %basic 19
<    none_x: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:head == none**** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out B: var Boolean
<    B := head == none
< 
< **** OI:getVqual:initial:B
< **   encOG:
< out B: var Boolean
<    B := head == none
< **   OGs:[0:isEmpty]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:isEmpty]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:isEmpty]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isEmpty]
< **   encOG: 
< out B: var Boolean
<    B := head == none
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< out B: var Boolean
<    B := head == none
< **   OGS:[0:isEmpty]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< out B: var Boolean
<    B := head == none
< **   OGS:[0:isEmpty]
< **** ENC:OI.viaInclude:[0:isEmpty]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest(isEmpty)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest(isEmpty)]
< **** savedOGS:save:False[0:Set,nest(isEmpty)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(isEmpty)]
< **   OGS:[0:Set,nest(isEmpty)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(isEmpty)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,nest(isEmpty)]
< **** savedOGS:save:was:[0:Set,nest(isEmpty)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(isEmpty)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(isEmpty)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< out B: var Boolean
<    B := head == none
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:head := link(e,head)
< **   encOG: head := link(e,head)
< **** Invocation:semCheck: 
< **   encOG:head := link(e,head)
< **** OG:semCheck:link(e,head)
< **   encOG: head := link(e,head)
< **** Invocation:semCheck: link(e,head)
< **   encOG:head := link(e,head)
< **** OI:semCheck: "link(e,head)" rec: "head"
< **   encOG:head := link(e,head)
< **** Pattern:checkActualArgs:
< link: 
<    in e: ref elm
<    in next: ref link
< **   actualArgs: (e,head)
< **   fArgs(in e: ref elm,in next: ref link,)
< 
< **   encOG:head := link(e,head)**   argAtInx: 1 in:PTN:
< link: 
<    in e: ref elm
<    in next: ref link
< **   theOI: link(e,head)
< **   fArg: in e: ref elm
< **   aArg: e
< **   theOI.f.f:label: ObjectGenerator
< link(e,head)
< **   encOG:head := link(e,head)
< **   savedOGS: [0:Set]
< **** PTN:getOGsequenceOfArg: 
< link: 
<    in e: ref elm
<    in next: ref link
< **   theOI: link(e,head)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:Set,nest(link)]
< **   getOGsequenceOfArg:aArgs:(e,head)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    in next: ref link
< **   OGS: [0:Set,nest(link)]
< **   theFargOG:
< 
< in e: ref elm
<    in next: ref link
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,nest(link)]
< **** DataItem:getVqual: in e: ref elm
< [0:Set,nest(link)]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:Set,nest(link)]
< 
< **** OI:getVqual: elm on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link)]
< **   encOG: head := link(e,head)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    in next: ref link
< **** ENC:OI.getVqual:[1:Set,nest(link)]
< **   ENC:result:[1:Set]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OG:semCheck:e
< **   encOG: link(e,head)
< **** Invocation:semCheck: e
< **   encOG:link(e,head)
< **** OI:semCheck: "e" rec: "none"
< **   encOG:link(e,head)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   argAtInx: 2 in:PTN:
< link: 
<    in e: ref elm
<    in next: ref link
< **   theOI: link(e,head)
< **   fArg: in next: ref link
< **   aArg: head
< **   theOI.f.f:label: ObjectGenerator
< link(e,head)
< **   encOG:head := link(e,head)
< **   savedOGS: [0:Set]
< **** PTN:getOGsequenceOfArg: 
< link: 
<    in e: ref elm
<    in next: ref link
< **   theOI: link(e,head)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in next: ref link
< **** Items:localSearch: next
< **   in:
< 
< in e: ref elm
< in next: ref link
< **   isChecked: True
< **   Items:localSearch:Decls: next
< Try: "e"
< Try: "next"
< **** Items:localSearch:end: next
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:Set,nest(link)]
< **   getOGsequenceOfArg:aArgs:(e,head)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    in next: ref link
< **   OGS: [0:Set,nest(link)]
< **   theFargOG:
< 
< in e: ref elm
<    in next: ref link
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,nest(link)]
< **** DataItem:getVqual: in next: ref link
< [0:Set,nest(link)]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Set,nest(link)]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link)]
< **   encOG: head := link(e,head)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in e: ref elm
<    in next: ref link
< **** ENC:OI.getVqual:[1:Set,nest(link)]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:head
< **   encOG: link(e,head)
< **** Invocation:semCheck: head
< **   encOG:link(e,head)
< **** OI:semCheck: "head" rec: "none"
< **   encOG:link(e,head)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< 
< **** OI:getVqual: head on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: head := link(e,head)
< 
< **** OI:getVqual:initial:head
< **   encOG:head := link(e,head)
< **   OGs:[0:Set]
< **   ATd: head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Set]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Set]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: head := link(e,head)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:initial:afterATd:head
< **   OGSx:[0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS: none
< **** OI:getVqual:end: head
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:"\nObs! Set:remove:not implemented!\n".print
< **   encOG: "\nObs! Set:remove:not implemented!\n".print
< **** Invocation:semCheck: 
< **   encOG:"\nObs! Set:remove:not implemented!\n".print
< **** OG:semCheck:"\nObs! Set:remove:not implemented!\n".print
< **   encOG: "\nObs! Set:remove:not implemented!\n".print
< **** Invocation:semCheck: "\nObs! Set:remove:not implemented!\n".print
< **   encOG:"\nObs! Set:remove:not implemented!\n".print
< **** OI:semCheck: "print" rec: ""\nObs! Set:remove:not implemented!\n""
< **   encOG:"\nObs! Set:remove:not implemented!\n".print
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:"\nObs! Set:remove:not implemented!\n".print**** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semcheck:IS not empty:eOG: 
< "\nObs! Set:remove:not implemented!\n".print
< **** OG:semCheck:
< out N: var integer
<    scan
<       N := N + 1
< **   encOG: 
< out N: var integer
<    scan
<       N := N + 1
< **** Invocation:semCheck: 
< **   encOG:
< out N: var integer
<    scan
<       N := N + 1
< 
< **** OG:semCheck:integer
< **   encOG: 
< out N: var integer
<    scan
<       N := N + 1
< **** Invocation:semCheck: integer
< **   encOG:
< out N: var integer
<    scan
<       N := N + 1
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out N: var integer
<    scan
<       N := N + 1
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out N: var integer
<    scan
<       N := N + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< scan
<    N := N + 1
< **   encOG: 
< out N: var integer
<    scan
<       N := N + 1
< **** Invocation:semCheck: scan
< **   encOG:
< out N: var integer
<    scan
<       N := N + 1
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< out N: var integer
<    scan
<       N := N + 1
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out N: var integer
<    scan
<       N := N + 1
< **** OG:semCheck:N + 1
< **   encOG: 
< scan
<    N := N + 1
< **** Invocation:semCheck: N + 1
< **   encOG:
< scan
<    N := N + 1
< 
< **** OI:semCheck: "N" rec: "N"
< **   encOG:
< scan
<    N := N + 1
< 
< **** OI:semCheck: "+ 1" rec: "N"
< **   encOG:
< scan
<    N := N + 1
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< scan
<    N := N + 1
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< N + 1
< **   encOG:
< scan
<    N := N + 1
< **   savedOGS: [0:Set,nest(scan$0),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set,nest(scan$0),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:Set,nest(scan$0),nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:Set,nest(scan$0),nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,nest(scan$0),nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:Set,nest(scan$0),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Set,nest(scan$0),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(scan$0),nest(integer),nest(+)]
< **   encOG: 
< scan
<    N := N + 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:Set,nest(scan$0),nest(integer),nest(+)]
< **   ENC:result:[1:Set,nest(scan$0),nest(integer)]
< **** ENC:OI.getVqual:[2:Set,nest(scan$0),nest(integer)]
< **   ENC:result:[2:Set,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:Set,nest(scan$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Set,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:Set,nest(scan$0)]
< **** savedOGS:save:False[0:Set,nest(scan$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS:[0:Set,nest(scan$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< **** OG:semCheck:1
< **   encOG: N + 1
< **** Invocation:semCheck: 1
< **   encOG:N + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: N on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< scan
<    N := N + 1
< 
< **** OI:getVqual:initial:N
< **   encOG:
< scan
<    N := N + 1
< **   OGs:[0:card]
< **   ATd: out N: var integer
< **** DataItem:getVqual: out N: var integer
< [0:card]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:card]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:card]
< **   encOG: 
< scan
<    N := N + 1
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< scan
<    N := N + 1
< **   OGS:[0:card]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< scan
<    N := N + 1
< **   OGS:[0:card]
< **** ENC:OI.viaInclude:[0:card]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest(scan$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Set,nest(scan$0)]
< **** savedOGS:save:False[0:Set,nest(scan$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS:[0:Set,nest(scan$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:N
< **   OGSx:[0:Set,nest(scan$0)]
< **** savedOGS:save:was:[0:Set,nest(scan$0)]
< **   OI: N
< **   OI:getQual:savedOI:N
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: N
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    N := N + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< out N: var integer
<    scan
<       N := N + 1
< **** OG:returnDecl: out N: var integer
< **** OG:semCheck:head := none
< **   encOG: head := none
< **** Invocation:semCheck: 
< **   encOG:head := none
< **** OG:semCheck:none
< **   encOG: head := none
< **** Invocation:semCheck: none
< **   encOG:head := none
< **** OI:semCheck: "none" rec: "head"
< **   encOG:head := none
< **** Pattern:checkActualArgs:
< none: 
<    %basic 19
<    none_x: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:head := none**** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< 
< **** OI:getVqual: head on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: head := none
< 
< **** OI:getVqual:initial:head
< **   encOG:head := none
< **   OGs:[0:Set]
< **   ATd: head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Set]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Set]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: head := none
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:initial:afterATd:head
< **   OGSx:[0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS: none
< **** OI:getVqual:end: head
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semcheck:IS not empty:eOG: 
< head := none
< **** OG:semCheck:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** Invocation:semCheck: 
< **   encOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** OG:semCheck:head
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** Invocation:semCheck: head
< **   encOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** OI:semCheck: "head" rec: "nxt"
< **   encOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< 
< **** OI:getVqual: nxt on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** OI:getVqual:initial:nxt
< **   encOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGs:[0:scan]
< **   ATd: nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:initial:afterATd:nxt
< **   OGSx:[0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS: none
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **   encOG: 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< 
< **** OG:semCheck:this(scan).nxt.next
< **   encOG: 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **** Invocation:semCheck: this(scan).nxt.next
< **   encOG:
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< 
< **** OI:semCheck: "this(scan)" rec: "nxtt"
< **   encOG:
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< 
< **** OI:semCheck: "nxt" rec: "this(scan)"
< **   encOG:
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< 
< **** OI:semCheck: "next" rec: "nxt"
< **   encOG:
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< 
< **** OI:getVqual: nxtt on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< 
< **** OI:getVqual:initial:nxtt
< **   encOG:
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **   OGs:[0:scanTail]
< **   ATd: nxtt: ref link
< **** DataItem:getVqual: nxtt: ref link
< [0:scanTail]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scanTail]
< 
< **** OI:getVqual: link on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scanTail]
< **   encOG: 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **** koks: link on: 2 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **** ENC:OI.getVqual:[1:scanTail]
< **   ENC:result:[1:scan]
< **** ENC:OI.getVqual:[2:scan]
< **   ENC:result:[2:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:initial:afterATd:nxtt
< **   OGSx:[0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxtt
< **   OI:getQual:savedOI:nxtt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS: none
< **** OI:getVqual:end: nxtt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:
< if (nxtt =/= none) :then 
<    current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **   encOG: 
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< **** Invocation:semCheck: if (nxtt =/= none) :then 
<    current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **   encOG:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< 
< **** OG:semCheck:(nxtt =/= none)
< **   encOG: 
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< **** Invocation:semCheck: (nxtt =/= none)
< **   encOG:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< 
< **** Invocation:semCheck: nxtt =/= none
< **   encOG:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< 
< **** OI:semCheck: "nxtt" rec: "none"
< **   encOG:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< 
< **** OI:semCheck: "=/= none" rec: "nxtt"
< **   encOG:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: none
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   theOI: =/= none
< **   fArg: in objx: ref Object
< **   aArg: none
< **   theOI.f.f:label: BracketedExp
< (nxtt =/= none)
< **   encOG:
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< **   savedOGS: [0:Set,nest(link),Object]
< **** PTN:getOGsequenceOfArg: 
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   theOI: =/= none
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 57
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set,nest(link),Object]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:Set,nest(link),Object,nest(=/=)]
< **   getOGsequenceOfArg:aArgs:none
< **   fArgs.origin.OG=theFargsOG: 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:Set,nest(link),Object,nest(=/=)]
< **   theFargOG:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,nest(link),Object,nest(=/=)]
< **** DataItem:getVqual: in objx: ref Object
< [0:Set,nest(link),Object,nest(=/=)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:Set,nest(link),Object,nest(=/=)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link),Object,nest(=/=)]
< **   encOG: 
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,nest(link),Object,nest(=/=)]
< **   ENC:result:[1:Set,nest(link),Object]
< **** ENC:OI.getVqual:[2:Set,nest(link),Object]
< **** pathToSuper: "" of:DOG:
< in e: ref elm
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in e: ref elm
<    in next: ref link
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Set,nest(link)]
< **   ENC:result:[3:Set]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:none
< **   encOG: (nxtt =/= none)
< **** Invocation:semCheck: none
< **   encOG:(nxtt =/= none)
< **** OI:semCheck: "none" rec: "none"
< **   encOG:(nxtt =/= none)
< **** Pattern:checkActualArgs:
< none: 
<    %basic 19
<    none_x: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:(nxtt =/= none)**** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:nxtt.e
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** Invocation:semCheck: nxtt.e
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:semCheck: "nxtt" rec: "current"
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:semCheck: "e" rec: "nxtt"
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OI:getVqual: current on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:getVqual:initial:current
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **   OGs:[0:scanTail]
< **   ATd: current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scanTail]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scanTail]
< 
< **** OI:getVqual: elm on=2 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:scanTail]
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** koks: elm on: 2 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **** ENC:OI.getVqual:[1:scanTail]
< **   ENC:result:[1:scan]
< **** ENC:OI.getVqual:[2:scan]
< **   ENC:result:[2:Set]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:initial:afterATd:current
< **   OGSx:[0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS: none
< **** OI:getVqual:end: current
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OG:semCheck:inner(scanTail)
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** Invocation:semCheck: inner(scanTail)
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:semCheck: "inner(scanTail)" rec: "none"
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** OG:semCheck:nxtt.next
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** Invocation:semCheck: nxtt.next
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:semCheck: "nxtt" rec: "nxtt"
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:semCheck: "next" rec: "nxtt"
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< 
< **** OI:getVqual: nxtt on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:getVqual:initial:nxtt
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **   OGs:[0:scanTail]
< **   ATd: nxtt: ref link
< **** DataItem:getVqual: nxtt: ref link
< [0:scanTail]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scanTail]
< 
< **** OI:getVqual: link on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scanTail]
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** koks: link on: 2 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **** ENC:OI.getVqual:[1:scanTail]
< **   ENC:result:[1:scan]
< **** ENC:OI.getVqual:[2:scan]
< **   ENC:result:[2:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:initial:afterATd:nxtt
< **   OGSx:[0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxtt
< **   OI:getQual:savedOI:nxtt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS: none
< **** OI:getVqual:end: nxtt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:restart(loop)
< **   encOG: 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxtt.e
<    inner(scanTail)
<    nxtt := nxtt.next
<    restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (nxtt =/= none) :then 
<       current := nxtt.e
<       inner(scanTail)
<       nxtt := nxtt.next
<       restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
<       if (nxtt =/= none) :then 
< ...
< **** OG:semCheck:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** Invocation:semCheck: if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< :else 
<    nxt := nxt
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OG:semCheck:(nxt =/= none)
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** Invocation:semCheck: (nxt =/= none)
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** Invocation:semCheck: nxt =/= none
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:semCheck: "nxt" rec: "none"
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:semCheck: "=/= none" rec: "nxt"
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** Pattern:checkActualArgs:
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   actualArgs: none
< **   fArgs(in objx: ref Object,)
< 
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   argAtInx: 1 in:PTN:
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   theOI: =/= none
< **   fArg: in objx: ref Object
< **   aArg: none
< **   theOI.f.f:label: BracketedExp
< (nxt =/= none)
< **   encOG:
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   savedOGS: [0:Set,nest(link),Object]
< **** PTN:getOGsequenceOfArg: 
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   theOI: =/= none
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in objx: ref Object
< **** Items:localSearch: objx
< **   in:
< 
< %basic 57
< in objx: ref Object
< out V: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: objx
< Try: "objx"
< **** Items:localSearch:end: objx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set,nest(link),Object]
< **   OGS.DOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   After:[0:Set,nest(link),Object,nest(=/=)]
< **   getOGsequenceOfArg:aArgs:none
< **   fArgs.origin.OG=theFargsOG: 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   OGS: [0:Set,nest(link),Object,nest(=/=)]
< **   theFargOG:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,nest(link),Object,nest(=/=)]
< **** DataItem:getVqual: in objx: ref Object
< [0:Set,nest(link),Object,nest(=/=)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:Set,nest(link),Object,nest(=/=)]
< 
< **** OI:getVqual: Object on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link),Object,nest(=/=)]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: Object on: 2 Items 
< **   father: Object
< **   father.f.f.f.f:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,nest(link),Object,nest(=/=)]
< **   ENC:result:[1:Set,nest(link),Object]
< **** ENC:OI.getVqual:[2:Set,nest(link),Object]
< **** pathToSuper: "" of:DOG:
< in e: ref elm
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in e: ref elm
<    in next: ref link
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Set,nest(link)]
< **   ENC:result:[3:Set]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** Pattern:getVqual: Object :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:none
< **   encOG: (nxt =/= none)
< **** Invocation:semCheck: none
< **   encOG:(nxt =/= none)
< **** OI:semCheck: "none" rec: "none"
< **   encOG:(nxt =/= none)
< **** Pattern:checkActualArgs:
< none: 
<    %basic 19
<    none_x: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:(nxt =/= none)**** OG:semcheck:IS not empty:eOG: 
< 
< %basic 19
<    none_x: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var boolean
< **** OG:semCheck:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:nxt.e
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: nxt.e
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "nxt" rec: "current"
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "e" rec: "nxt"
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OI:getVqual: current on=2 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** PRE: [0:scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:result:[0:scan,scan]
< 
< **** OI:getVqual:initial:current
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGs:[0:scan,scan]
< **   ATd: current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan,scan]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan,scan]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan,scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[1:scan,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   ENC:pred:  pred.DOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[2:scan]
< **   ENC:result:[2:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Set,Collection]
< **   ENC:result:[1:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:initial:afterATd:current
< **   OGSx:[0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS: none
< **** OI:getVqual:end: current
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OG:semCheck:inner(scan)
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: inner(scan)
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "inner(scan)" rec: "none"
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OG:semCheck:nxt.next
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: nxt.next
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "nxt" rec: "nxt"
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "next" rec: "nxt"
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual:initial:nxt
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGs:[0:scan]
< **   ATd: nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:initial:afterATd:nxt
< **   OGSx:[0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS: none
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semCheck:restart(Loop)
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: restart(Loop)
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:semCheck: "restart(Loop)" rec: "none"
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OG:semCheck:nxt := nxt
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** Invocation:semCheck: 
< **   encOG:
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OG:semCheck:nxt
< **   encOG: nxt := nxt
< **** Invocation:semCheck: nxt
< **   encOG:nxt := nxt
< **** OI:semCheck: "nxt" rec: "nxt"
< **   encOG:nxt := nxt
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: nxt := nxt
< 
< **** OI:getVqual:initial:nxt
< **   encOG:nxt := nxt
< **   OGs:[0:scan]
< **   ATd: nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: nxt := nxt
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:initial:afterATd:nxt
< **   OGSx:[0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS: none
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OG:semcheck:IS not empty:eOG: 
< nxt := nxt
< **** OG:semcheck:IS not empty:eOG: 
< nxt := nxt
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** OG:semCheck:
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **   encOG: 
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** Invocation:semCheck: 
< **   encOG:
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** OG:semCheck:
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **   encOG: 
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** Invocation:semCheck: scan
< **   encOG:
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** OG:semCheck:current
< **   encOG: 
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** Invocation:semCheck: current
< **   encOG:
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** OI:semCheck: "current" rec: "current"
< **   encOG:
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OI:getVqual: current on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** OI:getVqual:initial:current
< **   encOG:
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **   OGs:[0:scan$0]
< **   ATd: current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan$0]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan$0]
< 
< **** OI:getVqual: elm on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$0]
< **   encOG: 
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** ENC:OI.getVqual:[1:scan$0]
< **   ENC:result:[1:forAllX]
< **** PRE: [0:forAllX]
< **** pathToSuper: "" of:DOG:
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **   innerDOG: 
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   PRE:result:[0:forAllX,Object]
< 
< **** getVqual:B2:
< [0:forAllX,Object]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:forAllX,Object]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:forAllX,Object]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:forAllX,Object]
< **** searchBinding: in elm:< Object
< [0:forAllX]
< **   checkDOG: forAllX 
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< father:
< forAllX: 
<    current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
< ...
< **   Ex: 
< **   Ex.OGs.super:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   checkDOG: Object 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< father:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< !!!! No binding found in OGsequence! Use: in elm:< Object
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:forAllX,Object]
< **** savedOGS:save:False[0:forAllX,Object]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAllX,Object]
< **   OGS:[0:forAllX,Object]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:forAllX,Object]
< 
< **** getVqual:initial:afterATd:current
< **   OGSx:[0:forAllX,Object]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS: none
< **** OI:getVqual:end: current
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:forAllX,Object]
< **** OG:semCheck:
< inner(forAllX)
< -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **   encOG: 
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** Invocation:semCheck: inner(forAllX)
< -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **   encOG:
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** OI:semCheck: "inner(forAllX)" rec: "none"
< **   encOG:
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    (this(forAllX)).current := current
<    inner(forAllX)
<    -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** OG:semcheck:IS not empty:eOG: 
< 
< current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
<       -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
< **** OG:semCheck:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** OG:semCheck:
< in x: ref Object
<    out V: var Boolean
< **   encOG: 
< in x: ref Object
<    out V: var Boolean
< **** Invocation:semCheck: 
< **   encOG:
< in x: ref Object
<    out V: var Boolean
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in x: ref Object
<    out V: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< in x: ref Object
<    out V: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in x: ref Object
<    out V: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in x: ref Object
<    out V: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in x: ref Object
<    out V: var Boolean
< **** OG:returnDecl: out V: var Boolean
< **** OG:semCheck:Boolean
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:true
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** Invocation:semCheck: true
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** OI:semCheck: "true" rec: "B"
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** OI:getVqual:initial:B
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **   OGs:[0:forAll]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:forAll]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:forAll]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:forAll]
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **   OGS:[0:forAll]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **   OGS:[0:forAll]
< **** ENC:OI.viaInclude:[0:forAll]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest(forAll)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest(forAll)]
< **** savedOGS:save:False[0:Set,nest(forAll)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(forAll)]
< **   OGS:[0:Set,nest(forAll)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(forAll)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,nest(forAll)]
< **** savedOGS:save:was:[0:Set,nest(forAll)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(forAll)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(forAll)]
< **** OG:semCheck:
< scan
<    B := B && pred(current)
< **   encOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** OG:semCheck:B && pred(current)
< **   encOG: 
< scan
<    B := B && pred(current)
< **** Invocation:semCheck: B && pred(current)
< **   encOG:
< scan
<    B := B && pred(current)
< 
< **** OI:semCheck: "B" rec: "B"
< **   encOG:
< scan
<    B := B && pred(current)
< 
< **** OI:semCheck: "&& pred(current)" rec: "B"
< **   encOG:
< scan
<    B := B && pred(current)
< 
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: pred(current)
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< scan
<    B := B && pred(current)
< **   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && pred(current)
< **   fArg: in B: var boolean
< **   aArg: pred(current)
< **   theOI.f.f:label: ObjectGenerator
< B && pred(current)
< **   encOG:
< scan
<    B := B && pred(current)
< **   savedOGS: [0:Set,nest(scan$0),nest(Boolean)]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && pred(current)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Set,nest(scan$0),nest(Boolean)]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Set,nest(scan$0),nest(Boolean),nest(&&)]
< **   getOGsequenceOfArg:aArgs:pred(current)
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Set,nest(scan$0),nest(Boolean),nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Set,nest(scan$0),nest(Boolean),nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:Set,nest(scan$0),nest(Boolean),nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Set,nest(scan$0),nest(Boolean),nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(scan$0),nest(Boolean),nest(&&)]
< **   encOG: 
< scan
<    B := B && pred(current)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Set,nest(scan$0),nest(Boolean),nest(&&)]
< **   ENC:result:[1:Set,nest(scan$0),nest(Boolean)]
< **** ENC:OI.getVqual:[2:Set,nest(scan$0),nest(Boolean)]
< **   ENC:result:[2:Set,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:Set,nest(scan$0)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set,nest(scan$0)]
< **** savedOGS:save:False[0:Set,nest(scan$0)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS:[0:Set,nest(scan$0)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< **** OG:semCheck:pred(current)
< **   encOG: B && pred(current)
< **** Invocation:semCheck: pred(current)
< **   encOG:B && pred(current)
< **** OI:semCheck: "pred(current)" rec: "none"
< **   encOG:B && pred(current)
< **** Pattern:checkActualArgs:
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< **   actualArgs: pred(current)
< **   fArgs(in x: ref Object,)
< 
< **   encOG:B && pred(current)**   argAtInx: 1 in:PTN:
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< **   theOI: pred(current)
< **   fArg: in x: ref Object
< **   aArg: current
< **   theOI.f.f:label: ObjectGenerator
< pred(current)
< **   encOG:B && pred(current)
< **   savedOGS: [0:forAll&]
< **** PTN:getOGsequenceOfArg: 
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< **   theOI: pred(current)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in x: ref Object
< **** Items:localSearch: x
< **   in:
< 
< in x: ref Object
< out V: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: x
< Try: "x"
< **** Items:localSearch:end: x
< **   pathTo:parDecl:pn:0
< **   OGS:[0:forAll&]
< **   OGS.DOG:
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **   After:[0:forAll&,nest(pred)]
< **   getOGsequenceOfArg:aArgs:pred(current)
< **   fArgs.origin.OG=theFargsOG: 
< in x: ref Object
<    out V: var Boolean
< **   OGS: [0:forAll&,nest(pred)]
< **   theFargOG:
< 
< in x: ref Object
<    out V: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:forAll&,nest(pred)]
< **** DataItem:getVqual: in x: ref Object
< [0:forAll&,nest(pred)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:forAll&,nest(pred)]
< 
< **** OI:getVqual: Object on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:forAll&,nest(pred)]
< **   encOG: B && pred(current)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Object
< **   encOG: B && pred(current)
< **   OGS:[0:forAll&,nest(pred)]
< ***** viaInclude:notTop: Object name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Object
< **   encOG: B && pred(current)
< **   OGS:[0:forAll&,nest(pred)]
< **** ENC:OI.viaInclude:[0:forAll&,nest(pred)]
< **   ENC:result:[0:forAll&]
< **** viaInclude:GOT:
< [0:forAll&,nest(&&)]
< **** Pattern:getVqual: Object :isVirtual:False
< [0:forAll&,nest(&&)]
< **** savedOGS:save:False[0:forAll&,nest(&&)]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAll&,nest(&&)]
< **   OGS:[0:forAll&,nest(&&)]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:forAll&,nest(&&)]
< **** OG:semCheck:current
< **   encOG: pred(current)
< **** Invocation:semCheck: current
< **   encOG:pred(current)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:pred(current)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< scan
<    B := B && pred(current)
< 
< **** OI:getVqual:initial:B
< **   encOG:
< scan
<    B := B && pred(current)
< **   OGs:[0:forAll]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:forAll]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:forAll]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:forAll]
< **   encOG: 
< scan
<    B := B && pred(current)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    B := B && pred(current)
< **   OGS:[0:forAll]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    B := B && pred(current)
< **   OGS:[0:forAll]
< **** ENC:OI.viaInclude:[0:forAll]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest(scan$0)]
< **** savedOGS:save:False[0:Set,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS:[0:Set,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,nest(scan$0)]
< **** savedOGS:save:was:[0:Set,nest(scan$0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    B := B && pred(current)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **   encOG: 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< 
< **** OG:semCheck:
< in x: ref elm
<    out V: var Boolean
< **   encOG: 
< in x: ref elm
<    out V: var Boolean
< **** Invocation:semCheck: 
< **   encOG:
< in x: ref elm
<    out V: var Boolean
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in x: ref elm
<    out V: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< in x: ref elm
<    out V: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in x: ref elm
<    out V: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in x: ref elm
<    out V: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in x: ref elm
<    out V: var Boolean
< **** OG:returnDecl: out V: var Boolean
< **** OG:semCheck:Boolean
< **   encOG: 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **   encOG: 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:Fxx(current)
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** Invocation:semCheck: Fxx(current)
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** OI:semCheck: "Fxx(current)" rec: "BBB"
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** Pattern:checkActualArgs:
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **   actualArgs: Fxx(current)
< **   fArgs(in x: ref elm,)
< 
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **   argAtInx: 1 in:PTN:
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **   theOI: Fxx(current)
< **   fArg: in x: ref elm
< **   aArg: current
< **   theOI.f.f:label: ObjectGenerator
< Fxx(current)
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **   savedOGS: [0:exists&]
< **** PTN:getOGsequenceOfArg: 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **   theOI: Fxx(current)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in x: ref elm
< **** Items:localSearch: x
< **   in:
< 
< in x: ref elm
< out V: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: x
< Try: "x"
< **** Items:localSearch:end: x
< **   pathTo:parDecl:pn:0
< **   OGS:[0:exists&]
< **   OGS.DOG:
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **   After:[0:exists&,nest(Fxx)]
< **   getOGsequenceOfArg:aArgs:Fxx(current)
< **   fArgs.origin.OG=theFargsOG: 
< in x: ref elm
<    out V: var Boolean
< **   OGS: [0:exists&,nest(Fxx)]
< **   theFargOG:
< 
< in x: ref elm
<    out V: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:exists&,nest(Fxx)]
< **** DataItem:getVqual: in x: ref elm
< [0:exists&,nest(Fxx)]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:exists&,nest(Fxx)]
< 
< **** OI:getVqual: elm on=2 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:exists&,nest(Fxx)]
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** koks: elm on: 2 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in x: ref elm
<    out V: var Boolean
< **** ENC:OI.getVqual:[1:exists&,nest(Fxx)]
< **   ENC:result:[1:exists&]
< **** ENC:OI.getVqual:[2:exists&]
< **   ENC:result:[2:Set]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OG:semCheck:current
< **   encOG: Fxx(current)
< **** Invocation:semCheck: current
< **   encOG:Fxx(current)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:Fxx(current)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out V: var Boolean
< 
< **** OI:getVqual: BBB on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** OI:getVqual:initial:BBB
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **   OGs:[0:scan$0]
< **   ATd: BBB: var Boolean
< **** DataItem:getVqual: BBB: var Boolean
< [0:scan$0]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:scan$0]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$0]
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **   OGS:[0:scan$0]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **   OGS:[0:scan$0]
< **** ENC:OI.viaInclude:[0:scan$0]
< **   ENC:result:[0:exists]
< **** viaInclude:GOT:
< [0:exists,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:exists,nest(scan$0)]
< **** savedOGS:save:False[0:exists,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:exists,nest(scan$0)]
< **   OGS:[0:exists,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:exists,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:BBB
< **   OGSx:[0:exists,nest(scan$0)]
< **** savedOGS:save:was:[0:exists,nest(scan$0)]
< **   OI: BBB
< **   OI:getQual:savedOI:BBB
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:exists,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: BBB
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:exists,nest(scan$0)]
< **** OG:semCheck:
< if (BBB) :then 
<    B := true
<    leave(scan)
< :else 
<    B := B
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** Invocation:semCheck: if (BBB) :then 
<    B := true
<    leave(scan)
< :else 
<    B := B
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** OG:semCheck:(BBB)
< **   encOG: 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** Invocation:semCheck: (BBB)
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** Invocation:semCheck: BBB
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** OI:semCheck: "BBB" rec: "none"
< **   encOG:
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< B := true
<    leave(scan)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:true
< **   encOG: 
< B := true
<    leave(scan)
< **** Invocation:semCheck: true
< **   encOG:
< B := true
<    leave(scan)
< 
< **** OI:semCheck: "true" rec: "B"
< **   encOG:
< B := true
<    leave(scan)
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< B := true
<    leave(scan)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< B := true
<    leave(scan)
< 
< **** OI:getVqual:initial:B
< **   encOG:
< B := true
<    leave(scan)
< **   OGs:[0:exists]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:exists]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:exists]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:exists]
< **   encOG: 
< B := true
<    leave(scan)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< B := true
<    leave(scan)
< **   OGS:[0:exists]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< B := true
<    leave(scan)
< **   OGS:[0:exists]
< **** ENC:OI.viaInclude:[0:exists]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest($0)]
< **** savedOGS:save:False[0:Set,nest($0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest($0)]
< **   OGS:[0:Set,nest($0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest($0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,nest($0)]
< **** savedOGS:save:was:[0:Set,nest($0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest($0)]
< **** OG:semCheck:leave(scan)
< **   encOG: 
< B := true
<    leave(scan)
< **** Invocation:semCheck: leave(scan)
< **   encOG:
< B := true
<    leave(scan)
< 
< **** OI:semCheck: "leave(scan)" rec: "none"
< **   encOG:
< B := true
<    leave(scan)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(scan)
< **** OG:semcheck:IS not empty:eOG: 
< 
< B := true
<    leave(scan)
< **** OG:semCheck:B := B
< **   encOG: 
< B := true
<    leave(scan)
< **** Invocation:semCheck: 
< **   encOG:
< B := true
<    leave(scan)
< 
< **** OG:semCheck:B
< **   encOG: B := B
< **** Invocation:semCheck: B
< **   encOG:B := B
< **** OI:semCheck: "B" rec: "B"
< **   encOG:B := B
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OI:getVqual: B on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: B := B
< 
< **** OI:getVqual:initial:B
< **   encOG:B := B
< **   OGs:[0:exists]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:exists]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:exists]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:exists]
< **   encOG: B := B
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: B := B
< **   OGS:[0:exists]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: B := B
< **   OGS:[0:exists]
< **** ENC:OI.viaInclude:[0:exists]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest($0)]
< **** savedOGS:save:False[0:Set,nest($0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest($0)]
< **   OGS:[0:Set,nest($0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest($0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Set,nest($0)]
< **** savedOGS:save:was:[0:Set,nest($0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< B := B
< **** OG:semcheck:IS not empty:eOG: 
< B := B
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    BBB: var Boolean
<    BBB := Fxx(current)
<    if (BBB) :then 
<       B := true
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OG:semCheck:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   encOG: 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **** Invocation:semCheck: 
< **   encOG:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **** Invocation:semCheck: Boolean
< **   encOG:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **** OG:returnDecl: out z: var Boolean
< **** OG:semCheck:Boolean
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:IV
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: IV
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "IV" rec: "V"
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OI:getVqual: V on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:getVqual:initial:V
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   OGs:[0:reduce]
< **   ATd: out V: var Boolean
< **** DataItem:getVqual: out V: var Boolean
< [0:reduce]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:reduce]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce]
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   OGS:[0:reduce]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   OGS:[0:reduce]
< **** ENC:OI.viaInclude:[0:reduce]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest(reduce)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest(reduce)]
< **** savedOGS:save:False[0:Set,nest(reduce)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(reduce)]
< **   OGS:[0:Set,nest(reduce)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(reduce)]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:Set,nest(reduce)]
< **** savedOGS:save:was:[0:Set,nest(reduce)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(reduce)]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(reduce)]
< **** OG:semCheck:
< scan
<    V := F(current,V)
< **   encOG: 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** Invocation:semCheck: scan
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:semCheck:F(current,V)
< **   encOG: 
< scan
<    V := F(current,V)
< **** Invocation:semCheck: F(current,V)
< **   encOG:
< scan
<    V := F(current,V)
< 
< **** OI:semCheck: "F(current,V)" rec: "V"
< **   encOG:
< scan
<    V := F(current,V)
< 
< **** Pattern:checkActualArgs:
< in F:< 
<    in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   actualArgs: (current,V)
< **   fArgs(in x: ref Object,in b: var Boolean,)
< 
< **   encOG:
< scan
<    V := F(current,V)
< **   argAtInx: 1 in:PTN:
< in F:< 
<    in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   fArg: in x: ref Object
< **   aArg: current
< **   theOI.f.f:label: ObjectGenerator
< F(current,V)
< **   encOG:
< scan
<    V := F(current,V)
< **   savedOGS: [0:reduce&]
< **** PTN:getOGsequenceOfArg: 
< in F:< 
<    in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in x: ref Object
< **** Items:localSearch: x
< **   in:
< 
< in x: ref Object
< in b: var Boolean
< out z: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: x
< Try: "x"
< **** Items:localSearch:end: x
< **   pathTo:parDecl:pn:0
< **   OGS:[0:reduce&]
< **   OGS.DOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   After:[0:reduce&,nest(F)]
< **   getOGsequenceOfArg:aArgs:(current,V)
< **   fArgs.origin.OG=theFargsOG: 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   OGS: [0:reduce&,nest(F)]
< **   theFargOG:
< 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:reduce&,nest(F)]
< **** DataItem:getVqual: in x: ref Object
< [0:reduce&,nest(F)]
< **** ObjectGenerator:getVqual: Object
< **   hasVirtualArgs: False
< **** INV:getVqual:Object
< **   OGs: [0:reduce&,nest(F)]
< 
< **** OI:getVqual: Object on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce&,nest(F)]
< **   encOG: 
< scan
<    V := F(current,V)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Object
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce&,nest(F)]
< ***** viaInclude:notTop: Object name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Object
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce&,nest(F)]
< **** ENC:OI.viaInclude:[0:reduce&,nest(F)]
< **   ENC:result:[0:reduce&]
< **** viaInclude:GOT:
< [0:reduce&,nest(scan$0)]
< **** Pattern:getVqual: Object :isVirtual:False
< [0:reduce&,nest(scan$0)]
< **** savedOGS:save:False[0:reduce&,nest(scan$0)]
< **   OI: Object
< **   OI:getQual:savedOI:Object
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:reduce&,nest(scan$0)]
< **   OGS:[0:reduce&,nest(scan$0)]
< **** OI:getVqual:end: Object
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:reduce&,nest(scan$0)]
< **** OG:semCheck:current
< **   encOG: F(current,V)
< **** Invocation:semCheck: current
< **   encOG:F(current,V)
< **** OI:semCheck: "current" rec: "none"
< **   encOG:F(current,V)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   argAtInx: 2 in:PTN:
< in F:< 
<    in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   fArg: in b: var Boolean
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< F(current,V)
< **   encOG:
< scan
<    V := F(current,V)
< **   savedOGS: [0:reduce&]
< **** PTN:getOGsequenceOfArg: 
< in F:< 
<    in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   theOI: F(current,V)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in b: var Boolean
< **** Items:localSearch: b
< **   in:
< 
< in x: ref Object
< in b: var Boolean
< out z: var Boolean
< **   isChecked: True
< **   Items:localSearch:Decls: b
< Try: "x"
< Try: "b"
< **** Items:localSearch:end: b
< **   pathTo:parDecl:pn:0
< **   OGS:[0:reduce&]
< **   OGS.DOG:
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **   After:[0:reduce&,nest(F)]
< **   getOGsequenceOfArg:aArgs:(current,V)
< **   fArgs.origin.OG=theFargsOG: 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   OGS: [0:reduce&,nest(F)]
< **   theFargOG:
< 
< in x: ref Object
<    in b: var Boolean
<    out z: var Boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:reduce&,nest(F)]
< **** DataItem:getVqual: in b: var Boolean
< [0:reduce&,nest(F)]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:reduce&,nest(F)]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce&,nest(F)]
< **   encOG: 
< scan
<    V := F(current,V)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce&,nest(F)]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce&,nest(F)]
< **** ENC:OI.viaInclude:[0:reduce&,nest(F)]
< **   ENC:result:[0:reduce&]
< **** viaInclude:GOT:
< [0:reduce&,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:reduce&,nest(scan$0)]
< **** savedOGS:save:False[0:reduce&,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:reduce&,nest(scan$0)]
< **   OGS:[0:reduce&,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:reduce&,nest(scan$0)]
< **** OG:semCheck:V
< **   encOG: F(current,V)
< **** Invocation:semCheck: V
< **   encOG:F(current,V)
< **** OI:semCheck: "V" rec: "none"
< **   encOG:F(current,V)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out z: var Boolean
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< scan
<    V := F(current,V)
< 
< **** OI:getVqual:initial:V
< **   encOG:
< scan
<    V := F(current,V)
< **   OGs:[0:reduce]
< **   ATd: out V: var Boolean
< **** DataItem:getVqual: out V: var Boolean
< [0:reduce]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:reduce]
< 
< **** OI:getVqual: Boolean on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:reduce]
< **   encOG: 
< scan
<    V := F(current,V)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    V := F(current,V)
< **   OGS:[0:reduce]
< **** ENC:OI.viaInclude:[0:reduce]
< **   ENC:result:[0:Set]
< **** viaInclude:GOT:
< [0:Set,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,nest(scan$0)]
< **** savedOGS:save:False[0:Set,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS:[0:Set,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:Set,nest(scan$0)]
< **** savedOGS:save:was:[0:Set,nest(scan$0)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,nest(scan$0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    V := F(current,V)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in F:< 
<       in x: ref Object
<       in b: var Boolean
<       out z: var Boolean
<    in IV: var Boolean
< ...
< **** OG:returnDecl: out V: var Boolean
< **** OG:semCheck:
< in e: ref elm
<    in next: ref link
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **** Invocation:semCheck: 
< **   encOG:
< in e: ref elm
<    in next: ref link
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in e: ref elm
<    in next: ref link
< **** OG:semCheck:inner(Set)
< **   encOG: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** Invocation:semCheck: inner(Set)
< **   encOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** OI:semCheck: "inner(Set)" rec: "none"
< **   encOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** OG:semCheck:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** Invocation:semCheck: 
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** Invocation:semCheck: "("
< **   encOG:
< print: 
<       put(ch)
< 
< **** OG:semCheck:char
< **   encOG: 
< print: 
<       put(ch)
< **** Invocation:semCheck: char
< **   encOG:
< print: 
<       put(ch)
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< print: 
<       put(ch)
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< print: 
<       put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Invocation:semCheck: ")"
< **   encOG:
< print: 
<       put(ch)
< 
< **** OG:semCheck:
< print: 
<       put(ch)
< **   encOG: 
< print: 
<       put(ch)
< **** Invocation:semCheck: 
< **   encOG:
< print: 
<       put(ch)
< 
< **** OG:semCheck:put(ch)
< **   encOG: put(ch)
< **** Invocation:semCheck: 
< **   encOG:put(ch)
< **** OG:semCheck:put(ch)
< **   encOG: put(ch)
< **** Invocation:semCheck: put(ch)
< **   encOG:put(ch)
< **** OI:semCheck: "put(ch)" rec: "none"
< **   encOG:put(ch)
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(ch)
< **   fArgs(in ch: val char,)
< 
< **   encOG:put(ch)**   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(ch)
< **   fArg: in ch: val char
< **   aArg: ch
< **   theOI.f.f:label: ObjectGenerator
< put(ch)
< **   encOG:put(ch)
< **   savedOGS: [0:Record,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(ch)
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Record,nest(print)]
< **   OGS.DOG:put(ch)
< **   After:[0:Record,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(ch)
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Record,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Record,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Record,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Record,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Record,nest(print),nest(put)]
< **   encOG: put(ch)
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Record,nest(print),nest(put)]
< **   ENC:result:[1:Record,nest(print)]
< 
< **** getVqual:B2:
< [0:Record,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Record,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Record,nest(print)]
< **** savedOGS:save:False[0:Record,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Record,nest(print)]
< **   OGS:[0:Record,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Record,nest(print)]
< **** OG:semCheck:ch
< **   encOG: put(ch)
< **** Invocation:semCheck: ch
< **   encOG:put(ch)
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< print: 
<       put(ch)
< **** OG:semCheck:Set(#Record)
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** Invocation:semCheck: Set(#Record)
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "Set(#Record)" rec: "none"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** Pattern:checkActualArgs:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   actualArgs: Set(#Record)
< **   fArgs(in elm:< Object,)
< 
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   argAtInx: 1 in:PTN:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Record)
< **   fArg: in elm:< Object
< **   aArg: #Record
< **   theOI.f.f:label: ObjectGenerator
< Set(#Record)
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   savedOGS: [0:SetLib]
< **** PTN:getOGsequenceOfArg: 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Record)
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "has"
< Try: "isEmpty"
< Try: "insert"
< Try: "remove"
< Try: "card"
< Try: "clear"
< Try: "scan"
< Try: "forAllX"
< Try: "forAll"
< Try: "exists"
< Try: "reduce"
< Try: "link"
< Try: "head"
< **** Signature:localSearch: elm in: Set
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< %id "Collection"
< %globals
< in elm:< Object
< scan:< 
<    %OSDvisibility skipInternal
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:SetLib]
< **   OGS.DOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   After:[0:SetLib,nest(Set)]
< **   getOGsequenceOfArg:aArgs:Set(#Record)
< **   fArgs.origin.OG=theFargsOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS: [0:SetLib,nest(Set)]
< **   theFargOG:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** PRE: [0:SetLib,nest(Set)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:SetLib,nest(Set),Collection]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:SetLib,nest(Set),Collection]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:SetLib,nest(Set),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:SetLib,nest(Set),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set),Collection]
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Record
< **   encOG: Set(#Record)
< **** Invocation:semCheck: #Record
< **   encOG:Set(#Record)
< **** OI:semCheck: "#Record" rec: "none"
< **   encOG:Set(#Record)
< **** OG:semcheck:IS not empty:eOG: 
< 
< print: 
<       put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** OG:semCheck:L.insert(Record('d'))
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** Invocation:semCheck: L.insert(Record('d'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "insert(Record('d'))" rec: "L"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(Record('d'))
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('d'))
< **   fArg: in e: ref elm
< **   aArg: Record('d')
< **   theOI.f.f:label: ObjectGenerator
< L.insert(Record('d'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   savedOGS: [0:SetLib,nest(Set&)]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('d'))
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:SetLib,nest(Set&)]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:SetLib,nest(Set&),nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(Record('d'))
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:SetLib,nest(Set&),nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:SetLib,nest(Set&),nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:SetLib,nest(Set&),nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:SetLib,nest(Set&),nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:SetLib,nest(Set&),nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:SetLib,nest(Set&),nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:SetLib,nest(Set&),nest(insert),insert]
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:SetLib,nest(Set&),nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:SetLib,nest(Set&),nest(insert)]
< **   ENC:result:[2:SetLib,nest(Set&)]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:SetLib,nest(Set&)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:SetLib,nest(Set&),Collection]
< **   ENC:result:[1:SetLib,nest(Set&),Collection]
< 
< **** getVqual:B2:
< [0:SetLib,nest(Set&),Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:SetLib,nest(Set&),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:SetLib,nest(Set&),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&),Collection]
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:SetLib,nest(Set&),Collection&]
< **** savedOGS:save:False[0:SetLib,nest(Set&),Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:SetLib,nest(Set&),Collection&]
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OG:semCheck:Record('d')
< **   encOG: L.insert(Record('d'))
< **** Invocation:semCheck: Record('d')
< **   encOG:L.insert(Record('d'))
< **** OI:semCheck: "Record('d')" rec: "none"
< **   encOG:L.insert(Record('d'))
< **** Pattern:checkActualArgs:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   actualArgs: Record('d')
< **   fArgs(ch: var char,)
< 
< **   encOG:L.insert(Record('d'))**   argAtInx: 1 in:PTN:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('d')
< **   fArg: ch: var char
< **   aArg: 'd'
< **   theOI.f.f:label: ObjectGenerator
< Record('d')
< **   encOG:L.insert(Record('d'))
< **   savedOGS: [0:test]
< **** PTN:getOGsequenceOfArg: 
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('d')
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: ch: var char
< **** Items:localSearch: ch
< **   in:
< 
< print: 
<    put(ch)
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "print"
< **** Signature:localSearch: ch in: Record(ch: var char)
< **** Items:localSearch: ch
< **   in:
< 
< %$B "("
< ch: var char
< %$E ")"
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< *** found in signature:paramItems: ch
< **** Signature:localSearch:end: ch
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:test]
< **   OGS.DOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   After:[0:test,nest(Record)]
< **   getOGsequenceOfArg:aArgs:Record('d')
< **   fArgs.origin.OG=theFargsOG: 
< print: 
<       put(ch)
< **   OGS: [0:test,nest(Record)]
< **   theFargOG:
< 
< print: 
<       put(ch)
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:test,nest(Record)]
< **** DataItem:getVqual: ch: var char
< [0:test,nest(Record)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:test,nest(Record)]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:test,nest(Record)]
< **   encOG: L.insert(Record('d'))
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: L.insert(Record('d'))
< **   OGS:[0:test,nest(Record)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: L.insert(Record('d'))
< **   OGS:[0:test,nest(Record)]
< **** ENC:OI.viaInclude:[0:test,nest(Record)]
< **   ENC:result:[0:test]
< **** viaInclude:GOT:
< [0:test,nest(insert)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:test,nest(insert)]
< **** savedOGS:save:False[0:test,nest(insert)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:test,nest(insert)]
< **   OGS:[0:test,nest(insert)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:test,nest(insert)]
< **** OG:semCheck:'d'
< **   encOG: Record('d')
< **** Invocation:semCheck: 'd'
< **   encOG:Record('d')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< print: 
<       put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:L.insert(Record('c'))
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** Invocation:semCheck: L.insert(Record('c'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "insert(Record('c'))" rec: "L"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(Record('c'))
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('c'))
< **   fArg: in e: ref elm
< **   aArg: Record('c')
< **   theOI.f.f:label: ObjectGenerator
< L.insert(Record('c'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   savedOGS: [0:SetLib,nest(Set&)]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('c'))
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:SetLib,nest(Set&)]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:SetLib,nest(Set&),nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(Record('c'))
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:SetLib,nest(Set&),nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:SetLib,nest(Set&),nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:SetLib,nest(Set&),nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:SetLib,nest(Set&),nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:SetLib,nest(Set&),nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:SetLib,nest(Set&),nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:SetLib,nest(Set&),nest(insert),insert]
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:SetLib,nest(Set&),nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:SetLib,nest(Set&),nest(insert)]
< **   ENC:result:[2:SetLib,nest(Set&)]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:SetLib,nest(Set&)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:SetLib,nest(Set&),Collection]
< **   ENC:result:[1:SetLib,nest(Set&),Collection]
< 
< **** getVqual:B2:
< [0:SetLib,nest(Set&),Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:SetLib,nest(Set&),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:SetLib,nest(Set&),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&),Collection]
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:SetLib,nest(Set&),Collection&]
< **** savedOGS:save:False[0:SetLib,nest(Set&),Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:SetLib,nest(Set&),Collection&]
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OG:semCheck:Record('c')
< **   encOG: L.insert(Record('c'))
< **** Invocation:semCheck: Record('c')
< **   encOG:L.insert(Record('c'))
< **** OI:semCheck: "Record('c')" rec: "none"
< **   encOG:L.insert(Record('c'))
< **** Pattern:checkActualArgs:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   actualArgs: Record('c')
< **   fArgs(ch: var char,)
< 
< **   encOG:L.insert(Record('c'))**   argAtInx: 1 in:PTN:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('c')
< **   fArg: ch: var char
< **   aArg: 'c'
< **   theOI.f.f:label: ObjectGenerator
< Record('c')
< **   encOG:L.insert(Record('c'))
< **   savedOGS: [0:test]
< **** PTN:getOGsequenceOfArg: 
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('c')
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: ch: var char
< **** Items:localSearch: ch
< **   in:
< 
< print: 
<    put(ch)
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "print"
< **** Signature:localSearch: ch in: Record(ch: var char)
< **** Items:localSearch: ch
< **   in:
< 
< %$B "("
< ch: var char
< %$E ")"
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< *** found in signature:paramItems: ch
< **** Signature:localSearch:end: ch
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:test]
< **   OGS.DOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   After:[0:test,nest(Record)]
< **   getOGsequenceOfArg:aArgs:Record('c')
< **   fArgs.origin.OG=theFargsOG: 
< print: 
<       put(ch)
< **   OGS: [0:test,nest(Record)]
< **   theFargOG:
< 
< print: 
<       put(ch)
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:test,nest(Record)]
< **** DataItem:getVqual: ch: var char
< [0:test,nest(Record)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:test,nest(Record)]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:test,nest(Record)]
< **   encOG: L.insert(Record('c'))
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: L.insert(Record('c'))
< **   OGS:[0:test,nest(Record)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: L.insert(Record('c'))
< **   OGS:[0:test,nest(Record)]
< **** ENC:OI.viaInclude:[0:test,nest(Record)]
< **   ENC:result:[0:test]
< **** viaInclude:GOT:
< [0:test,nest(insert)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:test,nest(insert)]
< **** savedOGS:save:False[0:test,nest(insert)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:test,nest(insert)]
< **   OGS:[0:test,nest(insert)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:test,nest(insert)]
< **** OG:semCheck:'c'
< **   encOG: Record('c')
< **** Invocation:semCheck: 'c'
< **   encOG:Record('c')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< print: 
<       put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:L.insert(Record('b'))
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** Invocation:semCheck: L.insert(Record('b'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "insert(Record('b'))" rec: "L"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(Record('b'))
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('b'))
< **   fArg: in e: ref elm
< **   aArg: Record('b')
< **   theOI.f.f:label: ObjectGenerator
< L.insert(Record('b'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   savedOGS: [0:SetLib,nest(Set&)]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('b'))
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:SetLib,nest(Set&)]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:SetLib,nest(Set&),nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(Record('b'))
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:SetLib,nest(Set&),nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:SetLib,nest(Set&),nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:SetLib,nest(Set&),nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:SetLib,nest(Set&),nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:SetLib,nest(Set&),nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:SetLib,nest(Set&),nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:SetLib,nest(Set&),nest(insert),insert]
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:SetLib,nest(Set&),nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:SetLib,nest(Set&),nest(insert)]
< **   ENC:result:[2:SetLib,nest(Set&)]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:SetLib,nest(Set&)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:SetLib,nest(Set&),Collection]
< **   ENC:result:[1:SetLib,nest(Set&),Collection]
< 
< **** getVqual:B2:
< [0:SetLib,nest(Set&),Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:SetLib,nest(Set&),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:SetLib,nest(Set&),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&),Collection]
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:SetLib,nest(Set&),Collection&]
< **** savedOGS:save:False[0:SetLib,nest(Set&),Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:SetLib,nest(Set&),Collection&]
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OG:semCheck:Record('b')
< **   encOG: L.insert(Record('b'))
< **** Invocation:semCheck: Record('b')
< **   encOG:L.insert(Record('b'))
< **** OI:semCheck: "Record('b')" rec: "none"
< **   encOG:L.insert(Record('b'))
< **** Pattern:checkActualArgs:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   actualArgs: Record('b')
< **   fArgs(ch: var char,)
< 
< **   encOG:L.insert(Record('b'))**   argAtInx: 1 in:PTN:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('b')
< **   fArg: ch: var char
< **   aArg: 'b'
< **   theOI.f.f:label: ObjectGenerator
< Record('b')
< **   encOG:L.insert(Record('b'))
< **   savedOGS: [0:test]
< **** PTN:getOGsequenceOfArg: 
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('b')
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: ch: var char
< **** Items:localSearch: ch
< **   in:
< 
< print: 
<    put(ch)
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "print"
< **** Signature:localSearch: ch in: Record(ch: var char)
< **** Items:localSearch: ch
< **   in:
< 
< %$B "("
< ch: var char
< %$E ")"
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< *** found in signature:paramItems: ch
< **** Signature:localSearch:end: ch
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:test]
< **   OGS.DOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   After:[0:test,nest(Record)]
< **   getOGsequenceOfArg:aArgs:Record('b')
< **   fArgs.origin.OG=theFargsOG: 
< print: 
<       put(ch)
< **   OGS: [0:test,nest(Record)]
< **   theFargOG:
< 
< print: 
<       put(ch)
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:test,nest(Record)]
< **** DataItem:getVqual: ch: var char
< [0:test,nest(Record)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:test,nest(Record)]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:test,nest(Record)]
< **   encOG: L.insert(Record('b'))
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: L.insert(Record('b'))
< **   OGS:[0:test,nest(Record)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: L.insert(Record('b'))
< **   OGS:[0:test,nest(Record)]
< **** ENC:OI.viaInclude:[0:test,nest(Record)]
< **   ENC:result:[0:test]
< **** viaInclude:GOT:
< [0:test,nest(insert)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:test,nest(insert)]
< **** savedOGS:save:False[0:test,nest(insert)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:test,nest(insert)]
< **   OGS:[0:test,nest(insert)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:test,nest(insert)]
< **** OG:semCheck:'b'
< **   encOG: Record('b')
< **** Invocation:semCheck: 'b'
< **   encOG:Record('b')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< print: 
<       put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:L.insert(Record('a'))
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** Invocation:semCheck: L.insert(Record('a'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "insert(Record('a'))" rec: "L"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(Record('a'))
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('a'))
< **   fArg: in e: ref elm
< **   aArg: Record('a')
< **   theOI.f.f:label: ObjectGenerator
< L.insert(Record('a'))
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   savedOGS: [0:SetLib,nest(Set&)]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Record('a'))
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:SetLib,nest(Set&)]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:SetLib,nest(Set&),nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(Record('a'))
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:SetLib,nest(Set&),nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:SetLib,nest(Set&),nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:SetLib,nest(Set&),nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:SetLib,nest(Set&),nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:SetLib,nest(Set&),nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:SetLib,nest(Set&),nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:SetLib,nest(Set&),nest(insert),insert]
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:SetLib,nest(Set&),nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:SetLib,nest(Set&),nest(insert)]
< **   ENC:result:[2:SetLib,nest(Set&)]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:SetLib,nest(Set&)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:SetLib,nest(Set&),Collection]
< **   ENC:result:[1:SetLib,nest(Set&),Collection]
< 
< **** getVqual:B2:
< [0:SetLib,nest(Set&),Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:SetLib,nest(Set&),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:SetLib,nest(Set&),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&),Collection]
< **** searchBinding: in elm:< Object
< [0:SetLib,nest(Set&)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:SetLib,nest(Set&),Collection&]
< **** savedOGS:save:False[0:SetLib,nest(Set&),Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:SetLib,nest(Set&),Collection&]
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:SetLib,nest(Set&),Collection&]
< **** OG:semCheck:Record('a')
< **   encOG: L.insert(Record('a'))
< **** Invocation:semCheck: Record('a')
< **   encOG:L.insert(Record('a'))
< **** OI:semCheck: "Record('a')" rec: "none"
< **   encOG:L.insert(Record('a'))
< **** Pattern:checkActualArgs:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   actualArgs: Record('a')
< **   fArgs(ch: var char,)
< 
< **   encOG:L.insert(Record('a'))**   argAtInx: 1 in:PTN:
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('a')
< **   fArg: ch: var char
< **   aArg: 'a'
< **   theOI.f.f:label: ObjectGenerator
< Record('a')
< **   encOG:L.insert(Record('a'))
< **   savedOGS: [0:test]
< **** PTN:getOGsequenceOfArg: 
< Record(ch: var char): 
<    print: 
<       put(ch)
< **   theOI: Record('a')
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: ch: var char
< **** Items:localSearch: ch
< **   in:
< 
< print: 
<    put(ch)
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "print"
< **** Signature:localSearch: ch in: Record(ch: var char)
< **** Items:localSearch: ch
< **   in:
< 
< %$B "("
< ch: var char
< %$E ")"
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< *** found in signature:paramItems: ch
< **** Signature:localSearch:end: ch
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:test]
< **   OGS.DOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **   After:[0:test,nest(Record)]
< **   getOGsequenceOfArg:aArgs:Record('a')
< **   fArgs.origin.OG=theFargsOG: 
< print: 
<       put(ch)
< **   OGS: [0:test,nest(Record)]
< **   theFargOG:
< 
< print: 
<       put(ch)
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:test,nest(Record)]
< **** DataItem:getVqual: ch: var char
< [0:test,nest(Record)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:test,nest(Record)]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:test,nest(Record)]
< **   encOG: L.insert(Record('a'))
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: L.insert(Record('a'))
< **   OGS:[0:test,nest(Record)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: L.insert(Record('a'))
< **   OGS:[0:test,nest(Record)]
< **** ENC:OI.viaInclude:[0:test,nest(Record)]
< **   ENC:result:[0:test]
< **** viaInclude:GOT:
< [0:test,nest(insert)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:test,nest(insert)]
< **** savedOGS:save:False[0:test,nest(insert)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:test,nest(insert)]
< **   OGS:[0:test,nest(insert)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:test,nest(insert)]
< **** OG:semCheck:'a'
< **   encOG: Record('a')
< **** Invocation:semCheck: 'a'
< **   encOG:Record('a')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< print: 
<       put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **   encOG: 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** Invocation:semCheck: L.scan
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** OI:semCheck: "scan" rec: "L"
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** OG:semCheck:current.print
< **   encOG: 
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **** Invocation:semCheck: current.print
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** OI:semCheck: "print" rec: "current"
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** Pattern:checkActualArgs:
< print: 
<    put(ch)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **** OG:semcheck:IS not empty:eOG: 
< put(ch)
< **** OG:semCheck:
< if (current.ch = 'b') :then 
<    put('[')
<    scanTail
<       current.print
<    put(']')
< ...
< **   encOG: 
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **** Invocation:semCheck: if (current.ch = 'b') :then 
<    put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** OG:semCheck:(current.ch = 'b')
< **   encOG: 
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **** Invocation:semCheck: (current.ch = 'b')
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** Invocation:semCheck: current.ch = 'b'
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** OI:semCheck: "ch" rec: "current"
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** OI:semCheck: "= 'b'" rec: "ch"
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: 'b'
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 'b'
< **   fArg: in Veq: var this(Value)
< **   aArg: 'b'
< **   theOI.f.f:label: BracketedExp
< (current.ch = 'b')
< **   encOG:
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **   savedOGS: [0:scan$0,nest(L&),nest(char),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 'b'
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:scan$0,nest(L&),nest(char),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:scan$0,nest(L&),nest(char),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:'b'
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:scan$0,nest(L&),nest(char),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:scan$0,nest(L&),nest(char),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:scan$0,nest(L&),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:scan$0,nest(L&),nest(char),Value&,nest(=)]
< **** getOGstart: 
< [0:scan$0,nest(L&),nest(char),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:'b'
< **   encOG: (current.ch = 'b')
< **** Invocation:semCheck: 'b'
< **   encOG:(current.ch = 'b')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:put('[')
< **   encOG: 
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** Invocation:semCheck: put('[')
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< 
< **** OI:semCheck: "put('[')" rec: "none"
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('[')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('[')
< **   fArg: in ch: val char
< **   aArg: '['
< **   theOI.f.f:label: ObjectGenerator
< put('[')
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   savedOGS: [0:scan$0,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('[')
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:scan$0,nest($0)]
< **   OGS.DOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   After:[0:scan$0,nest($0),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('[')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:scan$0,nest($0),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:scan$0,nest($0),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:scan$0,nest($0),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:scan$0,nest($0),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$0,nest($0),nest(put)]
< **   encOG: 
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:scan$0,nest($0),nest(put)]
< **   ENC:result:[1:scan$0,nest($0)]
< 
< **** getVqual:B2:
< [0:scan$0,nest($0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:scan$0,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:scan$0,nest($0)]
< **** savedOGS:save:False[0:scan$0,nest($0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:scan$0,nest($0)]
< **   OGS:[0:scan$0,nest($0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:scan$0,nest($0)]
< **** OG:semCheck:'['
< **   encOG: put('[')
< **** Invocation:semCheck: '['
< **   encOG:put('[')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:
< scanTail
<    current.print
< **   encOG: 
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** Invocation:semCheck: scanTail
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< 
< **** OI:semCheck: "scanTail" rec: "none"
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< 
< **** Pattern:checkActualArgs:
< scanTail: 
<    current: ref elm
<    nxtt: ref link
<    nxtt := this(scan).nxt.next
<    loop: do 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** OG:semCheck:current.print
< **   encOG: 
< scanTail
<    current.print
< **** Invocation:semCheck: current.print
< **   encOG:
< scanTail
<    current.print
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< scanTail
<    current.print
< 
< **** OI:semCheck: "print" rec: "current"
< **   encOG:
< scanTail
<    current.print
< 
< **** Pattern:checkActualArgs:
< print: 
<    put(ch)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scanTail
<    current.print
< **** OG:semcheck:IS not empty:eOG: 
< put(ch)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scanTail
<    current.print
< **** OG:semCheck:
< put(']')
< --test
< **   encOG: 
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** Invocation:semCheck: put(']')
< --test
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< 
< **** OI:semCheck: "put(']')" rec: "none"
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(']')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(']')
< **   fArg: in ch: val char
< **   aArg: ']'
< **   theOI.f.f:label: ObjectGenerator
< 
< put(']')
< --test
< **   encOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   savedOGS: [0:scan$0,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(']')
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:scan$0,nest($0)]
< **   OGS.DOG:
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **   After:[0:scan$0,nest($0),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(']')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:scan$0,nest($0),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:scan$0,nest($0),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:scan$0,nest($0),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:scan$0,nest($0),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$0,nest($0),nest(put)]
< **   encOG: 
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:scan$0,nest($0),nest(put)]
< **   ENC:result:[1:scan$0,nest($0)]
< 
< **** getVqual:B2:
< [0:scan$0,nest($0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:scan$0,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:scan$0,nest($0)]
< **** savedOGS:save:False[0:scan$0,nest($0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:scan$0,nest($0)]
< **   OGS:[0:scan$0,nest($0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:scan$0,nest($0)]
< **** OG:semCheck:']'
< **   encOG: 
< put(']')
< --test
< **** Invocation:semCheck: ']'
< **   encOG:
< put(']')
< --test
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< 
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** OG:semcheck:IS not empty:eOG: 
< 
< put('[')
<    scanTail
<       current.print
<    put(']')
<    --test
< **** OG:semcheck:IS not empty:eOG: 
< 
< L.scan
<    current.print
<    if (current.ch = 'b') :then 
<       put('[')
<       scanTail
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Record(ch: var char): 
<       print: 
<          put(ch)
<    L: obj Set(#Record)
<    L.insert(Record('d'))
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< **** OG:semCheck:
< %domain_boundary
<    %public
<    Dimension: 
<       %dimension "-top-"
<       %public
< ...
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OG:semCheck:
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< **   encOG: 
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< 
< **** Invocation:semCheck: "-top-"
< **   encOG:
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< 
< **** OG:semCheck:Unit
< **   encOG: Unit
< **** Invocation:semCheck: Unit
< **   encOG:Unit
< **** OI:semCheck: "Unit" rec: "PrimaryUnit"
< **   encOG:Unit
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **   encOG: 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** Invocation:semCheck: Value
< **   encOG:
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< 
< **** OI:semCheck: "Value" rec: "Unit"
< **   encOG:
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< 
< **** Invocation:semCheck: "U"
< **   encOG:
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< 
< **** Invocation:semCheck: 1
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** OG:semCheck:Float
< **   encOG: 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** Invocation:semCheck: Float
< **   encOG:
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:Unit
< **   encOG: Unit
< **** Invocation:semCheck: Unit
< **   encOG:Unit
< **** OI:semCheck: "Unit" rec: "thisUnit"
< **   encOG:Unit
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:Unit
< **   encOG: Unit
< **** Invocation:semCheck: Unit
< **   encOG:Unit
< **** OI:semCheck: "Unit" rec: "argUnit"
< **   encOG:Unit
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:Unit
< **   encOG: Unit
< **** Invocation:semCheck: Unit
< **   encOG:Unit
< **** OI:semCheck: "Unit" rec: "resUnit"
< **   encOG:Unit
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** Invocation:semCheck: 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:magnitude + V.magnitude
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** Invocation:semCheck: magnitude + V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** OI:semCheck: "+ V.magnitude" rec: "magnitude"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 109
<    in V: var float
<    out R: var float
< **   actualArgs: V.magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 109
<    in V: var float
<    out R: var float
< **   theOI: + V.magnitude
< **   fArg: in V: var float
< **   aArg: V.magnitude
< **   theOI.f.f:label: ObjectGenerator
< magnitude + V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **   savedOGS: [0:Dimension,nest(+?),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 109
<    in V: var float
<    out R: var float
< **   theOI: + V.magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 109
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(+?),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(+?),nest(float),nest(+)]
< **   getOGsequenceOfArg:aArgs:V.magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **   OGS: [0:Dimension,nest(+?),nest(float),nest(+)]
< **   theFargOG:
< 
< %basic 109
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(+?),nest(float),nest(+)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(+?),nest(float),nest(+)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(+?),nest(float),nest(+)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(+?),nest(float),nest(+)]
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 109
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Dimension,nest(+?),nest(float),nest(+)]
< **   ENC:result:[1:Dimension,nest(+?),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(+?),nest(float)]
< **   ENC:result:[2:Dimension,nest(+?)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(+?)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(+?)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(+?)]
< **** savedOGS:save:False[0:Dimension,nest(+?)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(+?)]
< **   OGS:[0:Dimension,nest(+?)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(+?)]
< **** OG:semCheck:V.magnitude
< **   encOG: magnitude + V.magnitude
< **** Invocation:semCheck: V.magnitude
< **   encOG:magnitude + V.magnitude
< **** OI:semCheck: "V" rec: "none"
< **   encOG:magnitude + V.magnitude
< **** OI:semCheck: "magnitude" rec: "V"
< **   encOG:magnitude + V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **   OGs:[0:+?]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:+?]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:+?]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+?]
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **   OGS:[0:+?]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **   OGS:[0:+?]
< **** ENC:OI.viaInclude:[0:+?]
< **   ENC:result:[0:Unit]
< **** viaInclude:GOT:
< [0:Unit,nest(+?)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit,nest(+?)]
< **** savedOGS:save:False[0:Unit,nest(+?)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(+?)]
< **   OGS:[0:Unit,nest(+?)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(+?)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Unit,nest(+?)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(+?)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude + V.magnitude
< **** OG:returnDecl: out R: var thisUnit
< **** OG:semCheck:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** Invocation:semCheck: 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:magnitude - V.magnitude
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** Invocation:semCheck: magnitude - V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** OI:semCheck: "- V.magnitude" rec: "magnitude"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 110
<    in V: var float
<    out R: var float
< **   actualArgs: V.magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 110
<    in V: var float
<    out R: var float
< **   theOI: - V.magnitude
< **   fArg: in V: var float
< **   aArg: V.magnitude
< **   theOI.f.f:label: ObjectGenerator
< magnitude - V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **   savedOGS: [0:Dimension,nest(-?),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 110
<    in V: var float
<    out R: var float
< **   theOI: - V.magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 110
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(-?),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(-?),nest(float),nest(-)]
< **   getOGsequenceOfArg:aArgs:V.magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 110
<    in V: var float
<    out R: var float
< **   OGS: [0:Dimension,nest(-?),nest(float),nest(-)]
< **   theFargOG:
< 
< %basic 110
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(-?),nest(float),nest(-)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(-?),nest(float),nest(-)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(-?),nest(float),nest(-)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(-?),nest(float),nest(-)]
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 110
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Dimension,nest(-?),nest(float),nest(-)]
< **   ENC:result:[1:Dimension,nest(-?),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(-?),nest(float)]
< **   ENC:result:[2:Dimension,nest(-?)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(-?)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(-?)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(-?)]
< **** savedOGS:save:False[0:Dimension,nest(-?)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(-?)]
< **   OGS:[0:Dimension,nest(-?)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(-?)]
< **** OG:semCheck:V.magnitude
< **   encOG: magnitude - V.magnitude
< **** Invocation:semCheck: V.magnitude
< **   encOG:magnitude - V.magnitude
< **** OI:semCheck: "V" rec: "none"
< **   encOG:magnitude - V.magnitude
< **** OI:semCheck: "magnitude" rec: "V"
< **   encOG:magnitude - V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **   OGs:[0:-?]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:-?]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:-?]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:-?]
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **   OGS:[0:-?]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **   OGS:[0:-?]
< **** ENC:OI.viaInclude:[0:-?]
< **   ENC:result:[0:Unit]
< **** viaInclude:GOT:
< [0:Unit,nest(-?)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit,nest(-?)]
< **** savedOGS:save:False[0:Unit,nest(-?)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(-?)]
< **   OGS:[0:Unit,nest(-?)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(-?)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Unit,nest(-?)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(-?)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var thisUnit
<    out R: var thisUnit
<    R.magnitude := magnitude - V.magnitude
< **** OG:returnDecl: out R: var thisUnit
< **** OG:semCheck:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** Invocation:semCheck: 
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** OG:semCheck:Float
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** Invocation:semCheck: Float
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** OI:semCheck: "Float" rec: "none"
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:magnitude * V
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** Invocation:semCheck: magnitude * V
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** OI:semCheck: "* V" rec: "magnitude"
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: V
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * V
< **   fArg: in V: var float
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< magnitude * V
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **   savedOGS: [0:Dimension,nest(*?),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * V
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(*?),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(*?),nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:V
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:Dimension,nest(*?),nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(*?),nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(*?),nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(*?),nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(*?),nest(float),nest(*)]
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Dimension,nest(*?),nest(float),nest(*)]
< **   ENC:result:[1:Dimension,nest(*?),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(*?),nest(float)]
< **   ENC:result:[2:Dimension,nest(*?)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(*?)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(*?)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(*?)]
< **** savedOGS:save:False[0:Dimension,nest(*?)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(*?)]
< **   OGS:[0:Dimension,nest(*?)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(*?)]
< **** OG:semCheck:V
< **   encOG: magnitude * V
< **** Invocation:semCheck: V
< **   encOG:magnitude * V
< **** OI:semCheck: "V" rec: "none"
< **   encOG:magnitude * V
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **   OGs:[0:*?]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:*?]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:*?]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:*?]
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **   OGS:[0:*?]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **   OGS:[0:*?]
< **** ENC:OI.viaInclude:[0:*?]
< **   ENC:result:[0:Unit]
< **** viaInclude:GOT:
< [0:Unit,nest(*?)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit,nest(*?)]
< **** savedOGS:save:False[0:Unit,nest(*?)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(*?)]
< **   OGS:[0:Unit,nest(*?)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(*?)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Unit,nest(*?)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(*?)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var Float
<    out R: var thisUnit
<    R.magnitude := magnitude * V
< **** OG:returnDecl: out R: var thisUnit
< **** OG:semCheck:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** Invocation:semCheck: 
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** OG:semCheck:integer
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** Invocation:semCheck: integer
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:magnitude / V
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** Invocation:semCheck: magnitude / V
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** OI:semCheck: "/ V" rec: "magnitude"
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** Pattern:checkActualArgs:
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   actualArgs: V
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **   argAtInx: 1 in:PTN:
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   theOI: / V
< **   fArg: in V: var float
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< magnitude / V
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **   savedOGS: [0:Dimension,nest(/?),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   theOI: / V
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 121
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(/?),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(/?),nest(float),nest(/)]
< **   getOGsequenceOfArg:aArgs:V
< **   fArgs.origin.OG=theFargsOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **   OGS: [0:Dimension,nest(/?),nest(float),nest(/)]
< **   theFargOG:
< 
< %basic 121
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(/?),nest(float),nest(/)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(/?),nest(float),nest(/)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(/?),nest(float),nest(/)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(/?),nest(float),nest(/)]
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 121
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Dimension,nest(/?),nest(float),nest(/)]
< **   ENC:result:[1:Dimension,nest(/?),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(/?),nest(float)]
< **   ENC:result:[2:Dimension,nest(/?)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(/?)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(/?)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(/?)]
< **** savedOGS:save:False[0:Dimension,nest(/?)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(/?)]
< **   OGS:[0:Dimension,nest(/?)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(/?)]
< **** OG:semCheck:V
< **   encOG: magnitude / V
< **** Invocation:semCheck: V
< **   encOG:magnitude / V
< **** OI:semCheck: "V" rec: "none"
< **   encOG:magnitude / V
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **   OGs:[0:/?]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:/?]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:/?]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:/?]
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **   OGS:[0:/?]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **   OGS:[0:/?]
< **** ENC:OI.viaInclude:[0:/?]
< **   ENC:result:[0:Unit]
< **** viaInclude:GOT:
< [0:Unit,nest(/?)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit,nest(/?)]
< **** savedOGS:save:False[0:Unit,nest(/?)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(/?)]
< **   OGS:[0:Unit,nest(/?)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(/?)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Unit,nest(/?)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(/?)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude / V
< **** OG:returnDecl: out R: var thisUnit
< **** OG:semCheck:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:thisUnit
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:magnitude
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** Invocation:semCheck: magnitude
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **   OGs:[0:^?]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:^?]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:^?]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:^?]
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **   OGS:[0:^?]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **   OGS:[0:^?]
< **** ENC:OI.viaInclude:[0:^?]
< **   ENC:result:[0:Unit]
< **** viaInclude:GOT:
< [0:Unit,nest(^?)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit,nest(^?)]
< **** savedOGS:save:False[0:Unit,nest(^?)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(^?)]
< **   OGS:[0:Unit,nest(^?)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(^?)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Unit,nest(^?)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(^?)]
< **** OG:semCheck:
< if (exp > 0) :then 
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< :else 
< ...
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** Invocation:semCheck: if (exp > 0) :then 
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< :else 
<    exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OG:semCheck:(exp > 0)
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** Invocation:semCheck: (exp > 0)
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** Invocation:semCheck: exp > 0
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OI:semCheck: "exp" rec: "none"
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** OI:semCheck: "> 0" rec: "exp"
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< 
< **** Pattern:checkActualArgs:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **   argAtInx: 1 in:PTN:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (exp > 0)
< **   encOG:
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **   savedOGS: [0:Unit,nest(^?),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 53
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Unit,nest(^?),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:Unit,nest(^?),nest(integer),nest(>)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:Unit,nest(^?),nest(integer),nest(>)]
< **   theFargOG:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Unit,nest(^?),nest(integer),nest(>)]
< **** DataItem:getVqual: in V: var integer
< [0:Unit,nest(^?),nest(integer),nest(>)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Unit,nest(^?),nest(integer),nest(>)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit,nest(^?),nest(integer),nest(>)]
< **   encOG: 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:Unit,nest(^?),nest(integer),nest(>)]
< **   ENC:result:[1:Unit,nest(^?),nest(integer)]
< **** ENC:OI.getVqual:[2:Unit,nest(^?),nest(integer)]
< **   ENC:result:[2:Unit,nest(^?)]
< 
< **** getVqual:B2:
< [0:Unit,nest(^?)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Unit,nest(^?)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:Unit,nest(^?)]
< **** savedOGS:save:False[0:Unit,nest(^?)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(^?)]
< **   OGS:[0:Unit,nest(^?)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(^?)]
< **** OG:semCheck:0
< **   encOG: (exp > 0)
< **** Invocation:semCheck: 0
< **   encOG:(exp > 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG: 
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **** Invocation:semCheck: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< 
< **** OI:semCheck: "for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< " rec: "none"
< **   encOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   savedOGS: [0:^?,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:^?,nest($0)]
< **   OGS.DOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   After:[0:^?,nest($0),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:^?,nest($0),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:^?,nest($0),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:^?,nest($0),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:^?,nest($0),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:^?,nest($0),nest(for:to:repeat)]
< **   encOG: 
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:^?,nest($0),nest(for:to:repeat)]
< **   ENC:result:[1:^?,nest($0)]
< 
< **** getVqual:B2:
< [0:^?,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:^?,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:^?,nest($0)]
< **** savedOGS:save:False[0:^?,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:^?,nest($0)]
< **   OGS:[0:^?,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:^?,nest($0)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArg: last: var integer
< **   aArg: exp - 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   savedOGS: [0:^?,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:^?,nest($0)]
< **   OGS.DOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   After:[0:^?,nest($0),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:^?,nest($0),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:^?,nest($0),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:^?,nest($0),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:^?,nest($0),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:^?,nest($0),nest(for:to:repeat)]
< **   encOG: 
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:^?,nest($0),nest(for:to:repeat)]
< **   ENC:result:[1:^?,nest($0)]
< 
< **** getVqual:B2:
< [0:^?,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:^?,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:^?,nest($0)]
< **** savedOGS:save:False[0:^?,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:^?,nest($0)]
< **   OGS:[0:^?,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:^?,nest($0)]
< **** OG:semCheck:exp - 1
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** Invocation:semCheck: exp - 1
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OI:semCheck: "exp" rec: "none"
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OI:semCheck: "- 1" rec: "exp"
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< exp - 1
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   savedOGS: [0:Unit,nest($0),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Unit,nest($0),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:Unit,nest($0),nest(integer),nest(-)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:Unit,nest($0),nest(integer),nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Unit,nest($0),nest(integer),nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:Unit,nest($0),nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Unit,nest($0),nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit,nest($0),nest(integer),nest(-)]
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:Unit,nest($0),nest(integer),nest(-)]
< **   ENC:result:[1:Unit,nest($0),nest(integer)]
< **** ENC:OI.getVqual:[2:Unit,nest($0),nest(integer)]
< **   ENC:result:[2:Unit,nest($0)]
< 
< **** getVqual:B2:
< [0:Unit,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Unit,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:Unit,nest($0)]
< **** savedOGS:save:False[0:Unit,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest($0)]
< **   OGS:[0:Unit,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest($0)]
< **** OG:semCheck:1
< **   encOG: exp - 1
< **** Invocation:semCheck: 1
< **   encOG:exp - 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArg: repeat:< object
< **   aArg: R.magnitude := R.magnitude * magnitude
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   savedOGS: [0:^?,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:^?,nest($0)]
< **   OGS.DOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **   After:[0:^?,nest($0),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:^?,nest($0),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:^?,nest($0),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:^?,nest($0),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:^?,nest($0),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:^?,nest($0),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:R.magnitude := R.magnitude * magnitude
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OG:semCheck:R.magnitude * magnitude
< **   encOG: R.magnitude := R.magnitude * magnitude
< **** Invocation:semCheck: R.magnitude * magnitude
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** OI:semCheck: "R" rec: "magnitude"
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** OI:semCheck: "magnitude" rec: "R"
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** OI:semCheck: "* magnitude" rec: "magnitude"
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:R.magnitude := R.magnitude * magnitude**   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * magnitude
< **   fArg: in V: var float
< **   aArg: magnitude
< **   theOI.f.f:label: ObjectGenerator
< R.magnitude * magnitude
< **   encOG:R.magnitude := R.magnitude * magnitude
< **   savedOGS: [0:Unit&,nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Unit&,nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Unit&,nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:Unit&,nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Unit&,nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:Unit&,nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Unit&,nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit&,nest(float),nest(*)]
< **   encOG: R.magnitude := R.magnitude * magnitude
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Unit&,nest(float),nest(*)]
< **   ENC:result:[1:Unit&,nest(float)]
< **** ENC:OI.getVqual:[2:Unit&,nest(float)]
< **   ENC:result:[2:Unit&]
< 
< **** getVqual:B2:
< [0:Unit&]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit&]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Unit&]
< **** savedOGS:save:False[0:Unit&]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&]
< **   OGS:[0:Unit&]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit&]
< **** OG:semCheck:magnitude
< **   encOG: R.magnitude * magnitude
< **** Invocation:semCheck: magnitude
< **   encOG:R.magnitude * magnitude
< **** OI:semCheck: "magnitude" rec: "none"
< **   encOG:R.magnitude * magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: R.magnitude := R.magnitude * magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:R.magnitude := R.magnitude * magnitude
< **   OGs:[0:repeat$0]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:repeat$0]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:repeat$0]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$0]
< **   encOG: R.magnitude := R.magnitude * magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: R.magnitude := R.magnitude * magnitude
< **   OGS:[0:repeat$0]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: R.magnitude := R.magnitude * magnitude
< **   OGS:[0:repeat$0]
< **** ENC:OI.viaInclude:[0:repeat$0]
< **   ENC:result:[0:for:to:repeat$0]
< **** viaInclude:GOT:
< [0:for:to:repeat$0,nest(repeat$0)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:for:to:repeat$0,nest(repeat$0)]
< **** savedOGS:save:False[0:for:to:repeat$0,nest(repeat$0)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:for:to:repeat$0,nest(repeat$0)]
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:for:to:repeat$0,nest(repeat$0)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := R.magnitude * magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **** OG:semCheck:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   encOG: 
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
< 
< **** OG:semCheck:(0 - exp)
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** Invocation:semCheck: (0 - exp)
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** Invocation:semCheck: 0 - exp
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** OI:semCheck: "- exp" rec: "0"
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: exp
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - exp
< **   fArg: in V: var integer
< **   aArg: exp
< **   theOI.f.f:label: BracketedExp
< (0 - exp)
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - exp
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:exp
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:exp
< **   encOG: (0 - exp)
< **** Invocation:semCheck: exp
< **   encOG:(0 - exp)
< **** OI:semCheck: "exp" rec: "none"
< **   encOG:(0 - exp)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: exp on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** OI:getVqual:initial:exp
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   OGs:[0:^?]
< **   ATd: in exp: var integer
< **** DataItem:getVqual: in exp: var integer
< [0:^?]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:^?]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:^?]
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   OGS:[0:^?]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   OGS:[0:^?]
< **** ENC:OI.viaInclude:[0:^?]
< **   ENC:result:[0:Unit]
< **** viaInclude:GOT:
< [0:Unit,nest($0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Unit,nest($0)]
< **** savedOGS:save:False[0:Unit,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest($0)]
< **   OGS:[0:Unit,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest($0)]
< 
< **** getVqual:initial:afterATd:exp
< **   OGSx:[0:Unit,nest($0)]
< **** savedOGS:save:was:[0:Unit,nest($0)]
< **   OI: exp
< **   OI:getQual:savedOI:exp
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: exp
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest($0)]
< **** OG:semCheck:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** Invocation:semCheck: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** OI:semCheck: "for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< " rec: "none"
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   savedOGS: [0:^?,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:^?,nest($0)]
< **   OGS.DOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   After:[0:^?,nest($0),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:^?,nest($0),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:^?,nest($0),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:^?,nest($0),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:^?,nest($0),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:^?,nest($0),nest(for:to:repeat)]
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:^?,nest($0),nest(for:to:repeat)]
< **   ENC:result:[1:^?,nest($0)]
< 
< **** getVqual:B2:
< [0:^?,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:^?,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:^?,nest($0)]
< **** savedOGS:save:False[0:^?,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:^?,nest($0)]
< **   OGS:[0:^?,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:^?,nest($0)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArg: last: var integer
< **   aArg: exp - 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   savedOGS: [0:^?,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:^?,nest($0)]
< **   OGS.DOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   After:[0:^?,nest($0),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:^?,nest($0),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:^?,nest($0),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:^?,nest($0),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:^?,nest($0),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:^?,nest($0),nest(for:to:repeat)]
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:^?,nest($0),nest(for:to:repeat)]
< **   ENC:result:[1:^?,nest($0)]
< 
< **** getVqual:B2:
< [0:^?,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:^?,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:^?,nest($0)]
< **** savedOGS:save:False[0:^?,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:^?,nest($0)]
< **   OGS:[0:^?,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:^?,nest($0)]
< **** OG:semCheck:exp - 1
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** Invocation:semCheck: exp - 1
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OI:semCheck: "exp" rec: "none"
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OI:semCheck: "- 1" rec: "exp"
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< exp - 1
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   savedOGS: [0:Unit,nest($0),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Unit,nest($0),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:Unit,nest($0),nest(integer),nest(-)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:Unit,nest($0),nest(integer),nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Unit,nest($0),nest(integer),nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:Unit,nest($0),nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Unit,nest($0),nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit,nest($0),nest(integer),nest(-)]
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:Unit,nest($0),nest(integer),nest(-)]
< **   ENC:result:[1:Unit,nest($0),nest(integer)]
< **** ENC:OI.getVqual:[2:Unit,nest($0),nest(integer)]
< **   ENC:result:[2:Unit,nest($0)]
< 
< **** getVqual:B2:
< [0:Unit,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Unit,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:Unit,nest($0)]
< **** savedOGS:save:False[0:Unit,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest($0)]
< **   OGS:[0:Unit,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest($0)]
< **** OG:semCheck:1
< **   encOG: exp - 1
< **** Invocation:semCheck: 1
< **   encOG:exp - 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArg: repeat:< object
< **   aArg: R.magnitude := R.magnitude * magnitude
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   savedOGS: [0:^?,nest($0)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:^?,nest($0)]
< **   OGS.DOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   After:[0:^?,nest($0),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:^?,nest($0),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:^?,nest($0),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:^?,nest($0),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:^?,nest($0),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:^?,nest($0),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:R.magnitude := R.magnitude * magnitude
< **   encOG: 
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(exp - 1):repeat
<    R.magnitude := R.magnitude * magnitude
< 
< 
< **** OG:semCheck:R.magnitude * magnitude
< **   encOG: R.magnitude := R.magnitude * magnitude
< **** Invocation:semCheck: R.magnitude * magnitude
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** OI:semCheck: "R" rec: "magnitude"
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** OI:semCheck: "magnitude" rec: "R"
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** OI:semCheck: "* magnitude" rec: "magnitude"
< **   encOG:R.magnitude := R.magnitude * magnitude
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:R.magnitude := R.magnitude * magnitude**   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * magnitude
< **   fArg: in V: var float
< **   aArg: magnitude
< **   theOI.f.f:label: ObjectGenerator
< R.magnitude * magnitude
< **   encOG:R.magnitude := R.magnitude * magnitude
< **   savedOGS: [0:Unit&,nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Unit&,nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Unit&,nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:Unit&,nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Unit&,nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:Unit&,nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Unit&,nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit&,nest(float),nest(*)]
< **   encOG: R.magnitude := R.magnitude * magnitude
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Unit&,nest(float),nest(*)]
< **   ENC:result:[1:Unit&,nest(float)]
< **** ENC:OI.getVqual:[2:Unit&,nest(float)]
< **   ENC:result:[2:Unit&]
< 
< **** getVqual:B2:
< [0:Unit&]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit&]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Unit&]
< **** savedOGS:save:False[0:Unit&]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&]
< **   OGS:[0:Unit&]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit&]
< **** OG:semCheck:magnitude
< **   encOG: R.magnitude * magnitude
< **** Invocation:semCheck: magnitude
< **   encOG:R.magnitude * magnitude
< **** OI:semCheck: "magnitude" rec: "none"
< **   encOG:R.magnitude * magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: R.magnitude := R.magnitude * magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:R.magnitude := R.magnitude * magnitude
< **   OGs:[0:repeat$0]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:repeat$0]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:repeat$0]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$0]
< **   encOG: R.magnitude := R.magnitude * magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: R.magnitude := R.magnitude * magnitude
< **   OGS:[0:repeat$0]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: R.magnitude := R.magnitude * magnitude
< **   OGS:[0:repeat$0]
< **** ENC:OI.viaInclude:[0:repeat$0]
< **   ENC:result:[0:for:to:repeat$0]
< **** viaInclude:GOT:
< [0:for:to:repeat$0,nest(repeat$0)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:for:to:repeat$0,nest(repeat$0)]
< **** savedOGS:save:False[0:for:to:repeat$0,nest(repeat$0)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:for:to:repeat$0,nest(repeat$0)]
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:for:to:repeat$0,nest(repeat$0)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := R.magnitude * magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:1.0 / R.magnitude
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** Invocation:semCheck: 1.0 / R.magnitude
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** OI:semCheck: "/ R.magnitude" rec: "1.0"
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** Pattern:checkActualArgs:
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   actualArgs: R.magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   argAtInx: 1 in:PTN:
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   theOI: / R.magnitude
< **   fArg: in V: var float
< **   aArg: R.magnitude
< **   theOI.f.f:label: ObjectGenerator
< 1.0 / R.magnitude
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   savedOGS: [0:float]
< **** PTN:getOGsequenceOfArg: 
< /  : 
<    %basic 121
<    in V: var float
<    out R: var float
< **   theOI: / R.magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 121
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:float]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:float,nest(/)]
< **   getOGsequenceOfArg:aArgs:R.magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 121
<    in V: var float
<    out R: var float
< **   OGS: [0:float,nest(/)]
< **   theFargOG:
< 
< %basic 121
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:float,nest(/)]
< **** DataItem:getVqual: in V: var float
< [0:float,nest(/)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:float,nest(/)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:float,nest(/)]
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 121
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:float,nest(/)]
< **   ENC:result:[1:float]
< **** ENC:OI.getVqual:[2:float]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:R.magnitude
< **   encOG: 1.0 / R.magnitude
< **** Invocation:semCheck: R.magnitude
< **   encOG:1.0 / R.magnitude
< **** OI:semCheck: "R" rec: "none"
< **   encOG:1.0 / R.magnitude
< **** OI:semCheck: "magnitude" rec: "R"
< **   encOG:1.0 / R.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   OGs:[0:$0]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:$0]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:^?]
< **** viaInclude:GOT:
< [0:^?,nest($0)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:^?,nest($0)]
< **** savedOGS:save:False[0:^?,nest($0)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:^?,nest($0)]
< **   OGS:[0:^?,nest($0)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:^?,nest($0)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:^?,nest($0)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:^?,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< exp := (0 - exp)
<    for(1):to(exp - 1):repeat
<       R.magnitude := R.magnitude * magnitude
<    
<    R.magnitude := 1.0 / R.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< in exp: var integer
<    out R: var thisUnit
<    R.magnitude := magnitude
<    if (exp > 0) :then 
<       for(1):to(exp - 1):repeat
< ...
< **** OG:returnDecl: out R: var thisUnit
< **** OG:semCheck:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** Invocation:semCheck: 
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** OG:semCheck:argUnit
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** Invocation:semCheck: argUnit
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** OI:semCheck: "argUnit" rec: "none"
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** Pattern:checkActualArgs:argUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:resUnit
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** Invocation:semCheck: resUnit
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** OI:semCheck: "resUnit" rec: "none"
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** Pattern:checkActualArgs:resUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:magnitude * V.magnitude
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** Invocation:semCheck: magnitude * V.magnitude
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** OI:semCheck: "* V.magnitude" rec: "magnitude"
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: V.magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * V.magnitude
< **   fArg: in V: var float
< **   aArg: V.magnitude
< **   theOI.f.f:label: ObjectGenerator
< magnitude * V.magnitude
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **   savedOGS: [0:Dimension,nest(***),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * V.magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(***),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(***),nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:V.magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:Dimension,nest(***),nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(***),nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(***),nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(***),nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(***),nest(float),nest(*)]
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Dimension,nest(***),nest(float),nest(*)]
< **   ENC:result:[1:Dimension,nest(***),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(***),nest(float)]
< **   ENC:result:[2:Dimension,nest(***)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(***)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(***)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(***)]
< **** savedOGS:save:False[0:Dimension,nest(***)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(***)]
< **   OGS:[0:Dimension,nest(***)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(***)]
< **** OG:semCheck:V.magnitude
< **   encOG: magnitude * V.magnitude
< **** Invocation:semCheck: V.magnitude
< **   encOG:magnitude * V.magnitude
< **** OI:semCheck: "V" rec: "none"
< **   encOG:magnitude * V.magnitude
< **** OI:semCheck: "magnitude" rec: "V"
< **   encOG:magnitude * V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **   OGs:[0:***]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:***]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:***]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:***]
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **   OGS:[0:***]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **   OGS:[0:***]
< **** ENC:OI.viaInclude:[0:***]
< **   ENC:result:[0:Unit]
< **** viaInclude:GOT:
< [0:Unit,nest(***)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit,nest(***)]
< **** savedOGS:save:False[0:Unit,nest(***)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(***)]
< **   OGS:[0:Unit,nest(***)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(***)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Unit,nest(***)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(***)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var argUnit
<    out R: var resUnit
<    R.magnitude := magnitude * V.magnitude
< **** OG:returnDecl: out R: var resUnit
< **** OG:semCheck:
< in V: var float
<    magnitude := magnitude + V
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< **** Invocation:semCheck: 
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< 
< **** OG:semCheck:float
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< **** Invocation:semCheck: float
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:magnitude + V
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< **** Invocation:semCheck: magnitude + V
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< 
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< 
< **** OI:semCheck: "+ V" rec: "magnitude"
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 109
<    in V: var float
<    out R: var float
< **   actualArgs: V
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 109
<    in V: var float
<    out R: var float
< **   theOI: + V
< **   fArg: in V: var float
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< magnitude + V
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< **   savedOGS: [0:Dimension,nest(=+),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 109
<    in V: var float
<    out R: var float
< **   theOI: + V
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 109
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(=+),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(=+),nest(float),nest(+)]
< **   getOGsequenceOfArg:aArgs:V
< **   fArgs.origin.OG=theFargsOG: 
< %basic 109
<    in V: var float
<    out R: var float
< **   OGS: [0:Dimension,nest(=+),nest(float),nest(+)]
< **   theFargOG:
< 
< %basic 109
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(=+),nest(float),nest(+)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(=+),nest(float),nest(+)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(=+),nest(float),nest(+)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(=+),nest(float),nest(+)]
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 109
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Dimension,nest(=+),nest(float),nest(+)]
< **   ENC:result:[1:Dimension,nest(=+),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(=+),nest(float)]
< **   ENC:result:[2:Dimension,nest(=+)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(=+)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(=+)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(=+)]
< **** savedOGS:save:False[0:Dimension,nest(=+)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(=+)]
< **   OGS:[0:Dimension,nest(=+)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(=+)]
< **** OG:semCheck:V
< **   encOG: magnitude + V
< **** Invocation:semCheck: V
< **   encOG:magnitude + V
< **** OI:semCheck: "V" rec: "none"
< **   encOG:magnitude + V
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in V: var float
<    magnitude := magnitude + V
< **   OGs:[0:Unit]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:Unit]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:Unit]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit]
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< **   OGS:[0:Unit]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in V: var float
<    magnitude := magnitude + V
< **   OGS:[0:Unit]
< **** ENC:OI.viaInclude:[0:Unit]
< **   ENC:result:[0:Dimension]
< **** viaInclude:GOT:
< [0:Dimension,nest(=+)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(=+)]
< **** savedOGS:save:False[0:Dimension,nest(=+)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(=+)]
< **   OGS:[0:Dimension,nest(=+)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(=+)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Dimension,nest(=+)]
< **** savedOGS:save:was:[0:Dimension,nest(=+)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(=+)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(=+)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var float
<    magnitude := magnitude + V
< **** OG:semCheck:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:
< if (magnitude < V.magnitude) :then 
<    R.magnitude := magnitude
< :else 
<    R.magnitude := V.magnitude
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: if (magnitude < V.magnitude) :then 
<    R.magnitude := magnitude
< :else 
<    R.magnitude := V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OG:semCheck:(magnitude < V.magnitude)
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: (magnitude < V.magnitude)
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Invocation:semCheck: magnitude < V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "magnitude" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "< V.magnitude" rec: "magnitude"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:
< <  : 
<    %basic 123
<    in V: var float
<    out B: var boolean
< **   actualArgs: V.magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **   argAtInx: 1 in:PTN:
< <  : 
<    %basic 123
<    in V: var float
<    out B: var boolean
< **   theOI: < V.magnitude
< **   fArg: in V: var float
< **   aArg: V.magnitude
< **   theOI.f.f:label: BracketedExp
< (magnitude < V.magnitude)
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **   savedOGS: [0:Dimension,nest(min),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< <  : 
<    %basic 123
<    in V: var float
<    out B: var boolean
< **   theOI: < V.magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 123
< in V: var float
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(min),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(min),nest(float),nest(<)]
< **   getOGsequenceOfArg:aArgs:V.magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 123
<    in V: var float
<    out B: var boolean
< **   OGS: [0:Dimension,nest(min),nest(float),nest(<)]
< **   theFargOG:
< 
< %basic 123
<    in V: var float
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(min),nest(float),nest(<)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(min),nest(float),nest(<)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(min),nest(float),nest(<)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(min),nest(float),nest(<)]
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 123
<    in V: var float
<    out B: var boolean
< **** ENC:OI.getVqual:[1:Dimension,nest(min),nest(float),nest(<)]
< **   ENC:result:[1:Dimension,nest(min),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(min),nest(float)]
< **   ENC:result:[2:Dimension,nest(min)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(min)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(min)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(min)]
< **** savedOGS:save:False[0:Dimension,nest(min)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(min)]
< **   OGS:[0:Dimension,nest(min)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(min)]
< **** OG:semCheck:V.magnitude
< **   encOG: (magnitude < V.magnitude)
< **** Invocation:semCheck: V.magnitude
< **   encOG:(magnitude < V.magnitude)
< **** OI:semCheck: "V" rec: "none"
< **   encOG:(magnitude < V.magnitude)
< **** OI:semCheck: "magnitude" rec: "V"
< **   encOG:(magnitude < V.magnitude)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:R.magnitude := magnitude
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:magnitude
< **   encOG: R.magnitude := magnitude
< **** Invocation:semCheck: magnitude
< **   encOG:R.magnitude := magnitude
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:R.magnitude := magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: R.magnitude := magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:R.magnitude := magnitude
< **   OGs:[0:$0]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:$0]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: R.magnitude := magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: R.magnitude := magnitude
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: R.magnitude := magnitude
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:min]
< **** viaInclude:GOT:
< [0:min,nest($0)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:min,nest($0)]
< **** savedOGS:save:False[0:min,nest($0)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:min,nest($0)]
< **   OGS:[0:min,nest($0)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:min,nest($0)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:min,nest($0)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:min,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := magnitude
< **** OG:semCheck:R.magnitude := V.magnitude
< **   encOG: R.magnitude := magnitude
< **** Invocation:semCheck: 
< **   encOG:R.magnitude := magnitude
< **** OG:semCheck:V.magnitude
< **   encOG: R.magnitude := V.magnitude
< **** Invocation:semCheck: V.magnitude
< **   encOG:R.magnitude := V.magnitude
< **** OI:semCheck: "V" rec: "magnitude"
< **   encOG:R.magnitude := V.magnitude
< **** OI:semCheck: "magnitude" rec: "V"
< **   encOG:R.magnitude := V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: R.magnitude := V.magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:R.magnitude := V.magnitude
< **   OGs:[0:$0]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:$0]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: R.magnitude := V.magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: R.magnitude := V.magnitude
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: R.magnitude := V.magnitude
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:min]
< **** viaInclude:GOT:
< [0:min,nest($0)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:min,nest($0)]
< **** savedOGS:save:False[0:min,nest($0)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:min,nest($0)]
< **   OGS:[0:min,nest($0)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:min,nest($0)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:min,nest($0)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:min,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude < V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** OG:returnDecl: out R: var thisUnit
< **** OG:semCheck:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:thisUnit
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: thisUnit
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "thisUnit" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:thisUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:
< if (magnitude > V.magnitude) :then 
<    R.magnitude := magnitude
< :else 
<    R.magnitude := V.magnitude
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: if (magnitude > V.magnitude) :then 
<    R.magnitude := magnitude
< :else 
<    R.magnitude := V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OG:semCheck:(magnitude > V.magnitude)
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** Invocation:semCheck: (magnitude > V.magnitude)
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Invocation:semCheck: magnitude > V.magnitude
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "magnitude" rec: "none"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** OI:semCheck: "> V.magnitude" rec: "magnitude"
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< 
< **** Pattern:checkActualArgs:
< >  : 
<    %basic 125
<    in V: var float
<    out B: var boolean
< **   actualArgs: V.magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **   argAtInx: 1 in:PTN:
< >  : 
<    %basic 125
<    in V: var float
<    out B: var boolean
< **   theOI: > V.magnitude
< **   fArg: in V: var float
< **   aArg: V.magnitude
< **   theOI.f.f:label: BracketedExp
< (magnitude > V.magnitude)
< **   encOG:
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **   savedOGS: [0:Dimension,nest(max),nest(float)]
< **** PTN:getOGsequenceOfArg: 
< >  : 
<    %basic 125
<    in V: var float
<    out B: var boolean
< **   theOI: > V.magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 125
< in V: var float
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension,nest(max),nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension,nest(max),nest(float),nest(>)]
< **   getOGsequenceOfArg:aArgs:V.magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 125
<    in V: var float
<    out B: var boolean
< **   OGS: [0:Dimension,nest(max),nest(float),nest(>)]
< **   theFargOG:
< 
< %basic 125
<    in V: var float
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension,nest(max),nest(float),nest(>)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension,nest(max),nest(float),nest(>)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension,nest(max),nest(float),nest(>)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension,nest(max),nest(float),nest(>)]
< **   encOG: 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 125
<    in V: var float
<    out B: var boolean
< **** ENC:OI.getVqual:[1:Dimension,nest(max),nest(float),nest(>)]
< **   ENC:result:[1:Dimension,nest(max),nest(float)]
< **** ENC:OI.getVqual:[2:Dimension,nest(max),nest(float)]
< **   ENC:result:[2:Dimension,nest(max)]
< 
< **** getVqual:B2:
< [0:Dimension,nest(max)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(max)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension,nest(max)]
< **** savedOGS:save:False[0:Dimension,nest(max)]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(max)]
< **   OGS:[0:Dimension,nest(max)]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(max)]
< **** OG:semCheck:V.magnitude
< **   encOG: (magnitude > V.magnitude)
< **** Invocation:semCheck: V.magnitude
< **   encOG:(magnitude > V.magnitude)
< **** OI:semCheck: "V" rec: "none"
< **   encOG:(magnitude > V.magnitude)
< **** OI:semCheck: "magnitude" rec: "V"
< **   encOG:(magnitude > V.magnitude)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:R.magnitude := magnitude
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:magnitude
< **   encOG: R.magnitude := magnitude
< **** Invocation:semCheck: magnitude
< **   encOG:R.magnitude := magnitude
< **** OI:semCheck: "magnitude" rec: "magnitude"
< **   encOG:R.magnitude := magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: R.magnitude := magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:R.magnitude := magnitude
< **   OGs:[0:$0]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:$0]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: R.magnitude := magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: R.magnitude := magnitude
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: R.magnitude := magnitude
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:max]
< **** viaInclude:GOT:
< [0:max,nest($0)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:max,nest($0)]
< **** savedOGS:save:False[0:max,nest($0)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:max,nest($0)]
< **   OGS:[0:max,nest($0)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:max,nest($0)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:max,nest($0)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:max,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := magnitude
< **** OG:semCheck:R.magnitude := V.magnitude
< **   encOG: R.magnitude := magnitude
< **** Invocation:semCheck: 
< **   encOG:R.magnitude := magnitude
< **** OG:semCheck:V.magnitude
< **   encOG: R.magnitude := V.magnitude
< **** Invocation:semCheck: V.magnitude
< **   encOG:R.magnitude := V.magnitude
< **** OI:semCheck: "V" rec: "magnitude"
< **   encOG:R.magnitude := V.magnitude
< **** OI:semCheck: "magnitude" rec: "V"
< **   encOG:R.magnitude := V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: R.magnitude := V.magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:R.magnitude := V.magnitude
< **   OGs:[0:$0]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:$0]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: R.magnitude := V.magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: R.magnitude := V.magnitude
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: R.magnitude := V.magnitude
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:max]
< **** viaInclude:GOT:
< [0:max,nest($0)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:max,nest($0)]
< **** savedOGS:save:False[0:max,nest($0)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:max,nest($0)]
< **   OGS:[0:max,nest($0)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:max,nest($0)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:max,nest($0)]
< **** savedOGS:save:was:[0:Unit&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:max,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< R.magnitude := V.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var thisUnit
<    out R: var thisUnit
<    if (magnitude > V.magnitude) :then 
<       R.magnitude := magnitude
<    :else 
< ...
< **** OG:returnDecl: out R: var thisUnit
< **** OG:semCheck:
< out base: var PrimaryUnit
<    inner(toPrimary)
< **   encOG: 
< out base: var PrimaryUnit
<    inner(toPrimary)
< **** Invocation:semCheck: 
< **   encOG:
< out base: var PrimaryUnit
<    inner(toPrimary)
< 
< **** OG:semCheck:PrimaryUnit
< **   encOG: 
< out base: var PrimaryUnit
<    inner(toPrimary)
< **** Invocation:semCheck: PrimaryUnit
< **   encOG:
< out base: var PrimaryUnit
<    inner(toPrimary)
< 
< **** OI:semCheck: "PrimaryUnit" rec: "none"
< **   encOG:
< out base: var PrimaryUnit
<    inner(toPrimary)
< 
< **** Pattern:checkActualArgs:PrimaryUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out base: var PrimaryUnit
<    inner(toPrimary)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:inner(toPrimary)
< **   encOG: 
< out base: var PrimaryUnit
<    inner(toPrimary)
< **** Invocation:semCheck: inner(toPrimary)
< **   encOG:
< out base: var PrimaryUnit
<    inner(toPrimary)
< 
< **** OI:semCheck: "inner(toPrimary)" rec: "none"
< **   encOG:
< out base: var PrimaryUnit
<    inner(toPrimary)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< out base: var PrimaryUnit
<    inner(toPrimary)
< **** OG:semcheck:IS not empty:eOG: 
< 
< out base: var PrimaryUnit
<    inner(toPrimary)
< **** OG:returnDecl: out base: var PrimaryUnit
< **** OG:semCheck:
< in base: var PrimaryUnit
<    inner(fromPrimary)
< **   encOG: 
< in base: var PrimaryUnit
<    inner(fromPrimary)
< **** Invocation:semCheck: 
< **   encOG:
< in base: var PrimaryUnit
<    inner(fromPrimary)
< 
< **** OG:semCheck:PrimaryUnit
< **   encOG: 
< in base: var PrimaryUnit
<    inner(fromPrimary)
< **** Invocation:semCheck: PrimaryUnit
< **   encOG:
< in base: var PrimaryUnit
<    inner(fromPrimary)
< 
< **** OI:semCheck: "PrimaryUnit" rec: "none"
< **   encOG:
< in base: var PrimaryUnit
<    inner(fromPrimary)
< 
< **** Pattern:checkActualArgs:PrimaryUnit:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in base: var PrimaryUnit
<    inner(fromPrimary)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:inner(fromPrimary)
< **   encOG: 
< in base: var PrimaryUnit
<    inner(fromPrimary)
< **** Invocation:semCheck: inner(fromPrimary)
< **   encOG:
< in base: var PrimaryUnit
<    inner(fromPrimary)
< 
< **** OI:semCheck: "inner(fromPrimary)" rec: "none"
< **   encOG:
< in base: var PrimaryUnit
<    inner(fromPrimary)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in base: var PrimaryUnit
<    inner(fromPrimary)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in base: var PrimaryUnit
<    inner(fromPrimary)
< **** OG:semCheck:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **   encOG: 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** Invocation:semCheck: 
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** OG:semCheck:"Unit:".print
< **   encOG: 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** Invocation:semCheck: "Unit:".print
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** OI:semCheck: "print" rec: ""Unit:""
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:inner(print)
< **   encOG: 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** Invocation:semCheck: inner(print)
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** OI:semCheck: "inner(print)" rec: "none"
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** OG:semCheck:put(':')
< **   encOG: 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** Invocation:semCheck: put(':')
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** OI:semCheck: "put(':')" rec: "none"
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(':')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(':')
< **   fArg: in ch: val char
< **   aArg: ':'
< **   theOI.f.f:label: ObjectGenerator
< put(':')
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **   savedOGS: [0:Unit,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(':')
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Unit,nest(print)]
< **   OGS.DOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **   After:[0:Unit,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(':')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Unit,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Unit,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Unit,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Unit,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit,nest(print),nest(put)]
< **   encOG: 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Unit,nest(print),nest(put)]
< **   ENC:result:[1:Unit,nest(print)]
< 
< **** getVqual:B2:
< [0:Unit,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Unit,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Unit,nest(print)]
< **** savedOGS:save:False[0:Unit,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(print)]
< **   OGS:[0:Unit,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(print)]
< **** OG:semCheck:':'
< **   encOG: put(':')
< **** Invocation:semCheck: ':'
< **   encOG:put(':')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:putFloat(magnitude)
< **   encOG: 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** Invocation:semCheck: putFloat(magnitude)
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** OI:semCheck: "putFloat(magnitude)" rec: "none"
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< 
< **** Pattern:checkActualArgs:
< putFloat: 
<    %basic 142
<    in X: var Float
<    out V: var integer
< **   actualArgs: putFloat(magnitude)
< **   fArgs(in X: var Float,)
< 
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **   argAtInx: 1 in:PTN:
< putFloat: 
<    %basic 142
<    in X: var Float
<    out V: var integer
< **   theOI: putFloat(magnitude)
< **   fArg: in X: var Float
< **   aArg: magnitude
< **   theOI.f.f:label: ObjectGenerator
< putFloat(magnitude)
< **   encOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **   savedOGS: [0:Unit,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< putFloat: 
<    %basic 142
<    in X: var Float
<    out V: var integer
< **   theOI: putFloat(magnitude)
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in X: var Float
< **** Items:localSearch: X
< **   in:
< 
< %basic 142
< in X: var Float
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: X
< Try: "X"
< **** Items:localSearch:end: X
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Unit,nest(print)]
< **   OGS.DOG:
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **   After:[0:Unit,nest(print),nest(putFloat)]
< **   getOGsequenceOfArg:aArgs:putFloat(magnitude)
< **   fArgs.origin.OG=theFargsOG: 
< %basic 142
<    in X: var Float
<    out V: var integer
< **   OGS: [0:Unit,nest(print),nest(putFloat)]
< **   theFargOG:
< 
< %basic 142
<    in X: var Float
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Unit,nest(print),nest(putFloat)]
< **** DataItem:getVqual: in X: var Float
< [0:Unit,nest(print),nest(putFloat)]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:Unit,nest(print),nest(putFloat)]
< 
< **** OI:getVqual: Float on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Unit,nest(print),nest(putFloat)]
< **   encOG: 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** koks: Float on: 1 Items 
< **   father: Float
< **   father.f.f.f.f:
< 
< %basic 142
<    in X: var Float
<    out V: var integer
< **** ENC:OI.getVqual:[1:Unit,nest(print),nest(putFloat)]
< **   ENC:result:[1:Unit,nest(print)]
< 
< **** getVqual:B2:
< [0:Unit,nest(print)]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Unit,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Unit,nest(print)]
< **** savedOGS:save:False[0:Unit,nest(print)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Unit,nest(print)]
< **   OGS:[0:Unit,nest(print)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Unit,nest(print)]
< **** OG:semCheck:magnitude
< **   encOG: putFloat(magnitude)
< **** Invocation:semCheck: magnitude
< **   encOG:putFloat(magnitude)
< **** OI:semCheck: "magnitude" rec: "none"
< **   encOG:putFloat(magnitude)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Unit:".print
<    inner(print)
<    put(':')
<    putFloat(magnitude)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< **   encOG: 
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< 
< **** OG:semCheck:inner(Symbol)
< **   encOG: 
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< **** Invocation:semCheck: inner(Symbol)
< **   encOG:
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< 
< **** OI:semCheck: "inner(Symbol)" rec: "none"
< **   encOG:
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    out T: var StringLib.String
<    inner(Symbol)
< **** OG:returnDecl: out T: var StringLib.String
< **** OG:semCheck:Unit
< **   encOG: Unit
< **** Invocation:semCheck: Unit
< **   encOG:Unit
< **** OI:semCheck: "Unit" rec: "MultArgL"
< **   encOG:Unit
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:Unit
< **   encOG: Unit
< **** Invocation:semCheck: Unit
< **   encOG:Unit
< **** OI:semCheck: "Unit" rec: "MultArgR"
< **   encOG:Unit
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:Unit
< **   encOG: Unit
< **** Invocation:semCheck: Unit
< **   encOG:Unit
< **** OI:semCheck: "Unit" rec: "MultRes"
< **   encOG:Unit
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** Invocation:semCheck: 
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OG:semCheck:MultArgL
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** Invocation:semCheck: MultArgL
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OI:semCheck: "MultArgL" rec: "none"
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** Pattern:checkActualArgs:MultArgL:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:MultArgR
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** Invocation:semCheck: MultArgR
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OI:semCheck: "MultArgR" rec: "none"
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** Pattern:checkActualArgs:MultArgR:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:MultRes
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** Invocation:semCheck: MultRes
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OI:semCheck: "MultRes" rec: "none"
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** Pattern:checkActualArgs:MultRes:< Unit**   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %unit "U", 1
<    %public
<    magnitude: var Float
<    thisUnit:< Unit
< ...
< **** OG:semCheck:L.magnitude * R.magnitude
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** Invocation:semCheck: L.magnitude * R.magnitude
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OI:semCheck: "L" rec: "magnitude"
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OI:semCheck: "magnitude" rec: "L"
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OI:semCheck: "* R.magnitude" rec: "magnitude"
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** Pattern:checkActualArgs:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   actualArgs: R.magnitude
< **   fArgs(in V: var float,)
< 
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **   argAtInx: 1 in:PTN:
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * R.magnitude
< **   fArg: in V: var float
< **   aArg: R.magnitude
< **   theOI.f.f:label: ObjectGenerator
< L.magnitude * R.magnitude
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **   savedOGS: [0:Dimension&,nest(float)]
< **** PTN:getOGsequenceOfArg: 
< *  : 
<    %basic 112
<    in V: var float
<    out R: var float
< **   theOI: * R.magnitude
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var float
< **** Items:localSearch: V
< **   in:
< 
< %basic 112
< in V: var float
< out R: var float
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Dimension&,nest(float)]
< **   OGS.DOG:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   After:[0:Dimension&,nest(float),nest(*)]
< **   getOGsequenceOfArg:aArgs:R.magnitude
< **   fArgs.origin.OG=theFargsOG: 
< %basic 112
<    in V: var float
<    out R: var float
< **   OGS: [0:Dimension&,nest(float),nest(*)]
< **   theFargOG:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Dimension&,nest(float),nest(*)]
< **** DataItem:getVqual: in V: var float
< [0:Dimension&,nest(float),nest(*)]
< **** ObjectGenerator:getVqual: float
< **   hasVirtualArgs: False
< **** INV:getVqual:float
< **   OGs: [0:Dimension&,nest(float),nest(*)]
< 
< **** OI:getVqual: float on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Dimension&,nest(float),nest(*)]
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** koks: float on: 2 Items 
< **   father: float
< **   father.f.f.f.f:
< 
< %basic 112
<    in V: var float
<    out R: var float
< **** ENC:OI.getVqual:[1:Dimension&,nest(float),nest(*)]
< **   ENC:result:[1:Dimension&,nest(float)]
< **** ENC:OI.getVqual:[2:Dimension&,nest(float)]
< **   ENC:result:[2:Dimension&]
< 
< **** getVqual:B2:
< [0:Dimension&]
< ---
< 
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension&]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< [0:Dimension&]
< **** savedOGS:save:False[0:Dimension&]
< **   OI: float
< **   OI:getQual:savedOI:float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension&]
< **   OGS:[0:Dimension&]
< **** OI:getVqual:end: float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension&]
< **** OG:semCheck:R.magnitude
< **   encOG: L.magnitude * R.magnitude
< **** Invocation:semCheck: R.magnitude
< **   encOG:L.magnitude * R.magnitude
< **** OI:semCheck: "R" rec: "none"
< **   encOG:L.magnitude * R.magnitude
< **** OI:semCheck: "magnitude" rec: "R"
< **   encOG:L.magnitude * R.magnitude
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:returnDecl: out R: var float
< 
< **** OI:getVqual: magnitude on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< 
< **** OI:getVqual:initial:magnitude
< **   encOG:
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **   OGs:[0:gMult]
< **   ATd: magnitude: var Float
< **** DataItem:getVqual: magnitude: var Float
< [0:gMult]
< **** ObjectGenerator:getVqual: Float
< **   hasVirtualArgs: False
< **** INV:getVqual:Float
< **   OGs: [0:gMult]
< 
< **** OI:getVqual: Float on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:gMult]
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: Float
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **   OGS:[0:gMult]
< ***** viaInclude:notTop: Float name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Float
< **   encOG: 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **   OGS:[0:gMult]
< **** ENC:OI.viaInclude:[0:gMult]
< **   ENC:result:[0:Dimension]
< **** viaInclude:GOT:
< [0:Dimension,nest(gMult)]
< **** Pattern:getVqual: float :isVirtual:False
< [0:Dimension,nest(gMult)]
< **** savedOGS:save:False[0:Dimension,nest(gMult)]
< **   OI: Float
< **   OI:getQual:savedOI:Float
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension,nest(gMult)]
< **   OGS:[0:Dimension,nest(gMult)]
< **** OI:getVqual:end: Float
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(gMult)]
< 
< **** getVqual:initial:afterATd:magnitude
< **   OGSx:[0:Dimension,nest(gMult)]
< **** savedOGS:save:was:[0:Dimension&,nest(Unit)]
< **   OI: magnitude
< **   OI:getQual:savedOI:magnitude
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Dimension&,nest(Unit)]
< **   OGS: none
< **** OI:getVqual:end: magnitude
< **   qual: 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Dimension,nest(gMult)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in L: var MultArgL
<    in R: var MultArgR
<    out U: var MultRes
<    U.magnitude := L.magnitude * R.magnitude
< **** OG:returnDecl: out U: var MultRes
< **** OG:semCheck:inner(Dimension)
< **   encOG: 
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< **** Invocation:semCheck: inner(Dimension)
< **   encOG:
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< 
< **** OI:semCheck: "inner(Dimension)" rec: "none"
< **   encOG:
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %dimension "-top-"
<    %public
<    PrimaryUnit:< Unit
<    Unit: Value
<       %unit "U", 1
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %domain_boundary
<    %public
<    Dimension: 
<       %dimension "-top-"
<       %public
< ...
< **** OG:semCheck:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** Invocation:semCheck: LIB
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** OI:semCheck: "LIB" rec: "%module"
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** OG:semCheck:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Invocation:semCheck: Value
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** OI:semCheck: "Value" rec: "String"
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** Invocation:semCheck: disguised
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** OI:semCheck: "disguised" rec: "%OSDvisibility"
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** Pattern:checkActualArgs:
< disguised: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Invocation:semCheck: 5
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** OG:semCheck:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Invocation:semCheck: 
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** OG:semCheck:integer
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Invocation:semCheck: integer
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:get[0] -- actually an index error, accessing length
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Invocation:semCheck: get[0] -- actually an index error, accessing length
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** OI:semCheck: "get[0] -- actually an index error, accessing length" rec: "V"
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[0]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[0] -- actually an index error, accessing length
< **   fArg: inx: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< get[0] -- actually an index error, accessing length
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   savedOGS: [0:String]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[0] -- actually an index error, accessing length
< **   theOI.on:1,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:String,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[0]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:String,nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(length)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(length)]
< **** savedOGS:save:False[0:String,nest(length)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(length)]
< **   OGS:[0:String,nest(length)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(length)]
< **** OG:semCheck:0
< **   encOG: get[0] -- actually an index error, accessing length
< **** Invocation:semCheck: 0
< **   encOG:get[0] -- actually an index error, accessing length
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: V on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** OI:getVqual:initial:V
< **   encOG:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGs:[0:length]
< **   ATd: out V: var integer
< **** DataItem:getVqual: out V: var integer
< [0:length]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:length]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:length]
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:length]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:length]
< **** ENC:OI.viaInclude:[0:length]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(length)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(length)]
< **** savedOGS:save:False[0:String,nest(length)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(length)]
< **   OGS:[0:String,nest(length)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(length)]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:String,nest(length)]
< **** savedOGS:save:was:[0:String,nest(length)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(length)]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(length)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** OG:returnDecl: out V: var integer
< **** Invocation:semCheck: "["
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** OG:semCheck:integer
< **   encOG: 
< %basic 117
<    out ch: var char
< **** Invocation:semCheck: integer
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 117
<    out ch: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Invocation:semCheck: "]"
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** OG:semCheck:
< %basic 117
<    out ch: var char
< **   encOG: 
< %basic 117
<    out ch: var char
< **** Invocation:semCheck: 
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** Invocation:semCheck: 117
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** OG:semCheck:char
< **   encOG: 
< %basic 117
<    out ch: var char
< **** Invocation:semCheck: char
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %basic 117
<    out ch: var char
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %basic 117
<    out ch: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %basic 117
<    out ch: var char
< **** OG:returnDecl: out ch: var char
< **** OG:semCheck:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Length
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** Invocation:semCheck: Length
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** OI:semCheck: "Length" rec: "L"
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< 
< **** OI:getVqual: L on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** OI:getVqual:initial:L
< **   encOG:
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   OGs:[0:+]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:+]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   OGS:[0:+]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   OGS:[0:+]
< **** ENC:OI.viaInclude:[0:+]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(+)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(+)]
< **** savedOGS:save:False[0:String,nest(+)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(+)]
< **   OGS:[0:String,nest(+)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(+)]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:String,nest(+)]
< **** savedOGS:save:was:[0:String,nest(+)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(+)]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(+)]
< **** OG:semCheck:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Indexed(L + S.length,Integer)
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** Invocation:semCheck: Indexed(L + S.length,Integer)
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:semCheck: "Indexed(L + S.length,Integer)" rec: "none"
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** Pattern:checkActualArgs:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   actualArgs: (L + S.length,Integer)
< **   fArgs(in range: var Integer,in elm:< Object,)
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   argAtInx: 1 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(L + S.length,Integer)
< **   fArg: in range: var Integer
< **   aArg: L + S.length
< **   theOI.f.f:label: ObjectGenerator
< Indexed(L + S.length,Integer)
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(L + S.length,Integer)
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in range: var Integer
< **** Items:localSearch: range
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: range
< Try: "range"
< **** Items:localSearch:end: range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(repeat$0)]
< **   OGS.DOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   After:[0:+,nest(repeat$0),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(L + S.length,Integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:+,nest(repeat$0),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(repeat$0),nest(Indexed)]
< **** DataItem:getVqual: in range: var Integer
< [0:+,nest(repeat$0),nest(Indexed)]
< **** ObjectGenerator:getVqual: Integer
< **   hasVirtualArgs: False
< **** INV:getVqual:Integer
< **   OGs: [0:+,nest(repeat$0),nest(Indexed)]
< 
< **** OI:getVqual: Integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(repeat$0),nest(Indexed)]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: Integer on: 1 Items 
< **   father: Integer
< **   father.f.f.f.f:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** ENC:OI.getVqual:[1:+,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[1:+,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:+,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: Integer
< **   OI:getQual:savedOI:Integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: Integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:L + S.length
< **   encOG: Indexed(L + S.length,Integer)
< **** Invocation:semCheck: L + S.length
< **   encOG:Indexed(L + S.length,Integer)
< **** OI:semCheck: "L" rec: "none"
< **   encOG:Indexed(L + S.length,Integer)
< **** OI:semCheck: "+ S.length" rec: "L"
< **   encOG:Indexed(L + S.length,Integer)
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: S.length
< **   fArgs(in V: var integer,)
< 
< **   encOG:Indexed(L + S.length,Integer)**   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + S.length
< **   fArg: in V: var integer
< **   aArg: S.length
< **   theOI.f.f:label: ObjectGenerator
< L + S.length
< **   encOG:Indexed(L + S.length,Integer)
< **   savedOGS: [0:String,nest(doplus),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + S.length
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(doplus),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:String,nest(doplus),nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:S.length
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:String,nest(doplus),nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(doplus),nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:String,nest(doplus),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(doplus),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(doplus),nest(integer),nest(+)]
< **   encOG: Indexed(L + S.length,Integer)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:String,nest(doplus),nest(integer),nest(+)]
< **   ENC:result:[1:String,nest(doplus),nest(integer)]
< **** ENC:OI.getVqual:[2:String,nest(doplus),nest(integer)]
< **   ENC:result:[2:String,nest(doplus)]
< 
< **** getVqual:B2:
< [0:String,nest(doplus)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(doplus)]
< **** savedOGS:save:False[0:String,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:String,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< **** OG:semCheck:S.length
< **   encOG: L + S.length
< **** Invocation:semCheck: S.length
< **   encOG:L + S.length
< **** OI:semCheck: "S" rec: "none"
< **   encOG:L + S.length
< **** OI:semCheck: "length" rec: "S"
< **   encOG:L + S.length
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:L + S.length**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **   argAtInx: 2 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(L + S.length,Integer)
< **   fArg: in elm:< Object
< **   aArg: Integer
< **   theOI.f.f:label: ObjectGenerator
< Indexed(L + S.length,Integer)
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(L + S.length,Integer)
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "range"
< Try: "elm"
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(repeat$0)]
< **   OGS.DOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   After:[0:+,nest(repeat$0),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(L + S.length,Integer)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:+,nest(repeat$0),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(repeat$0),nest(Indexed)]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:+,nest(repeat$0),nest(Indexed)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:+,nest(repeat$0),nest(Indexed)]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:+,nest(repeat$0),nest(Indexed)]
< **   checkDOG: Indexed 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< father:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:Integer
< **   encOG: Indexed(L + S.length,Integer)
< **** Invocation:semCheck: Integer
< **   encOG:Indexed(L + S.length,Integer)
< **** OI:semCheck: "Integer" rec: "none"
< **   encOG:Indexed(L + S.length,Integer)
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:Indexed(L + S.length,Integer)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** Invocation:semCheck: for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:semCheck: "for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< " rec: "none"
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(doplus)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(doplus)]
< **   OGS.DOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   After:[0:+,nest(doplus),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:+,nest(doplus),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(doplus),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:+,nest(doplus),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(doplus),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(doplus),nest(for:to:repeat)]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:+,nest(doplus),nest(for:to:repeat)]
< **   ENC:result:[1:+,nest(doplus)]
< 
< **** getVqual:B2:
< [0:+,nest(doplus)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(doplus)]
< **** savedOGS:save:False[0:+,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:+,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   fArg: last: var integer
< **   aArg: L
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(doplus)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(doplus)]
< **   OGS.DOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   After:[0:+,nest(doplus),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:+,nest(doplus),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(doplus),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:+,nest(doplus),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(doplus),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(doplus),nest(for:to:repeat)]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:+,nest(doplus),nest(for:to:repeat)]
< **   ENC:result:[1:+,nest(doplus)]
< 
< **** getVqual:B2:
< [0:+,nest(doplus)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(doplus)]
< **** savedOGS:save:False[0:+,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:+,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< **** OG:semCheck:L
< **   encOG: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **** Invocation:semCheck: L
< **   encOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   fArg: repeat:< object
< **   aArg: 
< e := get[inx]
<    T.put(e):at[inx]
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(doplus)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(doplus)]
< **   OGS.DOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   After:[0:+,nest(doplus),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:+,nest(doplus),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(doplus),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:+,nest(doplus),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:+,nest(doplus),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:+,nest(doplus),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< e := get[inx]
<    T.put(e):at[inx]
< **   encOG: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< 
< **** OG:semCheck:get[inx]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** Invocation:semCheck: get[inx]
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:semCheck: "get[inx]" rec: "e"
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< get[inx]
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< **   savedOGS: [0:String]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:4,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:String,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:String,nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(repeat$0)]
< **** savedOGS:save:False[0:String,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$0)]
< **   OGS:[0:String,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: get[inx]
< **** Invocation:semCheck: inx
< **   encOG:get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: e on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual:initial:e
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< **   OGs:[0:doplus]
< **   ATd: e: var integer
< **** DataItem:getVqual: e: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:e
< **   OGSx:[0:+,nest(repeat$0)]
< **** savedOGS:save:was:[0:+,nest(repeat$0)]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS: none
< **** OI:getVqual:end: e
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:T.put(e):at[inx]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** Invocation:semCheck: T.put(e):at[inx]
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:semCheck: "T" rec: "none"
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:semCheck: "put(e):at[inx]" rec: "T"
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put(e):at[inx]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[inx]
< **   fArg: V: var integer
< **   aArg: e
< **   theOI.f.f:label: ObjectGenerator
< T.put(e):at[inx]
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< **   savedOGS: [0:+,nest(repeat$0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(repeat$0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(e):at[inx]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:+,nest(repeat$0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:+,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[2:+,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:+,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:e
< **   encOG: T.put(e):at[inx]
< **** Invocation:semCheck: e
< **   encOG:T.put(e):at[inx]
< **** OI:semCheck: "e" rec: "none"
< **   encOG:T.put(e):at[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< T.put(e):at[inx]
< **   encOG:
< e := get[inx]
<    T.put(e):at[inx]
< **   savedOGS: [0:+,nest(repeat$0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(repeat$0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(e):at[inx]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:+,nest(repeat$0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:+,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[2:+,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:+,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: T.put(e):at[inx]
< **** Invocation:semCheck: inx
< **   encOG:T.put(e):at[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:T.put(e):at[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semcheck:IS not empty:eOG: 
< 
< e := get[inx]
<    T.put(e):at[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** Invocation:semCheck: for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:semCheck: "for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< " rec: "none"
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(doplus)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(doplus)]
< **   OGS.DOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   After:[0:+,nest(doplus),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:+,nest(doplus),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(doplus),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:+,nest(doplus),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(doplus),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(doplus),nest(for:to:repeat)]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:+,nest(doplus),nest(for:to:repeat)]
< **   ENC:result:[1:+,nest(doplus)]
< 
< **** getVqual:B2:
< [0:+,nest(doplus)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(doplus)]
< **** savedOGS:save:False[0:+,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:+,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   fArg: last: var integer
< **   aArg: S.length
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(doplus)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(doplus)]
< **   OGS.DOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   After:[0:+,nest(doplus),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:+,nest(doplus),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(doplus),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:+,nest(doplus),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(doplus),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(doplus),nest(for:to:repeat)]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:+,nest(doplus),nest(for:to:repeat)]
< **   ENC:result:[1:+,nest(doplus)]
< 
< **** getVqual:B2:
< [0:+,nest(doplus)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(doplus)]
< **** savedOGS:save:False[0:+,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:+,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< **** OG:semCheck:S.length
< **   encOG: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** Invocation:semCheck: S.length
< **   encOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< 
< **** OI:semCheck: "S" rec: "none"
< **   encOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< 
< **** OI:semCheck: "length" rec: "S"
< **   encOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   fArg: repeat:< object
< **   aArg: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   savedOGS: [0:+,nest(doplus)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(doplus)]
< **   OGS.DOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   After:[0:+,nest(doplus),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:+,nest(doplus),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(doplus),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:+,nest(doplus),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:+,nest(doplus),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:+,nest(doplus),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   encOG: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< 
< **** OG:semCheck:S.get[inx]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** Invocation:semCheck: S.get[inx]
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:semCheck: "S" rec: "e"
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:semCheck: "get[inx]" rec: "S"
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< S.get[inx]
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   savedOGS: [0:StringLib,nest(String)]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(String)]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:StringLib,nest(String),nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:StringLib,nest(String),nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(String),nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:StringLib,nest(String),nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(String),nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(String),nest(get)]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:StringLib,nest(String),nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:StringLib,nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:StringLib,nest(String),nest(get)]
< **   ENC:result:[0:StringLib,nest(String)]
< **** viaInclude:GOT:
< [0:StringLib,nest(String),nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(String),nest(repeat$0)]
< **** savedOGS:save:False[0:StringLib,nest(String),nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(String),nest(repeat$0)]
< **   OGS:[0:StringLib,nest(String),nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(String),nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: S.get[inx]
< **** Invocation:semCheck: inx
< **   encOG:S.get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:S.get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: e on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual:initial:e
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGs:[0:doplus]
< **   ATd: e: var integer
< **** DataItem:getVqual: e: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:e
< **   OGSx:[0:+,nest(repeat$0)]
< **** savedOGS:save:was:[0:+,nest(repeat$0)]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS: none
< **** OI:getVqual:end: e
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:L + inx
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** Invocation:semCheck: L + inx
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:semCheck: "L" rec: "i"
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:semCheck: "+ inx" rec: "L"
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: inx
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + inx
< **   fArg: in V: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< L + inx
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   savedOGS: [0:String,nest(repeat$0),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(repeat$0),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:String,nest(repeat$0),nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:String,nest(repeat$0),nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(repeat$0),nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:String,nest(repeat$0),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(repeat$0),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(repeat$0),nest(integer),nest(+)]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:String,nest(repeat$0),nest(integer),nest(+)]
< **   ENC:result:[1:String,nest(repeat$0),nest(integer)]
< **** ENC:OI.getVqual:[2:String,nest(repeat$0),nest(integer)]
< **   ENC:result:[2:String,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:String,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(repeat$0)]
< **** savedOGS:save:False[0:String,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$0)]
< **   OGS:[0:String,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: L + inx
< **** Invocation:semCheck: inx
< **   encOG:L + inx
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:L + inx
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: i on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual:initial:i
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGs:[0:doplus]
< **   ATd: i: var integer
< **** DataItem:getVqual: i: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:i
< **   OGSx:[0:+,nest(repeat$0)]
< **** savedOGS:save:was:[0:+,nest(repeat$0)]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS: none
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:T.put(e):at[i]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** Invocation:semCheck: T.put(e):at[i]
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:semCheck: "T" rec: "none"
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:semCheck: "put(e):at[i]" rec: "T"
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put(e):at[i]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[i]
< **   fArg: V: var integer
< **   aArg: e
< **   theOI.f.f:label: ObjectGenerator
< T.put(e):at[i]
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   savedOGS: [0:+,nest(repeat$0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[i]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(repeat$0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(e):at[i]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:+,nest(repeat$0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:+,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[2:+,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:+,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:e
< **   encOG: T.put(e):at[i]
< **** Invocation:semCheck: e
< **   encOG:T.put(e):at[i]
< **** OI:semCheck: "e" rec: "none"
< **   encOG:T.put(e):at[i]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[i]
< **   fArg: inx: var integer
< **   aArg: i
< **   theOI.f.f:label: ObjectGenerator
< T.put(e):at[i]
< **   encOG:
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   savedOGS: [0:+,nest(repeat$0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(e):at[i]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:+,nest(repeat$0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(e):at[i]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:+,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:+,nest(repeat$0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:+,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[2:+,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:+,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$0)]
< **** savedOGS:save:False[0:+,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$0)]
< **   OGS:[0:+,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$0)]
< **** OG:semCheck:i
< **   encOG: T.put(e):at[i]
< **** Invocation:semCheck: i
< **   encOG:T.put(e):at[i]
< **** OI:semCheck: "i" rec: "none"
< **   encOG:T.put(e):at[i]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semcheck:IS not empty:eOG: 
< 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:
< T.asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** Invocation:semCheck: T.asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:semCheck: "T" rec: "V"
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:semCheck: "asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]" rec: "T"
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** Pattern:checkActualArgs:
< asString: 
<    %basic 118
<    out S: var LIB.StringLib.String
< **   actualArgs: -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   fArgs()
< 
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:returnDecl: out S: var LIB.StringLib.String
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual:initial:V
< **   encOG:
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGs:[0:+]
< **   ATd: out V: var String
< **** DataItem:getVqual: out V: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OG:semcheck:IS not empty:eOG: 
< 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** OG:returnDecl: out V: var String
< **** OG:semCheck:
< in T: var String
<    --.. primitive or ?
< **   encOG: 
< in T: var String
<    --.. primitive or ?
< **** Invocation:semCheck: 
< **   encOG:
< in T: var String
<    --.. primitive or ?
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in T: var String
<    --.. primitive or ?
< **** OG:semCheck:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   encOG: 
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< 
< **** OG:semCheck:char
< **   encOG: 
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **** Invocation:semCheck: char
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   encOG: 
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **** Invocation:semCheck: for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< 
< **** OI:semCheck: "for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< " rec: "none"
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   savedOGS: [0:String,nest(scan)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(scan)]
< **   OGS.DOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   After:[0:String,nest(scan),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:String,nest(scan),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(scan),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:String,nest(scan),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(scan),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(scan),nest(for:to:repeat)]
< **   encOG: 
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:String,nest(scan),nest(for:to:repeat)]
< **   ENC:result:[1:String,nest(scan)]
< 
< **** getVqual:B2:
< [0:String,nest(scan)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(scan)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(scan)]
< **** savedOGS:save:False[0:String,nest(scan)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(scan)]
< **   OGS:[0:String,nest(scan)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(scan)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   fArg: last: var integer
< **   aArg: length
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   savedOGS: [0:String,nest(scan)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(scan)]
< **   OGS.DOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   After:[0:String,nest(scan),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:String,nest(scan),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(scan),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:String,nest(scan),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(scan),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(scan),nest(for:to:repeat)]
< **   encOG: 
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:String,nest(scan),nest(for:to:repeat)]
< **   ENC:result:[1:String,nest(scan)]
< 
< **** getVqual:B2:
< [0:String,nest(scan)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(scan)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(scan)]
< **** savedOGS:save:False[0:String,nest(scan)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(scan)]
< **   OGS:[0:String,nest(scan)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(scan)]
< **** OG:semCheck:length
< **   encOG: 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **** Invocation:semCheck: length
< **   encOG:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< 
< **** OI:semCheck: "length" rec: "none"
< **   encOG:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   fArg: repeat:< object
< **   aArg: 
< current := get[inx]
<    inner(scan)
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   encOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   savedOGS: [0:String,nest(scan)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(scan)]
< **   OGS.DOG:
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **   After:[0:String,nest(scan),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:String,nest(scan),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(scan),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:String,nest(scan),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:String,nest(scan),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:String,nest(scan),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< current := get[inx]
<    inner(scan)
< **   encOG: 
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(length):repeat
<    current := get[inx]
<    inner(scan)
< 
< 
< **** OG:semCheck:get[inx]
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **** Invocation:semCheck: get[inx]
< **   encOG:
< current := get[inx]
<    inner(scan)
< 
< **** OI:semCheck: "get[inx]" rec: "current"
< **   encOG:
< current := get[inx]
<    inner(scan)
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< current := get[inx]
<    inner(scan)
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< get[inx]
< **   encOG:
< current := get[inx]
<    inner(scan)
< **   savedOGS: [0:String]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:String,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:String,nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(repeat$0)]
< **** savedOGS:save:False[0:String,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$0)]
< **   OGS:[0:String,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: get[inx]
< **** Invocation:semCheck: inx
< **   encOG:get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: current on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< current := get[inx]
<    inner(scan)
< 
< **** OI:getVqual:initial:current
< **   encOG:
< current := get[inx]
<    inner(scan)
< **   OGs:[0:scan]
< **   ATd: current: var char
< **** DataItem:getVqual: current: var char
< [0:scan]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:scan]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **   OGS:[0:scan]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **   OGS:[0:scan]
< **** ENC:OI.viaInclude:[0:scan]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$0)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:String,nest(repeat$0)]
< **** savedOGS:save:False[0:String,nest(repeat$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$0)]
< **   OGS:[0:String,nest(repeat$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:current
< **   OGSx:[0:String,nest(repeat$0)]
< **** savedOGS:save:was:[0:String,nest(repeat$0)]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$0)]
< **   OGS: none
< **** OI:getVqual:end: current
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$0)]
< **** OG:semCheck:inner(scan)
< **   encOG: 
< current := get[inx]
<    inner(scan)
< **** Invocation:semCheck: inner(scan)
< **   encOG:
< current := get[inx]
<    inner(scan)
< 
< **** OI:semCheck: "inner(scan)" rec: "none"
< **   encOG:
< current := get[inx]
<    inner(scan)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[inx]
<    inner(scan)
< **** OG:semcheck:IS not empty:eOG: 
< 
< current := get[inx]
<    inner(scan)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %Public
<    current: var char
<    for(1):to(length):repeat
<       current := get[inx]
<       inner(scan)
< ...
< **** OG:semCheck:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** Invocation:semCheck: 
< **   encOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< 
< **** OG:semCheck:"gogo\n".print
< **   encOG: "gogo\n".print
< **** Invocation:semCheck: 
< **   encOG:"gogo\n".print
< **** OG:semCheck:"gogo\n".print
< **   encOG: "gogo\n".print
< **** Invocation:semCheck: "gogo\n".print
< **   encOG:"gogo\n".print
< **** OI:semCheck: "print" rec: ""gogo\n""
< **   encOG:"gogo\n".print
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:"gogo\n".print**** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semcheck:IS not empty:eOG: 
< "gogo\n".print
< **** OG:semCheck:
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** Invocation:semCheck: for(1):to(length):repeat
<    put(get[inx])
< 
< **   encOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< 
< **** OI:semCheck: "for(1):to(length):repeat
<    put(get[inx])
< " rec: "none"
< **   encOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(length):repeat
<    put(get[inx])
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   encOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   savedOGS: [0:String,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    put(get[inx])
< 
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(print)]
< **   OGS.DOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   After:[0:String,nest(print),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:String,nest(print),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(print),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:String,nest(print),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(print),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(print),nest(for:to:repeat)]
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:String,nest(print),nest(for:to:repeat)]
< **   ENC:result:[1:String,nest(print)]
< 
< **** getVqual:B2:
< [0:String,nest(print)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(print)]
< **** savedOGS:save:False[0:String,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(print)]
< **   OGS:[0:String,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(print)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(length):repeat
<    put(get[inx])
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   fArg: last: var integer
< **   aArg: length
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   encOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   savedOGS: [0:String,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    put(get[inx])
< 
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(print)]
< **   OGS.DOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   After:[0:String,nest(print),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:String,nest(print),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(print),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:String,nest(print),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(print),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(print),nest(for:to:repeat)]
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:String,nest(print),nest(for:to:repeat)]
< **   ENC:result:[1:String,nest(print)]
< 
< **** getVqual:B2:
< [0:String,nest(print)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(print)]
< **** savedOGS:save:False[0:String,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(print)]
< **   OGS:[0:String,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(print)]
< **** OG:semCheck:length
< **   encOG: 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **** Invocation:semCheck: length
< **   encOG:
< for(1):to(length):repeat
<    put(get[inx])
< 
< 
< **** OI:semCheck: "length" rec: "none"
< **   encOG:
< for(1):to(length):repeat
<    put(get[inx])
< 
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< for(1):to(length):repeat
<    put(get[inx])
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   fArg: repeat:< object
< **   aArg: put(get[inx])
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   encOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   savedOGS: [0:String,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    put(get[inx])
< 
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String,nest(print)]
< **   OGS.DOG:
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   After:[0:String,nest(print),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:String,nest(print),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(print),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:String,nest(print),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:String,nest(print),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:String,nest(print),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:put(get[inx])
< **   encOG: 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(length):repeat
<    put(get[inx])
< 
< 
< **** OG:semCheck:put(get[inx])
< **   encOG: put(get[inx])
< **** Invocation:semCheck: put(get[inx])
< **   encOG:put(get[inx])
< **** OI:semCheck: "put(get[inx])" rec: "none"
< **   encOG:put(get[inx])
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(get[inx])
< **   fArgs(in ch: val char,)
< 
< **   encOG:put(get[inx])**   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(get[inx])
< **   fArg: in ch: val char
< **   aArg: get[inx]
< **   theOI.f.f:label: ObjectGenerator
< put(get[inx])
< **   encOG:put(get[inx])
< **   savedOGS: [0:for:to:repeat$0,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(get[inx])
< **   theOI.on:5,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< **   OGS.DOG:put(get[inx])
< **   After:[0:for:to:repeat$0,nest(repeat$0),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(get[inx])
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:for:to:repeat$0,nest(repeat$0),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:for:to:repeat$0,nest(repeat$0),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:for:to:repeat$0,nest(repeat$0),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:for:to:repeat$0,nest(repeat$0),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$0,nest(repeat$0),nest(put)]
< **   encOG: put(get[inx])
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:for:to:repeat$0,nest(repeat$0),nest(put)]
< **   ENC:result:[1:for:to:repeat$0,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:for:to:repeat$0,nest(repeat$0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:for:to:repeat$0,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:for:to:repeat$0,nest(repeat$0)]
< **** savedOGS:save:False[0:for:to:repeat$0,nest(repeat$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:for:to:repeat$0,nest(repeat$0)]
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:for:to:repeat$0,nest(repeat$0)]
< **** OG:semCheck:get[inx]
< **   encOG: put(get[inx])
< **** Invocation:semCheck: get[inx]
< **   encOG:put(get[inx])
< **** OI:semCheck: "get[inx]" rec: "none"
< **   encOG:put(get[inx])
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:put(get[inx])**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< get[inx]
< **   encOG:put(get[inx])
< **   savedOGS: [0:String]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:3,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:String,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:String,nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: put(get[inx])
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: put(get[inx])
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: put(get[inx])
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(put)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(put)]
< **** savedOGS:save:False[0:String,nest(put)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(put)]
< **   OGS:[0:String,nest(put)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(put)]
< **** OG:semCheck:inx
< **   encOG: get[inx]
< **** Invocation:semCheck: inx
< **   encOG:get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< put(get[inx])
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   encOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** Invocation:semCheck: 
< **   encOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< 
< **** OG:semCheck:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:char
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: char
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: char
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:length
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: length
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "length" rec: "L"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< 
< **** OI:getVqual: L on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual:initial:L
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGs:[0:loop]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:=,nest(loop)]
< **** savedOGS:save:was:[0:=,nest(loop)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OG:semCheck:
< if (L <> Veq.length) :then 
<    leave(loop)
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: if (L <> Veq.length) :then 
<    leave(loop)
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OG:semCheck:(L <> Veq.length)
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: (L <> Veq.length)
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Invocation:semCheck: L <> Veq.length
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "<> Veq.length" rec: "L"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< <>  : 
<    %basic 55
<    in V: var integer
<    out B: var boolean
< **   actualArgs: Veq.length
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   argAtInx: 1 in:PTN:
< <>  : 
<    %basic 55
<    in V: var integer
<    out B: var boolean
< **   theOI: <> Veq.length
< **   fArg: in V: var integer
< **   aArg: Veq.length
< **   theOI.f.f:label: BracketedExp
< (L <> Veq.length)
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   savedOGS: [0:=,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< <>  : 
<    %basic 55
<    in V: var integer
<    out B: var boolean
< **   theOI: <> Veq.length
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 55
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:=,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:=,nest(loop),nest(integer),nest(<>)]
< **   getOGsequenceOfArg:aArgs:Veq.length
< **   fArgs.origin.OG=theFargsOG: 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:=,nest(loop),nest(integer),nest(<>)]
< **   theFargOG:
< 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:=,nest(loop),nest(integer),nest(<>)]
< **** DataItem:getVqual: in V: var integer
< [0:=,nest(loop),nest(integer),nest(<>)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:=,nest(loop),nest(integer),nest(<>)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(loop),nest(integer),nest(<>)]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:=,nest(loop),nest(integer),nest(<>)]
< **   ENC:result:[1:=,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:=,nest(loop),nest(integer)]
< **   ENC:result:[2:=,nest(loop)]
< 
< **** getVqual:B2:
< [0:=,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OG:semCheck:Veq.length
< **   encOG: (L <> Veq.length)
< **** Invocation:semCheck: Veq.length
< **   encOG:(L <> Veq.length)
< **** OI:semCheck: "Veq" rec: "none"
< **   encOG:(L <> Veq.length)
< **** OI:semCheck: "length" rec: "Veq"
< **   encOG:(L <> Veq.length)
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:(L <> Veq.length)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:leave(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:leave(loop)
< **   encOG: leave(loop)
< **** Invocation:semCheck: leave(loop)
< **   encOG:leave(loop)
< **** OI:semCheck: "leave(loop)" rec: "none"
< **   encOG:leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< leave(loop)
< **** OG:semCheck:true
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: true
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "true" rec: "beq"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: beq on=1 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** OI:getVqual:initial:beq
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGs:[0:=,=]
< **   ATd: out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:=,=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,=]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:=,=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   ENC:pred:  pred.DOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   OGsuper: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[2:=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:initial:afterATd:beq
< **   OGSx:[0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: beq
< **   OI:getQual:savedOI:beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS: none
< **** OI:getVqual:end: beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OG:semCheck:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** Invocation:semCheck: for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:semCheck: "for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< " rec: "none"
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   savedOGS: [0:=,nest(loop)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:=,nest(loop)]
< **   OGS.DOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   After:[0:=,nest(loop),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:=,nest(loop),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:=,nest(loop),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:=,nest(loop),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:=,nest(loop),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(loop),nest(for:to:repeat)]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:=,nest(loop),nest(for:to:repeat)]
< **   ENC:result:[1:=,nest(loop)]
< 
< **** getVqual:B2:
< [0:=,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   fArg: last: var integer
< **   aArg: length
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   savedOGS: [0:=,nest(loop)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:=,nest(loop)]
< **   OGS.DOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   After:[0:=,nest(loop),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:=,nest(loop),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:=,nest(loop),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:=,nest(loop),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:=,nest(loop),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(loop),nest(for:to:repeat)]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:=,nest(loop),nest(for:to:repeat)]
< **   ENC:result:[1:=,nest(loop)]
< 
< **** getVqual:B2:
< [0:=,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OG:semCheck:length
< **   encOG: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **** Invocation:semCheck: length
< **   encOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< 
< **** OI:semCheck: "length" rec: "none"
< **   encOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   fArg: repeat:< object
< **   aArg: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   encOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   savedOGS: [0:=,nest(loop)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:=,nest(loop)]
< **   OGS.DOG:
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   After:[0:=,nest(loop),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:=,nest(loop),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:=,nest(loop),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:=,nest(loop),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:=,nest(loop),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:=,nest(loop),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   encOG: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< 
< **** OG:semCheck:get[inx]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** Invocation:semCheck: get[inx]
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:semCheck: "get[inx]" rec: "c1"
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< get[inx]
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   savedOGS: [0:String]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:4,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:String,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:String,nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(repeat$0)]
< **** savedOGS:save:False[0:String,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$0)]
< **   OGS:[0:String,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: get[inx]
< **** Invocation:semCheck: inx
< **   encOG:get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: c1 on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual:initial:c1
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGs:[0:loop]
< **   ATd: c1: var char
< **** DataItem:getVqual: c1: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$0)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$0)]
< **** savedOGS:save:False[0:=,nest(repeat$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$0)]
< **   OGS:[0:=,nest(repeat$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:c1
< **   OGSx:[0:=,nest(repeat$0)]
< **** savedOGS:save:was:[0:=,nest(repeat$0)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$0)]
< **   OGS: none
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$0)]
< **** OG:semCheck:Veq.get[inx]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** Invocation:semCheck: Veq.get[inx]
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:semCheck: "Veq" rec: "c2"
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:semCheck: "get[inx]" rec: "Veq"
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< Veq.get[inx]
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   savedOGS: [0:=,=,nest(String)]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:=,=,nest(String)]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:=,=,nest(String),nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:=,=,nest(String),nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:=,=,nest(String),nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:=,=,nest(String),nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:=,=,nest(String),nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,=,nest(String),nest(get)]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:=,=,nest(String),nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:=,=,nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:=,=,nest(String),nest(get)]
< **   ENC:result:[0:=,=,nest(String)]
< **** viaInclude:GOT:
< [0:=,=,nest(String),nest(repeat$0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,=,nest(String),nest(repeat$0)]
< **** savedOGS:save:False[0:=,=,nest(String),nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=,nest(String),nest(repeat$0)]
< **   OGS:[0:=,=,nest(String),nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=,nest(String),nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: Veq.get[inx]
< **** Invocation:semCheck: inx
< **   encOG:Veq.get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:Veq.get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: c2 on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual:initial:c2
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGs:[0:loop]
< **   ATd: c2: var char
< **** DataItem:getVqual: c2: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$0)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$0)]
< **** savedOGS:save:False[0:=,nest(repeat$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$0)]
< **   OGS:[0:=,nest(repeat$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$0)]
< 
< **** getVqual:initial:afterATd:c2
< **   OGSx:[0:=,nest(repeat$0)]
< **** savedOGS:save:was:[0:=,nest(repeat$0)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$0)]
< **   OGS: none
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$0)]
< **** OG:semCheck:
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** Invocation:semCheck: if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OG:semCheck:(c1 <> c2)
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** Invocation:semCheck: (c1 <> c2)
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** Invocation:semCheck: c1 <> c2
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:semCheck: "c1" rec: "none"
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:semCheck: "<> c2" rec: "c1"
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** Pattern:checkActualArgs:
< <>  : 
<    %basic 55
<    in V: var char
<    out B: var boolean
< **   actualArgs: c2
< **   fArgs(in V: var char,)
< 
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   argAtInx: 1 in:PTN:
< <>  : 
<    %basic 55
<    in V: var char
<    out B: var boolean
< **   theOI: <> c2
< **   fArg: in V: var char
< **   aArg: c2
< **   theOI.f.f:label: BracketedExp
< (c1 <> c2)
< **   encOG:
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   savedOGS: [0:=,nest(repeat$0),nest(char)]
< **** PTN:getOGsequenceOfArg: 
< <>  : 
<    %basic 55
<    in V: var char
<    out B: var boolean
< **   theOI: <> c2
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var char
< **** Items:localSearch: V
< **   in:
< 
< %basic 55
< in V: var char
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:=,nest(repeat$0),nest(char)]
< **   OGS.DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   After:[0:=,nest(repeat$0),nest(char),nest(<>)]
< **   getOGsequenceOfArg:aArgs:c2
< **   fArgs.origin.OG=theFargsOG: 
< %basic 55
<    in V: var char
<    out B: var boolean
< **   OGS: [0:=,nest(repeat$0),nest(char),nest(<>)]
< **   theFargOG:
< 
< %basic 55
<    in V: var char
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:=,nest(repeat$0),nest(char),nest(<>)]
< **** DataItem:getVqual: in V: var char
< [0:=,nest(repeat$0),nest(char),nest(<>)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:=,nest(repeat$0),nest(char),nest(<>)]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(repeat$0),nest(char),nest(<>)]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %basic 55
<    in V: var char
<    out B: var boolean
< **** ENC:OI.getVqual:[1:=,nest(repeat$0),nest(char),nest(<>)]
< **   ENC:result:[1:=,nest(repeat$0),nest(char)]
< **** ENC:OI.getVqual:[2:=,nest(repeat$0),nest(char)]
< **   ENC:result:[2:=,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:=,nest(repeat$0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$0)]
< **** savedOGS:save:False[0:=,nest(repeat$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$0)]
< **   OGS:[0:=,nest(repeat$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$0)]
< **** OG:semCheck:c2
< **   encOG: (c1 <> c2)
< **** Invocation:semCheck: c2
< **   encOG:(c1 <> c2)
< **** OI:semCheck: "c2" rec: "none"
< **   encOG:(c1 <> c2)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< Beq := false
<    leave(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:false
< **   encOG: 
< Beq := false
<    leave(loop)
< **** Invocation:semCheck: false
< **   encOG:
< Beq := false
<    leave(loop)
< 
< **** OI:semCheck: "false" rec: "Beq"
< **   encOG:
< Beq := false
<    leave(loop)
< 
< **** Pattern:checkActualArgs:
< False: 
<    %globals
<    out B: var boolean
<    B := 0
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< Beq := false
<    leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< Beq := false
<    leave(loop)
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** OI:getVqual:initial:Beq
< **   encOG:
< Beq := false
<    leave(loop)
< **   OGs:[0:=,=]
< **   ATd: out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:=,=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,=]
< **   encOG: 
< Beq := false
<    leave(loop)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:=,=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   ENC:pred:  pred.DOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   OGsuper: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[2:=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:initial:afterATd:Beq
< **   OGSx:[0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS: none
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OG:semCheck:leave(loop)
< **   encOG: 
< Beq := false
<    leave(loop)
< **** Invocation:semCheck: leave(loop)
< **   encOG:
< Beq := false
<    leave(loop)
< 
< **** OI:semCheck: "leave(loop)" rec: "none"
< **   encOG:
< Beq := false
<    leave(loop)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := false
<    leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := false
<    leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := false
<    leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** Invocation:semCheck: 
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OG:semCheck:boolean
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** Invocation:semCheck: boolean
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:this(String) = V
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** Invocation:semCheck: this(String) = V
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OI:semCheck: "this(String)" rec: "B"
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OI:semCheck: "= V" rec: "this(String)"
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** Pattern:checkActualArgs:
< =  :: 
<    loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
< ...
< **   actualArgs: V
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   argAtInx: 1 in:PTN:
< =  :: 
<    loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
< ...
< **   theOI: = V
< **   fArg: in Veq: var this(Value)
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< this(String) = V
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   savedOGS: [0:String&]
< **** PTN:getOGsequenceOfArg: 
< =  :: 
<    loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
< ...
< **   theOI: = V
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< loop: do 
<    c1: var char
<    c2: var char
<    L: var integer
<    L := length
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "loop"
< **** Signature:localSearch: Veq in: =  
< **** Items:localSearch: Veq
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< **** Items:localSearch:end: Veq
< **** Signature:localSearch:end: Veq
< **   Items:localSearch:trySuper:
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:1
< **   OGS:[0:String&]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:String&,nest(=)]
< **   getOGsequenceOfArg:aArgs:V
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:String&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PRE: [0:String&,nest(=)]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:String&,nest(=),=]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:String&,nest(=),=]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:String&,nest(=),=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:String&,nest(=),=]
< **** getOGstart: 
< [0:String&,nest(=),=]
< **** getOGstart: 
< [0:String&,nest(=)]
< **** getOGstart:isNest: True qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** OG:semCheck:V
< **   encOG: this(String) = V
< **** Invocation:semCheck: V
< **   encOG:this(String) = V
< **** OI:semCheck: "V" rec: "none"
< **   encOG:this(String) = V
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OI:getVqual:initial:B
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   OGs:[0:<>]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:<>]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<>]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<>]
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   OGS:[0:<>]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   OGS:[0:<>]
< **** ENC:OI.viaInclude:[0:<>]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(<>)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:String,nest(<>)]
< **** savedOGS:save:False[0:String,nest(<>)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(<>)]
< **   OGS:[0:String,nest(<>)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(<>)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:String,nest(<>)]
< **** savedOGS:save:was:[0:String,nest(<>)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(<>)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(<>)]
< **** OG:semCheck:B.not
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** Invocation:semCheck: B.not
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OI:semCheck: "B" rec: "B"
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OI:semCheck: "not" rec: "B"
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** Pattern:checkActualArgs:
< not: 
<    %basic 65
<    out R: var boolean
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< 
< **** OI:getVqual:initial:B
< **   encOG:
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   OGs:[0:<>]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:<>]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<>]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<>]
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   OGS:[0:<>]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **   OGS:[0:<>]
< **** ENC:OI.viaInclude:[0:<>]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(<>)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:String,nest(<>)]
< **** savedOGS:save:False[0:String,nest(<>)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(<>)]
< **   OGS:[0:String,nest(<>)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(<>)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:String,nest(<>)]
< **** savedOGS:save:was:[0:String,nest(<>)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(<>)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(<>)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in V: var String
<    out B: var boolean
<    B := this(String) = V
<    B := B.not
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   encOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **** Invocation:semCheck: 
< **   encOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< 
< **** OG:semCheck:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   encOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **** Invocation:semCheck: 
< **   encOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< 
< **** OG:semCheck:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **   encOG: 
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** Invocation:semCheck: 
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** Invocation:semCheck: char
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:char
< **   encOG: 
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** Invocation:semCheck: char
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** Invocation:semCheck: if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OG:semCheck:(L1 = 0)
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** Invocation:semCheck: (L1 = 0)
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** Invocation:semCheck: L1 = 0
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:semCheck: "L1" rec: "none"
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:semCheck: "= 0" rec: "L1"
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: 0
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 0
< **   fArg: in Veq: var this(Value)
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (L1 = 0)
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   savedOGS: [0:<=,nest(isEmpty),nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 0
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:<=,nest(isEmpty),nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:0
< **   encOG: (L1 = 0)
< **** Invocation:semCheck: 0
< **   encOG:(L1 = 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< Beq := L1 <= L2
<    leave(matchEq)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:L1 <= L2
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** Invocation:semCheck: L1 <= L2
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:semCheck: "L1" rec: "Beq"
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:semCheck: "<= L2" rec: "L1"
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: L2
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< **   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= L2
< **   fArg: in Veq: var this(Value)
< **   aArg: L2
< **   theOI.f.f:label: ObjectGenerator
< L1 <= L2
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< **   savedOGS: [0:<=,nest($0),nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= L2
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:<=,nest($0),nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:L2
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** getOGstart: 
< [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:L2
< **   encOG: L1 <= L2
< **** Invocation:semCheck: L2
< **   encOG:L1 <= L2
< **** OI:semCheck: "L2" rec: "none"
< **   encOG:L1 <= L2
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** OI:getVqual:initial:Beq
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGs:[0:<=,<=]
< **   ATd: out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:initial:afterATd:Beq
< **   OGSx:[0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS: none
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OG:semCheck:leave(matchEq)
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** Invocation:semCheck: leave(matchEq)
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:semCheck: "leave(matchEq)" rec: "none"
< **   encOG:
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OG:semCheck:
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** Invocation:semCheck: if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OG:semCheck:(L2 = 0)
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** Invocation:semCheck: (L2 = 0)
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** Invocation:semCheck: L2 = 0
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:semCheck: "L2" rec: "none"
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:semCheck: "= 0" rec: "L2"
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: 0
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 0
< **   fArg: in Veq: var this(Value)
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (L2 = 0)
< **   encOG:
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   savedOGS: [0:<=,nest(isEmpty),nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = 0
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:<=,nest(isEmpty),nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** getOGstart: 
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:0
< **   encOG: (L2 = 0)
< **** Invocation:semCheck: 0
< **   encOG:(L2 = 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< Beq := false
<    leave(matchEq)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:false
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **** Invocation:semCheck: false
< **   encOG:
< Beq := false
<    leave(matchEq)
< 
< **** OI:semCheck: "false" rec: "Beq"
< **   encOG:
< Beq := false
<    leave(matchEq)
< 
< **** Pattern:checkActualArgs:
< False: 
<    %globals
<    out B: var boolean
<    B := 0
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< Beq := false
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** OI:getVqual:initial:Beq
< **   encOG:
< Beq := false
<    leave(matchEq)
< **   OGs:[0:<=,<=]
< **   ATd: out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:initial:afterATd:Beq
< **   OGSx:[0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS: none
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OG:semCheck:leave(matchEq)
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **** Invocation:semCheck: leave(matchEq)
< **   encOG:
< Beq := false
<    leave(matchEq)
< 
< **** OI:semCheck: "leave(matchEq)" rec: "none"
< **   encOG:
< Beq := false
<    leave(matchEq)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := false
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := false
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := false
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** OG:semCheck:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:inx + 1
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** Invocation:semCheck: inx + 1
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:semCheck: "inx" rec: "inx"
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:semCheck: "+ 1" rec: "inx"
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< inx + 1
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   savedOGS: [0:loop,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:loop,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:loop,nest(loop),nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:loop,nest(loop),nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:loop,nest(loop),nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:loop,nest(loop),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop,nest(loop),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest(loop),nest(integer),nest(+)]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:loop,nest(loop),nest(integer),nest(+)]
< **   ENC:result:[1:loop,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:loop,nest(loop),nest(integer)]
< **   ENC:result:[2:loop,nest(loop)]
< 
< **** getVqual:B2:
< [0:loop,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OG:semCheck:1
< **   encOG: inx + 1
< **** Invocation:semCheck: 1
< **   encOG:inx + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual:initial:inx
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGs:[0:matchEq]
< **   ATd: inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:initial:afterATd:inx
< **   OGSx:[0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OG:semCheck:get[inx]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** Invocation:semCheck: get[inx]
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:semCheck: "get[inx]" rec: "c1"
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< get[inx]
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   savedOGS: [0:String]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:4,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:String]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:String,nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:String,nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:String,nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(loop)]
< **** savedOGS:save:False[0:String,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(loop)]
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OG:semCheck:inx
< **   encOG: get[inx]
< **** Invocation:semCheck: inx
< **   encOG:get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual:initial:c1
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGs:[0:matchEq]
< **   ATd: c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:initial:afterATd:c1
< **   OGSx:[0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OG:semCheck:Veq.get[inx]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** Invocation:semCheck: Veq.get[inx]
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:semCheck: "Veq" rec: "c2"
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:semCheck: "get[inx]" rec: "Veq"
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   actualArgs: get[inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< Veq.get[inx]
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   savedOGS: [0:<=,<=,nest(String)]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **   theOI: get[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 117
< out ch: var char
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "ch"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:<=,<=,nest(String)]
< **   OGS.DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   After:[0:<=,<=,nest(String),nest(get)]
< **   getOGsequenceOfArg:aArgs:get[inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 117
<    out ch: var char
< **   OGS: [0:<=,<=,nest(String),nest(get)]
< **   theFargOG:
< 
< %basic 117
<    out ch: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:<=,<=,nest(String),nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:<=,<=,nest(String),nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:<=,<=,nest(String),nest(get)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=,nest(String),nest(get)]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:<=,<=,nest(String),nest(get)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:<=,<=,nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:<=,<=,nest(String),nest(get)]
< **   ENC:result:[0:<=,<=,nest(String)]
< **** viaInclude:GOT:
< [0:<=,<=,nest(String),nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,<=,nest(String),nest(loop)]
< **** savedOGS:save:False[0:<=,<=,nest(String),nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=,nest(String),nest(loop)]
< **   OGS:[0:<=,<=,nest(String),nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=,nest(String),nest(loop)]
< **** OG:semCheck:inx
< **   encOG: Veq.get[inx]
< **** Invocation:semCheck: inx
< **   encOG:Veq.get[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:Veq.get[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out ch: var char
< 
< **** OI:getVqual: c2 on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual:initial:c2
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGs:[0:matchEq]
< **   ATd: c2: var char
< **** DataItem:getVqual: c2: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:initial:afterATd:c2
< **   OGSx:[0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OG:semCheck:
< if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** Invocation:semCheck: if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OG:semCheck:(c1 = c2)
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** Invocation:semCheck: (c1 = c2)
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** Invocation:semCheck: c1 = c2
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:semCheck: "c1" rec: "none"
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:semCheck: "= c2" rec: "c1"
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: c2
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = c2
< **   fArg: in Veq: var this(Value)
< **   aArg: c2
< **   theOI.f.f:label: BracketedExp
< (c1 = c2)
< **   encOG:
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   savedOGS: [0:loop,nest(loop),nest(char),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = c2
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:loop,nest(loop),nest(char),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:loop,nest(loop),nest(char),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:c2
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:loop,nest(loop),nest(char),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:loop,nest(loop),nest(char),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:loop,nest(loop),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:loop,nest(loop),nest(char),Value&,nest(=)]
< **** getOGstart: 
< [0:loop,nest(loop),nest(char),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:c2
< **   encOG: (c1 = c2)
< **** Invocation:semCheck: c2
< **   encOG:(c1 = c2)
< **** OI:semCheck: "c2" rec: "none"
< **   encOG:(c1 = c2)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< if (inx < L) :then 
<       restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:
< if (inx < L) :then 
<    restart(loop)
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** Invocation:semCheck: if (inx < L) :then 
<    restart(loop)
< **   encOG:
< if (inx < L) :then 
<       restart(loop)
< 
< **** OG:semCheck:(inx < L)
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** Invocation:semCheck: (inx < L)
< **   encOG:
< if (inx < L) :then 
<       restart(loop)
< 
< **** Invocation:semCheck: inx < L
< **   encOG:
< if (inx < L) :then 
<       restart(loop)
< 
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:
< if (inx < L) :then 
<       restart(loop)
< 
< **** OI:semCheck: "< L" rec: "inx"
< **   encOG:
< if (inx < L) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   actualArgs: L
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< if (inx < L) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < L
< **   fArg: in V: var integer
< **   aArg: L
< **   theOI.f.f:label: BracketedExp
< (inx < L)
< **   encOG:
< if (inx < L) :then 
<       restart(loop)
< **   savedOGS: [0:loop,nest($0),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < L
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 51
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:loop,nest($0),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:loop,nest($0),nest(integer),nest(<)]
< **   getOGsequenceOfArg:aArgs:L
< **   fArgs.origin.OG=theFargsOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:loop,nest($0),nest(integer),nest(<)]
< **   theFargOG:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:loop,nest($0),nest(integer),nest(<)]
< **** DataItem:getVqual: in V: var integer
< [0:loop,nest($0),nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop,nest($0),nest(integer),nest(<)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest($0),nest(integer),nest(<)]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:loop,nest($0),nest(integer),nest(<)]
< **   ENC:result:[1:loop,nest($0),nest(integer)]
< **** ENC:OI.getVqual:[2:loop,nest($0),nest(integer)]
< **   ENC:result:[2:loop,nest($0)]
< 
< **** getVqual:B2:
< [0:loop,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest($0)]
< **** savedOGS:save:False[0:loop,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($0)]
< **   OGS:[0:loop,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($0)]
< **** OG:semCheck:L
< **   encOG: (inx < L)
< **** Invocation:semCheck: L
< **   encOG:(inx < L)
< **** OI:semCheck: "L" rec: "none"
< **   encOG:(inx < L)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:restart(loop)
< **   encOG: restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:restart(loop)
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (inx < L) :then 
<       restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (inx < L) :then 
<       restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OG:semCheck:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** Invocation:semCheck: if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
<    leave(matchEq)
< **   encOG:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** OG:semCheck:(c1 = c2)
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** Invocation:semCheck: (c1 = c2)
< **   encOG:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** Invocation:semCheck: c1 = c2
< **   encOG:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** OI:semCheck: "c1" rec: "none"
< **   encOG:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** OI:semCheck: "= c2" rec: "c1"
< **   encOG:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** Pattern:checkActualArgs:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   actualArgs: c2
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   argAtInx: 1 in:PTN:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = c2
< **   fArg: in Veq: var this(Value)
< **   aArg: c2
< **   theOI.f.f:label: BracketedExp
< (c1 = c2)
< **   encOG:
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   savedOGS: [0:loop,nest(doit),nest(char),Value&]
< **** PTN:getOGsequenceOfArg: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   theOI: = c2
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:loop,nest(doit),nest(char),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:loop,nest(doit),nest(char),Value&,nest(=)]
< **   getOGsequenceOfArg:aArgs:c2
< **   fArgs.origin.OG=theFargsOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGS: [0:loop,nest(doit),nest(char),Value&,nest(=)]
< **   theFargOG:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:loop,nest(doit),nest(char),Value&,nest(=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:loop,nest(doit),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:loop,nest(doit),nest(char),Value&,nest(=)]
< **** getOGstart: 
< [0:loop,nest(doit),nest(char),Value&,nest(=)]
< **** getOGstart:isNest: True qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OG:semCheck:c2
< **   encOG: (c1 = c2)
< **** Invocation:semCheck: c2
< **   encOG:(c1 = c2)
< **** OI:semCheck: "c2" rec: "none"
< **   encOG:(c1 = c2)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semCheck:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:L1 <= L2
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** Invocation:semCheck: L1 <= L2
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:semCheck: "L1" rec: "Beq"
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:semCheck: "<= L2" rec: "L1"
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** Pattern:checkActualArgs:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   actualArgs: L2
< **   fArgs(in Veq: var this(Value),)
< 
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   argAtInx: 1 in:PTN:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= L2
< **   fArg: in Veq: var this(Value)
< **   aArg: L2
< **   theOI.f.f:label: ObjectGenerator
< L1 <= L2
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   savedOGS: [0:<=,nest($0),nest(integer),Value&]
< **** PTN:getOGsequenceOfArg: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   theOI: <= L2
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Veq: var this(Value)
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **   pathTo:parDecl:pn:0
< **   OGS:[0:<=,nest($0),nest(integer),Value&]
< **   OGS.DOG:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   After:[0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **   getOGsequenceOfArg:aArgs:L2
< **   fArgs.origin.OG=theFargsOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGS: [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **   theFargOG:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** getOGstart: 
< [0:<=,nest($0),nest(integer),Value&,nest(<=)]
< **** getOGstart:isNest: True qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** OG:semCheck:L2
< **   encOG: L1 <= L2
< **** Invocation:semCheck: L2
< **   encOG:L1 <= L2
< **** OI:semCheck: "L2" rec: "none"
< **   encOG:L1 <= L2
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out Beq: var boolean
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** OI:getVqual:initial:Beq
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   OGs:[0:<=,<=]
< **   ATd: out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:initial:afterATd:Beq
< **   OGSx:[0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS: none
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OG:semCheck:leave(matchEq)
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** Invocation:semCheck: leave(matchEq)
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:semCheck: "leave(matchEq)" rec: "none"
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** OG:semCheck:
< Beq := c1 < c2
<    leave(matchEq)
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** Invocation:semCheck: 
< **   encOG:
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OG:semCheck:c1 < c2
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** Invocation:semCheck: c1 < c2
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:semCheck: "c1" rec: "Beq"
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:semCheck: "< c2" rec: "c1"
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** Pattern:checkActualArgs:
< <  : 
<    %basic 51
<    in V: var char
<    out B: var boolean
< **   actualArgs: c2
< **   fArgs(in V: var char,)
< 
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< **   argAtInx: 1 in:PTN:
< <  : 
<    %basic 51
<    in V: var char
<    out B: var boolean
< **   theOI: < c2
< **   fArg: in V: var char
< **   aArg: c2
< **   theOI.f.f:label: ObjectGenerator
< c1 < c2
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< **   savedOGS: [0:loop,nest($0),nest(char)]
< **** PTN:getOGsequenceOfArg: 
< <  : 
<    %basic 51
<    in V: var char
<    out B: var boolean
< **   theOI: < c2
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var char
< **** Items:localSearch: V
< **   in:
< 
< %basic 51
< in V: var char
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:loop,nest($0),nest(char)]
< **   OGS.DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   After:[0:loop,nest($0),nest(char),nest(<)]
< **   getOGsequenceOfArg:aArgs:c2
< **   fArgs.origin.OG=theFargsOG: 
< %basic 51
<    in V: var char
<    out B: var boolean
< **   OGS: [0:loop,nest($0),nest(char),nest(<)]
< **   theFargOG:
< 
< %basic 51
<    in V: var char
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:loop,nest($0),nest(char),nest(<)]
< **** DataItem:getVqual: in V: var char
< [0:loop,nest($0),nest(char),nest(<)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop,nest($0),nest(char),nest(<)]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest($0),nest(char),nest(<)]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var char
<    out B: var boolean
< **** ENC:OI.getVqual:[1:loop,nest($0),nest(char),nest(<)]
< **   ENC:result:[1:loop,nest($0),nest(char)]
< **** ENC:OI.getVqual:[2:loop,nest($0),nest(char)]
< **   ENC:result:[2:loop,nest($0)]
< 
< **** getVqual:B2:
< [0:loop,nest($0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest($0)]
< **** savedOGS:save:False[0:loop,nest($0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($0)]
< **   OGS:[0:loop,nest($0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($0)]
< **** OG:semCheck:c2
< **   encOG: c1 < c2
< **** Invocation:semCheck: c2
< **   encOG:c1 < c2
< **** OI:semCheck: "c2" rec: "none"
< **   encOG:c1 < c2
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=True getRtnQual=False
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** OI:getVqual:initial:Beq
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< **   OGs:[0:<=,<=]
< **   ATd: out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:initial:afterATd:Beq
< **   OGSx:[0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS: none
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OG:semCheck:leave(matchEq)
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** Invocation:semCheck: leave(matchEq)
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:semCheck: "leave(matchEq)" rec: "none"
< **   encOG:
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := c1 < c2
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := c1 < c2
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Beq := c1 < c2
<    leave(matchEq)
< **** OG:semcheck:IS not empty:eOG: 
< 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** OG:semCheck:integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< length
< -- min length of this and V
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: length
< -- min length of this and V
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "length
< -- min length of this and V" rec: "L1"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: -- min length of this and V
< **   fArgs()
< 
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< 
< **** OI:getVqual: L1 on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:getVqual:initial:L1
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGs:[0:loop]
< **   ATd: L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:initial:afterATd:L1
< **   OGSx:[0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OG:semCheck:Veq.length
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: Veq.length
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "Veq" rec: "L2"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "length" rec: "Veq"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Pattern:checkActualArgs:
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< 
< **** OI:getVqual: L2 on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:getVqual:initial:L2
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGs:[0:loop]
< **   ATd: L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:initial:afterATd:L2
< **   OGSx:[0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OG:semCheck:
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OG:semCheck:(L1 < L2)
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: (L1 < L2)
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Invocation:semCheck: L1 < L2
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "L1" rec: "none"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "< L2" rec: "L1"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Pattern:checkActualArgs:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   actualArgs: L2
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   argAtInx: 1 in:PTN:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < L2
< **   fArg: in V: var integer
< **   aArg: L2
< **   theOI.f.f:label: BracketedExp
< (L1 < L2)
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   savedOGS: [0:<=,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < L2
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 51
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:<=,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:<=,nest(loop),nest(integer),nest(<)]
< **   getOGsequenceOfArg:aArgs:L2
< **   fArgs.origin.OG=theFargsOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:<=,nest(loop),nest(integer),nest(<)]
< **   theFargOG:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:<=,nest(loop),nest(integer),nest(<)]
< **** DataItem:getVqual: in V: var integer
< [0:<=,nest(loop),nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:<=,nest(loop),nest(integer),nest(<)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest(loop),nest(integer),nest(<)]
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:<=,nest(loop),nest(integer),nest(<)]
< **   ENC:result:[1:<=,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:<=,nest(loop),nest(integer)]
< **   ENC:result:[2:<=,nest(loop)]
< 
< **** getVqual:B2:
< [0:<=,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OG:semCheck:L2
< **   encOG: (L1 < L2)
< **** Invocation:semCheck: L2
< **   encOG:(L1 < L2)
< **** OI:semCheck: "L2" rec: "none"
< **   encOG:(L1 < L2)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:L := L1
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:L1
< **   encOG: L := L1
< **** Invocation:semCheck: L1
< **   encOG:L := L1
< **** OI:semCheck: "L1" rec: "L"
< **   encOG:L := L1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: L on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: L := L1
< 
< **** OI:getVqual:initial:L
< **   encOG:L := L1
< **   OGs:[0:loop]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: L := L1
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: L := L1
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: L := L1
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($0)]
< **** savedOGS:save:False[0:<=,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($0)]
< **   OGS:[0:<=,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($0)]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:<=,nest($0)]
< **** savedOGS:save:was:[0:<=,nest($0)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< L := L1
< **** OG:semCheck:L := L2
< **   encOG: L := L1
< **** Invocation:semCheck: 
< **   encOG:L := L1
< **** OG:semCheck:L2
< **   encOG: L := L2
< **** Invocation:semCheck: L2
< **   encOG:L := L2
< **** OI:semCheck: "L2" rec: "L"
< **   encOG:L := L2
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: L on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: L := L2
< 
< **** OI:getVqual:initial:L
< **   encOG:L := L2
< **   OGs:[0:loop]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: L := L2
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: L := L2
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: L := L2
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($0)]
< **** savedOGS:save:False[0:<=,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($0)]
< **   OGS:[0:<=,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($0)]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:<=,nest($0)]
< **** savedOGS:save:was:[0:<=,nest($0)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< L := L2
< **** OG:semcheck:IS not empty:eOG: 
< L := L2
< **** OG:semCheck:matchEq
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** Invocation:semCheck: matchEq
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:semCheck: "matchEq" rec: "none"
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** Pattern:checkActualArgs:
< matchEq: 
<    inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **** OG:returnDecl: out Beq: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:semCheck:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** Invocation:semCheck: 
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OG:semCheck:char
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** Invocation:semCheck: char
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OI:semCheck: "char" rec: "none"
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semCheck:Indexed(1,char)
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** Invocation:semCheck: Indexed(1,char)
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OI:semCheck: "Indexed(1,char)" rec: "none"
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** Pattern:checkActualArgs:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   actualArgs: (1,char)
< **   fArgs(in range: var Integer,in elm:< Object,)
< 
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   argAtInx: 1 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(1,char)
< **   fArg: in range: var Integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< Indexed(1,char)
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   savedOGS: [0:StringLib,nest(C)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(1,char)
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in range: var Integer
< **** Items:localSearch: range
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: range
< Try: "range"
< **** Items:localSearch:end: range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(C)]
< **   OGS.DOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   After:[0:StringLib,nest(C),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(1,char)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:StringLib,nest(C),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(C),nest(Indexed)]
< **** DataItem:getVqual: in range: var Integer
< [0:StringLib,nest(C),nest(Indexed)]
< **** ObjectGenerator:getVqual: Integer
< **   hasVirtualArgs: False
< **** INV:getVqual:Integer
< **   OGs: [0:StringLib,nest(C),nest(Indexed)]
< 
< **** OI:getVqual: Integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(C),nest(Indexed)]
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** koks: Integer on: 1 Items 
< **   father: Integer
< **   father.f.f.f.f:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** ENC:OI.getVqual:[1:StringLib,nest(C),nest(Indexed)]
< **   ENC:result:[1:StringLib,nest(C)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(C)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(C)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(C)]
< **** savedOGS:save:False[0:StringLib,nest(C)]
< **   OI: Integer
< **   OI:getQual:savedOI:Integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(C)]
< **   OGS:[0:StringLib,nest(C)]
< **** OI:getVqual:end: Integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(C)]
< **** OG:semCheck:1
< **   encOG: Indexed(1,char)
< **** Invocation:semCheck: 1
< **   encOG:Indexed(1,char)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(1,char)
< **   fArg: in elm:< Object
< **   aArg: char
< **   theOI.f.f:label: ObjectGenerator
< Indexed(1,char)
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   savedOGS: [0:StringLib,nest(C)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(1,char)
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "range"
< Try: "elm"
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(C)]
< **   OGS.DOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   After:[0:StringLib,nest(C),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(1,char)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:StringLib,nest(C),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(C),nest(Indexed)]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:StringLib,nest(C),nest(Indexed)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:StringLib,nest(C),nest(Indexed)]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:StringLib,nest(C),nest(Indexed)]
< **   checkDOG: Indexed 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< father:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:char
< **   encOG: Indexed(1,char)
< **** Invocation:semCheck: char
< **   encOG:Indexed(1,char)
< **** OI:semCheck: "char" rec: "none"
< **   encOG:Indexed(1,char)
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:Indexed(1,char)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:D.put(ch):at[1]
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** Invocation:semCheck: D.put(ch):at[1]
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OI:semCheck: "D" rec: "none"
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OI:semCheck: "put(ch):at[1]" rec: "D"
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put(ch):at[1]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[1]
< **   fArg: V: var integer
< **   aArg: ch
< **   theOI.f.f:label: ObjectGenerator
< D.put(ch):at[1]
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   savedOGS: [0:StringLib,nest(C),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[1]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(C),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(ch):at[1]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest(C),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest(C),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest(C)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(C)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(C)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(C)]
< **** savedOGS:save:False[0:StringLib,nest(C)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(C)]
< **   OGS:[0:StringLib,nest(C)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(C)]
< **** OG:semCheck:ch
< **   encOG: D.put(ch):at[1]
< **** Invocation:semCheck: ch
< **   encOG:D.put(ch):at[1]
< **** OI:semCheck: "ch" rec: "none"
< **   encOG:D.put(ch):at[1]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[1]
< **   fArg: inx: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< D.put(ch):at[1]
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   savedOGS: [0:StringLib,nest(C),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(ch):at[1]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(C),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(ch):at[1]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest(C),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest(C),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest(C),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest(C)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(C)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(C)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(C)]
< **** savedOGS:save:False[0:StringLib,nest(C)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(C)]
< **   OGS:[0:StringLib,nest(C)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(C)]
< **** OG:semCheck:1
< **   encOG: D.put(ch):at[1]
< **** Invocation:semCheck: 1
< **   encOG:D.put(ch):at[1]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semCheck:D.asString
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** Invocation:semCheck: D.asString
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OI:semCheck: "D" rec: "S"
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OI:semCheck: "asString" rec: "D"
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** Pattern:checkActualArgs:
< asString: 
<    %basic 118
<    out S: var LIB.StringLib.String
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:returnDecl: out S: var LIB.StringLib.String
< 
< **** OI:getVqual: S on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< 
< **** OI:getVqual:initial:S
< **   encOG:
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **   OGs:[0:C]
< **   ATd: out S: var String
< **** DataItem:getVqual: out S: var String
< [0:C]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:C]
< 
< **** OI:getVqual: String on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:C]
< **   encOG: 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** koks: String on: 1 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** ENC:OI.getVqual:[1:C]
< **   ENC:result:[1:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:initial:afterATd:S
< **   OGSx:[0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS: none
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in ch: var char
<    out S: var String
<    D: obj Indexed(1,char)
<    D.put(ch):at[1]
<    S := D.asString
< **** OG:returnDecl: out S: var String
< **** OG:semCheck:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Invocation:semCheck: disguised
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "disguised" rec: "%OSDvisibility"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< disguised: 
<    dummy: var integer -- const for OSDvisibility
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Indexed(20,char)
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: Indexed(20,char)
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "Indexed(20,char)" rec: "none"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   actualArgs: (20,char)
< **   fArgs(in range: var Integer,in elm:< Object,)
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   argAtInx: 1 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   fArg: in range: var Integer
< **   aArg: 20
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,char)
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in range: var Integer
< **** Items:localSearch: range
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: range
< Try: "range"
< **** Items:localSearch:end: range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0)]
< **   OGS.DOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   After:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,char)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(Indexed)]
< **** DataItem:getVqual: in range: var Integer
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **** ObjectGenerator:getVqual: Integer
< **   hasVirtualArgs: False
< **** INV:getVqual:Integer
< **   OGs: [0:StringLib,nest(repeat$0),nest(Indexed)]
< 
< **** OI:getVqual: Integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** koks: Integer on: 1 Items 
< **   father: Integer
< **   father.f.f.f.f:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** ENC:OI.getVqual:[1:StringLib,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[1:StringLib,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(repeat$0)]
< **** savedOGS:save:False[0:StringLib,nest(repeat$0)]
< **   OI: Integer
< **   OI:getQual:savedOI:Integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OI:getVqual:end: Integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OG:semCheck:20
< **   encOG: Indexed(20,char)
< **** Invocation:semCheck: 20
< **   encOG:Indexed(20,char)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   fArg: in elm:< Object
< **   aArg: char
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,char)
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "range"
< Try: "elm"
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0)]
< **   OGS.DOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   After:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,char)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(Indexed)]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   checkDOG: Indexed 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< father:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:char
< **   encOG: Indexed(20,char)
< **** Invocation:semCheck: char
< **   encOG:Indexed(20,char)
< **** OI:semCheck: "char" rec: "none"
< **   encOG:Indexed(20,char)
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:Indexed(20,char)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:Indexed(20,char)
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: Indexed(20,char)
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "Indexed(20,char)" rec: "none"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   actualArgs: (20,char)
< **   fArgs(in range: var Integer,in elm:< Object,)
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   argAtInx: 1 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   fArg: in range: var Integer
< **   aArg: 20
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,char)
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in range: var Integer
< **** Items:localSearch: range
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: range
< Try: "range"
< **** Items:localSearch:end: range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0)]
< **   OGS.DOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   After:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,char)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(Indexed)]
< **** DataItem:getVqual: in range: var Integer
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **** ObjectGenerator:getVqual: Integer
< **   hasVirtualArgs: False
< **** INV:getVqual:Integer
< **   OGs: [0:StringLib,nest(repeat$0),nest(Indexed)]
< 
< **** OI:getVqual: Integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** koks: Integer on: 1 Items 
< **   father: Integer
< **   father.f.f.f.f:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** ENC:OI.getVqual:[1:StringLib,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[1:StringLib,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(repeat$0)]
< **** savedOGS:save:False[0:StringLib,nest(repeat$0)]
< **   OI: Integer
< **   OI:getQual:savedOI:Integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OI:getVqual:end: Integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OG:semCheck:20
< **   encOG: Indexed(20,char)
< **** Invocation:semCheck: 20
< **   encOG:Indexed(20,char)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   fArg: in elm:< Object
< **   aArg: char
< **   theOI.f.f:label: ObjectGenerator
< Indexed(20,char)
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **   theOI: Indexed(20,char)
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< %basic 114
< %public
< in range: var Integer
< in elm:< Object
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "range"
< Try: "elm"
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0)]
< **   OGS.DOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   After:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   getOGsequenceOfArg:aArgs:(20,char)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OGS: [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   theFargOG:
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(Indexed)]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:StringLib,nest(repeat$0),nest(Indexed)]
< **   checkDOG: Indexed 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< father:
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:char
< **   encOG: Indexed(20,char)
< **** Invocation:semCheck: char
< **   encOG:Indexed(20,char)
< **** OI:semCheck: "char" rec: "none"
< **   encOG:Indexed(20,char)
< **** Pattern:checkActualArgs:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:Indexed(20,char)**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** OG:semCheck:integer
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:V < 0
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: V < 0
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "V" rec: "isNeg"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "< 0" rec: "V"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   argAtInx: 1 in:PTN:
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< V < 0
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(I2S),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **   theOI: < 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 51
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(I2S),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:StringLib,nest(I2S),nest(integer),nest(<)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:StringLib,nest(I2S),nest(integer),nest(<)]
< **   theFargOG:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(I2S),nest(integer),nest(<)]
< **** DataItem:getVqual: in V: var integer
< [0:StringLib,nest(I2S),nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(I2S),nest(integer),nest(<)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(I2S),nest(integer),nest(<)]
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:StringLib,nest(I2S),nest(integer),nest(<)]
< **   ENC:result:[1:StringLib,nest(I2S),nest(integer)]
< **** ENC:OI.getVqual:[2:StringLib,nest(I2S),nest(integer)]
< **   ENC:result:[2:StringLib,nest(I2S)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(I2S)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(I2S)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(I2S)]
< **** savedOGS:save:False[0:StringLib,nest(I2S)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(I2S)]
< **   OGS:[0:StringLib,nest(I2S)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(I2S)]
< **** OG:semCheck:0
< **   encOG: V < 0
< **** Invocation:semCheck: 0
< **   encOG:V < 0
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:getVqual:initial:isNeg
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   OGs:[0:I2S]
< **   ATd: isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:I2S]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:I2S]
< 
< **** OI:getVqual: Boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:I2S]
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   OGS:[0:I2S]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   OGS:[0:I2S]
< **** ENC:OI.viaInclude:[0:I2S]
< **   ENC:result:[0:StringLib]
< **** viaInclude:GOT:
< [0:StringLib,nest(I2S)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:StringLib,nest(I2S)]
< **** savedOGS:save:False[0:StringLib,nest(I2S)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(I2S)]
< **   OGS:[0:StringLib,nest(I2S)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(I2S)]
< 
< **** getVqual:initial:afterATd:isNeg
< **   OGSx:[0:StringLib,nest(I2S)]
< **** savedOGS:save:was:[0:StringLib,nest(I2S)]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(I2S)]
< **   OGS: none
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(I2S)]
< **** OG:semCheck:
< if (isNeg) :then 
<    V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: if (isNeg) :then 
<    V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OG:semCheck:(isNeg)
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: (isNeg)
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Invocation:semCheck: isNeg
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "isNeg" rec: "none"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:0 - V
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** Invocation:semCheck: 0 - V
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** OI:semCheck: "- V" rec: "0"
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: V
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - V
< **   fArg: in V: var integer
< **   aArg: V
< **   theOI.f.f:label: ObjectGenerator
< 0 - V
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - V
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:V
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:V
< **   encOG: 0 - V
< **** Invocation:semCheck: V
< **   encOG:0 - V
< **** OI:semCheck: "V" rec: "none"
< **   encOG:0 - V
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** OI:getVqual:initial:V
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   OGs:[0:I2S]
< **   ATd: in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:I2S]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:I2S]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:I2S]
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   OGS:[0:I2S]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   OGS:[0:I2S]
< **** ENC:OI.viaInclude:[0:I2S]
< **   ENC:result:[0:StringLib]
< **** viaInclude:GOT:
< [0:StringLib,nest($0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest($0)]
< **** savedOGS:save:False[0:StringLib,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest($0)]
< **   OGS:[0:StringLib,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest($0)]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:StringLib,nest($0)]
< **** savedOGS:save:was:[0:StringLib,nest($0)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest($0)]
< **** OG:semCheck:D.put('-'):at[1]
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** Invocation:semCheck: D.put('-'):at[1]
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** OI:semCheck: "D" rec: "none"
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** OI:semCheck: "put('-'):at[1]" rec: "D"
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put('-'):at[1]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('-'):at[1]
< **   fArg: V: var integer
< **   aArg: '-'
< **   theOI.f.f:label: ObjectGenerator
< D.put('-'):at[1]
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   savedOGS: [0:StringLib,nest($0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('-'):at[1]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest($0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put('-'):at[1]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest($0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest($0),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest($0)]
< 
< **** getVqual:B2:
< [0:StringLib,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest($0)]
< **** savedOGS:save:False[0:StringLib,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest($0)]
< **   OGS:[0:StringLib,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest($0)]
< **** OG:semCheck:'-'
< **   encOG: D.put('-'):at[1]
< **** Invocation:semCheck: '-'
< **   encOG:D.put('-'):at[1]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('-'):at[1]
< **   fArg: inx: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< D.put('-'):at[1]
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   savedOGS: [0:StringLib,nest($0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('-'):at[1]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest($0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put('-'):at[1]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest($0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest($0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest($0),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest($0)]
< 
< **** getVqual:B2:
< [0:StringLib,nest($0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest($0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest($0)]
< **** savedOGS:save:False[0:StringLib,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest($0)]
< **   OGS:[0:StringLib,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest($0)]
< **** OG:semCheck:1
< **   encOG: D.put('-'):at[1]
< **** Invocation:semCheck: 1
< **   encOG:D.put('-'):at[1]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semCheck:1
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** Invocation:semCheck: 1
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** OI:getVqual: L on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< 
< **** OI:getVqual:initial:L
< **   encOG:
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   OGs:[0:I2S]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:I2S]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:I2S]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:I2S]
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   OGS:[0:I2S]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **   OGS:[0:I2S]
< **** ENC:OI.viaInclude:[0:I2S]
< **   ENC:result:[0:StringLib]
< **** viaInclude:GOT:
< [0:StringLib,nest($0)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest($0)]
< **** savedOGS:save:False[0:StringLib,nest($0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest($0)]
< **   OGS:[0:StringLib,nest($0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest($0)]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:StringLib,nest($0)]
< **** savedOGS:save:was:[0:StringLib,nest($0)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< V := 0 - V
<    D.put('-'):at[1]
<    L := 1
< **** OG:semCheck:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   encOG: none
< **** Invocation:semCheck: 
< **   encOG:none
< **** OG:semCheck:L + 1
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: L + 1
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "L" rec: "L"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "+ 1" rec: "L"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   fArg: in V: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< L + 1
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:StringLib,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:StringLib,nest(loop),nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:StringLib,nest(loop),nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(loop),nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:StringLib,nest(loop),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(loop),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(loop),nest(integer),nest(+)]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:StringLib,nest(loop),nest(integer),nest(+)]
< **   ENC:result:[1:StringLib,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:StringLib,nest(loop),nest(integer)]
< **   ENC:result:[2:StringLib,nest(loop)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:1
< **   encOG: L + 1
< **** Invocation:semCheck: 1
< **   encOG:L + 1
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< 
< **** OI:getVqual: L on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual:initial:L
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGs:[0:I2S]
< **   ATd: L: var integer
< **** DataItem:getVqual: L: var integer
< [0:I2S]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:I2S]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:I2S]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGS:[0:I2S]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGS:[0:I2S]
< **** ENC:OI.viaInclude:[0:I2S]
< **   ENC:result:[0:StringLib]
< **** viaInclude:GOT:
< [0:StringLib,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< 
< **** getVqual:initial:afterATd:L
< **   OGSx:[0:StringLib,nest(loop)]
< **** savedOGS:save:was:[0:StringLib,nest(loop)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:D.put('0' + V /% 10):at[L]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: D.put('0' + V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "D" rec: "none"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "put('0' + V /% 10):at[L]" rec: "D"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put('0' + V /% 10):at[L]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('0' + V /% 10):at[L]
< **   fArg: V: var integer
< **   aArg: '0' + V /% 10
< **   theOI.f.f:label: ObjectGenerator
< D.put('0' + V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:StringLib,nest(loop),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('0' + V /% 10):at[L]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(loop),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put('0' + V /% 10):at[L]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest(loop),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest(loop),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest(loop)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:'0' + V /% 10
< **   encOG: D.put('0' + V /% 10):at[L]
< **** Invocation:semCheck: '0' + V /% 10
< **   encOG:D.put('0' + V /% 10):at[L]
< **** OI:semCheck: "+ V /% 10" rec: "'0'"
< **   encOG:D.put('0' + V /% 10):at[L]
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   actualArgs: V /% 10
< **   fArgs(in V: var char,)
< 
< **   encOG:D.put('0' + V /% 10):at[L]**   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   theOI: + V /% 10
< **   fArg: in V: var char
< **   aArg: V /% 10
< **   theOI.f.f:label: ObjectGenerator
< '0' + V /% 10
< **   encOG:D.put('0' + V /% 10):at[L]
< **   savedOGS: [0:char]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **   theOI: + V /% 10
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var char
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var char
< out R: var char
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:char]
< **   OGS.DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   After:[0:char,nest(+)]
< **   getOGsequenceOfArg:aArgs:V /% 10
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var char
<    out R: var char
< **   OGS: [0:char,nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var char
<    out R: var char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:char,nest(+)]
< **** DataItem:getVqual: in V: var char
< [0:char,nest(+)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:char,nest(+)]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:char,nest(+)]
< **   encOG: D.put('0' + V /% 10):at[L]
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var char
<    out R: var char
< **** ENC:OI.getVqual:[1:char,nest(+)]
< **   ENC:result:[1:char]
< **** ENC:OI.getVqual:[2:char]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:V /% 10
< **   encOG: '0' + V /% 10
< **** Invocation:semCheck: V /% 10
< **   encOG:'0' + V /% 10
< **** OI:semCheck: "V" rec: "none"
< **   encOG:'0' + V /% 10
< **** OI:semCheck: "/% 10" rec: "V"
< **   encOG:'0' + V /% 10
< **** Pattern:checkActualArgs:
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   actualArgs: 10
< **   fArgs(in V: var integer,)
< 
< **   encOG:'0' + V /% 10**   argAtInx: 1 in:PTN:
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   theOI: /% 10
< **   fArg: in V: var integer
< **   aArg: 10
< **   theOI.f.f:label: ObjectGenerator
< V /% 10
< **   encOG:'0' + V /% 10
< **   savedOGS: [0:StringLib,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **   theOI: /% 10
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 69
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:StringLib,nest(loop),nest(integer),nest(/%)]
< **   getOGsequenceOfArg:aArgs:10
< **   fArgs.origin.OG=theFargsOG: 
< %basic 69
<    in V: var integer
<    out R: var integer
< **   OGS: [0:StringLib,nest(loop),nest(integer),nest(/%)]
< **   theFargOG:
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(loop),nest(integer),nest(/%)]
< **** DataItem:getVqual: in V: var integer
< [0:StringLib,nest(loop),nest(integer),nest(/%)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(loop),nest(integer),nest(/%)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(loop),nest(integer),nest(/%)]
< **   encOG: '0' + V /% 10
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:StringLib,nest(loop),nest(integer),nest(/%)]
< **   ENC:result:[1:StringLib,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:StringLib,nest(loop),nest(integer)]
< **   ENC:result:[2:StringLib,nest(loop)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:10
< **   encOG: V /% 10
< **** Invocation:semCheck: 10
< **   encOG:V /% 10
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:returnDecl: out R: var char
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('0' + V /% 10):at[L]
< **   fArg: inx: var integer
< **   aArg: L
< **   theOI.f.f:label: ObjectGenerator
< D.put('0' + V /% 10):at[L]
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:StringLib,nest(loop),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put('0' + V /% 10):at[L]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(loop),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put('0' + V /% 10):at[L]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest(loop),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest(loop),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest(loop),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest(loop)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:L
< **   encOG: D.put('0' + V /% 10):at[L]
< **** Invocation:semCheck: L
< **   encOG:D.put('0' + V /% 10):at[L]
< **** OI:semCheck: "L" rec: "none"
< **   encOG:D.put('0' + V /% 10):at[L]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semCheck:V // 10
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: V // 10
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "V" rec: "V"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "// 10" rec: "V"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   actualArgs: 10
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   theOI: // 10
< **   fArg: in V: var integer
< **   aArg: 10
< **   theOI.f.f:label: ObjectGenerator
< V // 10
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:StringLib,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **   theOI: // 10
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 68
< in V: var integer
< out B: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:StringLib,nest(loop),nest(integer),nest(//)]
< **   getOGsequenceOfArg:aArgs:10
< **   fArgs.origin.OG=theFargsOG: 
< %basic 68
<    in V: var integer
<    out B: var integer
< **   OGS: [0:StringLib,nest(loop),nest(integer),nest(//)]
< **   theFargOG:
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(loop),nest(integer),nest(//)]
< **** DataItem:getVqual: in V: var integer
< [0:StringLib,nest(loop),nest(integer),nest(//)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(loop),nest(integer),nest(//)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(loop),nest(integer),nest(//)]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** ENC:OI.getVqual:[1:StringLib,nest(loop),nest(integer),nest(//)]
< **   ENC:result:[1:StringLib,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:StringLib,nest(loop),nest(integer)]
< **   ENC:result:[2:StringLib,nest(loop)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:10
< **   encOG: V // 10
< **** Invocation:semCheck: 10
< **   encOG:V // 10
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out B: var integer
< 
< **** OI:getVqual: V on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual:initial:V
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGs:[0:I2S]
< **   ATd: in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:I2S]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:I2S]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:I2S]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGS:[0:I2S]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   OGS:[0:I2S]
< **** ENC:OI.viaInclude:[0:I2S]
< **   ENC:result:[0:StringLib]
< **** viaInclude:GOT:
< [0:StringLib,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< 
< **** getVqual:initial:afterATd:V
< **   OGSx:[0:StringLib,nest(loop)]
< **** savedOGS:save:was:[0:StringLib,nest(loop)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS: none
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:
< if (V > 0) :then 
<    restart(loop)
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: if (V > 0) :then 
<    restart(loop)
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OG:semCheck:(V > 0)
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** Invocation:semCheck: (V > 0)
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Invocation:semCheck: V > 0
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "V" rec: "none"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:semCheck: "> 0" rec: "V"
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** Pattern:checkActualArgs:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   actualArgs: 0
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   argAtInx: 1 in:PTN:
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   fArg: in V: var integer
< **   aArg: 0
< **   theOI.f.f:label: BracketedExp
< (V > 0)
< **   encOG:
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **   savedOGS: [0:StringLib,nest(loop),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **   theOI: > 0
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 53
< in V: var integer
< out B: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(loop),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:StringLib,nest(loop),nest(integer),nest(>)]
< **   getOGsequenceOfArg:aArgs:0
< **   fArgs.origin.OG=theFargsOG: 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   OGS: [0:StringLib,nest(loop),nest(integer),nest(>)]
< **   theFargOG:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(loop),nest(integer),nest(>)]
< **** DataItem:getVqual: in V: var integer
< [0:StringLib,nest(loop),nest(integer),nest(>)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(loop),nest(integer),nest(>)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(loop),nest(integer),nest(>)]
< **   encOG: 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:StringLib,nest(loop),nest(integer),nest(>)]
< **   ENC:result:[1:StringLib,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:StringLib,nest(loop),nest(integer)]
< **   ENC:result:[2:StringLib,nest(loop)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(loop)]
< **** savedOGS:save:False[0:StringLib,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(loop)]
< **   OGS:[0:StringLib,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(loop)]
< **** OG:semCheck:0
< **   encOG: (V > 0)
< **** Invocation:semCheck: 0
< **   encOG:(V > 0)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:restart(loop)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:restart(loop)
< **   encOG: restart(loop)
< **** Invocation:semCheck: restart(loop)
< **   encOG:restart(loop)
< **** OI:semCheck: "restart(loop)" rec: "none"
< **   encOG:restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< restart(loop)
< **** OG:semcheck:IS not empty:eOG: 
< 
< L := L + 1
<    D.put('0' + V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** OG:semCheck:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< " rec: "none"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   actualArgs: for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   fArgs(first: var integer,last: var integer,repeat:< object,)
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   argAtInx: 1 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   fArg: first: var integer
< **   aArg: 1
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(I2S)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: first: var integer
< **** Items:localSearch: first
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: first in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: first
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: first
< Try: "first"
< **** Items:localSearch:end: first
< *** found in signature:paramItems: first
< **** Signature:localSearch:end: first
< **** Items:localSearch:end: first
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(I2S)]
< **   OGS.DOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   After:[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **** DataItem:getVqual: first: var integer
< [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(I2S),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:StringLib,nest(I2S),nest(for:to:repeat)]
< **   ENC:result:[1:StringLib,nest(I2S)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(I2S)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(I2S)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(I2S)]
< **** savedOGS:save:False[0:StringLib,nest(I2S)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(I2S)]
< **   OGS:[0:StringLib,nest(I2S)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(I2S)]
< **** OG:semCheck:1
< **   encOG: 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **** Invocation:semCheck: 1
< **   encOG:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   fArg: last: var integer
< **   aArg: L
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(I2S)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: last: var integer
< **** Items:localSearch: last
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: last in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: last
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: last
< Try: "first"
< Try: "last"
< **** Items:localSearch:end: last
< *** found in signature:paramItems: last
< **** Signature:localSearch:end: last
< **** Items:localSearch:end: last
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(I2S)]
< **   OGS.DOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   After:[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **** DataItem:getVqual: last: var integer
< [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(I2S),nest(for:to:repeat)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:StringLib,nest(I2S),nest(for:to:repeat)]
< **   ENC:result:[1:StringLib,nest(I2S)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(I2S)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(I2S)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(I2S)]
< **** savedOGS:save:False[0:StringLib,nest(I2S)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(I2S)]
< **   OGS:[0:StringLib,nest(I2S)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(I2S)]
< **** OG:semCheck:L
< **   encOG: 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **** Invocation:semCheck: L
< **   encOG:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< 
< **** OI:semCheck: "L" rec: "none"
< **   encOG:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 3 in:PTN:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   fArg: repeat:< object
< **   aArg: D2.put(D.get[L + 1 - inx]):at[inx]
< **   theOI.f.f:label: ObjectGenerator
< 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   savedOGS: [0:StringLib,nest(I2S)]
< **** PTN:getOGsequenceOfArg: 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   theOI: for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   theOI.on:2,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: repeat:< object
< **** Items:localSearch: repeat
< **   in:
< 
< %OSDvisibility skipInternal
< %globals inSub
< inx: var integer
< inx := first
< _doIt: do 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "inx"
< Try: "_doIt"
< **** Signature:localSearch: repeat in: for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** Items:localSearch: repeat
< **   in:
< 
< %$B "("
< first: var integer
< %$S "):to("
< last: var integer
< %$S "):repeat{"
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: repeat
< Try: "first"
< Try: "last"
< Try: "repeat"
< **** Items:localSearch:end: repeat
< *** found in signature:paramItems: repeat
< **** Signature:localSearch:end: repeat
< **** Items:localSearch:end: repeat
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(I2S)]
< **   OGS.DOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   After:[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   getOGsequenceOfArg:aArgs:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **   fArgs.origin.OG=theFargsOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   OGS: [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   theFargOG:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(I2S),nest(for:to:repeat)]
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:StringLib,nest(I2S),nest(for:to:repeat)]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:D2.put(D.get[L + 1 - inx]):at[inx]
< **   encOG: 
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< **** Invocation:semCheck: 
< **   encOG:
< for(1):to(L):repeat
<    D2.put(D.get[L + 1 - inx]):at[inx]
< 
< 
< **** OG:semCheck:D2.put(D.get[L + 1 - inx]):at[inx]
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** Invocation:semCheck: D2.put(D.get[L + 1 - inx]):at[inx]
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** OI:semCheck: "D2" rec: "none"
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** OI:semCheck: "put(D.get[L + 1 - inx]):at[inx]" rec: "D2"
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** Pattern:checkActualArgs:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   actualArgs: put(D.get[L + 1 - inx]):at[inx]
< **   fArgs(V: var integer,inx: var integer,)
< 
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]**   argAtInx: 1 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(D.get[L + 1 - inx]):at[inx]
< **   fArg: V: var integer
< **   aArg: D.get[L + 1 - inx]
< **   theOI.f.f:label: ObjectGenerator
< D2.put(D.get[L + 1 - inx]):at[inx]
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   savedOGS: [0:StringLib,nest(repeat$0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(D.get[L + 1 - inx]):at[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: V: var integer
< **** Items:localSearch: V
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: V
< **** Signature:localSearch: V in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: V
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< *** found in signature:paramItems: V
< **** Signature:localSearch:end: V
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(D.get[L + 1 - inx]):at[inx]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: V: var integer
< [0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest(repeat$0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(repeat$0)]
< **** savedOGS:save:False[0:StringLib,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OG:semCheck:D.get[L + 1 - inx]
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** Invocation:semCheck: D.get[L + 1 - inx]
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** OI:semCheck: "D" rec: "none"
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** OI:semCheck: "get[L + 1 - inx]" rec: "D"
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** Pattern:checkActualArgs:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   actualArgs: get[L + 1 - inx]
< **   fArgs(inx: var integer,)
< 
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]**   argAtInx: 1 in:PTN:
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[L + 1 - inx]
< **   fArg: inx: var integer
< **   aArg: L + 1 - inx
< **   theOI.f.f:label: ObjectGenerator
< D.get[L + 1 - inx]
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **** PTN:getOGsequenceOfArg: 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **   theOI: get[L + 1 - inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< 
< %basic 116
< out V: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< **** Signature:localSearch: inx in: get[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0)]
< **   OGS.DOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   After:[0:StringLib,nest(repeat$0),nest(get)]
< **   getOGsequenceOfArg:aArgs:get[L + 1 - inx]
< **   fArgs.origin.OG=theFargsOG: 
< %basic 116
<    out V: var integer
< **   OGS: [0:StringLib,nest(repeat$0),nest(get)]
< **   theFargOG:
< 
< %basic 116
<    out V: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(get)]
< **** DataItem:getVqual: inx: var integer
< [0:StringLib,nest(repeat$0),nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(repeat$0),nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(repeat$0),nest(get)]
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< get[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest(repeat$0),nest(get)]
< **   ENC:result:[1:StringLib,nest(repeat$0)]
< **** ENC:OI.getVqual:[2:StringLib,nest(repeat$0)]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OG:semCheck:L + 1 - inx
< **   encOG: D.get[L + 1 - inx]
< **** Invocation:semCheck: L + 1 - inx
< **   encOG:D.get[L + 1 - inx]
< **** OI:semCheck: "L" rec: "none"
< **   encOG:D.get[L + 1 - inx]
< **** OI:semCheck: "+ 1 - inx" rec: "L"
< **   encOG:D.get[L + 1 - inx]
< **** Pattern:checkActualArgs:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   actualArgs: 1 - inx
< **   fArgs(in V: var integer,)
< 
< **   encOG:D.get[L + 1 - inx]**   argAtInx: 1 in:PTN:
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1 - inx
< **   fArg: in V: var integer
< **   aArg: 1 - inx
< **   theOI.f.f:label: ObjectGenerator
< L + 1 - inx
< **   encOG:D.get[L + 1 - inx]
< **   savedOGS: [0:StringLib,nest(repeat$0),nest(integer)]
< **** PTN:getOGsequenceOfArg: 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **   theOI: + 1 - inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 61
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0),nest(integer)]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:StringLib,nest(repeat$0),nest(integer),nest(+)]
< **   getOGsequenceOfArg:aArgs:1 - inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   OGS: [0:StringLib,nest(repeat$0),nest(integer),nest(+)]
< **   theFargOG:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(integer),nest(+)]
< **** DataItem:getVqual: in V: var integer
< [0:StringLib,nest(repeat$0),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(repeat$0),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(repeat$0),nest(integer),nest(+)]
< **   encOG: D.get[L + 1 - inx]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:StringLib,nest(repeat$0),nest(integer),nest(+)]
< **   ENC:result:[1:StringLib,nest(repeat$0),nest(integer)]
< **** ENC:OI.getVqual:[2:StringLib,nest(repeat$0),nest(integer)]
< **   ENC:result:[2:StringLib,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(repeat$0)]
< **** savedOGS:save:False[0:StringLib,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OG:semCheck:1 - inx
< **   encOG: L + 1 - inx
< **** Invocation:semCheck: 1 - inx
< **   encOG:L + 1 - inx
< **** OI:semCheck: "- inx" rec: "1"
< **   encOG:L + 1 - inx
< **** Pattern:checkActualArgs:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   actualArgs: inx
< **   fArgs(in V: var integer,)
< 
< **   encOG:L + 1 - inx**   argAtInx: 1 in:PTN:
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx
< **   fArg: in V: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< 1 - inx
< **   encOG:L + 1 - inx
< **   savedOGS: [0:integer]
< **** PTN:getOGsequenceOfArg: 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **   theOI: - inx
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %basic 62
< in V: var integer
< out R: var integer
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:integer]
< **   OGS.DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   After:[0:integer,nest(-)]
< **   getOGsequenceOfArg:aArgs:inx
< **   fArgs.origin.OG=theFargsOG: 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   OGS: [0:integer,nest(-)]
< **   theFargOG:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:integer,nest(-)]
< **** DataItem:getVqual: in V: var integer
< [0:integer,nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:integer,nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:integer,nest(-)]
< **   encOG: L + 1 - inx
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:integer,nest(-)]
< **   ENC:result:[1:integer]
< **** ENC:OI.getVqual:[2:integer]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OG:semCheck:inx
< **   encOG: 1 - inx
< **** Invocation:semCheck: inx
< **   encOG:1 - inx
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:1 - inx
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out R: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out V: var integer
< **   argAtInx: 2 in:PTN:
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(D.get[L + 1 - inx]):at[inx]
< **   fArg: inx: var integer
< **   aArg: inx
< **   theOI.f.f:label: ObjectGenerator
< D2.put(D.get[L + 1 - inx]):at[inx]
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **   savedOGS: [0:StringLib,nest(repeat$0),nest(Indexed)]
< **** PTN:getOGsequenceOfArg: 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **   theOI: put(D.get[L + 1 - inx]):at[inx]
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: inx: var integer
< **** Items:localSearch: inx
< **   in:
< %basic 115
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< **** Signature:localSearch: inx in: put(V: var integer):at[inx: var integer]
< **** Items:localSearch: inx
< **   in:
< 
< %$B "("
< V: var integer
< %$S "):at["
< inx: var integer
< %$E "]"
< **   isChecked: True
< **   Items:localSearch:Decls: inx
< Try: "V"
< Try: "inx"
< **** Items:localSearch:end: inx
< *** found in signature:paramItems: inx
< **** Signature:localSearch:end: inx
< **** Items:localSearch:end: inx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:StringLib,nest(repeat$0),nest(Indexed)]
< **   OGS.DOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   After:[0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   getOGsequenceOfArg:aArgs:put(D.get[L + 1 - inx]):at[inx]
< **   fArgs.origin.OG=theFargsOG: %basic 115**   OGS: [0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   theFargOG:
< %basic 115
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** DataItem:getVqual: inx: var integer
< [0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< put(V: var integer):at[inx: var integer]
< **** ENC:OI.getVqual:[1:StringLib,nest(repeat$0),nest(Indexed),nest(put:at)]
< **   ENC:result:[1:StringLib,nest(repeat$0),nest(Indexed)]
< **** ENC:OI.getVqual:[2:StringLib,nest(repeat$0),nest(Indexed)]
< **   ENC:result:[2:StringLib,nest(repeat$0)]
< 
< **** getVqual:B2:
< [0:StringLib,nest(repeat$0)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(repeat$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:StringLib,nest(repeat$0)]
< **** savedOGS:save:False[0:StringLib,nest(repeat$0)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(repeat$0)]
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(repeat$0)]
< **** OG:semCheck:inx
< **   encOG: D2.put(D.get[L + 1 - inx]):at[inx]
< **** Invocation:semCheck: inx
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** OI:semCheck: "inx" rec: "none"
< **   encOG:D2.put(D.get[L + 1 - inx]):at[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< %basic 115
< **** OG:semcheck:IS not empty:eOG: 
< D2.put(D.get[L + 1 - inx]):at[inx]
< **** OG:semcheck:IS not empty:eOG: 
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** OG:semCheck:D2.asString
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** Invocation:semCheck: D2.asString
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "D2" rec: "Si2s"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:semCheck: "asString" rec: "D2"
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** Pattern:checkActualArgs:
< asString: 
<    %basic 118
<    out S: var LIB.StringLib.String
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:returnDecl: out S: var LIB.StringLib.String
< 
< **** OI:getVqual: Si2s on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< 
< **** OI:getVqual:initial:Si2s
< **   encOG:
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **   OGs:[0:I2S]
< **   ATd: out Si2s: var String
< **** DataItem:getVqual: out Si2s: var String
< [0:I2S]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:I2S]
< 
< **** OI:getVqual: String on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:I2S]
< **   encOG: 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** koks: String on: 1 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** ENC:OI.getVqual:[1:I2S]
< **   ENC:result:[1:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:initial:afterATd:Si2s
< **   OGSx:[0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: Si2s
< **   OI:getQual:savedOI:Si2s
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS: none
< **** OI:getVqual:end: Si2s
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "I2s"
<    %OSDvisibility disguised
<    %globals
<    in V: var integer
<    out Si2s: var String
< ...
< **** OG:returnDecl: out Si2s: var String
< **** OG:semCheck:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< **   encOG: 
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< **** Invocation:semCheck: 
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< 
< **** Invocation:semCheck: 145
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< 
< **** OG:semCheck:float
< **   encOG: 
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< **** Invocation:semCheck: float
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< 
< **** OI:semCheck: "float" rec: "none"
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< 
< **** Pattern:checkActualArgs:
< float: Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %globals
<    %basic 9
<    _thisBasicValue: var Float
<    %public
< ...
< **** OG:semCheck:String
< **   encOG: 
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< **** Invocation:semCheck: String
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< 
< **** OI:semCheck: "String" rec: "none"
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< 
< **** Pattern:checkActualArgs:
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "F2S"
<    %basic 145
<    %globals
<    in V: var float
<    out S: var String
< **** OG:returnDecl: out S: var String
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **** OG:semCheck:
< %id "workspace"
<    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
<    %domain_boundary
<    --AbstractEx
< --AccessEx
< ...
< **   encOG: 
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< 
< **** Invocation:semCheck: BETA
< **   encOG:
< %id "workspace"
<    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
<    %domain_boundary
<    --AbstractEx
< --AccessEx
< ...
< 
< **** OI:semCheck: "BETA" rec: "%visible"
< **   encOG:
< %id "workspace"
<    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
<    %domain_boundary
<    --AbstractEx
< --AccessEx
< ...
< 
< **** Invocation:semCheck: LIB
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** OI:semCheck: "LIB" rec: "BETA"
< **   encOG:
< %ID BETA
<    %OSDvisibility disguised
<    %module LIB, LIB.StringLib
<    %public
<    Object: 
< ...
< 
< **** Invocation:semCheck: LIB.BasicIO
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "LIB" rec: "LIB"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** OI:semCheck: "BasicIO" rec: "LIB"
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** Invocation:semCheck: LIB.Dimensions
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** OI:semCheck: "LIB" rec: "LIB.BasicIO"
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** OI:semCheck: "Dimensions" rec: "LIB"
< **   encOG:
< %module LIB.StringLib
<    %Public
<    Lock: 
<       dummy: var integer
<       %Public
< ...
< 
< **** Invocation:semCheck: LIB.StringLib
< **   encOG:
< %domain_boundary
<    %public
<    Dimension: 
<       %dimension "-top-"
<       %public
< ...
< 
< **** OI:semCheck: "LIB" rec: "LIB.Dimensions"
< **   encOG:
< %domain_boundary
<    %public
<    Dimension: 
<       %dimension "-top-"
<       %public
< ...
< 
< **** OI:semCheck: "StringLib" rec: "LIB"
< **   encOG:
< %domain_boundary
<    %public
<    Dimension: 
<       %dimension "-top-"
<       %public
< ...
< 
< **** OG:semCheck:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   encOG: 
< %id "workspace"
<    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
<    %domain_boundary
<    --AbstractEx
< --AccessEx
< ...
< **** Invocation:semCheck: 
< **   encOG:
< %id "workspace"
<    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
<    %domain_boundary
<    --AbstractEx
< --AccessEx
< ...
< 
< **** Invocation:semCheck: Collections
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Collections" rec: "%requires"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Invocation:semCheck: MapLib
< **   encOG:
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< 
< **** OI:semCheck: "MapLib" rec: "Collections"
< **   encOG:
< %visible StringLib
<    Collection: 
<       %id "Collection"
<       %globals
<       in elm:< Object
< ...
< 
< **** Invocation:semCheck: SetLib
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< 
< **** OI:semCheck: "SetLib" rec: "MapLib"
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< 
< **** Invocation:semCheck: Collections
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Collections" rec: "%visible"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OG:semCheck:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **   encOG: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** Invocation:semCheck: 
< **   encOG:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< 
< **** OG:semCheck:integer
< **   encOG: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** Invocation:semCheck: integer
< **   encOG:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< "Qualification:".print
<    putint(Q)
< **   encOG: 
< "Qualification:".print
<    putint(Q)
< **** Invocation:semCheck: 
< **   encOG:
< "Qualification:".print
<    putint(Q)
< 
< **** OG:semCheck:"Qualification:".print
< **   encOG: 
< "Qualification:".print
<    putint(Q)
< **** Invocation:semCheck: "Qualification:".print
< **   encOG:
< "Qualification:".print
<    putint(Q)
< 
< **** OI:semCheck: "print" rec: ""Qualification:""
< **   encOG:
< "Qualification:".print
<    putint(Q)
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Qualification:".print
<    putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:putint(Q)
< **   encOG: 
< "Qualification:".print
<    putint(Q)
< **** Invocation:semCheck: putint(Q)
< **   encOG:
< "Qualification:".print
<    putint(Q)
< 
< **** OI:semCheck: "putint(Q)" rec: "none"
< **   encOG:
< "Qualification:".print
<    putint(Q)
< 
< **** Pattern:checkActualArgs:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   actualArgs: putint(Q)
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< "Qualification:".print
<    putint(Q)
< **   argAtInx: 1 in:PTN:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(Q)
< **   fArg: in V: var integer
< **   aArg: Q
< **   theOI.f.f:label: ObjectGenerator
< putint(Q)
< **   encOG:
< "Qualification:".print
<    putint(Q)
< **   savedOGS: [0:Qualification,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(Q)
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %globals
< in V: var integer
< D: obj Indexed(20,#integer)
< L: var integer
< isNeg: var Boolean
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Qualification,nest(print)]
< **   OGS.DOG:
< "Qualification:".print
<    putint(Q)
< **   After:[0:Qualification,nest(print),nest(putint)]
< **   getOGsequenceOfArg:aArgs:putint(Q)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   OGS: [0:Qualification,nest(print),nest(putint)]
< **   theFargOG:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Qualification,nest(print),nest(putint)]
< **** DataItem:getVqual: in V: var integer
< [0:Qualification,nest(print),nest(putint)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Qualification,nest(print),nest(putint)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Qualification,nest(print),nest(putint)]
< **   encOG: 
< "Qualification:".print
<    putint(Q)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:Qualification,nest(print),nest(putint)]
< **   ENC:result:[1:Qualification,nest(print)]
< 
< **** getVqual:B2:
< [0:Qualification,nest(print)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Qualification,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:Qualification,nest(print)]
< **** savedOGS:save:False[0:Qualification,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Qualification,nest(print)]
< **   OGS:[0:Qualification,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Qualification,nest(print)]
< **** OG:semCheck:Q
< **   encOG: putint(Q)
< **** Invocation:semCheck: Q
< **   encOG:putint(Q)
< **** OI:semCheck: "Q" rec: "none"
< **   encOG:putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Qualification:".print
<    putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semCheck:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   encOG: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Invocation:semCheck: SetLib.Set(#Qualification)
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< 
< **** OI:semCheck: "SetLib" rec: "Qualifications"
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< 
< **** OI:semCheck: "Set(#Qualification)" rec: "SetLib"
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< 
< **** Pattern:checkActualArgs:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   actualArgs: Set(#Qualification)
< **   fArgs(in elm:< Object,)
< 
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   argAtInx: 1 in:PTN:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Qualification)
< **   fArg: in elm:< Object
< **   aArg: #Qualification
< **   theOI.f.f:label: ObjectGenerator
< 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   savedOGS: [0:workspace,nest(tinyY),nest(SetLib)]
< **** PTN:getOGsequenceOfArg: 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Qualification)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "has"
< Try: "isEmpty"
< Try: "insert"
< Try: "remove"
< Try: "card"
< Try: "clear"
< Try: "scan"
< Try: "forAllX"
< Try: "forAll"
< Try: "exists"
< Try: "reduce"
< Try: "link"
< Try: "head"
< **** Signature:localSearch: elm in: Set
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< %id "Collection"
< %globals
< in elm:< Object
< scan:< 
<    %OSDvisibility skipInternal
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:workspace,nest(tinyY),nest(SetLib)]
< **   OGS.DOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   After:[0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   getOGsequenceOfArg:aArgs:Set(#Qualification)
< **   fArgs.origin.OG=theFargsOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   theFargOG:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** PRE: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Qualification
< **   encOG: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Invocation:semCheck: #Qualification
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< 
< **** OI:semCheck: "#Qualification" rec: "none"
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semCheck:
< scan
<       current.print
< **   encOG: 
< scan
<       current.print
< **** Invocation:semCheck: 
< **   encOG:
< scan
<       current.print
< 
< **** OG:semCheck:
< scan
<    current.print
< **   encOG: 
< scan
<       current.print
< **** Invocation:semCheck: scan
< **   encOG:
< scan
<       current.print
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< scan
<       current.print
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       current.print
< **** OG:semCheck:current.print
< **   encOG: 
< scan
<    current.print
< **** Invocation:semCheck: current.print
< **   encOG:
< scan
<    current.print
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< scan
<    current.print
< 
< **** OI:semCheck: "print" rec: "current"
< **   encOG:
< scan
<    current.print
< 
< **** Pattern:checkActualArgs:
< print: 
<    "Qualification:".print
<    putint(Q)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<    current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Qualification:".print
<    putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<       current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** OG:semCheck:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   encOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** OG:semCheck:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **   encOG: 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** Invocation:semCheck: 
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OG:semCheck:"Expert:".print
< **   encOG: 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** Invocation:semCheck: "Expert:".print
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OI:semCheck: "print" rec: ""Expert:""
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:name.print
< **   encOG: 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** Invocation:semCheck: name.print
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OI:semCheck: "name" rec: "none"
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OI:semCheck: "print" rec: "name"
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:put(':')
< **   encOG: 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** Invocation:semCheck: put(':')
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OI:semCheck: "put(':')" rec: "none"
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(':')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(':')
< **   fArg: in ch: val char
< **   aArg: ':'
< **   theOI.f.f:label: ObjectGenerator
< put(':')
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **   savedOGS: [0:Expert,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(':')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Expert,nest(print)]
< **   OGS.DOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **   After:[0:Expert,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(':')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Expert,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Expert,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Expert,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Expert,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Expert,nest(print),nest(put)]
< **   encOG: 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Expert,nest(print),nest(put)]
< **   ENC:result:[1:Expert,nest(print)]
< 
< **** getVqual:B2:
< [0:Expert,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Expert,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Expert,nest(print)]
< **** savedOGS:save:False[0:Expert,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Expert,nest(print)]
< **   OGS:[0:Expert,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Expert,nest(print)]
< **** OG:semCheck:':'
< **   encOG: put(':')
< **** Invocation:semCheck: ':'
< **   encOG:put(':')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:quali.print
< **   encOG: 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** Invocation:semCheck: quali.print
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OI:semCheck: "quali" rec: "none"
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OI:semCheck: "print" rec: "quali"
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** Pattern:checkActualArgs:
< print: 
<    scan
<       current.print
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<       current.print
< **** OG:semCheck:newline
< **   encOG: 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** Invocation:semCheck: newline
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** OI:semCheck: "newline" rec: "none"
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< 
< **** Pattern:checkActualArgs:
< newline: 
<    %globals
<    put(10)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    put(10)
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OG:semCheck:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Invocation:semCheck: SetLib.Set(#Expert)
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** OI:semCheck: "SetLib" rec: "Experts"
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** OI:semCheck: "Set(#Expert)" rec: "SetLib"
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** Pattern:checkActualArgs:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   actualArgs: Set(#Expert)
< **   fArgs(in elm:< Object,)
< 
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   argAtInx: 1 in:PTN:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Expert)
< **   fArg: in elm:< Object
< **   aArg: #Expert
< **   theOI.f.f:label: ObjectGenerator
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   savedOGS: [0:workspace,nest(tinyY),nest(SetLib)]
< **** PTN:getOGsequenceOfArg: 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Expert)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "has"
< Try: "isEmpty"
< Try: "insert"
< Try: "remove"
< Try: "card"
< Try: "clear"
< Try: "scan"
< Try: "forAllX"
< Try: "forAll"
< Try: "exists"
< Try: "reduce"
< Try: "link"
< Try: "head"
< **** Signature:localSearch: elm in: Set
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< %id "Collection"
< %globals
< in elm:< Object
< scan:< 
<    %OSDvisibility skipInternal
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:workspace,nest(tinyY),nest(SetLib)]
< **   OGS.DOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   After:[0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   getOGsequenceOfArg:aArgs:Set(#Expert)
< **   fArgs.origin.OG=theFargsOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   theFargOG:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** PRE: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Expert
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Invocation:semCheck: #Expert
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** OI:semCheck: "#Expert" rec: "none"
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OG:semCheck:
< scan
<       current.print
< **   encOG: 
< scan
<       current.print
< **** Invocation:semCheck: 
< **   encOG:
< scan
<       current.print
< 
< **** OG:semCheck:
< scan
<    current.print
< **   encOG: 
< scan
<       current.print
< **** Invocation:semCheck: scan
< **   encOG:
< scan
<       current.print
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< scan
<       current.print
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       current.print
< **** OG:semCheck:current.print
< **   encOG: 
< scan
<    current.print
< **** Invocation:semCheck: current.print
< **   encOG:
< scan
<    current.print
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< scan
<    current.print
< 
< **** OI:semCheck: "print" rec: "current"
< **   encOG:
< scan
<    current.print
< 
< **** Pattern:checkActualArgs:
< print: 
<    "Expert:".print
<    name.print
<    put(':')
<    quali.print
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<    current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Expert:".print
<    name.print
<    put(':')
<    quali.print
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<       current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OG:semCheck:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **   encOG: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< 
< **** OG:semCheck:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **   encOG: 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** Invocation:semCheck: 
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** OG:semCheck:"alarm: ".print
< **   encOG: 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** Invocation:semCheck: "alarm: ".print
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** OI:semCheck: "print" rec: ""alarm: ""
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:descr.print
< **   encOG: 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** Invocation:semCheck: descr.print
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** OI:semCheck: "descr" rec: "none"
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** OI:semCheck: "print" rec: "descr"
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:put(':')
< **   encOG: 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** Invocation:semCheck: put(':')
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** OI:semCheck: "put(':')" rec: "none"
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(':')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(':')
< **   fArg: in ch: val char
< **   aArg: ':'
< **   theOI.f.f:label: ObjectGenerator
< put(':')
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **   savedOGS: [0:Alarm,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(':')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Alarm,nest(print)]
< **   OGS.DOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **   After:[0:Alarm,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(':')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Alarm,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Alarm,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Alarm,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Alarm,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Alarm,nest(print),nest(put)]
< **   encOG: 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Alarm,nest(print),nest(put)]
< **   ENC:result:[1:Alarm,nest(print)]
< 
< **** getVqual:B2:
< [0:Alarm,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Alarm,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Alarm,nest(print)]
< **** savedOGS:save:False[0:Alarm,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Alarm,nest(print)]
< **   OGS:[0:Alarm,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Alarm,nest(print)]
< **** OG:semCheck:':'
< **   encOG: put(':')
< **** Invocation:semCheck: ':'
< **   encOG:put(':')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:reqQuali.print
< **   encOG: 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** Invocation:semCheck: reqQuali.print
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** OI:semCheck: "reqQuali" rec: "none"
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** OI:semCheck: "print" rec: "reqQuali"
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< 
< **** Pattern:checkActualArgs:
< print: 
<    "Qualification:".print
<    putint(Q)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Qualification:".print
<    putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **** OG:semCheck:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   encOG: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** Invocation:semCheck: SetLib.Set(#Alarm)
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< 
< **** OI:semCheck: "SetLib" rec: "Alarms"
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< 
< **** OI:semCheck: "Set(#Alarm)" rec: "SetLib"
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< 
< **** Pattern:checkActualArgs:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   actualArgs: Set(#Alarm)
< **   fArgs(in elm:< Object,)
< 
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   argAtInx: 1 in:PTN:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Alarm)
< **   fArg: in elm:< Object
< **   aArg: #Alarm
< **   theOI.f.f:label: ObjectGenerator
< 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   savedOGS: [0:workspace,nest(tinyY),nest(SetLib)]
< **** PTN:getOGsequenceOfArg: 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Alarm)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "has"
< Try: "isEmpty"
< Try: "insert"
< Try: "remove"
< Try: "card"
< Try: "clear"
< Try: "scan"
< Try: "forAllX"
< Try: "forAll"
< Try: "exists"
< Try: "reduce"
< Try: "link"
< Try: "head"
< **** Signature:localSearch: elm in: Set
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< %id "Collection"
< %globals
< in elm:< Object
< scan:< 
<    %OSDvisibility skipInternal
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:workspace,nest(tinyY),nest(SetLib)]
< **   OGS.DOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   After:[0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   getOGsequenceOfArg:aArgs:Set(#Alarm)
< **   fArgs.origin.OG=theFargsOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   theFargOG:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** PRE: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Alarm
< **   encOG: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** Invocation:semCheck: #Alarm
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< 
< **** OI:semCheck: "#Alarm" rec: "none"
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **** OG:semCheck:
< scan
<       current.print
<       put(',')
<    newline
< **   encOG: 
< scan
<       current.print
<       put(',')
<    newline
< **** Invocation:semCheck: 
< **   encOG:
< scan
<       current.print
<       put(',')
<    newline
< 
< **** OG:semCheck:
< scan
<    current.print
<    put(',')
< **   encOG: 
< scan
<       current.print
<       put(',')
<    newline
< **** Invocation:semCheck: scan
< **   encOG:
< scan
<       current.print
<       put(',')
<    newline
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< scan
<       current.print
<       put(',')
<    newline
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       current.print
<       put(',')
<    newline
< **** OG:semCheck:current.print
< **   encOG: 
< scan
<    current.print
<    put(',')
< **** Invocation:semCheck: current.print
< **   encOG:
< scan
<    current.print
<    put(',')
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< scan
<    current.print
<    put(',')
< 
< **** OI:semCheck: "print" rec: "current"
< **   encOG:
< scan
<    current.print
<    put(',')
< 
< **** Pattern:checkActualArgs:
< print: 
<    "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<    current.print
<    put(',')
< **** OG:semcheck:IS not empty:eOG: 
< 
< "alarm: ".print
<    descr.print
<    put(':')
<    reqQuali.print
< **** OG:semCheck:put(',')
< **   encOG: 
< scan
<    current.print
<    put(',')
< **** Invocation:semCheck: put(',')
< **   encOG:
< scan
<    current.print
<    put(',')
< 
< **** OI:semCheck: "put(',')" rec: "none"
< **   encOG:
< scan
<    current.print
<    put(',')
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(',')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< scan
<    current.print
<    put(',')
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(',')
< **   fArg: in ch: val char
< **   aArg: ','
< **   theOI.f.f:label: ObjectGenerator
< put(',')
< **   encOG:
< scan
<    current.print
<    put(',')
< **   savedOGS: [0:print,nest(scan$0)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(',')
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: -- to be eliminated
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:print,nest(scan$0)]
< **   OGS.DOG:
< scan
<    current.print
<    put(',')
< **   After:[0:print,nest(scan$0),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(',')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:print,nest(scan$0),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:print,nest(scan$0),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:print,nest(scan$0),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:print,nest(scan$0),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:print,nest(scan$0),nest(put)]
< **   encOG: 
< scan
<    current.print
<    put(',')
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:print,nest(scan$0),nest(put)]
< **   ENC:result:[1:print,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:print,nest(scan$0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:print,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:print,nest(scan$0)]
< **** savedOGS:save:False[0:print,nest(scan$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:print,nest(scan$0)]
< **   OGS:[0:print,nest(scan$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:print,nest(scan$0)]
< **** OG:semCheck:','
< **   encOG: put(',')
< **** Invocation:semCheck: ','
< **   encOG:put(',')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    current.print
<    put(',')
< **** OG:semCheck:newline
< **   encOG: 
< scan
<       current.print
<       put(',')
<    newline
< **** Invocation:semCheck: newline
< **   encOG:
< scan
<       current.print
<       put(',')
<    newline
< 
< **** OI:semCheck: "newline" rec: "none"
< **   encOG:
< scan
<       current.print
<       put(',')
<    newline
< 
< **** Pattern:checkActualArgs:
< newline: 
<    %globals
<    put(10)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<       current.print
<       put(',')
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    put(10)
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<       current.print
<       put(',')
<    newline
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** OG:semCheck:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   encOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** OG:semCheck:integer
< **   encOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:integer
< **   encOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** Invocation:semCheck: integer
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OG:semCheck:"Period:".print
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: "Period:".print
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:semCheck: "print" rec: ""Period:""
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:putint(start)
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: putint(start)
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:semCheck: "putint(start)" rec: "none"
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** Pattern:checkActualArgs:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   actualArgs: putint(start)
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   argAtInx: 1 in:PTN:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(start)
< **   fArg: in V: var integer
< **   aArg: start
< **   theOI.f.f:label: ObjectGenerator
< putint(start)
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   savedOGS: [0:Period,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(start)
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %globals
< in V: var integer
< D: obj Indexed(20,#integer)
< L: var integer
< isNeg: var Boolean
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Period,nest(print)]
< **   OGS.DOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   After:[0:Period,nest(print),nest(putint)]
< **   getOGsequenceOfArg:aArgs:putint(start)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   OGS: [0:Period,nest(print),nest(putint)]
< **   theFargOG:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Period,nest(print),nest(putint)]
< **** DataItem:getVqual: in V: var integer
< [0:Period,nest(print),nest(putint)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Period,nest(print),nest(putint)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Period,nest(print),nest(putint)]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:Period,nest(print),nest(putint)]
< **   ENC:result:[1:Period,nest(print)]
< 
< **** getVqual:B2:
< [0:Period,nest(print)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Period,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:Period,nest(print)]
< **** savedOGS:save:False[0:Period,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Period,nest(print)]
< **   OGS:[0:Period,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Period,nest(print)]
< **** OG:semCheck:start
< **   encOG: putint(start)
< **** Invocation:semCheck: start
< **   encOG:putint(start)
< **** OI:semCheck: "start" rec: "none"
< **   encOG:putint(start)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semCheck:put(',')
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: put(',')
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:semCheck: "put(',')" rec: "none"
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put(',')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(',')
< **   fArg: in ch: val char
< **   aArg: ','
< **   theOI.f.f:label: ObjectGenerator
< put(',')
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   savedOGS: [0:Period,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put(',')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Period,nest(print)]
< **   OGS.DOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   After:[0:Period,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put(',')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Period,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Period,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Period,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Period,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Period,nest(print),nest(put)]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Period,nest(print),nest(put)]
< **   ENC:result:[1:Period,nest(print)]
< 
< **** getVqual:B2:
< [0:Period,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Period,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Period,nest(print)]
< **** savedOGS:save:False[0:Period,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Period,nest(print)]
< **   OGS:[0:Period,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Period,nest(print)]
< **** OG:semCheck:','
< **   encOG: put(',')
< **** Invocation:semCheck: ','
< **   encOG:put(',')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:put('Y')
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: put('Y')
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:semCheck: "put('Y')" rec: "none"
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('Y')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('Y')
< **   fArg: in ch: val char
< **   aArg: 'Y'
< **   theOI.f.f:label: ObjectGenerator
< put('Y')
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   savedOGS: [0:Period,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('Y')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Period,nest(print)]
< **   OGS.DOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   After:[0:Period,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('Y')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Period,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Period,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Period,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Period,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Period,nest(print),nest(put)]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Period,nest(print),nest(put)]
< **   ENC:result:[1:Period,nest(print)]
< 
< **** getVqual:B2:
< [0:Period,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Period,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Period,nest(print)]
< **** savedOGS:save:False[0:Period,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Period,nest(print)]
< **   OGS:[0:Period,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Period,nest(print)]
< **** OG:semCheck:'Y'
< **   encOG: put('Y')
< **** Invocation:semCheck: 'Y'
< **   encOG:put('Y')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:putint(end)
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: putint(end)
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:semCheck: "putint(end)" rec: "none"
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** Pattern:checkActualArgs:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   actualArgs: putint(end)
< **   fArgs(in V: var integer,)
< 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   argAtInx: 1 in:PTN:
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(end)
< **   fArg: in V: var integer
< **   aArg: end
< **   theOI.f.f:label: ObjectGenerator
< putint(end)
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   savedOGS: [0:Period,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< **   theOI: putint(end)
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: var integer
< **** Items:localSearch: V
< **   in:
< 
< %globals
< in V: var integer
< D: obj Indexed(20,#integer)
< L: var integer
< isNeg: var Boolean
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Period,nest(print)]
< **   OGS.DOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   After:[0:Period,nest(print),nest(putint)]
< **   getOGsequenceOfArg:aArgs:putint(end)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   OGS: [0:Period,nest(print),nest(putint)]
< **   theFargOG:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Period,nest(print),nest(putint)]
< **** DataItem:getVqual: in V: var integer
< [0:Period,nest(print),nest(putint)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Period,nest(print),nest(putint)]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Period,nest(print),nest(putint)]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:Period,nest(print),nest(putint)]
< **   ENC:result:[1:Period,nest(print)]
< 
< **** getVqual:B2:
< [0:Period,nest(print)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Period,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:Period,nest(print)]
< **** savedOGS:save:False[0:Period,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Period,nest(print)]
< **   OGS:[0:Period,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Period,nest(print)]
< **** OG:semCheck:end
< **   encOG: putint(end)
< **** Invocation:semCheck: end
< **   encOG:putint(end)
< **** OI:semCheck: "end" rec: "none"
< **   encOG:putint(end)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** OG:semCheck:put('U')
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: put('U')
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:semCheck: "put('U')" rec: "none"
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('U')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('U')
< **   fArg: in ch: val char
< **   aArg: 'U'
< **   theOI.f.f:label: ObjectGenerator
< put('U')
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   savedOGS: [0:Period,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('U')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Period,nest(print)]
< **   OGS.DOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   After:[0:Period,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('U')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Period,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Period,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Period,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Period,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Period,nest(print),nest(put)]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Period,nest(print),nest(put)]
< **   ENC:result:[1:Period,nest(print)]
< 
< **** getVqual:B2:
< [0:Period,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Period,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Period,nest(print)]
< **** savedOGS:save:False[0:Period,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Period,nest(print)]
< **   OGS:[0:Period,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Period,nest(print)]
< **** OG:semCheck:'U'
< **   encOG: put('U')
< **** Invocation:semCheck: 'U'
< **   encOG:put('U')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:newline
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** Invocation:semCheck: newline
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:semCheck: "newline" rec: "none"
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** Pattern:checkActualArgs:
< newline: 
<    %globals
<    put(10)
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    put(10)
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** OG:semCheck:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   encOG: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** Invocation:semCheck: SetLib.Set(#Period)
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< 
< **** OI:semCheck: "SetLib" rec: "Periods"
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< 
< **** OI:semCheck: "Set(#Period)" rec: "SetLib"
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< 
< **** Pattern:checkActualArgs:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   actualArgs: Set(#Period)
< **   fArgs(in elm:< Object,)
< 
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   argAtInx: 1 in:PTN:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Period)
< **   fArg: in elm:< Object
< **   aArg: #Period
< **   theOI.f.f:label: ObjectGenerator
< 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   savedOGS: [0:workspace,nest(tinyY),nest(SetLib)]
< **** PTN:getOGsequenceOfArg: 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   theOI: Set(#Period)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in elm:< Object
< **** Items:localSearch: elm
< **   in:
< 
< %globals
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "has"
< Try: "isEmpty"
< Try: "insert"
< Try: "remove"
< Try: "card"
< Try: "clear"
< Try: "scan"
< Try: "forAllX"
< Try: "forAll"
< Try: "exists"
< Try: "reduce"
< Try: "link"
< Try: "head"
< **** Signature:localSearch: elm in: Set
< **** Items:localSearch: elm
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< **** Items:localSearch:end: elm
< **** Signature:localSearch:end: elm
< **   Items:localSearch:trySuper:
< **** Items:localSearch: elm
< **   in:
< 
< %id "Collection"
< %globals
< in elm:< Object
< scan:< 
<    %OSDvisibility skipInternal
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: elm
< Try: "elm"
< **** Items:localSearch:end: elm
< **** Items:localSearch:end: elm
< **   pathTo:parDecl:pn:1
< **   OGS:[0:workspace,nest(tinyY),nest(SetLib)]
< **   OGS.DOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   After:[0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   getOGsequenceOfArg:aArgs:Set(#Period)
< **   fArgs.origin.OG=theFargsOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   theFargOG:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** PRE: [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** Pattern:getVqual: elm :isVirtual:True
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set),Collection]
< **** searchBinding: in elm:< Object
< [0:workspace,nest(tinyY),nest(SetLib),nest(Set)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Period
< **   encOG: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** Invocation:semCheck: #Period
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< 
< **** OI:semCheck: "#Period" rec: "none"
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** OG:semCheck:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **   encOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** Invocation:semCheck: 
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< 
< **** OG:semCheck:put('E')
< **   encOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** Invocation:semCheck: put('E')
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< 
< **** OI:semCheck: "put('E')" rec: "none"
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('E')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('E')
< **   fArg: in ch: val char
< **   aArg: 'E'
< **   theOI.f.f:label: ObjectGenerator
< put('E')
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **   savedOGS: [0:Periods,nest(print)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('E')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Periods,nest(print)]
< **   OGS.DOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **   After:[0:Periods,nest(print),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('E')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Periods,nest(print),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Periods,nest(print),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Periods,nest(print),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Periods,nest(print),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Periods,nest(print),nest(put)]
< **   encOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Periods,nest(print),nest(put)]
< **   ENC:result:[1:Periods,nest(print)]
< 
< **** getVqual:B2:
< [0:Periods,nest(print)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Periods,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Periods,nest(print)]
< **** savedOGS:save:False[0:Periods,nest(print)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Periods,nest(print)]
< **   OGS:[0:Periods,nest(print)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Periods,nest(print)]
< **** OG:semCheck:'E'
< **   encOG: put('E')
< **** Invocation:semCheck: 'E'
< **   encOG:put('E')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:
< scan
<    put('R')
<    current.print
<    put('T')
< **   encOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** Invocation:semCheck: scan
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< 
< **** OI:semCheck: "scan" rec: "none"
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** OG:semCheck:put('R')
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** Invocation:semCheck: put('R')
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** OI:semCheck: "put('R')" rec: "none"
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('R')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('R')
< **   fArg: in ch: val char
< **   aArg: 'R'
< **   theOI.f.f:label: ObjectGenerator
< put('R')
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   savedOGS: [0:print,nest(scan$0)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('R')
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: -- to be eliminated
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:print,nest(scan$0)]
< **   OGS.DOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   After:[0:print,nest(scan$0),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('R')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:print,nest(scan$0),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:print,nest(scan$0),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:print,nest(scan$0),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:print,nest(scan$0),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:print,nest(scan$0),nest(put)]
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:print,nest(scan$0),nest(put)]
< **   ENC:result:[1:print,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:print,nest(scan$0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:print,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:print,nest(scan$0)]
< **** savedOGS:save:False[0:print,nest(scan$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:print,nest(scan$0)]
< **   OGS:[0:print,nest(scan$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:print,nest(scan$0)]
< **** OG:semCheck:'R'
< **   encOG: put('R')
< **** Invocation:semCheck: 'R'
< **   encOG:put('R')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:current.print
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** Invocation:semCheck: current.print
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** OI:semCheck: "current" rec: "none"
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** OI:semCheck: "print" rec: "current"
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** Pattern:checkActualArgs:
< print: 
<    "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **** OG:semcheck:IS not empty:eOG: 
< 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** OG:semCheck:put('T')
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** Invocation:semCheck: put('T')
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** OI:semCheck: "put('T')" rec: "none"
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('T')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('T')
< **   fArg: in ch: val char
< **   aArg: 'T'
< **   theOI.f.f:label: ObjectGenerator
< put('T')
< **   encOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   savedOGS: [0:print,nest(scan$0)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('T')
< **   theOI.on:4,pn:0 viaIncl: True OGS.DOG.super: -- to be eliminated
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:print,nest(scan$0)]
< **   OGS.DOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   After:[0:print,nest(scan$0),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('T')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:print,nest(scan$0),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:print,nest(scan$0),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:print,nest(scan$0),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:print,nest(scan$0),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:print,nest(scan$0),nest(put)]
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:print,nest(scan$0),nest(put)]
< **   ENC:result:[1:print,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:print,nest(scan$0)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:print,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:print,nest(scan$0)]
< **** savedOGS:save:False[0:print,nest(scan$0)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:print,nest(scan$0)]
< **   OGS:[0:print,nest(scan$0)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:print,nest(scan$0)]
< **** OG:semCheck:'T'
< **   encOG: put('T')
< **** Invocation:semCheck: 'T'
< **   encOG:put('T')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semcheck:IS not empty:eOG: 
< 
< scan
<    put('R')
<    current.print
<    put('T')
< **** OG:semcheck:IS not empty:eOG: 
< 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** OG:semCheck:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Invocation:semCheck: MapLib.Map(#Period,#Experts)
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** OI:semCheck: "MapLib" rec: "Schedule"
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** OI:semCheck: "Map(#Period,#Experts)" rec: "MapLib"
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** Pattern:checkActualArgs:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   actualArgs: (#Period,#Experts)
< **   fArgs(in Domain:< Object,in Range:< Object,)
< 
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   argAtInx: 1 in:PTN:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   theOI: Map(#Period,#Experts)
< **   fArg: in Domain:< Object
< **   aArg: #Period
< **   theOI.f.f:label: ObjectGenerator
< 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   savedOGS: [0:workspace,nest(tinyY),nest(MapLib)]
< **** PTN:getOGsequenceOfArg: 
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   theOI: Map(#Period,#Experts)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Domain:< Object
< **** Items:localSearch: Domain
< **   in:
< 
< in Domain:< Object
< in Range:< Object
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: Domain
< Try: "Domain"
< **** Items:localSearch:end: Domain
< **   pathTo:parDecl:pn:0
< **   OGS:[0:workspace,nest(tinyY),nest(MapLib)]
< **   OGS.DOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< **   After:[0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   getOGsequenceOfArg:aArgs:(#Period,#Experts)
< **   fArgs.origin.OG=theFargsOG: 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   OGS: [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   theFargOG:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Period
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Invocation:semCheck: #Period
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** OI:semCheck: "#Period" rec: "none"
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   argAtInx: 2 in:PTN:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   theOI: Map(#Period,#Experts)
< **   fArg: in Range:< Object
< **   aArg: #Experts
< **   theOI.f.f:label: ObjectGenerator
< 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   savedOGS: [0:workspace,nest(tinyY),nest(MapLib)]
< **** PTN:getOGsequenceOfArg: 
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   theOI: Map(#Period,#Experts)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Range:< Object
< **** Items:localSearch: Range
< **   in:
< 
< in Domain:< Object
< in Range:< Object
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: Range
< Try: "Domain"
< Try: "Range"
< **** Items:localSearch:end: Range
< **   pathTo:parDecl:pn:0
< **   OGS:[0:workspace,nest(tinyY),nest(MapLib)]
< **   OGS.DOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< **   After:[0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   getOGsequenceOfArg:aArgs:(#Period,#Experts)
< **   fArgs.origin.OG=theFargsOG: 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   OGS: [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   theFargOG:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **** Pattern:getVqual: Range :isVirtual:True
< [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:workspace,nest(tinyY),nest(MapLib),nest(Map)]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** OG:semCheck:#Experts
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Invocation:semCheck: #Experts
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** OI:semCheck: "#Experts" rec: "none"
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OG:semCheck:integer
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Invocation:semCheck: integer
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** OG:semCheck:
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **   encOG: 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< 
< **** OG:semCheck:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **** Invocation:semCheck: 
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **** Invocation:semCheck: theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** OI:semCheck: "theSchedule" rec: "B"
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** OI:semCheck: "forAll(
<    E.elm.isEmpty.not)" rec: "theSchedule"
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< **   actualArgs: forAll(
<    E.elm.isEmpty.not)
< **   fArgs(in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll),)
< 
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   argAtInx: 1 in:PTN:
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< **   theOI: 
< forAll(
<    E.elm.isEmpty.not)
< **   fArg: 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **   aArg: E.elm.isEmpty.not
< **   theOI.f.f:label: ObjectGenerator
< 
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map]
< **** PTN:getOGsequenceOfArg: 
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< **   theOI: forAll(
<    E.elm.isEmpty.not)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** Items:localSearch: pred
< **   in:
< 
< %id "forAll"
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: pred
< Try: "pred"
< **** Items:localSearch:end: pred
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   getOGsequenceOfArg:aArgs:
< forAll(
<    E.elm.isEmpty.not)
< **   fArgs.origin.OG=theFargsOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   OGS: [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   theFargOG:
< 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **** Pattern:getVqual: pred :isVirtual:True
< [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **** newFindBinding: 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **** searchBinding: 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   checkDOG: forAll 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< father:
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **** newFindBinding:found: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** PTN:getVqual:gotBinding: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** OG:semCheck:E.elm.isEmpty.not
< **   encOG: 
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< **** Invocation:semCheck: 
< **   encOG:
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< 
< **** OG:semCheck:E.elm.isEmpty.not
< **   encOG: E.elm.isEmpty.not
< **** Invocation:semCheck: E.elm.isEmpty.not
< **   encOG:E.elm.isEmpty.not
< **** OI:semCheck: "E" rec: "none"
< **   encOG:E.elm.isEmpty.not
< **** OI:semCheck: "elm" rec: "E"
< **   encOG:E.elm.isEmpty.not
< **** OI:semCheck: "isEmpty" rec: "elm"
< **   encOG:E.elm.isEmpty.not
< **** Pattern:checkActualArgs:
< isEmpty: 
<    out B: var Boolean
<    B := head == none
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:E.elm.isEmpty.not**** OI:semCheck: "not" rec: "isEmpty"
< **   encOG:E.elm.isEmpty.not
< **** Pattern:checkActualArgs:
< not: 
<    %basic 65
<    out R: var boolean
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:E.elm.isEmpty.not**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< E.elm.isEmpty.not
< **** OG:returnDecl: out return: var Boolean
< **** OI:semCheck: "&& theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))" rec: "
< forAll(
<    E.elm.isEmpty.not)
< "
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: 
< && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **   fArg: in B: var boolean
< **   aArg: 
< theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **   theOI.f.f:label: ObjectGenerator
< 
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean)]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean)]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean),nest(&&)]
< **   getOGsequenceOfArg:aArgs:
< theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean),nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean),nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean),nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean),nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean),nest(&&)]
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean),nest(&&)]
< **   ENC:result:[1:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean)]
< **** ENC:OI.getVqual:[2:tinyY,nest(Schedule),r:Map,nest(Schedule),nest(Boolean)]
< **   ENC:result:[2:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< **** savedOGS:save:False[0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< **   OGS:[0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule),r:Map,nest(Schedule)]
< **** OG:semCheck:
< theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **   encOG: 
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< **** Invocation:semCheck: theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))
< **   encOG:
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< 
< **** OI:semCheck: "theAlarms" rec: "none"
< **   encOG:
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< 
< **** OI:semCheck: "forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))" rec: "theAlarms"
< **   encOG:
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< 
< **** Pattern:checkActualArgs:
< forAll: 
<    in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   actualArgs: forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))
< **   fArgs(in pred:< 
<    in x: ref Object
<    out V: var Boolean,)
< 
< **   encOG:
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< **   argAtInx: 1 in:PTN:
< forAll: 
<    in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   theOI: 
< forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **   fArg: 
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< **   aArg: 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **   theOI.f.f:label: ObjectGenerator
< 
< theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **   encOG:
< theSchedule.forAll(
<    E.elm.isEmpty.not) && theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
< ...
< **   savedOGS: [0:tinyY,nest(Alarms),r:Set]
< **** PTN:getOGsequenceOfArg: 
< forAll: 
<    in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   theOI: forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
<          out R: var Boolean
<          R := Ex.quali.has(A.reqQuali))))
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in pred:< 
<    in x: ref Object
<    out V: var Boolean
< **** Items:localSearch: pred
< **   in:
< 
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< out B: var Boolean
< B := true
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: pred
< Try: "pred"
< **** Items:localSearch:end: pred
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Alarms),r:Set]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Alarms),r:Set,nest(forAll)]
< **   getOGsequenceOfArg:aArgs:
< forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **   fArgs.origin.OG=theFargsOG: 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **   OGS: [0:tinyY,nest(Alarms),r:Set,nest(forAll)]
< **   theFargOG:
< 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Alarms),r:Set,nest(forAll)]
< **** Pattern:getVqual: pred :isVirtual:True
< [0:tinyY,nest(Alarms),r:Set,nest(forAll)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Alarms),r:Set,nest(forAll)]
< **** newFindBinding: 
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< **** searchBinding: 
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< [0:tinyY,nest(Alarms),r:Set,nest(forAll)]
< **   checkDOG: forAll 
< in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
<    B := true
< ...
< father:
< forAll: 
<    in pred:< 
<       in x: ref Object
<       out V: var Boolean
<    out B: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in pred:< 
<    in x: ref Object
<    out V: var Boolean
< **** newFindBinding:found: 
< in x: ref Object
<    out V: var Boolean
< **** PTN:getVqual:gotBinding: 
< in x: ref Object
<    out V: var Boolean
< **** OG:semCheck:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **   encOG: 
< theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< **** Invocation:semCheck: 
< **   encOG:
< theAlarms.forAll(
<    in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
< ...
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< theSchedule.forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **   encOG: 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **** Invocation:semCheck: theSchedule.forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< 
< **** OI:semCheck: "theSchedule" rec: "BB"
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< 
< **** OI:semCheck: "forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))" rec: "theSchedule"
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< 
< **** Pattern:checkActualArgs:
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< **   actualArgs: forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **   fArgs(in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll),)
< 
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **   argAtInx: 1 in:PTN:
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< **   theOI: 
< forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **   fArg: 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **   aArg: 
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< **   theOI.f.f:label: ObjectGenerator
< 
< theSchedule.forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map]
< **** PTN:getOGsequenceOfArg: 
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< **   theOI: forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** Items:localSearch: pred
< **   in:
< 
< %id "forAll"
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: pred
< Try: "pred"
< **** Items:localSearch:end: pred
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   getOGsequenceOfArg:aArgs:
< forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **   fArgs.origin.OG=theFargsOG: 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   OGS: [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   theFargOG:
< 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **** Pattern:getVqual: pred :isVirtual:True
< [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **** newFindBinding: 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **** searchBinding: 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< [0:tinyY,nest(Schedule),r:Map,nest(forAll)]
< **   checkDOG: forAll 
< %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
<       innerBool: inner
< ...
< father:
< forAll: 
<    %id "forAll"
<    in pred:< 
<       in E: ref Entry
<       out return: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in pred:< 
<    in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
< ...
< **** newFindBinding:found: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** PTN:getVqual:gotBinding: 
< in E: ref Entry
<    out return: var Boolean
<    innerBool: inner
<       out B: var Boolean
<    return := innerBool -- no innerBool(forAll)
< **** OG:semCheck:
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< **   encOG: 
< theSchedule.forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< **** Invocation:semCheck: 
< **   encOG:
< theSchedule.forAll(
<    E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali)))
< 
< **** OG:semCheck:
< E.elm.exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **   encOG: 
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< **** Invocation:semCheck: E.elm.exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **   encOG:
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< 
< **** OI:semCheck: "E" rec: "none"
< **   encOG:
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< 
< **** OI:semCheck: "elm" rec: "E"
< **   encOG:
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< 
< **** OI:semCheck: "exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))" rec: "elm"
< **   encOG:
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< 
< **** Pattern:checkActualArgs:
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   actualArgs: exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **   fArgs(in Fxx:< 
<    in x: ref elm
<    out V: var Boolean,)
< 
< **   encOG:
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< **   argAtInx: 1 in:PTN:
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   theOI: 
< exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **   fArg: 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **   aArg: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **   theOI.f.f:label: ObjectGenerator
< 
< E.elm.exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **   encOG:
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< **   savedOGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **** PTN:getOGsequenceOfArg: 
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   theOI: exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **** Items:localSearch: Fxx
< **   in:
< 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< out B: var Boolean
< scan
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: Fxx
< Try: "Fxx"
< **** Items:localSearch:end: Fxx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   getOGsequenceOfArg:aArgs:
< exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **   fArgs.origin.OG=theFargsOG: 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **   OGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   theFargOG:
< 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **** Pattern:getVqual: Fxx :isVirtual:True
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **** newFindBinding: 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **** searchBinding: 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   checkDOG: exists 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< father:
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **** newFindBinding:found: 
< in x: ref elm
<    out V: var Boolean
< **** PTN:getVqual:gotBinding: 
< in x: ref elm
<    out V: var Boolean
< **** OG:semCheck:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **   encOG: 
< E.elm.exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< **** Invocation:semCheck: 
< **   encOG:
< E.elm.exists(
<    in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali))
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **** Invocation:semCheck: Boolean
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:Ex.quali.has(A.reqQuali)
< **   encOG: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **** Invocation:semCheck: Ex.quali.has(A.reqQuali)
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "Ex" rec: "R"
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "quali" rec: "Ex"
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "has(A.reqQuali)" rec: "quali"
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< 
< **** Pattern:checkActualArgs:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   actualArgs: has(A.reqQuali)
< **   fArgs(in E: ref elm,)
< 
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **   argAtInx: 1 in:PTN:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(A.reqQuali)
< **   fArg: in E: ref elm
< **   aArg: A.reqQuali
< **   theOI.f.f:label: ObjectGenerator
< Ex.quali.has(A.reqQuali)
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **   savedOGS: [0:tinyY,nest(Qualifications),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(A.reqQuali)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in E: ref elm
< **** Items:localSearch: E
< **   in:
< 
< B := false
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Signature:localSearch: E in: has
< **** Items:localSearch: E
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Items:localSearch:end: E
< **** Signature:localSearch:end: E
< **   Items:localSearch:trySuper:
< **** Items:localSearch: E
< **   in:
< 
< in E: ref elm
< out B: var boolean
< inner(has)
< **   isChecked: True
< **   Items:localSearch:Decls: E
< Try: "E"
< **** Items:localSearch:end: E
< **** Items:localSearch:end: E
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Qualifications),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   getOGsequenceOfArg:aArgs:has(A.reqQuali)
< **   fArgs.origin.OG=theFargsOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   OGS: [0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   theFargOG:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** PRE: [0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** DataItem:getVqual: in E: ref elm
< [0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **   encOG: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[1:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[2:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   ENC:result:[2:tinyY,nest(Qualifications),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Qualifications),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications)]
< **   checkDOG: Qualifications 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< father:
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Qualification)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Qualification
< 
< ==== FOUND BINDING IN ARG: 
< #Qualification
< **** newFindBinding:found: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** PTN:getVqual:gotBinding: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OG:semCheck:A.reqQuali
< **   encOG: Ex.quali.has(A.reqQuali)
< **** Invocation:semCheck: A.reqQuali
< **   encOG:Ex.quali.has(A.reqQuali)
< **** OI:semCheck: "A" rec: "none"
< **   encOG:Ex.quali.has(A.reqQuali)
< **** OI:semCheck: "reqQuali" rec: "A"
< **   encOG:Ex.quali.has(A.reqQuali)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: R on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< 
< **** OI:getVqual:initial:R
< **   encOG:
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **   OGs:[0:$0]
< **   ATd: out R: var Boolean
< **** DataItem:getVqual: out R: var Boolean
< [0:$0]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Boolean on=9 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **** OI:viaInclude:on=9 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:exists$0]
< **** viaInclude:GOT:
< [0:exists$0,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:exists$0,nest($0)]
< **** savedOGS:save:False[0:exists$0,nest($0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:exists$0,nest($0)]
< **   OGS:[0:exists$0,nest($0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:exists$0,nest($0)]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:exists$0,nest($0)]
< **** savedOGS:save:was:[0:exists$0,nest($0)]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:exists$0,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:exists$0,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in Ex: ref Expert
<    out R: var Boolean
<    R := Ex.quali.has(A.reqQuali)
< **** OG:returnDecl: out R: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< E.elm.exists(
<       in Ex: ref Expert
<       out R: var Boolean
<       R := Ex.quali.has(A.reqQuali))
< **** OG:returnDecl: out return: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var Boolean
< 
< **** OI:getVqual: BB on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< 
< **** OI:getVqual:initial:BB
< **   encOG:
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **   OGs:[0:$0]
< **   ATd: out BB: var Boolean
< **** DataItem:getVqual: out BB: var Boolean
< [0:$0]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **** OI:viaInclude:on=5 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:forAll$0]
< **** viaInclude:GOT:
< [0:forAll$0,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:forAll$0,nest($0)]
< **** savedOGS:save:False[0:forAll$0,nest($0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAll$0,nest($0)]
< **   OGS:[0:forAll$0,nest($0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:forAll$0,nest($0)]
< 
< **** getVqual:initial:afterATd:BB
< **   OGSx:[0:forAll$0,nest($0)]
< **** savedOGS:save:was:[0:forAll$0,nest($0)]
< **   OI: BB
< **   OI:getQual:savedOI:BB
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAll$0,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: BB
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:forAll$0,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in A: ref Alarm
<    out BB: var Boolean
<    BB := theSchedule.forAll(
<       E.elm.exists(
<          in Ex: ref Expert
< ...
< **** OG:returnDecl: out BB: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< 
< **** OI:getVqual:initial:B
< **   encOG:
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   OGs:[0:PlantInvA]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:PlantInvA]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:PlantInvA]
< 
< **** OI:getVqual: Boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:PlantInvA]
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **** OI:viaInclude:on=3 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   OGS:[0:PlantInvA]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **   OGS:[0:PlantInvA]
< **** ENC:OI.viaInclude:[0:PlantInvA]
< **   ENC:result:[0:Plant]
< **** viaInclude:GOT:
< [0:Plant,nest(PlantInvA)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(PlantInvA)]
< **** savedOGS:save:False[0:Plant,nest(PlantInvA)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(PlantInvA)]
< **   OGS:[0:Plant,nest(PlantInvA)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(PlantInvA)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Plant,nest(PlantInvA)]
< **** savedOGS:save:was:[0:Plant,nest(PlantInvA)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(PlantInvA)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(PlantInvA)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< out B: var Boolean
<    B := theSchedule.forAll(
<       E.elm.isEmpty.not) && theAlarms.forAll(
<       in A: ref Alarm
<       out BB: var Boolean
< ...
< **** OG:returnDecl: out B: var Boolean
< **** OG:semCheck:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** Invocation:semCheck: 
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:true
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** Invocation:semCheck: true
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OI:semCheck: "true" rec: "B"
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** Pattern:checkActualArgs:
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OI:getVqual:initial:B
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **   OGs:[0:PlantInvB]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:PlantInvB]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:PlantInvB]
< 
< **** OI:getVqual: Boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:PlantInvB]
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** OI:viaInclude:on=3 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **   OGS:[0:PlantInvB]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **   OGS:[0:PlantInvB]
< **** ENC:OI.viaInclude:[0:PlantInvB]
< **   ENC:result:[0:Plant]
< **** viaInclude:GOT:
< [0:Plant,nest(PlantInvB)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(PlantInvB)]
< **** savedOGS:save:False[0:Plant,nest(PlantInvB)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(PlantInvB)]
< **   OGS:[0:Plant,nest(PlantInvB)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(PlantInvB)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Plant,nest(PlantInvB)]
< **** savedOGS:save:was:[0:Plant,nest(PlantInvB)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(PlantInvB)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(PlantInvB)]
< **** OG:semCheck:
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** Invocation:semCheck: theSchedule.scan
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OI:semCheck: "theSchedule" rec: "none"
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OI:semCheck: "scan" rec: "theSchedule"
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** OG:semCheck:B && current.elm.isEmpty.not
< **   encOG: 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **** Invocation:semCheck: B && current.elm.isEmpty.not
< **   encOG:
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< 
< **** OI:semCheck: "B" rec: "B"
< **   encOG:
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< 
< **** OI:semCheck: "&& current.elm.isEmpty.not" rec: "B"
< **   encOG:
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< 
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: current.elm.isEmpty.not
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && current.elm.isEmpty.not
< **   fArg: in B: var boolean
< **   aArg: current.elm.isEmpty.not
< **   theOI.f.f:label: ObjectGenerator
< B && current.elm.isEmpty.not
< **   encOG:
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **   savedOGS: [0:Plant,nest(scan$0),nest(Boolean)]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && current.elm.isEmpty.not
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Plant,nest(scan$0),nest(Boolean)]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   getOGsequenceOfArg:aArgs:current.elm.isEmpty.not
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   encOG: 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   ENC:result:[1:Plant,nest(scan$0),nest(Boolean)]
< **** ENC:OI.getVqual:[2:Plant,nest(scan$0),nest(Boolean)]
< **   ENC:result:[2:Plant,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:Plant,nest(scan$0)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Plant,nest(scan$0)]
< **** savedOGS:save:False[0:Plant,nest(scan$0)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(scan$0)]
< **   OGS:[0:Plant,nest(scan$0)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(scan$0)]
< **** OG:semCheck:current.elm.isEmpty.not
< **   encOG: B && current.elm.isEmpty.not
< **** Invocation:semCheck: current.elm.isEmpty.not
< **   encOG:B && current.elm.isEmpty.not
< **** OI:semCheck: "current" rec: "none"
< **   encOG:B && current.elm.isEmpty.not
< **** OI:semCheck: "elm" rec: "current"
< **   encOG:B && current.elm.isEmpty.not
< **** OI:semCheck: "isEmpty" rec: "elm"
< **   encOG:B && current.elm.isEmpty.not
< **** Pattern:checkActualArgs:
< isEmpty: 
<    out B: var Boolean
<    B := head == none
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:B && current.elm.isEmpty.not**** OI:semCheck: "not" rec: "isEmpty"
< **   encOG:B && current.elm.isEmpty.not
< **** Pattern:checkActualArgs:
< not: 
<    %basic 65
<    out R: var boolean
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:B && current.elm.isEmpty.not**** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=1 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< 
< **** OI:getVqual:initial:B
< **   encOG:
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **   OGs:[0:PlantInvB]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:PlantInvB]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:PlantInvB]
< 
< **** OI:getVqual: Boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:PlantInvB]
< **   encOG: 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **** OI:viaInclude:on=3 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **   OGS:[0:PlantInvB]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **   OGS:[0:PlantInvB]
< **** ENC:OI.viaInclude:[0:PlantInvB]
< **   ENC:result:[0:Plant]
< **** viaInclude:GOT:
< [0:Plant,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(scan$0)]
< **** savedOGS:save:False[0:Plant,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(scan$0)]
< **   OGS:[0:Plant,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Plant,nest(scan$0)]
< **** savedOGS:save:was:[0:Plant,nest(scan$0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(scan$0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< theSchedule.scan
<    B := B && current.elm.isEmpty.not
< **** OG:semCheck:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **   encOG: 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** Invocation:semCheck: theAlarms.forAllX
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OI:semCheck: "theAlarms" rec: "none"
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** OI:semCheck: "forAllX" rec: "theAlarms"
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< 
< **** Pattern:checkActualArgs:
< forAllX: 
<    current: ref elm
<    scan
<       (this(forAllX)).current := current
<       inner(forAllX)
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** OG:semCheck:current
< **   encOG: 
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **** Invocation:semCheck: current
< **   encOG:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< 
< **** OI:semCheck: "current" rec: "A"
< **   encOG:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< 
< **** OI:getVqual: A on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< 
< **** OI:getVqual:initial:A
< **   encOG:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **   OGs:[0:forAllX$0]
< **   ATd: A: ref Alarm
< **** DataItem:getVqual: A: ref Alarm
< [0:forAllX$0]
< **** ObjectGenerator:getVqual: Alarm
< **   hasVirtualArgs: False
< **** INV:getVqual:Alarm
< **   OGs: [0:forAllX$0]
< 
< **** OI:getVqual: Alarm on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:forAllX$0]
< **   encOG: 
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **** koks: Alarm on: 3 Items 
< **   father: Alarm
< **   father.f.f.f.f:
< 
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **** ENC:OI.getVqual:[1:forAllX$0]
< **   ENC:result:[1:PlantInvB]
< **** ENC:OI.getVqual:[2:PlantInvB]
< **   ENC:result:[2:Plant]
< **** ENC:OI.getVqual:[3:Plant]
< **   ENC:result:[3:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Alarm :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarm
< **   OI:getQual:savedOI:Alarm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarm
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:initial:afterATd:A
< **   OGSx:[0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: A
< **   OI:getQual:savedOI:A
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS: none
< **** OI:getVqual:end: A
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   encOG: 
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **** Invocation:semCheck: theSchedule.scan
< **   encOG:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< 
< **** OI:semCheck: "theSchedule" rec: "none"
< **   encOG:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< 
< **** OI:semCheck: "scan" rec: "theSchedule"
< **   encOG:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **** OG:semCheck:Boolean
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** Invocation:semCheck: Boolean
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:
< current.elm.exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** Invocation:semCheck: current.elm.exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:semCheck: "current" rec: "bbb"
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:semCheck: "elm" rec: "current"
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:semCheck: "exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))" rec: "elm"
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   actualArgs: exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **   fArgs(in Fxx:< 
<    in x: ref elm
<    out V: var Boolean,)
< 
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   argAtInx: 1 in:PTN:
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   theOI: 
< exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **   fArg: 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **   aArg: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **   theOI.f.f:label: ObjectGenerator
< 
< current.elm.exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   savedOGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **** PTN:getOGsequenceOfArg: 
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< **   theOI: exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **** Items:localSearch: Fxx
< **   in:
< 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< out B: var Boolean
< scan
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: Fxx
< Try: "Fxx"
< **** Items:localSearch:end: Fxx
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Plant,nest(Schedule&),nest(Experts),r:Set]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   getOGsequenceOfArg:aArgs:
< exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **   fArgs.origin.OG=theFargsOG: 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **   OGS: [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   theFargOG:
< 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **** Pattern:getVqual: Fxx :isVirtual:True
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **** newFindBinding: 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **** searchBinding: 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< [0:Plant,nest(Schedule&),nest(Experts),r:Set,nest(exists)]
< **   checkDOG: exists 
< in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
<    scan
< ...
< father:
< exists: 
<    in Fxx:< 
<       in x: ref elm
<       out V: var Boolean
<    out B: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in Fxx:< 
<    in x: ref elm
<    out V: var Boolean
< **** newFindBinding:found: 
< in x: ref elm
<    out V: var Boolean
< **** PTN:getVqual:gotBinding: 
< in x: ref elm
<    out V: var Boolean
< **** OG:semCheck:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **   encOG: 
< current.elm.exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< **** Invocation:semCheck: 
< **   encOG:
< current.elm.exists(
<    in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali))
< 
< **** OG:semCheck:Boolean
< **   encOG: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **** Invocation:semCheck: Boolean
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "Boolean" rec: "none"
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:E.quali.has(A.reqQuali)
< **   encOG: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **** Invocation:semCheck: E.quali.has(A.reqQuali)
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "E" rec: "R"
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "quali" rec: "E"
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< 
< **** OI:semCheck: "has(A.reqQuali)" rec: "quali"
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< 
< **** Pattern:checkActualArgs:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   actualArgs: has(A.reqQuali)
< **   fArgs(in E: ref elm,)
< 
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **   argAtInx: 1 in:PTN:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(A.reqQuali)
< **   fArg: in E: ref elm
< **   aArg: A.reqQuali
< **   theOI.f.f:label: ObjectGenerator
< E.quali.has(A.reqQuali)
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **   savedOGS: [0:tinyY,nest(Qualifications),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(A.reqQuali)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in E: ref elm
< **** Items:localSearch: E
< **   in:
< 
< B := false
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Signature:localSearch: E in: has
< **** Items:localSearch: E
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Items:localSearch:end: E
< **** Signature:localSearch:end: E
< **   Items:localSearch:trySuper:
< **** Items:localSearch: E
< **   in:
< 
< in E: ref elm
< out B: var boolean
< inner(has)
< **   isChecked: True
< **   Items:localSearch:Decls: E
< Try: "E"
< **** Items:localSearch:end: E
< **** Items:localSearch:end: E
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Qualifications),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   getOGsequenceOfArg:aArgs:has(A.reqQuali)
< **   fArgs.origin.OG=theFargsOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   OGS: [0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   theFargOG:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** PRE: [0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** DataItem:getVqual: in E: ref elm
< [0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **   encOG: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[1:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[2:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   ENC:result:[2:tinyY,nest(Qualifications),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Qualifications),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications)]
< **   checkDOG: Qualifications 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< father:
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Qualification)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Qualification
< 
< ==== FOUND BINDING IN ARG: 
< #Qualification
< **** newFindBinding:found: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** PTN:getVqual:gotBinding: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OG:semCheck:A.reqQuali
< **   encOG: E.quali.has(A.reqQuali)
< **** Invocation:semCheck: A.reqQuali
< **   encOG:E.quali.has(A.reqQuali)
< **** OI:semCheck: "A" rec: "none"
< **   encOG:E.quali.has(A.reqQuali)
< **** OI:semCheck: "reqQuali" rec: "A"
< **   encOG:E.quali.has(A.reqQuali)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: R on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< 
< **** OI:getVqual:initial:R
< **   encOG:
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **   OGs:[0:$0]
< **   ATd: out R: var Boolean
< **** DataItem:getVqual: out R: var Boolean
< [0:$0]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:$0]
< 
< **** OI:getVqual: Boolean on=7 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **** OI:viaInclude:on=7 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **   OGS:[0:$0]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:exists$0]
< **** viaInclude:GOT:
< [0:exists$0,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:exists$0,nest($0)]
< **** savedOGS:save:False[0:exists$0,nest($0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:exists$0,nest($0)]
< **   OGS:[0:exists$0,nest($0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:exists$0,nest($0)]
< 
< **** getVqual:initial:afterATd:R
< **   OGSx:[0:exists$0,nest($0)]
< **** savedOGS:save:was:[0:exists$0,nest($0)]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:exists$0,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: R
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:exists$0,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in E: ref Expert
<    out R: var Boolean
<    R := E.quali.has(A.reqQuali)
< **** OG:returnDecl: out R: var Boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var Boolean
< 
< **** OI:getVqual: bbb on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:getVqual:initial:bbb
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   OGs:[0:scan$0]
< **   ATd: bbb: var Boolean
< **** DataItem:getVqual: bbb: var Boolean
< [0:scan$0]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:scan$0]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$0]
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** OI:viaInclude:on=5 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   OGS:[0:scan$0]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   OGS:[0:scan$0]
< **** ENC:OI.viaInclude:[0:scan$0]
< **   ENC:result:[0:forAllX$0]
< **** viaInclude:GOT:
< [0:forAllX$0,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:forAllX$0,nest(scan$0)]
< **** savedOGS:save:False[0:forAllX$0,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAllX$0,nest(scan$0)]
< **   OGS:[0:forAllX$0,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:forAllX$0,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:bbb
< **   OGSx:[0:forAllX$0,nest(scan$0)]
< **** savedOGS:save:was:[0:forAllX$0,nest(scan$0)]
< **   OI: bbb
< **   OI:getQual:savedOI:bbb
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:forAllX$0,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: bbb
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:forAllX$0,nest(scan$0)]
< **** OG:semCheck:B && bbb
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** Invocation:semCheck: B && bbb
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:semCheck: "B" rec: "B"
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:semCheck: "&& bbb" rec: "B"
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** Pattern:checkActualArgs:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   actualArgs: bbb
< **   fArgs(in B: var boolean,)
< 
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   argAtInx: 1 in:PTN:
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && bbb
< **   fArg: in B: var boolean
< **   aArg: bbb
< **   theOI.f.f:label: ObjectGenerator
< B && bbb
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   savedOGS: [0:Plant,nest(scan$0),nest(Boolean)]
< **** PTN:getOGsequenceOfArg: 
< &&  : 
<    %basic 70
<    in B: var boolean
<    out R: var boolean
< **   theOI: && bbb
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in B: var boolean
< **** Items:localSearch: B
< **   in:
< 
< %basic 70
< in B: var boolean
< out R: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: B
< Try: "B"
< **** Items:localSearch:end: B
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Plant,nest(scan$0),nest(Boolean)]
< **   OGS.DOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   After:[0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   getOGsequenceOfArg:aArgs:bbb
< **   fArgs.origin.OG=theFargsOG: 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   OGS: [0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   theFargOG:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **** DataItem:getVqual: in B: var boolean
< [0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 70
<    in B: var boolean
<    out R: var boolean
< **** ENC:OI.getVqual:[1:Plant,nest(scan$0),nest(Boolean),nest(&&)]
< **   ENC:result:[1:Plant,nest(scan$0),nest(Boolean)]
< **** ENC:OI.getVqual:[2:Plant,nest(scan$0),nest(Boolean)]
< **   ENC:result:[2:Plant,nest(scan$0)]
< 
< **** getVqual:B2:
< [0:Plant,nest(scan$0)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(scan$0)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Plant,nest(scan$0)]
< **** savedOGS:save:False[0:Plant,nest(scan$0)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(scan$0)]
< **   OGS:[0:Plant,nest(scan$0)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(scan$0)]
< **** OG:semCheck:bbb
< **   encOG: B && bbb
< **** Invocation:semCheck: bbb
< **   encOG:B && bbb
< **** OI:semCheck: "bbb" rec: "none"
< **   encOG:B && bbb
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out R: var boolean
< 
< **** OI:getVqual: B on=2 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< 
< **** OI:getVqual:initial:B
< **   encOG:
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   OGs:[0:PlantInvB]
< **   ATd: out B: var Boolean
< **** DataItem:getVqual: out B: var Boolean
< [0:PlantInvB]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:PlantInvB]
< 
< **** OI:getVqual: Boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:PlantInvB]
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** OI:viaInclude:on=3 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: Boolean
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   OGS:[0:PlantInvB]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **   OGS:[0:PlantInvB]
< **** ENC:OI.viaInclude:[0:PlantInvB]
< **   ENC:result:[0:Plant]
< **** viaInclude:GOT:
< [0:Plant,nest(scan$0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Plant,nest(scan$0)]
< **** savedOGS:save:False[0:Plant,nest(scan$0)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(scan$0)]
< **   OGS:[0:Plant,nest(scan$0)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(scan$0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:Plant,nest(scan$0)]
< **** savedOGS:save:was:[0:Plant,nest(scan$0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(scan$0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(scan$0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< theSchedule.scan
<    bbb: var Boolean
<    bbb := current.elm.exists(
<       in E: ref Expert
<       out R: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< theAlarms.forAllX
<    A: ref Alarm
<    A := current
<    theSchedule.scan
<       bbb: var Boolean
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< out B: var Boolean
<    B := true
<    theSchedule.scan
<       B := B && current.elm.isEmpty.not
<    theAlarms.forAllX
< ...
< **** OG:returnDecl: out B: var Boolean
< **** Invocation:semCheck: "("
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** Invocation:semCheck: "):period("
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** Invocation:semCheck: ")"
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** OG:semCheck:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **   encOG: 
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **** Invocation:semCheck: 
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** OG:semCheck:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **   encOG: 
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **** Invocation:semCheck: theSchedule.lookup(p).scan
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** OI:semCheck: "theSchedule" rec: "none"
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** OI:semCheck: "lookup(p)" rec: "theSchedule"
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** Pattern:checkActualArgs:
< lookup: 
<    in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
< ...
< **   actualArgs: lookup(p)
< **   fArgs(in V: ref Domain,)
< 
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **   argAtInx: 1 in:PTN:
< lookup: 
<    in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
< ...
< **   theOI: lookup(p)
< **   fArg: in V: ref Domain
< **   aArg: p
< **   theOI.f.f:label: ObjectGenerator
< 
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **** PTN:getOGsequenceOfArg: 
< lookup: 
<    in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
< ...
< **   theOI: lookup(p)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: ref Domain
< **** Items:localSearch: V
< **   in:
< 
< in V: ref Domain
< out R: ref Range
< scan
<    if (V == current.inx) :then 
<       R := current.elm
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   getOGsequenceOfArg:aArgs:lookup(p)
< **   fArgs.origin.OG=theFargsOG: 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **   OGS: [0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   theFargOG:
< 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **** DataItem:getVqual: in V: ref Domain
< [0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   encOG: 
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   ENC:result:[1:tinyY,nest(Schedule&),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule&),r:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:tinyY,nest(Schedule&),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule&),r:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule&),r:Map]
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule&)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   superArg: ObjectGenerator #Period
< 
< ==== FOUND BINDING IN ARG: 
< #Period
< **** newFindBinding:found: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Domain
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:p
< **   encOG: 
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **** Invocation:semCheck: p
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** OI:semCheck: "p" rec: "none"
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** OI:semCheck: "scan" rec: "lookup(p)"
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< 
< **** Pattern:checkActualArgs:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **** OG:semCheck:
< if (exp.quali.has(A.reqQuali)) :then 
<    leave(#ExpertToPage:period)
< **   encOG: 
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **** Invocation:semCheck: if (exp.quali.has(A.reqQuali)) :then 
<    leave(#ExpertToPage:period)
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** OG:semCheck:(exp.quali.has(A.reqQuali))
< **   encOG: 
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **** Invocation:semCheck: (exp.quali.has(A.reqQuali))
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** Invocation:semCheck: exp.quali.has(A.reqQuali)
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** OI:semCheck: "exp" rec: "none"
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** OI:semCheck: "quali" rec: "exp"
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** OI:semCheck: "has(A.reqQuali)" rec: "quali"
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< 
< **** Pattern:checkActualArgs:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   actualArgs: has(A.reqQuali)
< **   fArgs(in E: ref elm,)
< 
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **   argAtInx: 1 in:PTN:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(A.reqQuali)
< **   fArg: in E: ref elm
< **   aArg: A.reqQuali
< **   theOI.f.f:label: BracketedExp
< (exp.quali.has(A.reqQuali))
< **   encOG:
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **   savedOGS: [0:tinyY,nest(Qualifications),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(A.reqQuali)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in E: ref elm
< **** Items:localSearch: E
< **   in:
< 
< B := false
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Signature:localSearch: E in: has
< **** Items:localSearch: E
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Items:localSearch:end: E
< **** Signature:localSearch:end: E
< **   Items:localSearch:trySuper:
< **** Items:localSearch: E
< **   in:
< 
< in E: ref elm
< out B: var boolean
< inner(has)
< **   isChecked: True
< **   Items:localSearch:Decls: E
< Try: "E"
< **** Items:localSearch:end: E
< **** Items:localSearch:end: E
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Qualifications),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   getOGsequenceOfArg:aArgs:has(A.reqQuali)
< **   fArgs.origin.OG=theFargsOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   OGS: [0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   theFargOG:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** PRE: [0:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** DataItem:getVqual: in E: ref elm
< [0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **   encOG: 
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[1:tinyY,nest(Qualifications),r:Set&,nest(has),has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[2:tinyY,nest(Qualifications),r:Set&,nest(has)]
< **   ENC:result:[2:tinyY,nest(Qualifications),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Qualifications),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications)]
< **   checkDOG: Qualifications 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< father:
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Qualification)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Qualification
< 
< ==== FOUND BINDING IN ARG: 
< #Qualification
< **** newFindBinding:found: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** PTN:getVqual:gotBinding: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OG:semCheck:A.reqQuali
< **   encOG: (exp.quali.has(A.reqQuali))
< **** Invocation:semCheck: A.reqQuali
< **   encOG:(exp.quali.has(A.reqQuali))
< **** OI:semCheck: "A" rec: "none"
< **   encOG:(exp.quali.has(A.reqQuali))
< **** OI:semCheck: "reqQuali" rec: "A"
< **   encOG:(exp.quali.has(A.reqQuali))
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< **** OG:semCheck:leave(#ExpertToPage:period)
< **   encOG: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Invocation:semCheck: 
< **   encOG:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< 
< **** OG:semCheck:leave(#ExpertToPage:period)
< **   encOG: leave(#ExpertToPage:period)
< **** Invocation:semCheck: leave(#ExpertToPage:period)
< **   encOG:leave(#ExpertToPage:period)
< **** OI:semCheck: "leave(#ExpertToPage:period)" rec: "none"
< **   encOG:leave(#ExpertToPage:period)
< **** OG:semcheck:IS not empty:eOG: 
< leave(#ExpertToPage:period)
< **** OG:semcheck:IS not empty:eOG: 
< leave(#ExpertToPage:period)
< **** OG:semcheck:IS not empty:eOG: 
< leave(#ExpertToPage:period)
< **** OG:semcheck:IS not empty:eOG: 
< 
< theSchedule.lookup(p).scan
<    if (exp.quali.has(A.reqQuali)) :then 
<       leave(#ExpertToPage:period)
< **** OG:semcheck:IS not empty:eOG: 
< 
< out exp: ref Expert
<    theSchedule.lookup(p).scan
<       if (exp.quali.has(A.reqQuali)) :then 
<          leave(#ExpertToPage:period)
< **** OG:returnDecl: out exp: ref Expert
< **** OG:semCheck:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** Invocation:semCheck: 
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** OG:semCheck:integer
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** Invocation:semCheck: integer
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** OI:semCheck: "integer" rec: "none"
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** Pattern:checkActualArgs:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semCheck:theSchedule.lookup(p).card
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** Invocation:semCheck: theSchedule.lookup(p).card
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** OI:semCheck: "theSchedule" rec: "n"
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** OI:semCheck: "lookup(p)" rec: "theSchedule"
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** Pattern:checkActualArgs:
< lookup: 
<    in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
< ...
< **   actualArgs: lookup(p)
< **   fArgs(in V: ref Domain,)
< 
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **   argAtInx: 1 in:PTN:
< lookup: 
<    in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
< ...
< **   theOI: lookup(p)
< **   fArg: in V: ref Domain
< **   aArg: p
< **   theOI.f.f:label: ObjectGenerator
< theSchedule.lookup(p).card
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **** PTN:getOGsequenceOfArg: 
< lookup: 
<    in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
< ...
< **   theOI: lookup(p)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in V: ref Domain
< **** Items:localSearch: V
< **   in:
< 
< in V: ref Domain
< out R: ref Range
< scan
<    if (V == current.inx) :then 
<       R := current.elm
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: V
< Try: "V"
< **** Items:localSearch:end: V
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   getOGsequenceOfArg:aArgs:lookup(p)
< **   fArgs.origin.OG=theFargsOG: 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **   OGS: [0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   theFargOG:
< 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **** DataItem:getVqual: in V: ref Domain
< [0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in V: ref Domain
<    out R: ref Range
<    scan
<       if (V == current.inx) :then 
<          R := current.elm
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule&),r:Map,nest(lookup)]
< **   ENC:result:[1:tinyY,nest(Schedule&),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule&),r:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:tinyY,nest(Schedule&),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule&),r:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule&),r:Map]
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule&)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   superArg: ObjectGenerator #Period
< 
< ==== FOUND BINDING IN ARG: 
< #Period
< **** newFindBinding:found: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Domain
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:p
< **   encOG: theSchedule.lookup(p).card
< **** Invocation:semCheck: p
< **   encOG:theSchedule.lookup(p).card
< **** OI:semCheck: "p" rec: "none"
< **   encOG:theSchedule.lookup(p).card
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** OI:semCheck: "card" rec: "lookup(p)"
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** Pattern:checkActualArgs:
< card: 
<    out N: var integer
<    scan
<       N := N + 1
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:returnDecl: out N: var integer
< 
< **** OI:getVqual: n on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< 
< **** OI:getVqual:initial:n
< **   encOG:
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **   OGs:[0:numberOfExperts]
< **   ATd: out n: var integer
< **** DataItem:getVqual: out n: var integer
< [0:numberOfExperts]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:numberOfExperts]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:numberOfExperts]
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** OI:viaInclude:on=3 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **   OGS:[0:numberOfExperts]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **   OGS:[0:numberOfExperts]
< **** ENC:OI.viaInclude:[0:numberOfExperts]
< **   ENC:result:[0:Plant]
< **** viaInclude:GOT:
< [0:Plant,nest(numberOfExperts)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:Plant,nest(numberOfExperts)]
< **** savedOGS:save:False[0:Plant,nest(numberOfExperts)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(numberOfExperts)]
< **   OGS:[0:Plant,nest(numberOfExperts)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(numberOfExperts)]
< 
< **** getVqual:initial:afterATd:n
< **   OGSx:[0:Plant,nest(numberOfExperts)]
< **** savedOGS:save:was:[0:Plant,nest(numberOfExperts)]
< **   OI: n
< **   OI:getQual:savedOI:n
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(numberOfExperts)]
< **   OGS: none
< **** OI:getVqual:end: n
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(numberOfExperts)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in p: ref Period
<    out n: var integer
<    n := theSchedule.lookup(p).card
< **** OG:returnDecl: out n: var integer
< **** OG:semCheck:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** Invocation:semCheck: 
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OG:semCheck:put('Q')
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** Invocation:semCheck: put('Q')
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:semCheck: "put('Q')" rec: "none"
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('Q')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('Q')
< **   fArg: in ch: val char
< **   aArg: 'Q'
< **   theOI.f.f:label: ObjectGenerator
< put('Q')
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   savedOGS: [0:Plant,nest(expertIsOnDutyR)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('Q')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Plant,nest(expertIsOnDutyR)]
< **   OGS.DOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   After:[0:Plant,nest(expertIsOnDutyR),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('Q')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Plant,nest(expertIsOnDutyR),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Plant,nest(expertIsOnDutyR),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Plant,nest(expertIsOnDutyR),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Plant,nest(expertIsOnDutyR),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant,nest(expertIsOnDutyR),nest(put)]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Plant,nest(expertIsOnDutyR),nest(put)]
< **   ENC:result:[1:Plant,nest(expertIsOnDutyR)]
< 
< **** getVqual:B2:
< [0:Plant,nest(expertIsOnDutyR)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Plant,nest(expertIsOnDutyR)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Plant,nest(expertIsOnDutyR)]
< **** savedOGS:save:False[0:Plant,nest(expertIsOnDutyR)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(expertIsOnDutyR)]
< **   OGS:[0:Plant,nest(expertIsOnDutyR)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(expertIsOnDutyR)]
< **** OG:semCheck:'Q'
< **   encOG: put('Q')
< **** Invocation:semCheck: 'Q'
< **   encOG:put('Q')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:
< theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** Invocation:semCheck: theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:semCheck: "theSchedule" rec: "fp"
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:semCheck: "select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))" rec: "theSchedule"
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** Pattern:checkActualArgs:
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< **   actualArgs: select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   fArgs(in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean,)
< 
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   argAtInx: 1 in:PTN:
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< **   theOI: 
< select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   fArg: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **   aArg: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   theOI.f.f:label: ObjectGenerator
< 
< theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map&]
< **** PTN:getOGsequenceOfArg: 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< **   theOI: select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** Items:localSearch: pred
< **   in:
< 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< out R: ref SetLib.Set(#Domain)
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: pred
< Try: "pred"
< **** Items:localSearch:end: pred
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule),r:Map&]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **   getOGsequenceOfArg:aArgs:
< select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   fArgs.origin.OG=theFargsOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGS: [0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **   theFargOG:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **** Pattern:getVqual: pred :isVirtual:True
< [0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **** newFindBinding: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** searchBinding: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< [0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **   checkDOG: select 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< father:
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** newFindBinding:found: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** PTN:getVqual:gotBinding: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** OG:semCheck:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   encOG: 
< theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **** Invocation:semCheck: 
< **   encOG:
< theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< 
< **** OG:semCheck:boolean
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** Invocation:semCheck: boolean
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:semCheck: "boolean" rec: "none"
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** Pattern:checkActualArgs:
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:semCheck:ES.has(ep)
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** Invocation:semCheck: ES.has(ep)
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:semCheck: "ES" rec: "B"
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:semCheck: "has(ep)" rec: "ES"
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** Pattern:checkActualArgs:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   actualArgs: has(ep)
< **   fArgs(in E: ref elm,)
< 
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   argAtInx: 1 in:PTN:
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(ep)
< **   fArg: in E: ref elm
< **   aArg: ep
< **   theOI.f.f:label: ObjectGenerator
< ES.has(ep)
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   savedOGS: [0:tinyY,nest(Experts),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **   theOI: has(ep)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in E: ref elm
< **** Items:localSearch: E
< **   in:
< 
< B := false
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Signature:localSearch: E in: has
< **** Items:localSearch: E
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: E
< **** Items:localSearch:end: E
< **** Signature:localSearch:end: E
< **   Items:localSearch:trySuper:
< **** Items:localSearch: E
< **   in:
< 
< in E: ref elm
< out B: var boolean
< inner(has)
< **   isChecked: True
< **   Items:localSearch:Decls: E
< Try: "E"
< **** Items:localSearch:end: E
< **** Items:localSearch:end: E
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Experts),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Experts),r:Set&,nest(has)]
< **   getOGsequenceOfArg:aArgs:has(ep)
< **   fArgs.origin.OG=theFargsOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   OGS: [0:tinyY,nest(Experts),r:Set&,nest(has)]
< **   theFargOG:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** PRE: [0:tinyY,nest(Experts),r:Set&,nest(has)]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:tinyY,nest(Experts),r:Set&,nest(has),has]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Experts),r:Set&,nest(has),has]
< **** DataItem:getVqual: in E: ref elm
< [0:tinyY,nest(Experts),r:Set&,nest(has),has]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Experts),r:Set&,nest(has),has]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Experts),r:Set&,nest(has),has]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[1:tinyY,nest(Experts),r:Set&,nest(has),has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[2:tinyY,nest(Experts),r:Set&,nest(has)]
< **   ENC:result:[2:tinyY,nest(Experts),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Experts),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Expert
< 
< ==== FOUND BINDING IN ARG: 
< #Expert
< **** newFindBinding:found: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY,nest(Experts&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OG:semCheck:ep
< **   encOG: ES.has(ep)
< **** Invocation:semCheck: ep
< **   encOG:ES.has(ep)
< **** OI:semCheck: "ep" rec: "none"
< **   encOG:ES.has(ep)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** OG:returnDecl: out B: var boolean
< 
< **** OI:getVqual: B on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:getVqual:initial:B
< **   encOG:
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   OGs:[0:$0]
< **   ATd: out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:$0]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:$0]
< 
< **** OI:getVqual: boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$0]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** OI:viaInclude:on=5 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: boolean
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   OGS:[0:$0]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   OGS:[0:$0]
< **** ENC:OI.viaInclude:[0:$0]
< **   ENC:result:[0:select$0]
< **** viaInclude:GOT:
< [0:select$0,nest($0)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:select$0,nest($0)]
< **** savedOGS:save:False[0:select$0,nest($0)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select$0,nest($0)]
< **   OGS:[0:select$0,nest($0)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select$0,nest($0)]
< 
< **** getVqual:initial:afterATd:B
< **   OGSx:[0:select$0,nest($0)]
< **** savedOGS:save:was:[0:select$0,nest($0)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select$0,nest($0)]
< **   OGS: none
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select$0,nest($0)]
< **** OG:semcheck:IS not empty:eOG: 
< 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** OG:returnDecl: out B: var boolean
< **** OG:semcheck:IS not empty:eOG: 
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** OG:returnDecl: out R: ref SetLib.Set(#Domain)
< 
< **** OI:getVqual: fp on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:getVqual:initial:fp
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   OGs:[0:expertIsOnDutyR]
< **   ATd: out fp: ref Periods
< **** DataItem:getVqual: out fp: ref Periods
< [0:expertIsOnDutyR]
< **** ObjectGenerator:getVqual: Periods
< **   hasVirtualArgs: True
< **** INV:getVqual:Periods
< **   OGs: [0:expertIsOnDutyR]
< 
< **** OI:getVqual: Periods on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: Periods on: 2 Items 
< **   father: Periods
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:expertIsOnDutyR]
< **   ENC:result:[1:Plant]
< **** ENC:OI.getVqual:[2:Plant]
< **   ENC:result:[2:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** Pattern:getVqual: Periods :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Periods
< **   OI:getQual:savedOI:Periods
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Periods
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:initial:afterATd:fp
< **   OGSx:[0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: fp
< **   OI:getQual:savedOI:fp
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS: none
< **** OI:getVqual:end: fp
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:put('W')
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** Invocation:semCheck: put('W')
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:semCheck: "put('W')" rec: "none"
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** Pattern:checkActualArgs:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   actualArgs: put('W')
< **   fArgs(in ch: val char,)
< 
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   argAtInx: 1 in:PTN:
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('W')
< **   fArg: in ch: val char
< **   aArg: 'W'
< **   theOI.f.f:label: ObjectGenerator
< put('W')
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   savedOGS: [0:Plant,nest(expertIsOnDutyR)]
< **** PTN:getOGsequenceOfArg: 
< put:  -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   theOI: put('W')
< **   theOI.on:3,pn:0 viaIncl: True OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ch: val char
< **** Items:localSearch: ch
< **   in:
< 
< %globals
< %basic 2
< in ch: val char
< **   isChecked: True
< **   Items:localSearch:Decls: ch
< Try: "ch"
< **** Items:localSearch:end: ch
< **   pathTo:parDecl:pn:0
< **   OGS:[0:Plant,nest(expertIsOnDutyR)]
< **   OGS.DOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   After:[0:Plant,nest(expertIsOnDutyR),nest(put)]
< **   getOGsequenceOfArg:aArgs:put('W')
< **   fArgs.origin.OG=theFargsOG: 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   OGS: [0:Plant,nest(expertIsOnDutyR),nest(put)]
< **   theFargOG:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:Plant,nest(expertIsOnDutyR),nest(put)]
< **** DataItem:getVqual: in ch: val char
< [0:Plant,nest(expertIsOnDutyR),nest(put)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:Plant,nest(expertIsOnDutyR),nest(put)]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant,nest(expertIsOnDutyR),nest(put)]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** ENC:OI.getVqual:[1:Plant,nest(expertIsOnDutyR),nest(put)]
< **   ENC:result:[1:Plant,nest(expertIsOnDutyR)]
< 
< **** getVqual:B2:
< [0:Plant,nest(expertIsOnDutyR)]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:Plant,nest(expertIsOnDutyR)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:Plant,nest(expertIsOnDutyR)]
< **** savedOGS:save:False[0:Plant,nest(expertIsOnDutyR)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: val [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Plant,nest(expertIsOnDutyR)]
< **   OGS:[0:Plant,nest(expertIsOnDutyR)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Plant,nest(expertIsOnDutyR)]
< **** OG:semCheck:'W'
< **   encOG: put('W')
< **** Invocation:semCheck: 'W'
< **   encOG:put('W')
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< -- to be eliminated
<    %globals
<    %basic 2
<    in ch: val char
< **** OG:semCheck:fp.print
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** Invocation:semCheck: fp.print
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:semCheck: "fp" rec: "none"
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:semCheck: "print" rec: "fp"
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** Pattern:checkActualArgs:
< print: 
<    put('E')
<    scan
<       put('R')
<       current.print
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** OG:semcheck:IS not empty:eOG: 
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** OG:returnDecl: out fp: ref Periods
< **** OG:semcheck:IS not empty:eOG: 
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** OG:semCheck:Qualification(17)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Qualification(17)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Qualification(17)" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Qualification: 
<    %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
< ...
< **   actualArgs: Qualification(17)
< **   fArgs(in Q: var integer,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< Qualification: 
<    %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
< ...
< **   theOI: Qualification(17)
< **   fArg: in Q: var integer
< **   aArg: 17
< **   theOI.f.f:label: ObjectGenerator
< Qualification(17)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Qualification: 
<    %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
< ...
< **   theOI: Qualification(17)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in Q: var integer
< **** Items:localSearch: Q
< **   in:
< 
< %globals
< in Q: var integer
< print: 
<    "Qualification:".print
<    putint(Q)
< **   isChecked: True
< **   Items:localSearch:Decls: Q
< Try: "Q"
< **** Items:localSearch:end: Q
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Qualification)]
< **   getOGsequenceOfArg:aArgs:Qualification(17)
< **   fArgs.origin.OG=theFargsOG: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **   OGS: [0:tinyY,nest(Qualification)]
< **   theFargOG:
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Qualification)]
< **** DataItem:getVqual: in Q: var integer
< [0:tinyY,nest(Qualification)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:tinyY,nest(Qualification)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Qualification)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Qualification)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Qualification)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Qualification)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(tinyY)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(tinyY)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY)]
< **   OGS:[0:tinyY,nest(tinyY)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY)]
< **** OG:semCheck:17
< **   encOG: Qualification(17)
< **** Invocation:semCheck: 17
< **   encOG:Qualification(17)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semCheck:Qualifications
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Qualifications
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Qualifications" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** OG:semCheck:Experts --SetLib.Set(#Expert){}
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Experts --SetLib.Set(#Expert){}
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Experts --SetLib.Set(#Expert){}" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   actualArgs: --SetLib.Set(#Expert){}
< **   fArgs()
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OG:semCheck:Experts --SetLib.Set(#Expert){}
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Experts --SetLib.Set(#Expert){}
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Experts --SetLib.Set(#Expert){}" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   actualArgs: --SetLib.Set(#Expert){}
< **   fArgs()
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OG:semCheck:Alarms
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Alarms
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Alarms" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Alarms: SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** OG:semCheck:Schedule
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Schedule
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Schedule" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** OG:semCheck:
< Plant(AS,S)
<    
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Plant(AS,S)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Plant(AS,S)" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   actualArgs: (AS,S)
< **   fArgs(in theAlarms: ref Alarms,in theSchedule: ref Schedule,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   theOI: Plant(AS,S)
< **   fArg: in theAlarms: ref Alarms
< **   aArg: AS
< **   theOI.f.f:label: ObjectGenerator
< 
< Plant(AS,S)
<    
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   theOI: Plant(AS,S)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in theAlarms: ref Alarms
< **** Items:localSearch: theAlarms
< **   in:
< 
< in theAlarms: ref Alarms
< in theSchedule: ref Schedule
< PlantInvA: 
<    out B: var Boolean
<    B := theSchedule.forAll(
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: theAlarms
< Try: "theAlarms"
< **** Items:localSearch:end: theAlarms
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Plant)]
< **   getOGsequenceOfArg:aArgs:(AS,S)
< **   fArgs.origin.OG=theFargsOG: 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **   OGS: [0:tinyY,nest(Plant)]
< **   theFargOG:
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Plant)]
< **** DataItem:getVqual: in theAlarms: ref Alarms
< [0:tinyY,nest(Plant)]
< **** ObjectGenerator:getVqual: Alarms
< **   hasVirtualArgs: True
< **** INV:getVqual:Alarms
< **   OGs: [0:tinyY,nest(Plant)]
< 
< **** OI:getVqual: Alarms on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Plant)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Alarms on: 1 Items 
< **   father: Alarms
< **   father.f.f.f.f:
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Plant)]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarms: SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** Pattern:getVqual: Alarms :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarms
< **   OI:getQual:savedOI:Alarms
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarms
< **   qual: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:AS
< **   encOG: 
< Plant(AS,S)
<    
< **** Invocation:semCheck: AS
< **   encOG:
< Plant(AS,S)
<    
< 
< **** OI:semCheck: "AS" rec: "none"
< **   encOG:
< Plant(AS,S)
<    
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   argAtInx: 2 in:PTN:
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   theOI: Plant(AS,S)
< **   fArg: in theSchedule: ref Schedule
< **   aArg: S
< **   theOI.f.f:label: ObjectGenerator
< 
< Plant(AS,S)
<    
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   theOI: Plant(AS,S)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in theSchedule: ref Schedule
< **** Items:localSearch: theSchedule
< **   in:
< 
< in theAlarms: ref Alarms
< in theSchedule: ref Schedule
< PlantInvA: 
<    out B: var Boolean
<    B := theSchedule.forAll(
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: theSchedule
< Try: "theAlarms"
< Try: "theSchedule"
< **** Items:localSearch:end: theSchedule
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Plant)]
< **   getOGsequenceOfArg:aArgs:(AS,S)
< **   fArgs.origin.OG=theFargsOG: 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **   OGS: [0:tinyY,nest(Plant)]
< **   theFargOG:
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Plant)]
< **** DataItem:getVqual: in theSchedule: ref Schedule
< [0:tinyY,nest(Plant)]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY,nest(Plant)]
< 
< **** OI:getVqual: Schedule on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Plant)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 1 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Plant)]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:S
< **   encOG: 
< Plant(AS,S)
<    
< **** Invocation:semCheck: S
< **   encOG:
< Plant(AS,S)
<    
< 
< **** OI:semCheck: "S" rec: "none"
< **   encOG:
< Plant(AS,S)
<    
< 
< **** OG:semcheck:IS not empty:eOG: 
< 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** OG:semcheck:IS not empty:eOG: 
< 
< Plant(AS,S)
<    
< **** OG:semCheck:QS.insert(Q)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: QS.insert(Q)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "QS" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "insert(Q)" rec: "QS"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(Q)
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Q)
< **   fArg: in e: ref elm
< **   aArg: Q
< **   theOI.f.f:label: ObjectGenerator
< QS.insert(Q)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Qualifications),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(Q)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Qualifications),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Qualifications),r:Set&,nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(Q)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:tinyY,nest(Qualifications),r:Set&,nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:tinyY,nest(Qualifications),r:Set&,nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:tinyY,nest(Qualifications),r:Set&,nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Qualifications),r:Set&,nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:tinyY,nest(Qualifications),r:Set&,nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Qualifications),r:Set&,nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Qualifications),r:Set&,nest(insert),insert]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:tinyY,nest(Qualifications),r:Set&,nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:tinyY,nest(Qualifications),r:Set&,nest(insert)]
< **   ENC:result:[2:tinyY,nest(Qualifications),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Qualifications),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Qualifications),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Qualifications)]
< **   checkDOG: Qualifications 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< father:
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Qualification)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Qualification
< 
< ==== FOUND BINDING IN ARG: 
< #Qualification
< **** newFindBinding:found: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** PTN:getVqual:gotBinding: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Qualifications&),r:Set&,Collection]
< **** OG:semCheck:Q
< **   encOG: QS.insert(Q)
< **** Invocation:semCheck: Q
< **   encOG:QS.insert(Q)
< **** OI:semCheck: "Q" rec: "none"
< **   encOG:QS.insert(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:Alarm("OverHeat",Q)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Alarm("OverHeat",Q)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Alarm("OverHeat",Q)" rec: "A"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **   actualArgs: ("OverHeat",Q)
< **   fArgs(in descr: var StringLib.String,in reqQuali: ref Qualification,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **   theOI: Alarm("OverHeat",Q)
< **   fArg: in descr: var StringLib.String
< **   aArg: "OverHeat"
< **   theOI.f.f:label: ObjectGenerator
< Alarm("OverHeat",Q)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **   theOI: Alarm("OverHeat",Q)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in descr: var StringLib.String
< **** Items:localSearch: descr
< **   in:
< 
< in descr: var StringLib.String
< in reqQuali: ref Qualification
< %globals
< print: 
<    "alarm: ".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: descr
< Try: "descr"
< **** Items:localSearch:end: descr
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Alarm)]
< **   getOGsequenceOfArg:aArgs:("OverHeat",Q)
< **   fArgs.origin.OG=theFargsOG: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **   OGS: [0:tinyY,nest(Alarm)]
< **   theFargOG:
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Alarm)]
< **** DataItem:getVqual: in descr: var StringLib.String
< [0:tinyY,nest(Alarm)]
< **** ObjectGenerator:getVqual: StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:StringLib.String
< **   OGs: [0:tinyY,nest(Alarm)]
< 
< **** OI:getVqual: StringLib on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Alarm)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OI:viaInclude:on=2 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Alarm)]
< ***** viaInclude:notTop: StringLib name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Alarm)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Alarm)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(tinyY)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY)]
< **   OGS:[0:tinyY,nest(tinyY)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(tinyY)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY,nest(tinyY)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:tinyY]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: StringLib.String
< **   father.f.f.f.f:
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(tinyY),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:tinyY,nest(tinyY),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY),nest(StringLib)]
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OG:semCheck:"OverHeat"
< **   encOG: Alarm("OverHeat",Q)
< **** Invocation:semCheck: "OverHeat"
< **   encOG:Alarm("OverHeat",Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **   theOI: Alarm("OverHeat",Q)
< **   fArg: in reqQuali: ref Qualification
< **   aArg: Q
< **   theOI.f.f:label: ObjectGenerator
< Alarm("OverHeat",Q)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **   theOI: Alarm("OverHeat",Q)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in reqQuali: ref Qualification
< **** Items:localSearch: reqQuali
< **   in:
< 
< in descr: var StringLib.String
< in reqQuali: ref Qualification
< %globals
< print: 
<    "alarm: ".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: reqQuali
< Try: "descr"
< Try: "reqQuali"
< **** Items:localSearch:end: reqQuali
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Alarm)]
< **   getOGsequenceOfArg:aArgs:("OverHeat",Q)
< **   fArgs.origin.OG=theFargsOG: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **   OGS: [0:tinyY,nest(Alarm)]
< **   theFargOG:
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Alarm)]
< **** DataItem:getVqual: in reqQuali: ref Qualification
< [0:tinyY,nest(Alarm)]
< **** ObjectGenerator:getVqual: Qualification
< **   hasVirtualArgs: False
< **** INV:getVqual:Qualification
< **   OGs: [0:tinyY,nest(Alarm)]
< 
< **** OI:getVqual: Qualification on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Alarm)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualification on: 1 Items 
< **   father: Qualification
< **   father.f.f.f.f:
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Alarm)]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualification: 
<    %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
< ...
< **** Pattern:getVqual: Qualification :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualification
< **   OI:getQual:savedOI:Qualification
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualification
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:Q
< **   encOG: Alarm("OverHeat",Q)
< **** Invocation:semCheck: Q
< **   encOG:Alarm("OverHeat",Q)
< **** OI:semCheck: "Q" rec: "none"
< **   encOG:Alarm("OverHeat",Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< 
< **** OI:getVqual: A on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual:initial:A
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGs:[0:tinyY]
< **   ATd: A: ref Alarm
< **** DataItem:getVqual: A: ref Alarm
< [0:tinyY]
< **** ObjectGenerator:getVqual: Alarm
< **   hasVirtualArgs: False
< **** INV:getVqual:Alarm
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Alarm on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Alarm on: 0 Items 
< **   father: Alarm
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Alarm :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarm
< **   OI:getQual:savedOI:Alarm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarm
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:initial:afterATd:A
< **   OGSx:[0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: A
< **   OI:getQual:savedOI:A
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS: none
< **** OI:getVqual:end: A
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:Expert("John",QS)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Expert("John",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Expert("John",QS)" rec: "E1"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   actualArgs: ("John",QS)
< **   fArgs(in name: var StringLib.String,in quali: ref Qualifications,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("John",QS)
< **   fArg: in name: var StringLib.String
< **   aArg: "John"
< **   theOI.f.f:label: ObjectGenerator
< Expert("John",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("John",QS)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in name: var StringLib.String
< **** Items:localSearch: name
< **   in:
< 
< in name: var StringLib.String
< in quali: ref Qualifications
< %globals
< print: 
<    "Expert:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: name
< Try: "name"
< **** Items:localSearch:end: name
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Expert)]
< **   getOGsequenceOfArg:aArgs:("John",QS)
< **   fArgs.origin.OG=theFargsOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS: [0:tinyY,nest(Expert)]
< **   theFargOG:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Expert)]
< **** DataItem:getVqual: in name: var StringLib.String
< [0:tinyY,nest(Expert)]
< **** ObjectGenerator:getVqual: StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:StringLib.String
< **   OGs: [0:tinyY,nest(Expert)]
< 
< **** OI:getVqual: StringLib on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Expert)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OI:viaInclude:on=2 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Expert)]
< ***** viaInclude:notTop: StringLib name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Expert)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Expert)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(tinyY)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY)]
< **   OGS:[0:tinyY,nest(tinyY)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(tinyY)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY,nest(tinyY)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:tinyY]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: StringLib.String
< **   father.f.f.f.f:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(tinyY),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:tinyY,nest(tinyY),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY),nest(StringLib)]
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OG:semCheck:"John"
< **   encOG: Expert("John",QS)
< **** Invocation:semCheck: "John"
< **   encOG:Expert("John",QS)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("John",QS)
< **   fArg: in quali: ref Qualifications
< **   aArg: QS
< **   theOI.f.f:label: ObjectGenerator
< Expert("John",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("John",QS)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in quali: ref Qualifications
< **** Items:localSearch: quali
< **   in:
< 
< in name: var StringLib.String
< in quali: ref Qualifications
< %globals
< print: 
<    "Expert:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: quali
< Try: "name"
< Try: "quali"
< **** Items:localSearch:end: quali
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Expert)]
< **   getOGsequenceOfArg:aArgs:("John",QS)
< **   fArgs.origin.OG=theFargsOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS: [0:tinyY,nest(Expert)]
< **   theFargOG:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Expert)]
< **** DataItem:getVqual: in quali: ref Qualifications
< [0:tinyY,nest(Expert)]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY,nest(Expert)]
< 
< **** OI:getVqual: Qualifications on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Expert)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 1 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Expert)]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:QS
< **   encOG: Expert("John",QS)
< **** Invocation:semCheck: QS
< **   encOG:Expert("John",QS)
< **** OI:semCheck: "QS" rec: "none"
< **   encOG:Expert("John",QS)
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** OI:getVqual: E1 on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual:initial:E1
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGs:[0:tinyY]
< **   ATd: E1: ref Expert
< **** DataItem:getVqual: E1: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:initial:afterATd:E1
< **   OGSx:[0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E1
< **   OI:getQual:savedOI:E1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS: none
< **** OI:getVqual:end: E1
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:ES1.insert(E1)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: ES1.insert(E1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "ES1" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "insert(E1)" rec: "ES1"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(E1)
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(E1)
< **   fArg: in e: ref elm
< **   aArg: E1
< **   theOI.f.f:label: ObjectGenerator
< ES1.insert(E1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Experts),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(E1)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Experts),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(E1)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   ENC:result:[2:tinyY,nest(Experts),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Experts),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Expert
< 
< ==== FOUND BINDING IN ARG: 
< #Expert
< **** newFindBinding:found: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY,nest(Experts&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OG:semCheck:E1
< **   encOG: ES1.insert(E1)
< **** Invocation:semCheck: E1
< **   encOG:ES1.insert(E1)
< **** OI:semCheck: "E1" rec: "none"
< **   encOG:ES1.insert(E1)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:Expert("Laura",QS)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Expert("Laura",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Expert("Laura",QS)" rec: "E1"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   actualArgs: ("Laura",QS)
< **   fArgs(in name: var StringLib.String,in quali: ref Qualifications,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Laura",QS)
< **   fArg: in name: var StringLib.String
< **   aArg: "Laura"
< **   theOI.f.f:label: ObjectGenerator
< Expert("Laura",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Laura",QS)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in name: var StringLib.String
< **** Items:localSearch: name
< **   in:
< 
< in name: var StringLib.String
< in quali: ref Qualifications
< %globals
< print: 
<    "Expert:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: name
< Try: "name"
< **** Items:localSearch:end: name
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Expert)]
< **   getOGsequenceOfArg:aArgs:("Laura",QS)
< **   fArgs.origin.OG=theFargsOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS: [0:tinyY,nest(Expert)]
< **   theFargOG:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Expert)]
< **** DataItem:getVqual: in name: var StringLib.String
< [0:tinyY,nest(Expert)]
< **** ObjectGenerator:getVqual: StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:StringLib.String
< **   OGs: [0:tinyY,nest(Expert)]
< 
< **** OI:getVqual: StringLib on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Expert)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OI:viaInclude:on=2 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Expert)]
< ***** viaInclude:notTop: StringLib name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Expert)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Expert)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(tinyY)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY)]
< **   OGS:[0:tinyY,nest(tinyY)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(tinyY)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY,nest(tinyY)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:tinyY]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: StringLib.String
< **   father.f.f.f.f:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(tinyY),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:tinyY,nest(tinyY),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY),nest(StringLib)]
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OG:semCheck:"Laura"
< **   encOG: Expert("Laura",QS)
< **** Invocation:semCheck: "Laura"
< **   encOG:Expert("Laura",QS)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Laura",QS)
< **   fArg: in quali: ref Qualifications
< **   aArg: QS
< **   theOI.f.f:label: ObjectGenerator
< Expert("Laura",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Laura",QS)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in quali: ref Qualifications
< **** Items:localSearch: quali
< **   in:
< 
< in name: var StringLib.String
< in quali: ref Qualifications
< %globals
< print: 
<    "Expert:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: quali
< Try: "name"
< Try: "quali"
< **** Items:localSearch:end: quali
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Expert)]
< **   getOGsequenceOfArg:aArgs:("Laura",QS)
< **   fArgs.origin.OG=theFargsOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS: [0:tinyY,nest(Expert)]
< **   theFargOG:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Expert)]
< **** DataItem:getVqual: in quali: ref Qualifications
< [0:tinyY,nest(Expert)]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY,nest(Expert)]
< 
< **** OI:getVqual: Qualifications on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Expert)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 1 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Expert)]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:QS
< **   encOG: Expert("Laura",QS)
< **** Invocation:semCheck: QS
< **   encOG:Expert("Laura",QS)
< **** OI:semCheck: "QS" rec: "none"
< **   encOG:Expert("Laura",QS)
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** OI:getVqual: E1 on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual:initial:E1
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGs:[0:tinyY]
< **   ATd: E1: ref Expert
< **** DataItem:getVqual: E1: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:initial:afterATd:E1
< **   OGSx:[0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E1
< **   OI:getQual:savedOI:E1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS: none
< **** OI:getVqual:end: E1
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:ES1.insert(E1)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: ES1.insert(E1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "ES1" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "insert(E1)" rec: "ES1"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(E1)
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(E1)
< **   fArg: in e: ref elm
< **   aArg: E1
< **   theOI.f.f:label: ObjectGenerator
< ES1.insert(E1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Experts),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(E1)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Experts),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(E1)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   ENC:result:[2:tinyY,nest(Experts),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Experts),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Expert
< 
< ==== FOUND BINDING IN ARG: 
< #Expert
< **** newFindBinding:found: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY,nest(Experts&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OG:semCheck:E1
< **   encOG: ES1.insert(E1)
< **** Invocation:semCheck: E1
< **   encOG:ES1.insert(E1)
< **** OI:semCheck: "E1" rec: "none"
< **   encOG:ES1.insert(E1)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:S.add(Period(0,8),ES1)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: S.add(Period(0,8),ES1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "S" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "add(Period(0,8),ES1)" rec: "S"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   actualArgs: (Period(0,8),ES1)
< **   fArgs(in S: ref Domain,in D: ref Range,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(0,8),ES1)
< **   fArg: in S: ref Domain
< **   aArg: Period(0,8)
< **   theOI.f.f:label: ObjectGenerator
< S.add(Period(0,8),ES1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map]
< **** PTN:getOGsequenceOfArg: 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(0,8),ES1)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in S: ref Domain
< **** Items:localSearch: S
< **   in:
< 
< in S: ref Domain
< in D: ref Range
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: S
< Try: "S"
< **** Items:localSearch:end: S
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   getOGsequenceOfArg:aArgs:(Period(0,8),ES1)
< **   fArgs.origin.OG=theFargsOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS: [0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   theFargOG:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **** DataItem:getVqual: in S: ref Domain
< [0:tinyY,nest(Schedule),r:Map,nest(add)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:tinyY,nest(Schedule),r:Map,nest(add)]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule),r:Map,nest(add)]
< **   ENC:result:[1:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:tinyY,nest(Schedule),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule),r:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule),r:Map]
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   superArg: ObjectGenerator #Period
< 
< ==== FOUND BINDING IN ARG: 
< #Period
< **** newFindBinding:found: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Domain
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:Period(0,8)
< **   encOG: S.add(Period(0,8),ES1)
< **** Invocation:semCheck: Period(0,8)
< **   encOG:S.add(Period(0,8),ES1)
< **** OI:semCheck: "Period(0,8)" rec: "none"
< **   encOG:S.add(Period(0,8),ES1)
< **** Pattern:checkActualArgs:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   actualArgs: (0,8)
< **   fArgs(in start: var integer,in end: var integer,)
< 
< **   encOG:S.add(Period(0,8),ES1)**   argAtInx: 1 in:PTN:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(0,8)
< **   fArg: in start: var integer
< **   aArg: 0
< **   theOI.f.f:label: ObjectGenerator
< Period(0,8)
< **   encOG:S.add(Period(0,8),ES1)
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(0,8)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in start: var integer
< **** Items:localSearch: start
< **   in:
< 
< in start: var integer
< in end: var integer
< %globals
< print: 
<    "Period:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: start
< Try: "start"
< **** Items:localSearch:end: start
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Period)]
< **   getOGsequenceOfArg:aArgs:(0,8)
< **   fArgs.origin.OG=theFargsOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OGS: [0:tinyY,nest(Period)]
< **   theFargOG:
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Period)]
< **** DataItem:getVqual: in start: var integer
< [0:tinyY,nest(Period)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:tinyY,nest(Period)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Period)]
< **   encOG: S.add(Period(0,8),ES1)
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: S.add(Period(0,8),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: S.add(Period(0,8),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Period)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(add)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(add)]
< **** savedOGS:save:False[0:tinyY,nest(add)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(add)]
< **   OGS:[0:tinyY,nest(add)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(add)]
< **** OG:semCheck:0
< **   encOG: Period(0,8)
< **** Invocation:semCheck: 0
< **   encOG:Period(0,8)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(0,8)
< **   fArg: in end: var integer
< **   aArg: 8
< **   theOI.f.f:label: ObjectGenerator
< Period(0,8)
< **   encOG:S.add(Period(0,8),ES1)
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(0,8)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in end: var integer
< **** Items:localSearch: end
< **   in:
< 
< in start: var integer
< in end: var integer
< %globals
< print: 
<    "Period:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: end
< Try: "start"
< Try: "end"
< **** Items:localSearch:end: end
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Period)]
< **   getOGsequenceOfArg:aArgs:(0,8)
< **   fArgs.origin.OG=theFargsOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OGS: [0:tinyY,nest(Period)]
< **   theFargOG:
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Period)]
< **** DataItem:getVqual: in end: var integer
< [0:tinyY,nest(Period)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:tinyY,nest(Period)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Period)]
< **   encOG: S.add(Period(0,8),ES1)
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: S.add(Period(0,8),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: S.add(Period(0,8),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Period)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(add)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(add)]
< **** savedOGS:save:False[0:tinyY,nest(add)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(add)]
< **   OGS:[0:tinyY,nest(add)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(add)]
< **** OG:semCheck:8
< **   encOG: Period(0,8)
< **** Invocation:semCheck: 8
< **   encOG:Period(0,8)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   argAtInx: 2 in:PTN:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(0,8),ES1)
< **   fArg: in D: ref Range
< **   aArg: ES1
< **   theOI.f.f:label: ObjectGenerator
< S.add(Period(0,8),ES1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **** PTN:getOGsequenceOfArg: 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(0,8),ES1)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in D: ref Range
< **** Items:localSearch: D
< **   in:
< 
< in S: ref Domain
< in D: ref Range
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: D
< Try: "S"
< Try: "D"
< **** Items:localSearch:end: D
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   getOGsequenceOfArg:aArgs:(Period(0,8),ES1)
< **   fArgs.origin.OG=theFargsOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS: [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   theFargOG:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **** DataItem:getVqual: in D: ref Range
< [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   ENC:result:[1:tinyY,nest(Schedule&),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule&),r:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:tinyY,nest(Schedule&),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule&),r:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:tinyY,nest(Schedule&),r:Map]
< **** searchBinding: in Range:< Object
< [0:tinyY,nest(Schedule&)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   currentArg: in Range:< Object
< **   superArg: ObjectGenerator #Experts
< 
< ==== FOUND BINDING IN ARG: 
< #Experts
< **** newFindBinding:found: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** PTN:getVqual:gotBinding: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Range
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:ES1
< **   encOG: S.add(Period(0,8),ES1)
< **** Invocation:semCheck: ES1
< **   encOG:S.add(Period(0,8),ES1)
< **** OI:semCheck: "ES1" rec: "none"
< **   encOG:S.add(Period(0,8),ES1)
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** OG:semCheck:Expert("Surayya",QS)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: Expert("Surayya",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "Expert("Surayya",QS)" rec: "E2"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   actualArgs: ("Surayya",QS)
< **   fArgs(in name: var StringLib.String,in quali: ref Qualifications,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Surayya",QS)
< **   fArg: in name: var StringLib.String
< **   aArg: "Surayya"
< **   theOI.f.f:label: ObjectGenerator
< Expert("Surayya",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Surayya",QS)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in name: var StringLib.String
< **** Items:localSearch: name
< **   in:
< 
< in name: var StringLib.String
< in quali: ref Qualifications
< %globals
< print: 
<    "Expert:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: name
< Try: "name"
< **** Items:localSearch:end: name
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Expert)]
< **   getOGsequenceOfArg:aArgs:("Surayya",QS)
< **   fArgs.origin.OG=theFargsOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS: [0:tinyY,nest(Expert)]
< **   theFargOG:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Expert)]
< **** DataItem:getVqual: in name: var StringLib.String
< [0:tinyY,nest(Expert)]
< **** ObjectGenerator:getVqual: StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:StringLib.String
< **   OGs: [0:tinyY,nest(Expert)]
< 
< **** OI:getVqual: StringLib on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Expert)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OI:viaInclude:on=2 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Expert)]
< ***** viaInclude:notTop: StringLib name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: StringLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY,nest(Expert)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Expert)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(tinyY)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY)]
< **   OGS:[0:tinyY,nest(tinyY)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(tinyY)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY,nest(tinyY)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:tinyY]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: StringLib.String
< **   father.f.f.f.f:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(tinyY),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:tinyY,nest(tinyY),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:tinyY,nest(tinyY),nest(StringLib)]
< **** savedOGS:save:False[0:tinyY,nest(tinyY),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(tinyY),nest(StringLib)]
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(tinyY),nest(StringLib)]
< **** OG:semCheck:"Surayya"
< **   encOG: Expert("Surayya",QS)
< **** Invocation:semCheck: "Surayya"
< **   encOG:Expert("Surayya",QS)
< **** OG:semcheck:IS not empty:eOG: 
< 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Surayya",QS)
< **   fArg: in quali: ref Qualifications
< **   aArg: QS
< **   theOI.f.f:label: ObjectGenerator
< Expert("Surayya",QS)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **   theOI: Expert("Surayya",QS)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in quali: ref Qualifications
< **** Items:localSearch: quali
< **   in:
< 
< in name: var StringLib.String
< in quali: ref Qualifications
< %globals
< print: 
<    "Expert:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: quali
< Try: "name"
< Try: "quali"
< **** Items:localSearch:end: quali
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Expert)]
< **   getOGsequenceOfArg:aArgs:("Surayya",QS)
< **   fArgs.origin.OG=theFargsOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS: [0:tinyY,nest(Expert)]
< **   theFargOG:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Expert)]
< **** DataItem:getVqual: in quali: ref Qualifications
< [0:tinyY,nest(Expert)]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY,nest(Expert)]
< 
< **** OI:getVqual: Qualifications on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Expert)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 1 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Expert)]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:QS
< **   encOG: Expert("Surayya",QS)
< **** Invocation:semCheck: QS
< **   encOG:Expert("Surayya",QS)
< **** OI:semCheck: "QS" rec: "none"
< **   encOG:Expert("Surayya",QS)
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** OI:getVqual: E2 on=0 pn=0 isNest=True getRtnQual=False
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual:initial:E2
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGs:[0:tinyY]
< **   ATd: E2: ref Expert
< **** DataItem:getVqual: E2: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:initial:afterATd:E2
< **   OGSx:[0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E2
< **   OI:getQual:savedOI:E2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS: none
< **** OI:getVqual:end: E2
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:ES2.insert(E2)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: ES2.insert(E2)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "ES2" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "insert(E2)" rec: "ES2"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(E2)
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(E2)
< **   fArg: in e: ref elm
< **   aArg: E2
< **   theOI.f.f:label: ObjectGenerator
< ES2.insert(E2)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Experts),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(E2)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Experts),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(E2)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:tinyY,nest(Experts),r:Set&,nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:tinyY,nest(Experts),r:Set&,nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:tinyY,nest(Experts),r:Set&,nest(insert)]
< **   ENC:result:[2:tinyY,nest(Experts),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Experts),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Experts),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Expert
< 
< ==== FOUND BINDING IN ARG: 
< #Expert
< **** newFindBinding:found: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY,nest(Experts&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts&),r:Set&,Collection]
< **** OG:semCheck:E2
< **   encOG: ES2.insert(E2)
< **** Invocation:semCheck: E2
< **   encOG:ES2.insert(E2)
< **** OI:semCheck: "E2" rec: "none"
< **   encOG:ES2.insert(E2)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:S.add(Period(8,16),ES2)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: S.add(Period(8,16),ES2)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "S" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "add(Period(8,16),ES2)" rec: "S"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   actualArgs: (Period(8,16),ES2)
< **   fArgs(in S: ref Domain,in D: ref Range,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(8,16),ES2)
< **   fArg: in S: ref Domain
< **   aArg: Period(8,16)
< **   theOI.f.f:label: ObjectGenerator
< S.add(Period(8,16),ES2)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map]
< **** PTN:getOGsequenceOfArg: 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(8,16),ES2)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in S: ref Domain
< **** Items:localSearch: S
< **   in:
< 
< in S: ref Domain
< in D: ref Range
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: S
< Try: "S"
< **** Items:localSearch:end: S
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   getOGsequenceOfArg:aArgs:(Period(8,16),ES2)
< **   fArgs.origin.OG=theFargsOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS: [0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   theFargOG:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **** DataItem:getVqual: in S: ref Domain
< [0:tinyY,nest(Schedule),r:Map,nest(add)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:tinyY,nest(Schedule),r:Map,nest(add)]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule),r:Map,nest(add)]
< **   ENC:result:[1:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:tinyY,nest(Schedule),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule),r:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule),r:Map]
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   superArg: ObjectGenerator #Period
< 
< ==== FOUND BINDING IN ARG: 
< #Period
< **** newFindBinding:found: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Domain
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:Period(8,16)
< **   encOG: S.add(Period(8,16),ES2)
< **** Invocation:semCheck: Period(8,16)
< **   encOG:S.add(Period(8,16),ES2)
< **** OI:semCheck: "Period(8,16)" rec: "none"
< **   encOG:S.add(Period(8,16),ES2)
< **** Pattern:checkActualArgs:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   actualArgs: (8,16)
< **   fArgs(in start: var integer,in end: var integer,)
< 
< **   encOG:S.add(Period(8,16),ES2)**   argAtInx: 1 in:PTN:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(8,16)
< **   fArg: in start: var integer
< **   aArg: 8
< **   theOI.f.f:label: ObjectGenerator
< Period(8,16)
< **   encOG:S.add(Period(8,16),ES2)
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(8,16)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in start: var integer
< **** Items:localSearch: start
< **   in:
< 
< in start: var integer
< in end: var integer
< %globals
< print: 
<    "Period:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: start
< Try: "start"
< **** Items:localSearch:end: start
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Period)]
< **   getOGsequenceOfArg:aArgs:(8,16)
< **   fArgs.origin.OG=theFargsOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OGS: [0:tinyY,nest(Period)]
< **   theFargOG:
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Period)]
< **** DataItem:getVqual: in start: var integer
< [0:tinyY,nest(Period)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:tinyY,nest(Period)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Period)]
< **   encOG: S.add(Period(8,16),ES2)
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: S.add(Period(8,16),ES2)
< **   OGS:[0:tinyY,nest(Period)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: S.add(Period(8,16),ES2)
< **   OGS:[0:tinyY,nest(Period)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Period)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(add)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(add)]
< **** savedOGS:save:False[0:tinyY,nest(add)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(add)]
< **   OGS:[0:tinyY,nest(add)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(add)]
< **** OG:semCheck:8
< **   encOG: Period(8,16)
< **** Invocation:semCheck: 8
< **   encOG:Period(8,16)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(8,16)
< **   fArg: in end: var integer
< **   aArg: 16
< **   theOI.f.f:label: ObjectGenerator
< Period(8,16)
< **   encOG:S.add(Period(8,16),ES2)
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(8,16)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in end: var integer
< **** Items:localSearch: end
< **   in:
< 
< in start: var integer
< in end: var integer
< %globals
< print: 
<    "Period:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: end
< Try: "start"
< Try: "end"
< **** Items:localSearch:end: end
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Period)]
< **   getOGsequenceOfArg:aArgs:(8,16)
< **   fArgs.origin.OG=theFargsOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OGS: [0:tinyY,nest(Period)]
< **   theFargOG:
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Period)]
< **** DataItem:getVqual: in end: var integer
< [0:tinyY,nest(Period)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:tinyY,nest(Period)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Period)]
< **   encOG: S.add(Period(8,16),ES2)
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: S.add(Period(8,16),ES2)
< **   OGS:[0:tinyY,nest(Period)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: S.add(Period(8,16),ES2)
< **   OGS:[0:tinyY,nest(Period)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Period)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(add)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(add)]
< **** savedOGS:save:False[0:tinyY,nest(add)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(add)]
< **   OGS:[0:tinyY,nest(add)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(add)]
< **** OG:semCheck:16
< **   encOG: Period(8,16)
< **** Invocation:semCheck: 16
< **   encOG:Period(8,16)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   argAtInx: 2 in:PTN:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(8,16),ES2)
< **   fArg: in D: ref Range
< **   aArg: ES2
< **   theOI.f.f:label: ObjectGenerator
< S.add(Period(8,16),ES2)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **** PTN:getOGsequenceOfArg: 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(8,16),ES2)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in D: ref Range
< **** Items:localSearch: D
< **   in:
< 
< in S: ref Domain
< in D: ref Range
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: D
< Try: "S"
< Try: "D"
< **** Items:localSearch:end: D
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   getOGsequenceOfArg:aArgs:(Period(8,16),ES2)
< **   fArgs.origin.OG=theFargsOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS: [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   theFargOG:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **** DataItem:getVqual: in D: ref Range
< [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   ENC:result:[1:tinyY,nest(Schedule&),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule&),r:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:tinyY,nest(Schedule&),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule&),r:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:tinyY,nest(Schedule&),r:Map]
< **** searchBinding: in Range:< Object
< [0:tinyY,nest(Schedule&)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   currentArg: in Range:< Object
< **   superArg: ObjectGenerator #Experts
< 
< ==== FOUND BINDING IN ARG: 
< #Experts
< **** newFindBinding:found: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** PTN:getVqual:gotBinding: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Range
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:ES2
< **   encOG: S.add(Period(8,16),ES2)
< **** Invocation:semCheck: ES2
< **   encOG:S.add(Period(8,16),ES2)
< **** OI:semCheck: "ES2" rec: "none"
< **   encOG:S.add(Period(8,16),ES2)
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** OG:semCheck:S.add(Period(16,24),ES1)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: S.add(Period(16,24),ES1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "S" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "add(Period(16,24),ES1)" rec: "S"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   actualArgs: (Period(16,24),ES1)
< **   fArgs(in S: ref Domain,in D: ref Range,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(16,24),ES1)
< **   fArg: in S: ref Domain
< **   aArg: Period(16,24)
< **   theOI.f.f:label: ObjectGenerator
< S.add(Period(16,24),ES1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map]
< **** PTN:getOGsequenceOfArg: 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(16,24),ES1)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in S: ref Domain
< **** Items:localSearch: S
< **   in:
< 
< in S: ref Domain
< in D: ref Range
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: S
< Try: "S"
< **** Items:localSearch:end: S
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   getOGsequenceOfArg:aArgs:(Period(16,24),ES1)
< **   fArgs.origin.OG=theFargsOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS: [0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   theFargOG:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **** DataItem:getVqual: in S: ref Domain
< [0:tinyY,nest(Schedule),r:Map,nest(add)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:tinyY,nest(Schedule),r:Map,nest(add)]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule),r:Map,nest(add)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule),r:Map,nest(add)]
< **   ENC:result:[1:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:tinyY,nest(Schedule),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule),r:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule),r:Map]
< **** searchBinding: in Domain:< Object
< [0:tinyY,nest(Schedule)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   superArg: ObjectGenerator #Period
< 
< ==== FOUND BINDING IN ARG: 
< #Period
< **** newFindBinding:found: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Domain
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:Period(16,24)
< **   encOG: S.add(Period(16,24),ES1)
< **** Invocation:semCheck: Period(16,24)
< **   encOG:S.add(Period(16,24),ES1)
< **** OI:semCheck: "Period(16,24)" rec: "none"
< **   encOG:S.add(Period(16,24),ES1)
< **** Pattern:checkActualArgs:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   actualArgs: (16,24)
< **   fArgs(in start: var integer,in end: var integer,)
< 
< **   encOG:S.add(Period(16,24),ES1)**   argAtInx: 1 in:PTN:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(16,24)
< **   fArg: in start: var integer
< **   aArg: 16
< **   theOI.f.f:label: ObjectGenerator
< Period(16,24)
< **   encOG:S.add(Period(16,24),ES1)
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(16,24)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in start: var integer
< **** Items:localSearch: start
< **   in:
< 
< in start: var integer
< in end: var integer
< %globals
< print: 
<    "Period:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: start
< Try: "start"
< **** Items:localSearch:end: start
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Period)]
< **   getOGsequenceOfArg:aArgs:(16,24)
< **   fArgs.origin.OG=theFargsOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OGS: [0:tinyY,nest(Period)]
< **   theFargOG:
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Period)]
< **** DataItem:getVqual: in start: var integer
< [0:tinyY,nest(Period)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:tinyY,nest(Period)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Period)]
< **   encOG: S.add(Period(16,24),ES1)
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: S.add(Period(16,24),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: S.add(Period(16,24),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Period)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(add)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(add)]
< **** savedOGS:save:False[0:tinyY,nest(add)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(add)]
< **   OGS:[0:tinyY,nest(add)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(add)]
< **** OG:semCheck:16
< **   encOG: Period(16,24)
< **** Invocation:semCheck: 16
< **   encOG:Period(16,24)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   argAtInx: 2 in:PTN:
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(16,24)
< **   fArg: in end: var integer
< **   aArg: 24
< **   theOI.f.f:label: ObjectGenerator
< Period(16,24)
< **   encOG:S.add(Period(16,24),ES1)
< **   savedOGS: [0:tinyY]
< **** PTN:getOGsequenceOfArg: 
< Period: 
<    in start: var integer
<    in end: var integer
<    %globals
<    print: 
< ...
< **   theOI: Period(16,24)
< **   theOI.on:0,pn:0 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in end: var integer
< **** Items:localSearch: end
< **   in:
< 
< in start: var integer
< in end: var integer
< %globals
< print: 
<    "Period:".print
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: end
< Try: "start"
< Try: "end"
< **** Items:localSearch:end: end
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY]
< **   OGS.DOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   After:[0:tinyY,nest(Period)]
< **   getOGsequenceOfArg:aArgs:(16,24)
< **   fArgs.origin.OG=theFargsOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OGS: [0:tinyY,nest(Period)]
< **   theFargOG:
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Period)]
< **** DataItem:getVqual: in end: var integer
< [0:tinyY,nest(Period)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:tinyY,nest(Period)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Period)]
< **   encOG: S.add(Period(16,24),ES1)
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: S.add(Period(16,24),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: S.add(Period(16,24),ES1)
< **   OGS:[0:tinyY,nest(Period)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Period)]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(add)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(add)]
< **** savedOGS:save:False[0:tinyY,nest(add)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(add)]
< **   OGS:[0:tinyY,nest(add)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(add)]
< **** OG:semCheck:24
< **   encOG: Period(16,24)
< **** Invocation:semCheck: 24
< **   encOG:Period(16,24)
< **** OG:semcheck:IS not empty:eOG: 
< 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   argAtInx: 2 in:PTN:
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(16,24),ES1)
< **   fArg: in D: ref Range
< **   aArg: ES1
< **   theOI.f.f:label: ObjectGenerator
< S.add(Period(16,24),ES1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **** PTN:getOGsequenceOfArg: 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **   theOI: add(Period(16,24),ES1)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in D: ref Range
< **** Items:localSearch: D
< **   in:
< 
< in S: ref Domain
< in D: ref Range
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: D
< Try: "S"
< Try: "D"
< **** Items:localSearch:end: D
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **   OGS.DOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   After:[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   getOGsequenceOfArg:aArgs:(Period(16,24),ES1)
< **   fArgs.origin.OG=theFargsOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS: [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   theFargOG:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **** DataItem:getVqual: in D: ref Range
< [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:tinyY,nest(Schedule&),r:Map,nest(add)]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule&),r:Map,nest(add)]
< **   ENC:result:[1:tinyY,nest(Schedule&),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule&),r:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:tinyY,nest(Schedule&),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule&),r:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:tinyY,nest(Schedule&),r:Map]
< **** searchBinding: in Range:< Object
< [0:tinyY,nest(Schedule&)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   currentArg: in Range:< Object
< **   superArg: ObjectGenerator #Experts
< 
< ==== FOUND BINDING IN ARG: 
< #Experts
< **** newFindBinding:found: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** PTN:getVqual:gotBinding: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Schedule&),r:Map]
< **** savedOGS:save:False[0:tinyY,nest(Schedule&),r:Map]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OI:getVqual:end: Range
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule&),r:Map]
< **** OG:semCheck:ES1
< **   encOG: S.add(Period(16,24),ES1)
< **** Invocation:semCheck: ES1
< **   encOG:S.add(Period(16,24),ES1)
< **** OI:semCheck: "ES1" rec: "none"
< **   encOG:S.add(Period(16,24),ES1)
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OG:semcheck:IS not empty:eOG: 
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** OG:semCheck:AS.insert(A)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: AS.insert(A)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "AS" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "insert(A)" rec: "AS"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< insert:: 
<    head := link(e,head)
< **   actualArgs: insert(A)
< **   fArgs(in e: ref elm,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< insert:: 
<    head := link(e,head)
< **   theOI: insert(A)
< **   fArg: in e: ref elm
< **   aArg: A
< **   theOI.f.f:label: ObjectGenerator
< AS.insert(A)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(Alarms),r:Set&]
< **** PTN:getOGsequenceOfArg: 
< insert:: 
<    head := link(e,head)
< **   theOI: insert(A)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: 
< **   fArgs[inx]: in e: ref elm
< **** Items:localSearch: e
< **   in:
< head := link(e,head)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Signature:localSearch: e in: insert
< **** Items:localSearch: e
< **   in:
< 
< **   isChecked: True
< **   Items:localSearch:Decls: e
< **** Items:localSearch:end: e
< **** Signature:localSearch:end: e
< **   Items:localSearch:trySuper:
< **** Items:localSearch: e
< **   in:
< 
< in e: ref elm
< inner(insert)
< **   isChecked: True
< **   Items:localSearch:Decls: e
< Try: "e"
< **** Items:localSearch:end: e
< **** Items:localSearch:end: e
< **   pathTo:parDecl:pn:1
< **   OGS:[0:tinyY,nest(Alarms),r:Set&]
< **   OGS.DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   After:[0:tinyY,nest(Alarms),r:Set&,nest(insert)]
< **   getOGsequenceOfArg:aArgs:insert(A)
< **   fArgs.origin.OG=theFargsOG: 
< in e: ref elm
<    inner(insert)
< **   OGS: [0:tinyY,nest(Alarms),r:Set&,nest(insert)]
< **   theFargOG:
< 
< in e: ref elm
<    inner(insert)
< **** PRE: [0:tinyY,nest(Alarms),r:Set&,nest(insert)]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:tinyY,nest(Alarms),r:Set&,nest(insert),insert]
< **   pn:aplOG:to:dclOG: 1
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(Alarms),r:Set&,nest(insert),insert]
< **** DataItem:getVqual: in e: ref elm
< [0:tinyY,nest(Alarms),r:Set&,nest(insert),insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:tinyY,nest(Alarms),r:Set&,nest(insert),insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Alarms),r:Set&,nest(insert),insert]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:tinyY,nest(Alarms),r:Set&,nest(insert),insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:tinyY,nest(Alarms),r:Set&,nest(insert)]
< **   ENC:result:[2:tinyY,nest(Alarms),r:Set&]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:tinyY,nest(Alarms),r:Set&]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:tinyY,nest(Alarms),r:Set&,Collection]
< **   ENC:result:[1:tinyY,nest(Alarms),r:Set&,Collection]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Alarms),r:Set&,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:tinyY,nest(Alarms),r:Set&,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Alarms),r:Set&,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Alarms),r:Set&,Collection]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Alarms),r:Set&]
< **** searchBinding: in elm:< Object
< [0:tinyY,nest(Alarms)]
< **   checkDOG: Alarms 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< father:
< Alarms: SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   Ex: Set(#Alarm)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Alarm
< 
< ==== FOUND BINDING IN ARG: 
< #Alarm
< **** newFindBinding:found: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **** PTN:getVqual:gotBinding: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< [0:tinyY,nest(Alarms&),r:Set&,Collection]
< **** savedOGS:save:False[0:tinyY,nest(Alarms&),r:Set&,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Alarms&),r:Set&,Collection]
< **   OGS:[0:tinyY,nest(Alarms&),r:Set&,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Alarms&),r:Set&,Collection]
< **** OG:semCheck:A
< **   encOG: AS.insert(A)
< **** Invocation:semCheck: A
< **   encOG:AS.insert(A)
< **** OI:semCheck: "A" rec: "none"
< **   encOG:AS.insert(A)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< head := link(e,head)
< **** OG:semCheck:"XXX\n".print
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: "XXX\n".print
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "print" rec: ""XXX\n""
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< print: 
<    gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
< ...
< **   actualArgs: 
< **   fArgs()
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OG:semCheck:P.expertIsOnDutyR(E1)
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** Invocation:semCheck: P.expertIsOnDutyR(E1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "P" rec: "none"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:semCheck: "expertIsOnDutyR(E1)" rec: "P"
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** Pattern:checkActualArgs:
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< **   actualArgs: expertIsOnDutyR(E1)
< **   fArgs(in ep: ref Expert,)
< 
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   argAtInx: 1 in:PTN:
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< **   theOI: expertIsOnDutyR(E1)
< **   fArg: in ep: ref Expert
< **   aArg: E1
< **   theOI.f.f:label: ObjectGenerator
< P.expertIsOnDutyR(E1)
< **   encOG:
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   savedOGS: [0:tinyY,nest(P),Plant]
< **** PTN:getOGsequenceOfArg: 
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< **   theOI: expertIsOnDutyR(E1)
< **   theOI.on:0,pn:1 viaIncl: False OGS.DOG.super: isEmpty
< **   fArgs[inx]: in ep: ref Expert
< **** Items:localSearch: ep
< **   in:
< 
< in ep: ref Expert
< out fp: ref Periods
< put('Q')
< fp := theSchedule.select(
<    in p: ref Period
< ...
< **   isChecked: True
< **   Items:localSearch:Decls: ep
< Try: "ep"
< **** Items:localSearch:end: ep
< **   pathTo:parDecl:pn:0
< **   OGS:[0:tinyY,nest(P),Plant]
< **   OGS.DOG:
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **   After:[0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **   getOGsequenceOfArg:aArgs:expertIsOnDutyR(E1)
< **   fArgs.origin.OG=theFargsOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   OGS: [0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **   theFargOG:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **   pn:aplOG:to:dclOG: 0
< **   OGS:after:OGS.PRE(pn):[0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **** DataItem:getVqual: in ep: ref Expert
< [0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< 
< **** OI:getVqual: Expert on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 2 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **   ENC:result:[1:tinyY,nest(P),Plant]
< **** ENC:OI.getVqual:[2:tinyY,nest(P),Plant]
< **** pathToSuper: "Plant(AS,S)" of:DOG:
< Plant(AS,S)
<    
< **   pathToSuper:DOG.super.scanSons:i=1:E:Plant(AS,S) :isImplSuper=False
< **   pathToSuper:E:"Plant(AS,S)" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Plant(AS,S)" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   ENC:pred:  pred.DOG: 
< Plant(AS,S)
<    
< **   OGsuper: 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** ENC:OI.getVqual:[3:tinyY,nest(P)]
< **   ENC:result:[3:tinyY]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OG:semCheck:E1
< **   encOG: P.expertIsOnDutyR(E1)
< **** Invocation:semCheck: E1
< **   encOG:P.expertIsOnDutyR(E1)
< **** OI:semCheck: "E1" rec: "none"
< **   encOG:P.expertIsOnDutyR(E1)
< **** OG:semcheck:IS not empty:eOG: 
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** OG:returnDecl: out fp: ref Periods
< **** OG:semcheck:IS not empty:eOG: 
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "workspace"
<    %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
<    %domain_boundary
<    --AbstractEx
< --AccessEx
< ...
< **** OG:semcheck:IS not empty:eOG: 
< 
< %id "BETAworld"
<    %modules BETA, LIB, LIB.StringLib, LIB.BasicIo
<    error: 
<       %basic 999
<    --BETA
< ...
< **** Pattern:check: thenPart
< **** Signature:check: thenPart
< **** Items:check:
< 
< **** basicScope:
< %id stub**** ObjectGenerator:check:%id stub
< ****  basicScope: none
< **** OG:check:super:
< **   basicScope: none
< **** Invocation:check: 
< **** INV:check:i=0 rec:none label: ???
< **   OGS: none
< **** check:super:end: %id stub
< **** superDesc:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   OG:  %id stub
< **** Items:check:
< %id stub
< **** basicScope: none
< **** NewProperty:Check: %id stub
< **** Pattern:check: repeat
< **** Signature:check: repeat
< **** Items:check:
< 
< **** basicScope:
< %id stub**** ObjectGenerator:check:%id stub
< ****  basicScope: none
< **** OG:check:super:
< **   basicScope: none
< **** Invocation:check: 
< **** INV:check:i=0 rec:none label: ???
< **   OGS: none
< **** check:super:end: %id stub
< **** superDesc:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   OG:  %id stub
< **** Items:check:
< %id stub
< **** basicScope: none
< **** NewProperty:Check: %id stub
< **** Pattern:check: elm
< **** Signature:check: elm
< **** Items:check:
< 
< **** basicScope:
< %id stub**** ObjectGenerator:check:%id stub
< ****  basicScope: none
< **** OG:check:super:
< **   basicScope: none
< **** Invocation:check: 
< **** INV:check:i=0 rec:none label: ???
< **   OGS: none
< **** check:super:end: %id stub
< **** superDesc:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   OG:  %id stub
< **** Items:check:
< %id stub
< **** basicScope: none
< **** NewProperty:Check: %id stub
< **** Pattern:check: Domain
< **** Signature:check: Domain
< **** Items:check:
< 
< **** basicScope:
< %id stub**** ObjectGenerator:check:%id stub
< ****  basicScope: none
< **** OG:check:super:
< **   basicScope: none
< **** Invocation:check: 
< **** INV:check:i=0 rec:none label: ???
< **   OGS: none
< **** check:super:end: %id stub
< **** superDesc:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   OG:  %id stub
< **** Items:check:
< %id stub
< **** basicScope: none
< **** NewProperty:Check: %id stub
< **** Pattern:check: Range
< **** Signature:check: Range
< **** Items:check:
< 
< **** basicScope:
< %id stub**** ObjectGenerator:check:%id stub
< ****  basicScope: none
< **** OG:check:super:
< **   basicScope: none
< **** Invocation:check: 
< **** INV:check:i=0 rec:none label: ???
< **   OGS: none
< **** check:super:end: %id stub
< **** superDesc:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   OG:  %id stub
< **** Items:check:
< %id stub
< **** basicScope: none
< **** NewProperty:Check: %id stub
< **** Pattern:check: elm
< **** Signature:check: elm
< **** Items:check:
< 
< **** basicScope:
< %id stub**** ObjectGenerator:check:%id stub
< ****  basicScope: none
< **** OG:check:super:
< **   basicScope: none
< **** Invocation:check: 
< **** INV:check:i=0 rec:none label: ???
< **   OGS: none
< **** check:super:end: %id stub
< **** superDesc:
< 
< %ID Object
< %basic 64
< %public
< ==  : 
<    %basic 56
< ...
< **   OG:  %id stub
< **** Items:check:
< %id stub
< **** basicScope: none
< **** NewProperty:Check: %id stub
< **** OI:getOIqual: "inner(Object)" IV:"inner(Object)"
< **   origin.encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** OI:getVqual: inner(Object) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Object]
< **   encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** koks: inner(Object) on: 1 Items 
< **   father: inner(Object)
< **   father.f.f.f.f:
< 
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **** ENC:OI.getVqual:[1:Object]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< inner: 
<    %basic 101
<    in inner: ref Object
< **** Pattern:getVqual: inner :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 101
<    in inner: ref Object
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inner(Object)
< **   OI:getQual:savedOI:inner(Object)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:Object]
< **** OI:getVqual:end: inner(Object)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "newline" IV:"newline"
< **   origin.encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< 
< **** OI:getVqual: newline on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:ascii]
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** koks: newline on: 0 Items 
< **   father: newline
< **   father.f.f.f.f:
< 
< ascii: obj 
<    asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
< ...
< 
< **** getVqual:B2:
< [0:ascii]
< ---
< newline: var char
< **** DataItem:getVqual: newline: var char
< [0:ascii]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:ascii]
< 
< **** OI:getVqual: char on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:ascii]
< **   encOG: 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** koks: char on: 1 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< asciiFoo: 
<       msg1:  -- obj
<          _put('F')
<          asciiBar.msg2
<    asciiBar:  -- obj
< ...
< **** ENC:OI.getVqual:[1:ascii]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: newline
< **   OI:getQual:savedOI:newline
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:ascii]
< **** OI:getVqual:end: newline
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Invocation:check: Veq
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
< **   OGS: none
< **** ObjectInvocation:checkOI: Veq  isFirst:True
< **** basicScope:A:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **** ObjectInvocation:check: Veq
< **** Items:search: "Veq" isFirst:True
< **   in: 
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< 
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 50
< in Veq: var this(Value)
< out Beq: var boolean
< inner(#= = )
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **** Items:search:end: Veq
< **** Found: "Veq" on=0 pn=0 Decl: "Veq" visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** encOG:True
< **   OGS: none
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OI:getVqual: Veq on=0 pn=0 isNest=False getRtnQual=False
< **   encOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OI:getVqual:initial:Veq
< **   encOG:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   OGs:[0:=]
< **   ATd: in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:initial:afterATd:Veq
< **   OGSx:[0:=]
< **** savedOGS:save:False[0:=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=]
< **   OGS:[0:=]
< **** OI:getVqual:end: Veq
< **   qual: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< ObjectGenerator
< **   OGS:[0:=]
< **** checkOI:checkOI:after:getVqual: Veq
< **** qual:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
<       %basic 50
<       in Veq: var this(Value)
<       out Beq: var boolean
<       inner(#= = )
<    <=  :< 
<       %basic 52
<       in Veq: var this(Value)
<       out Beq: var boolean
< **** OGS:
< [0:=]
< **** checkOI:after:getVqual:OF: Veq qual:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   basicScope: 
< %ID Value
< %globals
< %basic 21
< %public
< =  :< 
< ...
< **** OGS:
< [0:=]
< **** next:basicScope:from:Veq
< **   basicScope: 
< %ID Value
< %globals
< %basic 21
< %public
< =  :< 
< ...
< **** INV:getVqual:Veq
< **   OGs: [0:=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** OI:getOIqual: "inner(#= = )" IV:"inner(#= = )"
< **   origin.encOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** OI:getVqual: inner(#= = ) on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=]
< **   encOG: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** koks: inner(#= = ) on: 2 Items 
< **   father: inner(#= = )
< **   father.f.f.f.f:
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:=]
< **   ENC:result:[1:Value]
< **** ENC:OI.getVqual:[2:Value]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< inner: 
<    %basic 101
<    in inner: ref Object
< **** Pattern:getVqual: inner :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 101
<    in inner: ref Object
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inner(#= = )
< **   OI:getQual:savedOI:inner(#= = )
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:=]
< **** OI:getVqual:end: inner(#= = )
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:BETA]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: L on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: L on: 0 Items 
< **   father: L
< **   father.f.f.f.f:
< 
< loop: do 
<    c1: var char
<    c2: var char
<    L: var integer
<    L := length
< ...
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:was:[0:=,nest(loop)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OI:getOIqual: "length" IV:"length"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: length on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: length on: 2 Items 
< **   father: length
< **   father.f.f.f.f:
< 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:=]
< **** ENC:OI.getVqual:[2:=]
< **   ENC:result:[2:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: length
< **   OI:getQual:savedOI:length
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:loop]
< **** DataItem:getVqual: out V: var integer
< [0:String,nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(length)]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:String,nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:String,nest(length)]
< **** ENC:OI.viaInclude:[0:String,nest(length)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(loop)]
< **** savedOGS:save:False[0:String,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(loop)]
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:String,nest(loop)]
< **** OI:getVqual:end: length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OI:getOIqual: "L" IV:"L <> Veq.length"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: L on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: L on: 0 Items 
< **   father: L <> Veq.length
< **   father.f.f.f.f:
< 
< if (L <> Veq.length) :then 
<    leave(loop)
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:was:[0:=,nest(loop)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OI:getOIqual: "<> Veq.length" IV:"L <> Veq.length"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: L on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: L on: 0 Items 
< **   father: L <> Veq.length
< **   father.f.f.f.f:
< 
< if (L <> Veq.length) :then 
<    leave(loop)
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:was:[0:=,nest(loop)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< 
< **** OI:getVqual: <> Veq.length on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:=,nest(loop)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:=,nest(loop)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop),nest(integer)]
< **** koks: <> Veq.length on: 0 Items 
< **   father: L <> Veq.length
< **   father.f.f.f.f:
< 
< if (L <> Veq.length) :then 
<    leave(loop)
< 
< **** getVqual:B2:
< [0:=,nest(loop),nest(integer)]
< ---
< 
< <>  : 
<    %basic 55
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: <>   :isVirtual:False
< [0:=,nest(loop),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 55
<    in V: var integer
<    out B: var boolean
< [0:=,nest(loop),nest(integer)]
< **** savedOGS:save:was:[0:=,nest(loop),nest(integer)]
< **   OI: <> Veq.length
< **   OI:getQual:savedOI:<> Veq.length
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop),nest(integer)]
< **   OGS:[0:=,nest(loop)]
< **** DataItem:getVqual: out B: var boolean
< [0:=,nest(loop),nest(integer),nest(<>)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,nest(loop),nest(integer),nest(<>)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(loop),nest(integer),nest(<>)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:=,nest(loop),nest(integer),nest(<>)]
< **   ENC:result:[1:=,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:=,nest(loop),nest(integer)]
< **   ENC:result:[2:=,nest(loop)]
< 
< **** getVqual:B2:
< [0:=,nest(loop)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:=,nest(loop)]
< **** OI:getVqual:end: <> Veq.length
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OI:getOIqual: "<> Veq.length" IV:"L <> Veq.length"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: L on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: L on: 0 Items 
< **   father: L <> Veq.length
< **   father.f.f.f.f:
< 
< if (L <> Veq.length) :then 
<    leave(loop)
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:was:[0:=,nest(loop)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< 
< **** OI:getVqual: <> Veq.length on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:=,nest(loop)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:=,nest(loop)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:=,nest(loop),nest(integer)]
< **** koks: <> Veq.length on: 0 Items 
< **   father: L <> Veq.length
< **   father.f.f.f.f:
< 
< if (L <> Veq.length) :then 
<    leave(loop)
< 
< **** getVqual:B2:
< [0:=,nest(loop),nest(integer)]
< ---
< 
< <>  : 
<    %basic 55
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: <>   :isVirtual:False
< [0:=,nest(loop),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 55
<    in V: var integer
<    out B: var boolean
< [0:=,nest(loop),nest(integer)]
< **** savedOGS:save:was:[0:=,nest(loop),nest(integer)]
< **   OI: <> Veq.length
< **   OI:getQual:savedOI:<> Veq.length
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop),nest(integer)]
< **   OGS:[0:=,nest(loop)]
< **** DataItem:getVqual: out B: var boolean
< [0:=,nest(loop),nest(integer),nest(<>)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,nest(loop),nest(integer),nest(<>)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(loop),nest(integer),nest(<>)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 55
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:=,nest(loop),nest(integer),nest(<>)]
< **   ENC:result:[1:=,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:=,nest(loop),nest(integer)]
< **   ENC:result:[2:=,nest(loop)]
< 
< **** getVqual:B2:
< [0:=,nest(loop)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:=,nest(loop)]
< **** savedOGS:save:False[0:=,nest(loop)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(loop)]
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:=,nest(loop)]
< **** OI:getVqual:end: <> Veq.length
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(loop)]
< **** OI:getOIqual: "Veq" IV:"Veq.length"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: Veq on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: Veq on: 1 Items 
< **   father: Veq.length
< **   father.f.f.f.f:
< L <> Veq.length
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:=]
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** getVqual:B2:
< [0:=,=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:=,=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:=,=]
< **** getOGstart: 
< [0:=,=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:=,=]
< **** savedOGS:save:was:[0:=,=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=]
< **   OGS:[0:loop]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=]
< **** OI:getOIqual: "length" IV:"Veq.length"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: Veq on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: Veq on: 1 Items 
< **   father: Veq.length
< **   father.f.f.f.f:
< L <> Veq.length
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:=]
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** getVqual:B2:
< [0:=,=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:=,=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:=,=]
< **** getOGstart: 
< [0:=,=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:=,=]
< **** savedOGS:save:was:[0:=,=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=]
< **   OGS:[0:loop]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=]
< 
< **** OI:getVqual: length on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:=,=]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:=,=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** getVqual:added:isNest:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:=,=,nest(String)]
< **** koks: length on: 0 Items 
< **   father: Veq.length
< **   father.f.f.f.f:
< L <> Veq.length
< 
< **** getVqual:B2:
< [0:=,=,nest(String)]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:=,=,nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:=,=,nest(String)]
< **** savedOGS:save:was:[0:=,=,nest(String)]
< **   OI: length
< **   OI:getQual:savedOI:length
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=,nest(String)]
< **   OGS:[0:=,=]
< **** DataItem:getVqual: out V: var integer
< [0:=,=,nest(String),nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:=,=,nest(String),nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,=,nest(String),nest(length)]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:=,=,nest(String),nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:=,=,nest(String),nest(length)]
< **** ENC:OI.viaInclude:[0:=,=,nest(String),nest(length)]
< **   ENC:result:[0:=,=,nest(String)]
< **** viaInclude:GOT:
< [0:=,=,nest(String),nest(String)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:=,=,nest(String),nest(String)]
< **** savedOGS:save:False[0:=,=,nest(String),nest(String)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=,nest(String),nest(String)]
< **   OGS:[0:=,=,nest(String),nest(String)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=,nest(String),nest(String)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:=,=,nest(String),nest(String)]
< **** OI:getVqual:end: length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=,nest(String),nest(String)]
< **** OI:getOIqual: "beq" IV:"beq"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: beq on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: beq on: 1 Items 
< **   father: beq
< **   father.f.f.f.f:
< 
< loop: do 
<    c1: var char
<    c2: var char
<    L: var integer
<    L := length
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:=]
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** getVqual:B2:
< [0:=,=]
< ---
< out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:=,=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,=]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:=,=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   ENC:pred:  pred.DOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   OGsuper: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[2:=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: beq
< **   OI:getQual:savedOI:beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:loop]
< **** OI:getVqual:end: beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "V" IV:"V"
< **   origin.encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** OI:getVqual: V on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:length]
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** koks: V on: 0 Items 
< **   father: V
< **   father.f.f.f.f:
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** getVqual:B2:
< [0:length]
< ---
< out V: var integer
< **** DataItem:getVqual: out V: var integer
< [0:length]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:length]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:length]
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:length]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:length]
< **** ENC:OI.viaInclude:[0:length]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(length)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(length)]
< **** savedOGS:save:False[0:String,nest(length)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(length)]
< **   OGS:[0:String,nest(length)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(length)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(length)]
< **** savedOGS:save:was:[0:String,nest(length)]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(length)]
< **   OGS:[0:length]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(length)]
< **** OI:getOIqual: "get[0] -- actually an index error, accessing length" IV:"get[0] -- actually an index error, accessing length"
< **   origin.encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< 
< **** OI:getVqual: get[0] -- actually an index error, accessing length on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:length]
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** koks: get[0] -- actually an index error, accessing length on: 1 Items 
< **   father: get[0] -- actually an index error, accessing length
< **   father.f.f.f.f:
< 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** ENC:OI.getVqual:[1:length]
< **   ENC:result:[1:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: get[0] -- actually an index error, accessing length
< **   OI:getQual:savedOI:get[0] -- actually an index error, accessing length
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:length]
< **** DataItem:getVqual: out ch: var char
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(length)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:String,nest(length)]
< **** savedOGS:save:False[0:String,nest(length)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(length)]
< **   OGS:[0:String,nest(length)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(length)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:String,nest(length)]
< **** OI:getVqual:end: get[0] -- actually an index error, accessing length
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(length)]
< **** OI:getOIqual: "inner(X_asString)" IV:"inner(X_asString)"
< **   origin.encOG: 
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< 
< **** OI:getVqual: inner(X_asString) on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:X_asString]
< **   encOG: 
< -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** koks: inner(X_asString) on: 2 Items 
< **   father: inner(X_asString)
< **   father.f.f.f.f:
< 
< X_asString:<  -- does not wokr, problem with virtual in Object
<    out S: var LIB.StringLib.String
<    inner(X_asString)
< **** ENC:OI.getVqual:[1:X_asString]
< **   ENC:result:[1:Object]
< **** ENC:OI.getVqual:[2:Object]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< inner: 
<    %basic 101
<    in inner: ref Object
< **** Pattern:getVqual: inner :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 101
<    in inner: ref Object
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inner(X_asString)
< **   OI:getQual:savedOI:inner(X_asString)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:X_asString]
< **** OI:getVqual:end: inner(X_asString)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "Lock" IV:"Lock"
< **   origin.encOG: 
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< 
< **** OI:getVqual: Lock on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:screen]
< **   encOG: 
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< **** koks: Lock on: 1 Items 
< **   father: Lock
< **   father.f.f.f.f:
< 
< L: obj Lock
<    %Public
<    init: 
<       L.get
<       L.init
< ...
< **** ENC:OI.getVqual:[1:screen]
< **   ENC:result:[1:BasicIO]
< 
< **** getVqual:B2:
< [0:BasicIO]
< ---
< 
< Lock: 
<    dummy: var integer
<    %Public
<    M: var integer
<    init: 
< ...
< **** Pattern:getVqual: Lock :isVirtual:False
< [0:BasicIO]
< 
< **** getVqual:cont:afterATd:qual:
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< [0:BasicIO]
< **** savedOGS:save:False[0:BasicIO]
< **   OI: Lock
< **   OI:getQual:savedOI:Lock
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BasicIO]
< **   OGS:[0:BasicIO]
< **** OI:getVqual:end: Lock
< **   qual: 
< dummy: var integer
<    %Public
<    M: var integer
<    init: 
<       M := 0
< ...
< ObjectGenerator
< **   OGS:[0:BasicIO]
< **** OI:getOIqual: "leave(loop)" IV:"leave(loop)"
< **   origin.encOG: leave(loop)
< 
< **** OI:getVqual: leave(loop) on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$18]
< **   encOG: leave(loop)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: leave(loop)
< **   encOG: leave(loop)
< **   OGS:[0:$18]
< ***** viaInclude:notTop: leave name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: leave(loop)
< **   encOG: leave(loop)
< **   OGS:[0:$18]
< **** ENC:OI.viaInclude:[0:$18]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest($18)]
< **** Pattern:getVqual: leave(V: var integer) :isVirtual:False
< [0:loop,nest($18)]
< **** savedOGS:save:was:[0:loop,nest($18)]
< **   OI: leave(loop)
< **   OI:getQual:savedOI:leave(loop)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($18)]
< **   OGS:[0:loop,nest($18)]
< **** OI:getVqual:end: leave(loop)
< **   qual: %basic 103
< ObjectGenerator
< **   OGS:[0:loop,nest($18)]
< **** OI:getOIqual: "B" IV:"B"
< **   origin.encOG: 
< %globals
<    out B: var boolean
<    B := 1
< 
< **** OI:getVqual: B on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:True]
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 1
< **** koks: B on: 0 Items 
< **   father: B
< **   father.f.f.f.f:
< 
< True: 
<    %globals
<    out B: var boolean
<    B := 1
< 
< **** getVqual:B2:
< [0:True]
< ---
< out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:True]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:True]
< 
< **** OI:getVqual: boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:True]
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 1
< **** koks: boolean on: 1 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %globals
<    out B: var boolean
<    B := 1
< **** ENC:OI.getVqual:[1:True]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:True]
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:getVqual: inx on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** koks: inx on: 0 Items 
< **   father: inx
< **   father.f.f.f.f:
< 
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:for:to:repeat]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "first" IV:"first"
< **   origin.encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** OI:getVqual: first on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** koks: first on: 0 Items 
< **   father: first
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< first: var integer
< **** DataItem:getVqual: first: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: first
< **   OI:getQual:savedOI:first
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:for:to:repeat]
< **** OI:getVqual:end: first
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "inx" IV:"inx <= last"
< **   origin.encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:_doIt]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx <= last
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** ENC:OI.getVqual:[1:_doIt]
< **   ENC:result:[1:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:_doIt]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "<= last" IV:"inx <= last"
< **   origin.encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:_doIt]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx <= last
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** ENC:OI.getVqual:[1:_doIt]
< **   ENC:result:[1:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:_doIt]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: <= last on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: <= last on: 0 Items 
< **   father: inx <= last
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** PRE: [0:BETA,nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:BETA,nest(integer),Value]
< 
< **** getVqual:B2:
< [0:BETA,nest(integer),Value]
< ---
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Pattern:getVqual: <=   :isVirtual:True
< [0:BETA,nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(integer),Value]
< **** newFindBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:BETA,nest(integer),Value]
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:BETA,nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** newFindBinding:found: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** PTN:getVqual:gotBinding: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** getVqual:cont:afterATd:qual:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:BETA,nest(integer),Value&]
< **** savedOGS:save:was:[0:BETA,nest(integer),Value&]
< **   OI: <= last
< **   OI:getQual:savedOI:<= last
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out Beq: var boolean
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:BETA,nest(integer),Value&,nest(<=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),Value&,nest(<=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),Value&,nest(<=)]
< **   ENC:result:[1:BETA,nest(integer),Value&]
< **** ENC:OI.getVqual:[2:BETA,nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:BETA,nest(integer)]
< **   ENC:result:[3:BETA]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:BETA]
< **** OI:getVqual:end: <= last
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "<= last" IV:"inx <= last"
< **   origin.encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:_doIt]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx <= last
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** ENC:OI.getVqual:[1:_doIt]
< **   ENC:result:[1:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:_doIt]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: <= last on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: <= last on: 0 Items 
< **   father: inx <= last
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** PRE: [0:BETA,nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:BETA,nest(integer),Value]
< 
< **** getVqual:B2:
< [0:BETA,nest(integer),Value]
< ---
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Pattern:getVqual: <=   :isVirtual:True
< [0:BETA,nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:BETA,nest(integer),Value]
< **** newFindBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:BETA,nest(integer),Value]
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:BETA,nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** newFindBinding:found: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** PTN:getVqual:gotBinding: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** getVqual:cont:afterATd:qual:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:BETA,nest(integer),Value&]
< **** savedOGS:save:was:[0:BETA,nest(integer),Value&]
< **   OI: <= last
< **   OI:getQual:savedOI:<= last
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer),Value&]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out Beq: var boolean
< [0:BETA,nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:BETA,nest(integer),Value&,nest(<=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),Value&,nest(<=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),Value&,nest(<=)]
< **   ENC:result:[1:BETA,nest(integer),Value&]
< **** ENC:OI.getVqual:[2:BETA,nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:BETA,nest(integer)]
< **   ENC:result:[3:BETA]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:BETA]
< **** OI:getVqual:end: <= last
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "last" IV:"last"
< **   origin.encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< 
< **** OI:getVqual: last on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:_doIt]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: last on: 1 Items 
< **   father: last
< **   father.f.f.f.f:
< inx <= last
< **** ENC:OI.getVqual:[1:_doIt]
< **   ENC:result:[1:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< last: var integer
< **** DataItem:getVqual: last: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< if (inx <= last) :then 
<       repeat
<       inx := inx + 1
<       restart(_doIt)
<    :else 
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: last
< **   OI:getQual:savedOI:last
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:_doIt]
< **** OI:getVqual:end: last
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "repeat" IV:"repeat"
< **   origin.encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:getVqual: repeat on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$46]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: repeat on: 2 Items 
< **   father: repeat
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** ENC:OI.getVqual:[1:$46]
< **   ENC:result:[1:_doIt]
< **** ENC:OI.getVqual:[2:_doIt]
< **   ENC:result:[2:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< repeat:< object
< **** Pattern:getVqual: repeat :isVirtual:True
< [0:for:to:repeat]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:for:to:repeat]
< **** newFindBinding: repeat:< object
< **** searchBinding: repeat:< object
< [0:for:to:repeat]
< **   checkDOG: for:to:repeat 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< father:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< 
<  ==== FOUND BINDING: =====
< repeat:< object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:for:to:repeat&]
< **** savedOGS:save:was:[0:for:to:repeat&]
< **   OI: repeat
< **   OI:getQual:savedOI:repeat
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:for:to:repeat&]
< **   OGS:[0:$46]
< **** OI:getVqual:end: repeat
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:for:to:repeat&]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$46]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: inx on: 2 Items 
< **   father: inx
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** ENC:OI.getVqual:[1:$46]
< **   ENC:result:[1:_doIt]
< **** ENC:OI.getVqual:[2:_doIt]
< **   ENC:result:[2:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$46]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "inx" IV:"inx + 1"
< **   origin.encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$46]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: inx on: 2 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** ENC:OI.getVqual:[1:$46]
< **   ENC:result:[1:_doIt]
< **** ENC:OI.getVqual:[2:_doIt]
< **   ENC:result:[2:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$46]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "+ 1" IV:"inx + 1"
< **   origin.encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$46]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: inx on: 2 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** ENC:OI.getVqual:[1:$46]
< **   ENC:result:[1:_doIt]
< **** ENC:OI.getVqual:[2:_doIt]
< **   ENC:result:[2:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$46]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: + 1 on: 0 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: + 1
< **   OI:getQual:savedOI:+ 1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out R: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: + 1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "restart(_doIt)" IV:"restart(_doIt)"
< **   origin.encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< 
< **** OI:getVqual: restart(_doIt) on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$46]
< **   encOG: 
< repeat
<    inx := inx + 1
<    restart(_doIt)
< **** koks: restart(_doIt) on: 3 Items 
< **   father: restart(_doIt)
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** ENC:OI.getVqual:[1:$46]
< **   ENC:result:[1:_doIt]
< **** ENC:OI.getVqual:[2:_doIt]
< **   ENC:result:[2:for:to:repeat]
< **** ENC:OI.getVqual:[3:for:to:repeat]
< **   ENC:result:[3:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< restart(V: var integer):  -- odd parameter type!
<    %basic 102
< **** Pattern:getVqual: restart(V: var integer) :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< -- odd parameter type!
<    %basic 102
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: restart(_doIt)
< **   OI:getQual:savedOI:restart(_doIt)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$46]
< **** OI:getVqual:end: restart(_doIt)
< **   qual: 
< -- odd parameter type!
<    %basic 102
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: inx := inx
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$49]
< **   encOG: inx := inx
< **** koks: inx on: 2 Items 
< **   father: inx
< **   father.f.f.f.f:
< 
< if (inx <= last) :then 
<    repeat
<    inx := inx + 1
<    restart(_doIt)
< :else 
< ...
< **** ENC:OI.getVqual:[1:$49]
< **   ENC:result:[1:_doIt]
< **** ENC:OI.getVqual:[2:_doIt]
< **   ENC:result:[2:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: inx := inx
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$49]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: inx := inx
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$49]
< **   encOG: inx := inx
< **** koks: inx on: 2 Items 
< **   father: inx
< **   father.f.f.f.f:
< inx := inx
< **** ENC:OI.getVqual:[1:$49]
< **   ENC:result:[1:_doIt]
< **** ENC:OI.getVqual:[2:_doIt]
< **   ENC:result:[2:for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat]
< **   encOG: inx := inx
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$49]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "c1" IV:"c1"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: c1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: c1 on: 2 Items 
< **   father: c1
< **   father.f.f.f.f:
< 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$24)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:was:[0:=,nest(repeat$24)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getOIqual: "get[inx]" IV:"get[inx]"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: get[inx] on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: get[inx] on: 4 Items 
< **   father: get[inx]
< **   father.f.f.f.f:
< 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< **** ENC:OI.getVqual:[3:loop]
< **   ENC:result:[3:=]
< **** ENC:OI.getVqual:[4:=]
< **   ENC:result:[4:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: get[inx]
< **   OI:getQual:savedOI:get[inx]
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:repeat$24]
< **** DataItem:getVqual: out ch: var char
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$24)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:String,nest(repeat$24)]
< **** savedOGS:save:False[0:String,nest(repeat$24)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$24)]
< **   OGS:[0:String,nest(repeat$24)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$24)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:String,nest(repeat$24)]
< **** OI:getVqual:end: get[inx]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$24)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< get[inx]
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** PRE: [0:for:to:repeat$30]
< **** pathToSuper: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " of:DOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   innerDOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< *** got:innerDOG:1 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   pathToSuper:E:"
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:4,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$30,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$30,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$30,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$30,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$30,for:to:repeat]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$30,for:to:repeat]
< **** pathToSuper: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " of:DOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   innerDOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< *** got:innerDOG:1 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   pathToSuper:E:"
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< **   ENC:[pnx=0]oENC[onx=4]
< **** ENC:OI.getVqual:[2:loop]
< **   ENC:result:[2:=]
< **** ENC:OI.getVqual:[3:=]
< **   ENC:result:[3:String]
< **** ENC:OI.getVqual:[4:String]
< **   ENC:result:[4:StringLib]
< **** ENC:OI.getVqual:[5:StringLib]
< **   ENC:result:[5:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "c2" IV:"c2"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: c2 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: c2 on: 2 Items 
< **   father: c2
< **   father.f.f.f.f:
< 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< c2: var char
< **** DataItem:getVqual: c2: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$24)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:was:[0:=,nest(repeat$24)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getOIqual: "Veq" IV:"Veq.get[inx]"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: Veq on=3 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: Veq on: 3 Items 
< **   father: Veq.get[inx]
< **   father.f.f.f.f:
< 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< **** ENC:OI.getVqual:[3:loop]
< **   ENC:result:[3:=]
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** getVqual:B2:
< [0:=,=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:=,=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:=,=]
< **** getOGstart: 
< [0:=,=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:=,=]
< **** savedOGS:save:was:[0:=,=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=]
< **** OI:getOIqual: "get[inx]" IV:"Veq.get[inx]"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: Veq on=3 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: Veq on: 3 Items 
< **   father: Veq.get[inx]
< **   father.f.f.f.f:
< 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< **** ENC:OI.getVqual:[3:loop]
< **   ENC:result:[3:=]
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** getVqual:B2:
< [0:=,=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:=,=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:=,=]
< **** getOGstart: 
< [0:=,=]
< **** getOGstart: 
< [0:=]
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **** getOGstart:isNest: False qual: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:=,=]
< **** savedOGS:save:was:[0:=,=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=]
< 
< **** OI:getVqual: get[inx] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:=,=]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:=,=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** getVqual:added:isNest:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:=,=,nest(String)]
< **** koks: get[inx] on: 0 Items 
< **   father: Veq.get[inx]
< **   father.f.f.f.f:
< 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** getVqual:B2:
< [0:=,=,nest(String)]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:=,=,nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:=,=,nest(String)]
< **** savedOGS:save:was:[0:=,=,nest(String)]
< **   OI: get[inx]
< **   OI:getQual:savedOI:get[inx]
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=,nest(String)]
< **   OGS:[0:=,=]
< **** DataItem:getVqual: out ch: var char
< [0:=,=,nest(String),nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:=,=,nest(String),nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,=,nest(String),nest(get)]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:=,=,nest(String),nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:=,=,nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:=,=,nest(String),nest(get)]
< **   ENC:result:[0:=,=,nest(String)]
< **** viaInclude:GOT:
< [0:=,=,nest(String),nest(String)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,=,nest(String),nest(String)]
< **** savedOGS:save:False[0:=,=,nest(String),nest(String)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,=,nest(String),nest(String)]
< **   OGS:[0:=,=,nest(String),nest(String)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=,nest(String),nest(String)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:=,=,nest(String),nest(String)]
< **** OI:getVqual:end: get[inx]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,=,nest(String),nest(String)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< Veq.get[inx]
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** PRE: [0:for:to:repeat$30]
< **** pathToSuper: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " of:DOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   innerDOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< *** got:innerDOG:1 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   pathToSuper:E:"
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:4,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$30,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$30,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$30,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$30,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$30,for:to:repeat]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$30,for:to:repeat]
< **** pathToSuper: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " of:DOG:
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   innerDOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< *** got:innerDOG:1 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   pathToSuper:E:"
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< **   ENC:[pnx=0]oENC[onx=4]
< **** ENC:OI.getVqual:[2:loop]
< **   ENC:result:[2:=]
< **** ENC:OI.getVqual:[3:=]
< **   ENC:result:[3:String]
< **** ENC:OI.getVqual:[4:String]
< **   ENC:result:[4:StringLib]
< **** ENC:OI.getVqual:[5:StringLib]
< **   ENC:result:[5:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "c1" IV:"c1 <> c2"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: c1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: c1 on: 2 Items 
< **   father: c1 <> c2
< **   father.f.f.f.f:
< 
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$24)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:was:[0:=,nest(repeat$24)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getOIqual: "<> c2" IV:"c1 <> c2"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: c1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: c1 on: 2 Items 
< **   father: c1 <> c2
< **   father.f.f.f.f:
< 
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$24)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:was:[0:=,nest(repeat$24)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** OI:getVqual: <> c2 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:=,nest(repeat$24)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:=,nest(repeat$24)]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:=]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24),nest(char)]
< **** koks: <> c2 on: 0 Items 
< **   father: c1 <> c2
< **   father.f.f.f.f:
< 
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< 
< **** getVqual:B2:
< [0:=,nest(repeat$24),nest(char)]
< ---
< 
< <>  : 
<    %basic 55
<    in V: var char
<    out B: var boolean
< **** Pattern:getVqual: <>   :isVirtual:False
< [0:=,nest(repeat$24),nest(char)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 55
<    in V: var char
<    out B: var boolean
< [0:=,nest(repeat$24),nest(char)]
< **** savedOGS:save:was:[0:=,nest(repeat$24),nest(char)]
< **   OI: <> c2
< **   OI:getQual:savedOI:<> c2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24),nest(char)]
< **   OGS:[0:=,nest(repeat$24)]
< **** DataItem:getVqual: out B: var boolean
< [0:=,nest(repeat$24),nest(char),nest(<>)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,nest(repeat$24),nest(char),nest(<>)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(repeat$24),nest(char),nest(<>)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 55
<    in V: var char
<    out B: var boolean
< **** ENC:OI.getVqual:[1:=,nest(repeat$24),nest(char),nest(<>)]
< **   ENC:result:[1:=,nest(repeat$24),nest(char)]
< **** ENC:OI.getVqual:[2:=,nest(repeat$24),nest(char)]
< **   ENC:result:[2:=,nest(repeat$24)]
< 
< **** getVqual:B2:
< [0:=,nest(repeat$24)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:=,nest(repeat$24)]
< **** OI:getVqual:end: <> c2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getOIqual: "<> c2" IV:"c1 <> c2"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: c1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: c1 on: 2 Items 
< **   father: c1 <> c2
< **   father.f.f.f.f:
< 
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$24)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:was:[0:=,nest(repeat$24)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** OI:getVqual: <> c2 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:=,nest(repeat$24)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:=,nest(repeat$24)]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:=]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24),nest(char)]
< **** koks: <> c2 on: 0 Items 
< **   father: c1 <> c2
< **   father.f.f.f.f:
< 
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< 
< **** getVqual:B2:
< [0:=,nest(repeat$24),nest(char)]
< ---
< 
< <>  : 
<    %basic 55
<    in V: var char
<    out B: var boolean
< **** Pattern:getVqual: <>   :isVirtual:False
< [0:=,nest(repeat$24),nest(char)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 55
<    in V: var char
<    out B: var boolean
< [0:=,nest(repeat$24),nest(char)]
< **** savedOGS:save:was:[0:=,nest(repeat$24),nest(char)]
< **   OI: <> c2
< **   OI:getQual:savedOI:<> c2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24),nest(char)]
< **   OGS:[0:=,nest(repeat$24)]
< **** DataItem:getVqual: out B: var boolean
< [0:=,nest(repeat$24),nest(char),nest(<>)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,nest(repeat$24),nest(char),nest(<>)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,nest(repeat$24),nest(char),nest(<>)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 55
<    in V: var char
<    out B: var boolean
< **** ENC:OI.getVqual:[1:=,nest(repeat$24),nest(char),nest(<>)]
< **   ENC:result:[1:=,nest(repeat$24),nest(char)]
< **** ENC:OI.getVqual:[2:=,nest(repeat$24),nest(char)]
< **   ENC:result:[2:=,nest(repeat$24)]
< 
< **** getVqual:B2:
< [0:=,nest(repeat$24)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:=,nest(repeat$24)]
< **** OI:getVqual:end: <> c2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getOIqual: "c2" IV:"c2"
< **   origin.encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< 
< **** OI:getVqual: c2 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$24]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** koks: c2 on: 2 Items 
< **   father: c2
< **   father.f.f.f.f:
< c1 <> c2
< **** ENC:OI.getVqual:[1:repeat$24]
< **   ENC:result:[1:for:to:repeat$30]
< **** ENC:OI.getVqual:[2:for:to:repeat$30]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< c2: var char
< **** DataItem:getVqual: c2: var char
< [0:loop]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:loop]
< 
< **** OI:getVqual: char on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
<       leave(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:=]
< **** viaInclude:GOT:
< [0:=,nest(repeat$24)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:=,nest(repeat$24)]
< **** savedOGS:save:False[0:=,nest(repeat$24)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:=,nest(repeat$24)]
< **** savedOGS:save:was:[0:=,nest(repeat$24)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:=,nest(repeat$24)]
< **   OGS:[0:repeat$24]
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:=,nest(repeat$24)]
< **** OI:getOIqual: "Beq" IV:"Beq"
< **   origin.encOG: 
< Beq := false
<    leave(loop)
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$26]
< **   encOG: 
< Beq := false
<    leave(loop)
< **** koks: Beq on: 4 Items 
< **   father: Beq
< **   father.f.f.f.f:
< 
< if (c1 <> c2) :then 
<    Beq := false
<    leave(loop)
< **** ENC:OI.getVqual:[1:$26]
< **   ENC:result:[1:repeat$24]
< **** ENC:OI.getVqual:[2:repeat$24]
< **   ENC:result:[2:for:to:repeat$30]
< **** ENC:OI.getVqual:[3:for:to:repeat$30]
< **   ENC:result:[3:loop]
< **** ENC:OI.getVqual:[4:loop]
< **   ENC:result:[4:=]
< **** PRE: [0:=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   PRE:result:[0:=,=]
< 
< **** getVqual:B2:
< [0:=,=]
< ---
< out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:=,=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:=,=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:=,=]
< **   encOG: 
< Beq := false
<    leave(loop)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:=,=]
< **** pathToSuper: "" of:DOG:
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   innerDOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **   ENC:pred:  pred.DOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   OGsuper: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[2:=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: do 
<       c1: var char
<       c2: var char
<       L: var integer
<       L := length
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:$26]
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "leave(loop)" IV:"leave(loop)"
< **   origin.encOG: 
< Beq := false
<    leave(loop)
< 
< **** OI:getVqual: leave(loop) on=7 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$26]
< **   encOG: 
< Beq := false
<    leave(loop)
< **** OI:viaInclude:on=7 BETA %Include BETA
< **   OI: leave(loop)
< **   encOG: 
< Beq := false
<    leave(loop)
< **   OGS:[0:$26]
< ***** viaInclude:notTop: leave name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: leave(loop)
< **   encOG: 
< Beq := false
<    leave(loop)
< **   OGS:[0:$26]
< **** ENC:OI.viaInclude:[0:$26]
< **   ENC:result:[0:repeat$24]
< **** viaInclude:GOT:
< [0:repeat$24,nest($26)]
< **** Pattern:getVqual: leave(V: var integer) :isVirtual:False
< [0:repeat$24,nest($26)]
< **** savedOGS:save:was:[0:repeat$24,nest($26)]
< **   OI: leave(loop)
< **   OI:getQual:savedOI:leave(loop)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:repeat$24,nest($26)]
< **   OGS:[0:repeat$24,nest($26)]
< **** OI:getVqual:end: leave(loop)
< **   qual: %basic 103
< ObjectGenerator
< **   OGS:[0:repeat$24,nest($26)]
< **** OI:getOIqual: "B" IV:"B"
< **   origin.encOG: 
< %globals
<    out B: var boolean
<    B := 0
< 
< **** OI:getVqual: B on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:False]
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 0
< **** koks: B on: 0 Items 
< **   father: B
< **   father.f.f.f.f:
< 
< False: 
<    %globals
<    out B: var boolean
<    B := 0
< 
< **** getVqual:B2:
< [0:False]
< ---
< out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:False]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:False]
< 
< **** OI:getVqual: boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:False]
< **   encOG: 
< %globals
<    out B: var boolean
<    B := 0
< **** koks: boolean on: 1 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %globals
<    out B: var boolean
<    B := 0
< **** ENC:OI.getVqual:[1:False]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:False]
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "length" IV:"length"
< **   origin.encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< 
< **** OI:getVqual: length on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** koks: length on: 2 Items 
< **   father: length
< **   father.f.f.f.f:
< 
< for(1):to(length):repeat
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 <> c2) :then 
<       Beq := false
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:=]
< **** ENC:OI.getVqual:[2:=]
< **   ENC:result:[2:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: length
< **   OI:getQual:savedOI:length
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:loop]
< **** DataItem:getVqual: out V: var integer
< [0:String,nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(length)]
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:String,nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< c1: var char
<    c2: var char
<    L: var integer
<    L := length
<    if (L <> Veq.length) :then 
< ...
< **   OGS:[0:String,nest(length)]
< **** ENC:OI.viaInclude:[0:String,nest(length)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(loop)]
< **** savedOGS:save:False[0:String,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(loop)]
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:String,nest(loop)]
< **** OI:getVqual:end: length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Invocation:check: Veq
< **** INV:check:i=0 rec:none label: ObjectInvocation_Unary
< **   OGS: none
< **** ObjectInvocation:checkOI: Veq  isFirst:True
< **** basicScope:A:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **** ObjectInvocation:check: Veq
< **** Items:search: "Veq" isFirst:True
< **   in: 
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< 
< **** Items:localSearch: Veq
< **   in:
< 
< %basic 52
< in Veq: var this(Value)
< out Beq: var boolean
< **   isChecked: True
< **   Items:localSearch:Decls: Veq
< Try: "Veq"
< **** Items:localSearch:end: Veq
< **** Items:search:end: Veq
< **** Found: "Veq" on=0 pn=0 Decl: "Veq" visibility: "public"
< **   encModule: "BETAworld" domainModule: "BETAworld"
< **** encOG:True
< **   OGS: none
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** OI:getVqual: Veq on=0 pn=0 isNest=False getRtnQual=False
< **   encOG: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** OI:getVqual:initial:Veq
< **   encOG:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   OGs:[0:<=]
< **   ATd: in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** getVqual:initial:afterATd:Veq
< **   OGSx:[0:<=]
< **** savedOGS:save:False[0:<=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: ObjectGenerator [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=]
< **   OGS:[0:<=]
< **** OI:getVqual:end: Veq
< **   qual: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< ObjectGenerator
< **   OGS:[0:<=]
< **** checkOI:checkOI:after:getVqual: Veq
< **** qual:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
<       %basic 50
<       in Veq: var this(Value)
<       out Beq: var boolean
<       inner(#= = )
<    <=  :< 
<       %basic 52
<       in Veq: var this(Value)
<       out Beq: var boolean
< **** OGS:
< [0:<=]
< **** checkOI:after:getVqual:OF: Veq qual:
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   basicScope: 
< %ID Value
< %globals
< %basic 21
< %public
< =  :< 
< ...
< **** OGS:
< [0:<=]
< **** next:basicScope:from:Veq
< **   basicScope: 
< %ID Value
< %globals
< %basic 21
< %public
< =  :< 
< ...
< **** INV:getVqual:Veq
< **   OGs: [0:<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       -- "Hello"  <= "World" since H <= W
<       -- "Qweabc" <= "Qwevwxy" since a <= e
<       -- "Qweayc" <= "Qwexby"
<       -- "Qwe"    <= "Qwerty"
< ...
< **** OI:getOIqual: "L1" IV:"L1"
< **   origin.encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< 
< **** OI:getVqual: L1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** koks: L1 on: 0 Items 
< **   father: L1
< **   father.f.f.f.f:
< 
< loop: obj 
<    -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
< ...
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< -- "Hello"  <= "World" since H <= W
<    -- "Qweabc" <= "Qwevwxy" since a <= e
<    -- "Qweayc" <= "Qwexby"
<    -- "Qwe"    <= "Qwerty"
<    -- "Qwerty" <= "Qwe" - false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getOIqual: "length
< -- min length of this and V" IV:"length
< -- min length of this and V"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: length
< -- min length of this and V on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: length
< -- min length of this and V on: 2 Items 
< **   father: length
< -- min length of this and V
< **   father.f.f.f.f:
< 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:<=]
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: length
< -- min length of this and V
< **   OI:getQual:savedOI:
< length
< -- min length of this and V
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:loop]
< **** DataItem:getVqual: out V: var integer
< [0:String,nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(length)]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:String,nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:String,nest(length)]
< **** ENC:OI.viaInclude:[0:String,nest(length)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(loop)]
< **** savedOGS:save:False[0:String,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(loop)]
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:String,nest(loop)]
< **** OI:getVqual:end: 
< length
< -- min length of this and V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OI:getOIqual: "L2" IV:"L2"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: L2 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: L2 on: 0 Items 
< **   father: L2
< **   father.f.f.f.f:
< 
< loop: obj 
<    matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
< ...
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getOIqual: "Veq" IV:"Veq.length"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: Veq on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: Veq on: 1 Items 
< **   father: Veq.length
< **   father.f.f.f.f:
< 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,<=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,<=]
< **** getOGstart: 
< [0:<=,<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:<=,<=]
< **** savedOGS:save:was:[0:<=,<=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=]
< **   OGS:[0:loop]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=]
< **** OI:getOIqual: "length" IV:"Veq.length"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: Veq on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: Veq on: 1 Items 
< **   father: Veq.length
< **   father.f.f.f.f:
< 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,<=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,<=]
< **** getOGstart: 
< [0:<=,<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:<=,<=]
< **** savedOGS:save:was:[0:<=,<=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=]
< **   OGS:[0:loop]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=]
< 
< **** OI:getVqual: length on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,<=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** getVqual:added:isNest:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:<=,<=,nest(String)]
< **** koks: length on: 0 Items 
< **   father: Veq.length
< **   father.f.f.f.f:
< 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** getVqual:B2:
< [0:<=,<=,nest(String)]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:<=,<=,nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:<=,<=,nest(String)]
< **** savedOGS:save:was:[0:<=,<=,nest(String)]
< **   OI: length
< **   OI:getQual:savedOI:length
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=,nest(String)]
< **   OGS:[0:<=,<=]
< **** DataItem:getVqual: out V: var integer
< [0:<=,<=,nest(String),nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:<=,<=,nest(String),nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=,nest(String),nest(length)]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:<=,<=,nest(String),nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:<=,<=,nest(String),nest(length)]
< **** ENC:OI.viaInclude:[0:<=,<=,nest(String),nest(length)]
< **   ENC:result:[0:<=,<=,nest(String)]
< **** viaInclude:GOT:
< [0:<=,<=,nest(String),nest(String)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,<=,nest(String),nest(String)]
< **** savedOGS:save:False[0:<=,<=,nest(String),nest(String)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=,nest(String),nest(String)]
< **   OGS:[0:<=,<=,nest(String),nest(String)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=,nest(String),nest(String)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:<=,<=,nest(String),nest(String)]
< **** OI:getVqual:end: length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=,nest(String),nest(String)]
< **** OI:getOIqual: "L1" IV:"L1 < L2"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: L1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: L1 on: 0 Items 
< **   father: L1 < L2
< **   father.f.f.f.f:
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getOIqual: "< L2" IV:"L1 < L2"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: L1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: L1 on: 0 Items 
< **   father: L1 < L2
< **   father.f.f.f.f:
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** OI:getVqual: < L2 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest(loop)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest(loop)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop),nest(integer)]
< **** koks: < L2 on: 0 Items 
< **   father: L1 < L2
< **   father.f.f.f.f:
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< 
< **** getVqual:B2:
< [0:<=,nest(loop),nest(integer)]
< ---
< 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: <   :isVirtual:False
< [0:<=,nest(loop),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 51
<    in V: var integer
<    out B: var boolean
< [0:<=,nest(loop),nest(integer)]
< **** savedOGS:save:was:[0:<=,nest(loop),nest(integer)]
< **   OI: < L2
< **   OI:getQual:savedOI:< L2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop),nest(integer)]
< **   OGS:[0:<=,nest(loop)]
< **** DataItem:getVqual: out B: var boolean
< [0:<=,nest(loop),nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest(loop),nest(integer),nest(<)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest(loop),nest(integer),nest(<)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:<=,nest(loop),nest(integer),nest(<)]
< **   ENC:result:[1:<=,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:<=,nest(loop),nest(integer)]
< **   ENC:result:[2:<=,nest(loop)]
< 
< **** getVqual:B2:
< [0:<=,nest(loop)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest(loop)]
< **** OI:getVqual:end: < L2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getOIqual: "< L2" IV:"L1 < L2"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: L1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: L1 on: 0 Items 
< **   father: L1 < L2
< **   father.f.f.f.f:
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** OI:getVqual: < L2 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest(loop)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest(loop)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop),nest(integer)]
< **** koks: < L2 on: 0 Items 
< **   father: L1 < L2
< **   father.f.f.f.f:
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< 
< **** getVqual:B2:
< [0:<=,nest(loop),nest(integer)]
< ---
< 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: <   :isVirtual:False
< [0:<=,nest(loop),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 51
<    in V: var integer
<    out B: var boolean
< [0:<=,nest(loop),nest(integer)]
< **** savedOGS:save:was:[0:<=,nest(loop),nest(integer)]
< **   OI: < L2
< **   OI:getQual:savedOI:< L2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop),nest(integer)]
< **   OGS:[0:<=,nest(loop)]
< **** DataItem:getVqual: out B: var boolean
< [0:<=,nest(loop),nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest(loop),nest(integer),nest(<)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest(loop),nest(integer),nest(<)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:<=,nest(loop),nest(integer),nest(<)]
< **   ENC:result:[1:<=,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:<=,nest(loop),nest(integer)]
< **   ENC:result:[2:<=,nest(loop)]
< 
< **** getVqual:B2:
< [0:<=,nest(loop)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest(loop)]
< **** OI:getVqual:end: < L2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getOIqual: "L2" IV:"L2"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: L2 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: L2 on: 0 Items 
< **   father: L2
< **   father.f.f.f.f:
< L1 < L2
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(loop)]
< **** savedOGS:save:False[0:<=,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:<=,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(loop)]
< **** savedOGS:save:was:[0:<=,nest(loop)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(loop)]
< **** OI:getOIqual: "matchEq" IV:"matchEq"
< **   origin.encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< 
< **** OI:getVqual: matchEq on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **** koks: matchEq on: 0 Items 
< **   father: matchEq
< **   father.f.f.f.f:
< 
< loop: obj 
<    matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
< ...
< 
< **** getVqual:B2:
< [0:loop]
< ---
< 
< matchEq: 
<    inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
< ...
< **** Pattern:getVqual: matchEq :isVirtual:False
< [0:loop]
< 
< **** getVqual:cont:afterATd:qual:
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< [0:loop]
< **** savedOGS:save:was:[0:loop]
< **   OI: matchEq
< **   OI:getQual:savedOI:matchEq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop]
< **   OGS:[0:loop]
< **** OI:getVqual:end: matchEq
< **   qual: 
< inx: var integer
<    c1: var char
<    c2: var char
<    isEmpty: do 
<       if (L1 = 0) :then 
< ...
< ObjectGenerator
< **   OGS:[0:loop]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: L := L1
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$53]
< **   encOG: L := L1
< **** koks: L on: 1 Items 
< **   father: L
< **   father.f.f.f.f:
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< **** ENC:OI.getVqual:[1:$53]
< **   ENC:result:[1:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: L := L1
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: L := L1
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: L := L1
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($53)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($53)]
< **** savedOGS:save:False[0:<=,nest($53)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($53)]
< **   OGS:[0:<=,nest($53)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($53)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($53)]
< **** savedOGS:save:was:[0:<=,nest($53)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($53)]
< **   OGS:[0:$53]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($53)]
< **** OI:getOIqual: "L1" IV:"L1"
< **   origin.encOG: L := L1
< 
< **** OI:getVqual: L1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$53]
< **   encOG: L := L1
< **** koks: L1 on: 1 Items 
< **   father: L1
< **   father.f.f.f.f:
< L := L1
< **** ENC:OI.getVqual:[1:$53]
< **   ENC:result:[1:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: L := L1
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: L := L1
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: L := L1
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($53)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($53)]
< **** savedOGS:save:False[0:<=,nest($53)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($53)]
< **   OGS:[0:<=,nest($53)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($53)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($53)]
< **** savedOGS:save:was:[0:<=,nest($53)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($53)]
< **   OGS:[0:$53]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($53)]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: L := L2
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$54]
< **   encOG: L := L2
< **** koks: L on: 1 Items 
< **   father: L
< **   father.f.f.f.f:
< 
< if (L1 < L2) :then 
<    L := L1
< :else 
<    L := L2
< **** ENC:OI.getVqual:[1:$54]
< **   ENC:result:[1:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: L := L2
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: L := L2
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: L := L2
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($54)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($54)]
< **** savedOGS:save:False[0:<=,nest($54)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($54)]
< **   OGS:[0:<=,nest($54)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($54)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($54)]
< **** savedOGS:save:was:[0:<=,nest($54)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($54)]
< **   OGS:[0:$54]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($54)]
< **** OI:getOIqual: "L2" IV:"L2"
< **   origin.encOG: L := L2
< 
< **** OI:getVqual: L2 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$54]
< **   encOG: L := L2
< **** koks: L2 on: 1 Items 
< **   father: L2
< **   father.f.f.f.f:
< L := L2
< **** ENC:OI.getVqual:[1:$54]
< **   ENC:result:[1:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: L := L2
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: L := L2
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: L := L2
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($54)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($54)]
< **** savedOGS:save:False[0:<=,nest($54)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($54)]
< **   OGS:[0:<=,nest($54)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($54)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($54)]
< **** savedOGS:save:was:[0:<=,nest($54)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($54)]
< **   OGS:[0:$54]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($54)]
< **** OI:getOIqual: "L1" IV:"L1 = 0"
< **   origin.encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:getVqual: L1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isEmpty]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** koks: L1 on: 2 Items 
< **   father: L1 = 0
< **   father.f.f.f.f:
< 
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:isEmpty]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(isEmpty)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:was:[0:<=,nest(isEmpty)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:isEmpty]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getOIqual: "= 0" IV:"L1 = 0"
< **   origin.encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:getVqual: L1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isEmpty]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** koks: L1 on: 2 Items 
< **   father: L1 = 0
< **   father.f.f.f.f:
< 
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:isEmpty]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(isEmpty)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:was:[0:<=,nest(isEmpty)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:isEmpty]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** OI:getVqual: = 0 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest(isEmpty)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty),nest(integer)]
< **** koks: = 0 on: 0 Items 
< **   father: L1 = 0
< **   father.f.f.f.f:
< 
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **** PRE: [0:<=,nest(isEmpty),nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:<=,nest(isEmpty),nest(integer),Value]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty),nest(integer),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:<=,nest(isEmpty),nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value&]
< **** savedOGS:save:was:[0:<=,nest(isEmpty),nest(integer),Value&]
< **   OI: = 0
< **   OI:getQual:savedOI:= 0
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty),nest(integer),Value&]
< **   OGS:[0:<=,nest(isEmpty)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   ENC:result:[1:<=,nest(isEmpty),nest(integer),Value&]
< **** ENC:OI.getVqual:[2:<=,nest(isEmpty),nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:<=,nest(isEmpty),nest(integer)]
< **   ENC:result:[3:<=,nest(isEmpty)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:<=,nest(isEmpty)]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest(isEmpty)]
< **** OI:getVqual:end: = 0
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getOIqual: "= 0" IV:"L1 = 0"
< **   origin.encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:getVqual: L1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isEmpty]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** koks: L1 on: 2 Items 
< **   father: L1 = 0
< **   father.f.f.f.f:
< 
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:isEmpty]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(isEmpty)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:was:[0:<=,nest(isEmpty)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:isEmpty]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** OI:getVqual: = 0 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest(isEmpty)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty),nest(integer)]
< **** koks: = 0 on: 0 Items 
< **   father: L1 = 0
< **   father.f.f.f.f:
< 
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **** PRE: [0:<=,nest(isEmpty),nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:<=,nest(isEmpty),nest(integer),Value]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty),nest(integer),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:<=,nest(isEmpty),nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value&]
< **** savedOGS:save:was:[0:<=,nest(isEmpty),nest(integer),Value&]
< **   OI: = 0
< **   OI:getQual:savedOI:= 0
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty),nest(integer),Value&]
< **   OGS:[0:<=,nest(isEmpty)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   ENC:result:[1:<=,nest(isEmpty),nest(integer),Value&]
< **** ENC:OI.getVqual:[2:<=,nest(isEmpty),nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:<=,nest(isEmpty),nest(integer)]
< **   ENC:result:[3:<=,nest(isEmpty)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:<=,nest(isEmpty)]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest(isEmpty)]
< **** OI:getVqual:end: = 0
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getOIqual: "L2" IV:"L2 = 0"
< **   origin.encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:getVqual: L2 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isEmpty]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** koks: L2 on: 2 Items 
< **   father: L2 = 0
< **   father.f.f.f.f:
< 
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:isEmpty]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(isEmpty)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:was:[0:<=,nest(isEmpty)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:isEmpty]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getOIqual: "= 0" IV:"L2 = 0"
< **   origin.encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:getVqual: L2 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isEmpty]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** koks: L2 on: 2 Items 
< **   father: L2 = 0
< **   father.f.f.f.f:
< 
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:isEmpty]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(isEmpty)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:was:[0:<=,nest(isEmpty)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:isEmpty]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** OI:getVqual: = 0 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest(isEmpty)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty),nest(integer)]
< **** koks: = 0 on: 0 Items 
< **   father: L2 = 0
< **   father.f.f.f.f:
< 
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **** PRE: [0:<=,nest(isEmpty),nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:<=,nest(isEmpty),nest(integer),Value]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty),nest(integer),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:<=,nest(isEmpty),nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value&]
< **** savedOGS:save:was:[0:<=,nest(isEmpty),nest(integer),Value&]
< **   OI: = 0
< **   OI:getQual:savedOI:= 0
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty),nest(integer),Value&]
< **   OGS:[0:<=,nest(isEmpty)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   ENC:result:[1:<=,nest(isEmpty),nest(integer),Value&]
< **** ENC:OI.getVqual:[2:<=,nest(isEmpty),nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:<=,nest(isEmpty),nest(integer)]
< **   ENC:result:[3:<=,nest(isEmpty)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:<=,nest(isEmpty)]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest(isEmpty)]
< **** OI:getVqual:end: = 0
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getOIqual: "= 0" IV:"L2 = 0"
< **   origin.encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< 
< **** OI:getVqual: L2 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:isEmpty]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** koks: L2 on: 2 Items 
< **   father: L2 = 0
< **   father.f.f.f.f:
< 
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:isEmpty]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (L1 = 0) :then 
<       Beq := L1 <= L2
<       leave(matchEq)
<    if (L2 = 0) :then 
<       Beq := false
< ...
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest(isEmpty)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:was:[0:<=,nest(isEmpty)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:isEmpty]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< 
< **** OI:getVqual: = 0 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest(isEmpty)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest(isEmpty),nest(integer)]
< **** koks: = 0 on: 0 Items 
< **   father: L2 = 0
< **   father.f.f.f.f:
< 
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **** PRE: [0:<=,nest(isEmpty),nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:<=,nest(isEmpty),nest(integer),Value]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty),nest(integer),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:<=,nest(isEmpty),nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:<=,nest(isEmpty),nest(integer),Value&]
< **** savedOGS:save:was:[0:<=,nest(isEmpty),nest(integer),Value&]
< **   OI: = 0
< **   OI:getQual:savedOI:= 0
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty),nest(integer),Value&]
< **   OGS:[0:<=,nest(isEmpty)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:<=,nest(isEmpty),nest(integer),Value&,nest(=)]
< **   ENC:result:[1:<=,nest(isEmpty),nest(integer),Value&]
< **** ENC:OI.getVqual:[2:<=,nest(isEmpty),nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:<=,nest(isEmpty),nest(integer)]
< **   ENC:result:[3:<=,nest(isEmpty)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:<=,nest(isEmpty)]
< 
< **** getVqual:B2:
< [0:<=,nest(isEmpty)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest(isEmpty)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest(isEmpty)]
< **** savedOGS:save:False[0:<=,nest(isEmpty)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest(isEmpty)]
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest(isEmpty)]
< **** OI:getVqual:end: = 0
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest(isEmpty)]
< **** OI:getOIqual: "Beq" IV:"Beq"
< **   origin.encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$57]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** koks: Beq on: 4 Items 
< **   father: Beq
< **   father.f.f.f.f:
< 
< if (L1 = 0) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$57]
< **   ENC:result:[1:isEmpty]
< **** ENC:OI.getVqual:[2:isEmpty]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< **** ENC:OI.getVqual:[4:loop]
< **   ENC:result:[4:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:$57]
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "L1" IV:"L1 <= L2"
< **   origin.encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: L1 on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$57]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** koks: L1 on: 3 Items 
< **   father: L1 <= L2
< **   father.f.f.f.f:
< 
< Beq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$57]
< **   ENC:result:[1:isEmpty]
< **** ENC:OI.getVqual:[2:isEmpty]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($57)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($57)]
< **** savedOGS:save:False[0:<=,nest($57)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57)]
< **   OGS:[0:<=,nest($57)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($57)]
< **** savedOGS:save:was:[0:<=,nest($57)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57)]
< **   OGS:[0:$57]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< **** OI:getOIqual: "<= L2" IV:"L1 <= L2"
< **   origin.encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: L1 on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$57]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** koks: L1 on: 3 Items 
< **   father: L1 <= L2
< **   father.f.f.f.f:
< 
< Beq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$57]
< **   ENC:result:[1:isEmpty]
< **** ENC:OI.getVqual:[2:isEmpty]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($57)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($57)]
< **** savedOGS:save:False[0:<=,nest($57)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57)]
< **   OGS:[0:<=,nest($57)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($57)]
< **** savedOGS:save:was:[0:<=,nest($57)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57)]
< **   OGS:[0:$57]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< 
< **** OI:getVqual: <= L2 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest($57)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest($57)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($57),nest(integer)]
< **** koks: <= L2 on: 0 Items 
< **   father: L1 <= L2
< **   father.f.f.f.f:
< 
< Beq := L1 <= L2
<    leave(matchEq)
< **** PRE: [0:<=,nest($57),nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:<=,nest($57),nest(integer),Value]
< 
< **** getVqual:B2:
< [0:<=,nest($57),nest(integer),Value]
< ---
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Pattern:getVqual: <=   :isVirtual:True
< [0:<=,nest($57),nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:<=,nest($57),nest(integer),Value]
< **** newFindBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:<=,nest($57),nest(integer),Value]
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:<=,nest($57),nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** newFindBinding:found: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** PTN:getVqual:gotBinding: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** getVqual:cont:afterATd:qual:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:<=,nest($57),nest(integer),Value&]
< **** savedOGS:save:was:[0:<=,nest($57),nest(integer),Value&]
< **   OI: <= L2
< **   OI:getQual:savedOI:<= L2
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57),nest(integer),Value&]
< **   OGS:[0:<=,nest($57)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,nest($57),nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest($57),nest(integer),Value&,nest(<=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest($57),nest(integer),Value&,nest(<=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,nest($57),nest(integer),Value&,nest(<=)]
< **   ENC:result:[1:<=,nest($57),nest(integer),Value&]
< **** ENC:OI.getVqual:[2:<=,nest($57),nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:<=,nest($57),nest(integer)]
< **   ENC:result:[3:<=,nest($57)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:<=,nest($57)]
< 
< **** getVqual:B2:
< [0:<=,nest($57)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest($57)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest($57)]
< **** savedOGS:save:False[0:<=,nest($57)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57)]
< **   OGS:[0:<=,nest($57)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest($57)]
< **** OI:getVqual:end: <= L2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< **** OI:getOIqual: "L2" IV:"L2"
< **   origin.encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: L2 on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$57]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** koks: L2 on: 3 Items 
< **   father: L2
< **   father.f.f.f.f:
< L1 <= L2
< **** ENC:OI.getVqual:[1:$57]
< **   ENC:result:[1:isEmpty]
< **** ENC:OI.getVqual:[2:isEmpty]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($57)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($57)]
< **** savedOGS:save:False[0:<=,nest($57)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57)]
< **   OGS:[0:<=,nest($57)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($57)]
< **** savedOGS:save:was:[0:<=,nest($57)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($57)]
< **   OGS:[0:$57]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($57)]
< **** OI:getOIqual: "leave(matchEq)" IV:"leave(matchEq)"
< **   origin.encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: leave(matchEq) on=7 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$57]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=7 BETA %Include BETA
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:$57]
< ***** viaInclude:notTop: leave name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:$57]
< **** ENC:OI.viaInclude:[0:$57]
< **   ENC:result:[0:isEmpty]
< **** viaInclude:GOT:
< [0:isEmpty,nest($57)]
< **** Pattern:getVqual: leave(V: var integer) :isVirtual:False
< [0:isEmpty,nest($57)]
< **** savedOGS:save:was:[0:isEmpty,nest($57)]
< **   OI: leave(matchEq)
< **   OI:getQual:savedOI:leave(matchEq)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:isEmpty,nest($57)]
< **   OGS:[0:isEmpty,nest($57)]
< **** OI:getVqual:end: leave(matchEq)
< **   qual: %basic 103
< ObjectGenerator
< **   OGS:[0:isEmpty,nest($57)]
< **** OI:getOIqual: "Beq" IV:"Beq"
< **   origin.encOG: 
< Beq := false
<    leave(matchEq)
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$58]
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **** koks: Beq on: 4 Items 
< **   father: Beq
< **   father.f.f.f.f:
< 
< if (L2 = 0) :then 
<    Beq := false
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$58]
< **   ENC:result:[1:isEmpty]
< **** ENC:OI.getVqual:[2:isEmpty]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< **** ENC:OI.getVqual:[4:loop]
< **   ENC:result:[4:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:$58]
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "leave(matchEq)" IV:"leave(matchEq)"
< **   origin.encOG: 
< Beq := false
<    leave(matchEq)
< 
< **** OI:getVqual: leave(matchEq) on=7 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$58]
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **** OI:viaInclude:on=7 BETA %Include BETA
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **   OGS:[0:$58]
< ***** viaInclude:notTop: leave name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := false
<    leave(matchEq)
< **   OGS:[0:$58]
< **** ENC:OI.viaInclude:[0:$58]
< **   ENC:result:[0:isEmpty]
< **** viaInclude:GOT:
< [0:isEmpty,nest($58)]
< **** Pattern:getVqual: leave(V: var integer) :isVirtual:False
< [0:isEmpty,nest($58)]
< **** savedOGS:save:was:[0:isEmpty,nest($58)]
< **   OI: leave(matchEq)
< **   OI:getQual:savedOI:leave(matchEq)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:isEmpty,nest($58)]
< **   OGS:[0:isEmpty,nest($58)]
< **** OI:getVqual:end: leave(matchEq)
< **   qual: %basic 103
< ObjectGenerator
< **   OGS:[0:isEmpty,nest($58)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< 
< loop: do 
<    inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "inx" IV:"inx + 1"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "+ 1" IV:"inx + 1"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest(loop)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest(loop)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop),nest(integer)]
< **** koks: + 1 on: 0 Items 
< **   father: inx + 1
< **   father.f.f.f.f:
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** getVqual:B2:
< [0:loop,nest(loop),nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:loop,nest(loop),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:loop,nest(loop),nest(integer)]
< **** savedOGS:save:was:[0:loop,nest(loop),nest(integer)]
< **   OI: + 1
< **   OI:getQual:savedOI:+ 1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop),nest(integer)]
< **   OGS:[0:loop,nest(loop)]
< **** DataItem:getVqual: out R: var integer
< [0:loop,nest(loop),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop,nest(loop),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest(loop),nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:loop,nest(loop),nest(integer),nest(+)]
< **   ENC:result:[1:loop,nest(loop),nest(integer)]
< **** ENC:OI.getVqual:[2:loop,nest(loop),nest(integer)]
< **   ENC:result:[2:loop,nest(loop)]
< 
< **** getVqual:B2:
< [0:loop,nest(loop)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:loop,nest(loop)]
< **** OI:getVqual:end: + 1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "c1" IV:"c1"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: c1 on: 1 Items 
< **   father: c1
< **   father.f.f.f.f:
< 
< loop: do 
<    inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "get[inx]" IV:"get[inx]"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: get[inx] on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: get[inx] on: 4 Items 
< **   father: get[inx]
< **   father.f.f.f.f:
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< **** ENC:OI.getVqual:[3:loop]
< **   ENC:result:[3:<=]
< **** ENC:OI.getVqual:[4:<=]
< **   ENC:result:[4:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: get[inx]
< **   OI:getQual:savedOI:get[inx]
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:loop]
< **** DataItem:getVqual: out ch: var char
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:String,nest(loop)]
< **** savedOGS:save:False[0:String,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(loop)]
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:String,nest(loop)]
< **** OI:getVqual:end: get[inx]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(loop)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< get[inx]
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "c2" IV:"c2"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: c2 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: c2 on: 1 Items 
< **   father: c2
< **   father.f.f.f.f:
< 
< loop: do 
<    inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c2: var char
< **** DataItem:getVqual: c2: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "Veq" IV:"Veq.get[inx]"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: Veq on=3 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: Veq on: 3 Items 
< **   father: Veq.get[inx]
< **   father.f.f.f.f:
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< **** ENC:OI.getVqual:[3:loop]
< **   ENC:result:[3:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,<=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,<=]
< **** getOGstart: 
< [0:<=,<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:<=,<=]
< **** savedOGS:save:was:[0:<=,<=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=]
< **   OGS:[0:loop]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=]
< **** OI:getOIqual: "get[inx]" IV:"Veq.get[inx]"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: Veq on=3 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: Veq on: 3 Items 
< **   father: Veq.get[inx]
< **   father.f.f.f.f:
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< **** ENC:OI.getVqual:[2:matchEq]
< **   ENC:result:[2:loop]
< **** ENC:OI.getVqual:[3:loop]
< **   ENC:result:[3:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< in Veq: var this(Value)
< **** DataItem:getVqual: in Veq: var this(Value)
< [0:<=,<=]
< **** ObjectGenerator:getVqual: this(Value)
< **   hasVirtualArgs: False
< **** INV:getVqual:this(Value)
< **   OGs: [0:<=,<=]
< **** getOGstart: 
< [0:<=,<=]
< **** getOGstart: 
< [0:<=]
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **** getOGstart:isNest: False qual: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:<=,<=]
< **** savedOGS:save:was:[0:<=,<=]
< **   OI: Veq
< **   OI:getQual:savedOI:Veq
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=]
< **   OGS:[0:loop]
< **** OI:getVqual:end: Veq
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=]
< 
< **** OI:getVqual: get[inx] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,<=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** getVqual:added:isNest:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:<=,<=,nest(String)]
< **** koks: get[inx] on: 0 Items 
< **   father: Veq.get[inx]
< **   father.f.f.f.f:
< 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** getVqual:B2:
< [0:<=,<=,nest(String)]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:<=,<=,nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:<=,<=,nest(String)]
< **** savedOGS:save:was:[0:<=,<=,nest(String)]
< **   OI: get[inx]
< **   OI:getQual:savedOI:get[inx]
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=,nest(String)]
< **   OGS:[0:<=,<=]
< **** DataItem:getVqual: out ch: var char
< [0:<=,<=,nest(String),nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:<=,<=,nest(String),nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=,nest(String),nest(get)]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:<=,<=,nest(String),nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:<=,<=,nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:<=,<=,nest(String),nest(get)]
< **   ENC:result:[0:<=,<=,nest(String)]
< **** viaInclude:GOT:
< [0:<=,<=,nest(String),nest(String)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:<=,<=,nest(String),nest(String)]
< **** savedOGS:save:False[0:<=,<=,nest(String),nest(String)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,<=,nest(String),nest(String)]
< **   OGS:[0:<=,<=,nest(String),nest(String)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=,nest(String),nest(String)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:<=,<=,nest(String),nest(String)]
< **** OI:getVqual:end: get[inx]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,<=,nest(String),nest(String)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: inx on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< Veq.get[inx]
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "c1" IV:"c1 = c2"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: c1 on: 1 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "= c2" IV:"c1 = c2"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: c1 on: 1 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** OI:getVqual: = c2 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest(loop)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest(loop)]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop),nest(char)]
< **** koks: = c2 on: 0 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
< **** PRE: [0:loop,nest(loop),nest(char)]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:loop,nest(loop),nest(char),Value]
< 
< **** getVqual:B2:
< [0:loop,nest(loop),nest(char),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:loop,nest(loop),nest(char),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:loop,nest(loop),nest(char),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(loop),nest(char),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(loop),nest(char)]
< **   checkDOG: char 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< father:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(loop),nest(char),Value&]
< **** savedOGS:save:was:[0:loop,nest(loop),nest(char),Value&]
< **   OI: = c2
< **   OI:getQual:savedOI:= c2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop),nest(char),Value&]
< **   OGS:[0:loop,nest(loop)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:loop,nest(loop),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:loop,nest(loop),nest(char),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest(loop),nest(char),Value&,nest(=)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:loop,nest(loop),nest(char),Value&,nest(=)]
< **   ENC:result:[1:loop,nest(loop),nest(char),Value&]
< **** ENC:OI.getVqual:[2:loop,nest(loop),nest(char),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:loop,nest(loop),nest(char)]
< **   ENC:result:[3:loop,nest(loop)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:loop,nest(loop)]
< 
< **** getVqual:B2:
< [0:loop,nest(loop)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:loop,nest(loop)]
< **** OI:getVqual:end: = c2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "= c2" IV:"c1 = c2"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: c1 on: 1 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** OI:getVqual: = c2 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest(loop)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest(loop)]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop),nest(char)]
< **** koks: = c2 on: 0 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    if (inx < L) :then 
<       restart(loop)
< **** PRE: [0:loop,nest(loop),nest(char)]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:loop,nest(loop),nest(char),Value]
< 
< **** getVqual:B2:
< [0:loop,nest(loop),nest(char),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:loop,nest(loop),nest(char),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:loop,nest(loop),nest(char),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(loop),nest(char),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(loop),nest(char)]
< **   checkDOG: char 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< father:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(loop),nest(char),Value&]
< **** savedOGS:save:was:[0:loop,nest(loop),nest(char),Value&]
< **   OI: = c2
< **   OI:getQual:savedOI:= c2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop),nest(char),Value&]
< **   OGS:[0:loop,nest(loop)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:loop,nest(loop),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:loop,nest(loop),nest(char),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest(loop),nest(char),Value&,nest(=)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:loop,nest(loop),nest(char),Value&,nest(=)]
< **   ENC:result:[1:loop,nest(loop),nest(char),Value&]
< **** ENC:OI.getVqual:[2:loop,nest(loop),nest(char),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:loop,nest(loop),nest(char)]
< **   ENC:result:[3:loop,nest(loop)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:loop,nest(loop)]
< 
< **** getVqual:B2:
< [0:loop,nest(loop)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:loop,nest(loop)]
< **** OI:getVqual:end: = c2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "c2" IV:"c2"
< **   origin.encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< 
< **** OI:getVqual: c2 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** koks: c2 on: 1 Items 
< **   father: c2
< **   father.f.f.f.f:
< c1 = c2
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c2: var char
< **** DataItem:getVqual: c2: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< inx := inx + 1
<    c1 := get[inx]
<    c2 := Veq.get[inx]
<    if (c1 = c2) :then 
<       if (inx < L) :then 
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(loop)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(loop)]
< **** savedOGS:save:False[0:loop,nest(loop)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop,nest(loop)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(loop)]
< **** savedOGS:save:was:[0:loop,nest(loop)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(loop)]
< **   OGS:[0:loop]
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(loop)]
< **** OI:getOIqual: "inx" IV:"inx < L"
< **   origin.encOG: 
< if (inx < L) :then 
<       restart(loop)
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$60]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** koks: inx on: 2 Items 
< **   father: inx < L
< **   father.f.f.f.f:
< 
< if (inx < L) :then 
<    restart(loop)
< **** ENC:OI.getVqual:[1:$60]
< **   ENC:result:[1:loop]
< **** ENC:OI.getVqual:[2:loop]
< **   ENC:result:[2:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest($60)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest($60)]
< **** savedOGS:save:False[0:loop,nest($60)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:loop,nest($60)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest($60)]
< **** savedOGS:save:was:[0:loop,nest($60)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:$60]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< **** OI:getOIqual: "< L" IV:"inx < L"
< **   origin.encOG: 
< if (inx < L) :then 
<       restart(loop)
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$60]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** koks: inx on: 2 Items 
< **   father: inx < L
< **   father.f.f.f.f:
< 
< if (inx < L) :then 
<    restart(loop)
< **** ENC:OI.getVqual:[1:$60]
< **   ENC:result:[1:loop]
< **** ENC:OI.getVqual:[2:loop]
< **   ENC:result:[2:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest($60)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest($60)]
< **** savedOGS:save:False[0:loop,nest($60)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:loop,nest($60)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest($60)]
< **** savedOGS:save:was:[0:loop,nest($60)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:$60]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< 
< **** OI:getVqual: < L on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest($60)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest($60)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest($60),nest(integer)]
< **** koks: < L on: 0 Items 
< **   father: inx < L
< **   father.f.f.f.f:
< 
< if (inx < L) :then 
<    restart(loop)
< 
< **** getVqual:B2:
< [0:loop,nest($60),nest(integer)]
< ---
< 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: <   :isVirtual:False
< [0:loop,nest($60),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 51
<    in V: var integer
<    out B: var boolean
< [0:loop,nest($60),nest(integer)]
< **** savedOGS:save:was:[0:loop,nest($60),nest(integer)]
< **   OI: < L
< **   OI:getQual:savedOI:< L
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60),nest(integer)]
< **   OGS:[0:loop,nest($60)]
< **** DataItem:getVqual: out B: var boolean
< [0:loop,nest($60),nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:loop,nest($60),nest(integer),nest(<)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest($60),nest(integer),nest(<)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:loop,nest($60),nest(integer),nest(<)]
< **   ENC:result:[1:loop,nest($60),nest(integer)]
< **** ENC:OI.getVqual:[2:loop,nest($60),nest(integer)]
< **   ENC:result:[2:loop,nest($60)]
< 
< **** getVqual:B2:
< [0:loop,nest($60)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:loop,nest($60)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:loop,nest($60)]
< **** savedOGS:save:False[0:loop,nest($60)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:loop,nest($60)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:loop,nest($60)]
< **** OI:getVqual:end: < L
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< **** OI:getOIqual: "< L" IV:"inx < L"
< **   origin.encOG: 
< if (inx < L) :then 
<       restart(loop)
< 
< **** OI:getVqual: inx on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$60]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** koks: inx on: 2 Items 
< **   father: inx < L
< **   father.f.f.f.f:
< 
< if (inx < L) :then 
<    restart(loop)
< **** ENC:OI.getVqual:[1:$60]
< **   ENC:result:[1:loop]
< **** ENC:OI.getVqual:[2:loop]
< **   ENC:result:[2:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:matchEq]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: integer on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest($60)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:loop,nest($60)]
< **** savedOGS:save:False[0:loop,nest($60)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:loop,nest($60)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest($60)]
< **** savedOGS:save:was:[0:loop,nest($60)]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:$60]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< 
< **** OI:getVqual: < L on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest($60)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest($60)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:loop,nest($60),nest(integer)]
< **** koks: < L on: 0 Items 
< **   father: inx < L
< **   father.f.f.f.f:
< 
< if (inx < L) :then 
<    restart(loop)
< 
< **** getVqual:B2:
< [0:loop,nest($60),nest(integer)]
< ---
< 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: <   :isVirtual:False
< [0:loop,nest($60),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 51
<    in V: var integer
<    out B: var boolean
< [0:loop,nest($60),nest(integer)]
< **** savedOGS:save:was:[0:loop,nest($60),nest(integer)]
< **   OI: < L
< **   OI:getQual:savedOI:< L
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60),nest(integer)]
< **   OGS:[0:loop,nest($60)]
< **** DataItem:getVqual: out B: var boolean
< [0:loop,nest($60),nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:loop,nest($60),nest(integer),nest(<)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest($60),nest(integer),nest(<)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:loop,nest($60),nest(integer),nest(<)]
< **   ENC:result:[1:loop,nest($60),nest(integer)]
< **** ENC:OI.getVqual:[2:loop,nest($60),nest(integer)]
< **   ENC:result:[2:loop,nest($60)]
< 
< **** getVqual:B2:
< [0:loop,nest($60)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:loop,nest($60)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:loop,nest($60)]
< **** savedOGS:save:False[0:loop,nest($60)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($60)]
< **   OGS:[0:loop,nest($60)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:loop,nest($60)]
< **** OI:getVqual:end: < L
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($60)]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: 
< if (inx < L) :then 
<       restart(loop)
< 
< **** OI:getVqual: L on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$60]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** koks: L on: 3 Items 
< **   father: L
< **   father.f.f.f.f:
< inx < L
< **** ENC:OI.getVqual:[1:$60]
< **   ENC:result:[1:loop]
< **** ENC:OI.getVqual:[2:loop]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< if (inx < L) :then 
<       restart(loop)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($60)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($60)]
< **** savedOGS:save:False[0:<=,nest($60)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($60)]
< **   OGS:[0:<=,nest($60)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($60)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($60)]
< **** savedOGS:save:was:[0:<=,nest($60)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($60)]
< **   OGS:[0:$60]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($60)]
< **** OI:getOIqual: "restart(loop)" IV:"restart(loop)"
< **   origin.encOG: restart(loop)
< 
< **** OI:getVqual: restart(loop) on=8 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$61]
< **   encOG: restart(loop)
< **** OI:viaInclude:on=8 BETA %Include BETA
< **   OI: restart(loop)
< **   encOG: restart(loop)
< **   OGS:[0:$61]
< ***** viaInclude:notTop: restart name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: restart(loop)
< **   encOG: restart(loop)
< **   OGS:[0:$61]
< **** ENC:OI.viaInclude:[0:$61]
< **   ENC:result:[0:$60]
< **** viaInclude:GOT:
< [0:$60,nest($61)]
< **** Pattern:getVqual: restart(V: var integer) :isVirtual:False
< [0:$60,nest($61)]
< **** savedOGS:save:was:[0:$60,nest($61)]
< **   OI: restart(loop)
< **   OI:getQual:savedOI:restart(loop)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:$60,nest($61)]
< **   OGS:[0:$60,nest($61)]
< **** OI:getVqual:end: restart(loop)
< **   qual: 
< -- odd parameter type!
<    %basic 102
< ObjectGenerator
< **   OGS:[0:$60,nest($61)]
< **** OI:getOIqual: "c1" IV:"c1 = c2"
< **   origin.encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doit]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** koks: c1 on: 1 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **** ENC:OI.getVqual:[1:doit]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(doit)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(doit)]
< **** savedOGS:save:False[0:loop,nest(doit)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(doit)]
< **** savedOGS:save:was:[0:loop,nest(doit)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:doit]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< **** OI:getOIqual: "= c2" IV:"c1 = c2"
< **   origin.encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doit]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** koks: c1 on: 1 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **** ENC:OI.getVqual:[1:doit]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(doit)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(doit)]
< **** savedOGS:save:False[0:loop,nest(doit)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(doit)]
< **** savedOGS:save:was:[0:loop,nest(doit)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:doit]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< 
< **** OI:getVqual: = c2 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest(doit)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest(doit)]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(doit),nest(char)]
< **** koks: = c2 on: 0 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **** PRE: [0:loop,nest(doit),nest(char)]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:loop,nest(doit),nest(char),Value]
< 
< **** getVqual:B2:
< [0:loop,nest(doit),nest(char),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:loop,nest(doit),nest(char),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:loop,nest(doit),nest(char),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(doit),nest(char),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(doit),nest(char)]
< **   checkDOG: char 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< father:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(doit),nest(char),Value&]
< **** savedOGS:save:was:[0:loop,nest(doit),nest(char),Value&]
< **   OI: = c2
< **   OI:getQual:savedOI:= c2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit),nest(char),Value&]
< **   OGS:[0:loop,nest(doit)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:loop,nest(doit),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:loop,nest(doit),nest(char),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest(doit),nest(char),Value&,nest(=)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:loop,nest(doit),nest(char),Value&,nest(=)]
< **   ENC:result:[1:loop,nest(doit),nest(char),Value&]
< **** ENC:OI.getVqual:[2:loop,nest(doit),nest(char),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:loop,nest(doit),nest(char)]
< **   ENC:result:[3:loop,nest(doit)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:loop,nest(doit)]
< 
< **** getVqual:B2:
< [0:loop,nest(doit)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:loop,nest(doit)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:loop,nest(doit)]
< **** savedOGS:save:False[0:loop,nest(doit)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:loop,nest(doit)]
< **** OI:getVqual:end: = c2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< **** OI:getOIqual: "= c2" IV:"c1 = c2"
< **   origin.encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** OI:getVqual: c1 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doit]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** koks: c1 on: 1 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **** ENC:OI.getVqual:[1:doit]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(doit)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(doit)]
< **** savedOGS:save:False[0:loop,nest(doit)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(doit)]
< **** savedOGS:save:was:[0:loop,nest(doit)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:doit]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< 
< **** OI:getVqual: = c2 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest(doit)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest(doit)]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(doit),nest(char)]
< **** koks: = c2 on: 0 Items 
< **   father: c1 = c2
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **** PRE: [0:loop,nest(doit),nest(char)]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:loop,nest(doit),nest(char),Value]
< 
< **** getVqual:B2:
< [0:loop,nest(doit),nest(char),Value]
< ---
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** Pattern:getVqual: =   :isVirtual:True
< [0:loop,nest(doit),nest(char),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:loop,nest(doit),nest(char),Value]
< **** newFindBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(doit),nest(char),Value]
< **** searchBinding: 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(doit),nest(char)]
< **   checkDOG: char 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< father:
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< =  :< 
<    %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** newFindBinding:found: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** PTN:getVqual:gotBinding: 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< 
< **** getVqual:cont:afterATd:qual:
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< [0:loop,nest(doit),nest(char),Value&]
< **** savedOGS:save:was:[0:loop,nest(doit),nest(char),Value&]
< **   OI: = c2
< **   OI:getQual:savedOI:= c2
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit),nest(char),Value&]
< **   OGS:[0:loop,nest(doit)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:loop,nest(doit),nest(char),Value&,nest(=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:loop,nest(doit),nest(char),Value&,nest(=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest(doit),nest(char),Value&,nest(=)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 50
<    in Veq: var this(Value)
<    out Beq: var boolean
<    inner(#= = )
< **** ENC:OI.getVqual:[1:loop,nest(doit),nest(char),Value&,nest(=)]
< **   ENC:result:[1:loop,nest(doit),nest(char),Value&]
< **** ENC:OI.getVqual:[2:loop,nest(doit),nest(char),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:loop,nest(doit),nest(char)]
< **   ENC:result:[3:loop,nest(doit)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:loop,nest(doit)]
< 
< **** getVqual:B2:
< [0:loop,nest(doit)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:loop,nest(doit)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:loop,nest(doit)]
< **** savedOGS:save:False[0:loop,nest(doit)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:loop,nest(doit)]
< **** OI:getVqual:end: = c2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< **** OI:getOIqual: "c2" IV:"c2"
< **   origin.encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< 
< **** OI:getVqual: c2 on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doit]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** koks: c2 on: 1 Items 
< **   father: c2
< **   father.f.f.f.f:
< c1 = c2
< **** ENC:OI.getVqual:[1:doit]
< **   ENC:result:[1:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c2: var char
< **** DataItem:getVqual: c2: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< if (c1 = c2) :then 
<       -- we have inx = LBeq := L1 <= L2
<       leave(matchEq)
<    :else 
<       Beq := c1 < c2
< ...
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest(doit)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest(doit)]
< **** savedOGS:save:False[0:loop,nest(doit)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:loop,nest(doit)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest(doit)]
< **** savedOGS:save:was:[0:loop,nest(doit)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest(doit)]
< **   OGS:[0:doit]
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest(doit)]
< **** OI:getOIqual: "Beq" IV:"Beq"
< **   origin.encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$63]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** koks: Beq on: 4 Items 
< **   father: Beq
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **** ENC:OI.getVqual:[1:$63]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< **** ENC:OI.getVqual:[4:loop]
< **   ENC:result:[4:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:$63]
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "L1" IV:"L1 <= L2"
< **   origin.encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: L1 on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$63]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** koks: L1 on: 3 Items 
< **   father: L1 <= L2
< **   father.f.f.f.f:
< 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$63]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($63)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($63)]
< **** savedOGS:save:False[0:<=,nest($63)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63)]
< **   OGS:[0:<=,nest($63)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($63)]
< **** savedOGS:save:was:[0:<=,nest($63)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63)]
< **   OGS:[0:$63]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< **** OI:getOIqual: "<= L2" IV:"L1 <= L2"
< **   origin.encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: L1 on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$63]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** koks: L1 on: 3 Items 
< **   father: L1 <= L2
< **   father.f.f.f.f:
< 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$63]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L1: var integer
< **** DataItem:getVqual: L1: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($63)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($63)]
< **** savedOGS:save:False[0:<=,nest($63)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63)]
< **   OGS:[0:<=,nest($63)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($63)]
< **** savedOGS:save:was:[0:<=,nest($63)]
< **   OI: L1
< **   OI:getQual:savedOI:L1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63)]
< **   OGS:[0:$63]
< **** OI:getVqual:end: L1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< 
< **** OI:getVqual: <= L2 on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:<=,nest($63)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:<=,nest($63)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:<=]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($63),nest(integer)]
< **** koks: <= L2 on: 0 Items 
< **   father: L1 <= L2
< **   father.f.f.f.f:
< 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** PRE: [0:<=,nest($63),nest(integer)]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[0:<=,nest($63),nest(integer),Value]
< 
< **** getVqual:B2:
< [0:<=,nest($63),nest(integer),Value]
< ---
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** Pattern:getVqual: <=   :isVirtual:True
< [0:<=,nest($63),nest(integer),Value]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:<=,nest($63),nest(integer),Value]
< **** newFindBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:<=,nest($63),nest(integer),Value]
< **** searchBinding: 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:<=,nest($63),nest(integer)]
< **   checkDOG: integer 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< father:
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   Ex: value
< **   Ex.OGs.super:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   checkDOG: Value 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< father:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< 
<  ==== FOUND BINDING: =====
< 
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** newFindBinding:found: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** PTN:getVqual:gotBinding: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< 
< **** getVqual:cont:afterATd:qual:
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< [0:<=,nest($63),nest(integer),Value&]
< **** savedOGS:save:was:[0:<=,nest($63),nest(integer),Value&]
< **   OI: <= L2
< **   OI:getQual:savedOI:<= L2
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63),nest(integer),Value&]
< **   OGS:[0:<=,nest($63)]
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,nest($63),nest(integer),Value&,nest(<=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,nest($63),nest(integer),Value&,nest(<=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,nest($63),nest(integer),Value&,nest(<=)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,nest($63),nest(integer),Value&,nest(<=)]
< **   ENC:result:[1:<=,nest($63),nest(integer),Value&]
< **** ENC:OI.getVqual:[2:<=,nest($63),nest(integer),Value&]
< **** pathToSuper: "value" of:DOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:value :isImplSuper=False
< **   pathToSuper:E:"value" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "value" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:<=,nest($63),nest(integer)]
< **   ENC:result:[3:<=,nest($63)]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:<=,nest($63)]
< 
< **** getVqual:B2:
< [0:<=,nest($63)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:<=,nest($63)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:<=,nest($63)]
< **** savedOGS:save:False[0:<=,nest($63)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63)]
< **   OGS:[0:<=,nest($63)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< **** OI:getVqual:return: out Beq: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:<=,nest($63)]
< **** OI:getVqual:end: <= L2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< **** OI:getOIqual: "L2" IV:"L2"
< **   origin.encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: L2 on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$63]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** koks: L2 on: 3 Items 
< **   father: L2
< **   father.f.f.f.f:
< L1 <= L2
< **** ENC:OI.getVqual:[1:$63]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< 
< **** getVqual:B2:
< [0:loop]
< ---
< L2: var integer
< **** DataItem:getVqual: L2: var integer
< [0:loop]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:loop]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< -- we have inx = LBeq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:loop]
< **** ENC:OI.viaInclude:[0:loop]
< **   ENC:result:[0:<=]
< **** viaInclude:GOT:
< [0:<=,nest($63)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:<=,nest($63)]
< **** savedOGS:save:False[0:<=,nest($63)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63)]
< **   OGS:[0:<=,nest($63)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:<=,nest($63)]
< **** savedOGS:save:was:[0:<=,nest($63)]
< **   OI: L2
< **   OI:getQual:savedOI:L2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:<=,nest($63)]
< **   OGS:[0:$63]
< **** OI:getVqual:end: L2
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:<=,nest($63)]
< **** OI:getOIqual: "leave(matchEq)" IV:"leave(matchEq)"
< **   origin.encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< 
< **** OI:getVqual: leave(matchEq) on=7 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$63]
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **** OI:viaInclude:on=7 BETA %Include BETA
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:$63]
< ***** viaInclude:notTop: leave name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := L1 <= L2
<    leave(matchEq)
< **   OGS:[0:$63]
< **** ENC:OI.viaInclude:[0:$63]
< **   ENC:result:[0:doit]
< **** viaInclude:GOT:
< [0:doit,nest($63)]
< **** Pattern:getVqual: leave(V: var integer) :isVirtual:False
< [0:doit,nest($63)]
< **** savedOGS:save:was:[0:doit,nest($63)]
< **   OI: leave(matchEq)
< **   OI:getQual:savedOI:leave(matchEq)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:doit,nest($63)]
< **   OGS:[0:doit,nest($63)]
< **** OI:getVqual:end: leave(matchEq)
< **   qual: %basic 103
< ObjectGenerator
< **   OGS:[0:doit,nest($63)]
< **** OI:getOIqual: "Beq" IV:"Beq"
< **   origin.encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:getVqual: Beq on=4 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$64]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** koks: Beq on: 4 Items 
< **   father: Beq
< **   father.f.f.f.f:
< 
< if (c1 = c2) :then 
<    Beq := L1 <= L2
<    leave(matchEq)
< :else 
<    Beq := c1 < c2
< ...
< **** ENC:OI.getVqual:[1:$64]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< **** ENC:OI.getVqual:[3:matchEq]
< **   ENC:result:[3:loop]
< **** ENC:OI.getVqual:[4:loop]
< **   ENC:result:[4:<=]
< **** PRE: [0:<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   PRE:result:[0:<=,<=]
< 
< **** getVqual:B2:
< [0:<=,<=]
< ---
< out Beq: var boolean
< **** DataItem:getVqual: out Beq: var boolean
< [0:<=,<=]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:<=,<=]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:<=,<=]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[1:<=,<=]
< **** pathToSuper: "" of:DOG:
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   innerDOG: 
< matchEq: 
<       inx: var integer
<       c1: var char
<       c2: var char
<       isEmpty: do 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< <=  :< 
<    %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **   ENC:pred:  pred.DOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   OGsuper: 
< %basic 52
<    in Veq: var this(Value)
<    out Beq: var boolean
< **** ENC:OI.getVqual:[2:<=]
< **   ENC:result:[2:String]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:String]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **   PRE:result:[1:String,Value]
< **   ENC:result:[1:String,Value]
< **** ENC:OI.getVqual:[2:String,Value]
< **** pathToSuper: "Value" of:DOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   innerDOG: 
< loop: obj 
<       matchEq: 
<          inx: var integer
<          c1: var char
<          c2: var char
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Value :isImplSuper=False
< **   pathToSuper:E:"Value" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Value" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Value: 
<    %ID Value
<    %globals
<    %basic 21
<    %public
< ...
< **   ENC:pred:  pred.DOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGsuper: 
< %ID Value
<    %globals
<    %basic 21
<    %public
<    =  :< 
< ...
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:StringLib]
< **   ENC:result:[3:LIB]
< **   ENC:result:[2:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: Beq
< **   OI:getQual:savedOI:Beq
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:$64]
< **** OI:getVqual:end: Beq
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "c1" IV:"c1 < c2"
< **   origin.encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:getVqual: c1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$64]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** koks: c1 on: 2 Items 
< **   father: c1 < c2
< **   father.f.f.f.f:
< 
< Beq := c1 < c2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$64]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest($64)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest($64)]
< **** savedOGS:save:False[0:loop,nest($64)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64)]
< **   OGS:[0:loop,nest($64)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest($64)]
< **** savedOGS:save:was:[0:loop,nest($64)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64)]
< **   OGS:[0:$64]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< **** OI:getOIqual: "< c2" IV:"c1 < c2"
< **   origin.encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:getVqual: c1 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$64]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** koks: c1 on: 2 Items 
< **   father: c1 < c2
< **   father.f.f.f.f:
< 
< Beq := c1 < c2
<    leave(matchEq)
< **** ENC:OI.getVqual:[1:$64]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c1: var char
< **** DataItem:getVqual: c1: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest($64)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest($64)]
< **** savedOGS:save:False[0:loop,nest($64)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64)]
< **   OGS:[0:loop,nest($64)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest($64)]
< **** savedOGS:save:was:[0:loop,nest($64)]
< **   OI: c1
< **   OI:getQual:savedOI:c1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64)]
< **   OGS:[0:$64]
< **** OI:getVqual:end: c1
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< 
< **** OI:getVqual: < c2 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:loop,nest($64)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:loop,nest($64)]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:loop]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest($64),nest(char)]
< **** koks: < c2 on: 0 Items 
< **   father: c1 < c2
< **   father.f.f.f.f:
< 
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** getVqual:B2:
< [0:loop,nest($64),nest(char)]
< ---
< 
< <  : 
<    %basic 51
<    in V: var char
<    out B: var boolean
< **** Pattern:getVqual: <   :isVirtual:False
< [0:loop,nest($64),nest(char)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 51
<    in V: var char
<    out B: var boolean
< [0:loop,nest($64),nest(char)]
< **** savedOGS:save:was:[0:loop,nest($64),nest(char)]
< **   OI: < c2
< **   OI:getQual:savedOI:< c2
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64),nest(char)]
< **   OGS:[0:loop,nest($64)]
< **** DataItem:getVqual: out B: var boolean
< [0:loop,nest($64),nest(char),nest(<)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:loop,nest($64),nest(char),nest(<)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop,nest($64),nest(char),nest(<)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var char
<    out B: var boolean
< **** ENC:OI.getVqual:[1:loop,nest($64),nest(char),nest(<)]
< **   ENC:result:[1:loop,nest($64),nest(char)]
< **** ENC:OI.getVqual:[2:loop,nest($64),nest(char)]
< **   ENC:result:[2:loop,nest($64)]
< 
< **** getVqual:B2:
< [0:loop,nest($64)]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:loop,nest($64)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:loop,nest($64)]
< **** savedOGS:save:False[0:loop,nest($64)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64)]
< **   OGS:[0:loop,nest($64)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:loop,nest($64)]
< **** OI:getVqual:end: < c2
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< **** OI:getOIqual: "c2" IV:"c2"
< **   origin.encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:getVqual: c2 on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$64]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** koks: c2 on: 2 Items 
< **   father: c2
< **   father.f.f.f.f:
< c1 < c2
< **** ENC:OI.getVqual:[1:$64]
< **   ENC:result:[1:doit]
< **** ENC:OI.getVqual:[2:doit]
< **   ENC:result:[2:matchEq]
< 
< **** getVqual:B2:
< [0:matchEq]
< ---
< c2: var char
< **** DataItem:getVqual: c2: var char
< [0:matchEq]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:matchEq]
< 
< **** OI:getVqual: char on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:matchEq]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: char
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:matchEq]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:matchEq]
< **** ENC:OI.viaInclude:[0:matchEq]
< **   ENC:result:[0:loop]
< **** viaInclude:GOT:
< [0:loop,nest($64)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:loop,nest($64)]
< **** savedOGS:save:False[0:loop,nest($64)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64)]
< **   OGS:[0:loop,nest($64)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:loop,nest($64)]
< **** savedOGS:save:was:[0:loop,nest($64)]
< **   OI: c2
< **   OI:getQual:savedOI:c2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:loop,nest($64)]
< **   OGS:[0:$64]
< **** OI:getVqual:end: c2
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:loop,nest($64)]
< **** OI:getOIqual: "leave(matchEq)" IV:"leave(matchEq)"
< **   origin.encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< 
< **** OI:getVqual: leave(matchEq) on=7 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$64]
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **** OI:viaInclude:on=7 BETA %Include BETA
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:$64]
< ***** viaInclude:notTop: leave name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: leave(matchEq)
< **   encOG: 
< Beq := c1 < c2
<    leave(matchEq)
< **   OGS:[0:$64]
< **** ENC:OI.viaInclude:[0:$64]
< **   ENC:result:[0:doit]
< **** viaInclude:GOT:
< [0:doit,nest($64)]
< **** Pattern:getVqual: leave(V: var integer) :isVirtual:False
< [0:doit,nest($64)]
< **** savedOGS:save:was:[0:doit,nest($64)]
< **   OI: leave(matchEq)
< **   OI:getQual:savedOI:leave(matchEq)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:doit,nest($64)]
< **   OGS:[0:doit,nest($64)]
< **** OI:getVqual:end: leave(matchEq)
< **   qual: %basic 103
< ObjectGenerator
< **   OGS:[0:doit,nest($64)]
< **** DataItem:getVqual: T: var LIB.StringLib.String
< [0:puttext]
< **** ObjectGenerator:getVqual: LIB.StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:LIB.StringLib.String
< **   OGs: [0:puttext]
< 
< **** OI:getVqual: LIB on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:puttext]
< **   encOG: inner(puttext)
< **** koks: LIB on: 3 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< puttext(T: var LIB.StringLib.String)
< **** ENC:OI.getVqual:[1:puttext]
< **   ENC:result:[1:ConsoleIF]
< **** ENC:OI.getVqual:[2:ConsoleIF]
< **   ENC:result:[2:BETA]
< **** ENC:OI.getVqual:[3:BETA]
< **   ENC:result:[3:BETAworld]
< 
< **** getVqual:B2:
< [0:BETAworld]
< ---
< 
< --LIB
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:BETAworld]
< **** savedOGS:save:False[0:BETAworld]
< **   OI: LIB
< **   OI:getQual:savedOI:LIB
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld]
< **   OGS:[0:BETAworld]
< **** OI:getVqual:end: LIB
< **   qual: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld]
< 
< **** OI:getVqual: StringLib on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld]
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld]
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** getVqual:added:isNest:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:BETAworld,nest(LIB)]
< **** koks: StringLib on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< puttext(T: var LIB.StringLib.String)
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB)]
< ---
< 
< --StringLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:BETAworld,nest(LIB)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB)]
< **   OGS:[0:BETAworld,nest(LIB)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETAworld,nest(LIB)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETAworld,nest(LIB)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:BETAworld,nest(LIB),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< puttext(T: var LIB.StringLib.String)
< 
< **** getVqual:B2:
< [0:BETAworld,nest(LIB),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:BETAworld,nest(LIB),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:BETAworld,nest(LIB),nest(StringLib)]
< **** savedOGS:save:False[0:BETAworld,nest(LIB),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETAworld,nest(LIB),nest(StringLib)]
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETAworld,nest(LIB),nest(StringLib)]
< **** OI:getOIqual: "inner(puttext)" IV:"inner(puttext)"
< **   origin.encOG: inner(puttext)
< 
< **** OI:getVqual: inner(puttext) on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:puttext]
< **   encOG: inner(puttext)
< **** koks: inner(puttext) on: 2 Items 
< **   father: inner(puttext)
< **   father.f.f.f.f:
< 
< puttext(T: var LIB.StringLib.String):< 
<    inner(puttext)
< **** ENC:OI.getVqual:[1:puttext]
< **   ENC:result:[1:ConsoleIF]
< **** ENC:OI.getVqual:[2:ConsoleIF]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< inner: 
<    %basic 101
<    in inner: ref Object
< **** Pattern:getVqual: inner :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 101
<    in inner: ref Object
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inner(puttext)
< **   OI:getQual:savedOI:inner(puttext)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:puttext]
< **** OI:getVqual:end: inner(puttext)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "inner(putint)" IV:"inner(putint)"
< **   origin.encOG: inner(putint)
< 
< **** OI:getVqual: inner(putint) on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: inner(putint)
< **** koks: inner(putint) on: 2 Items 
< **   father: inner(putint)
< **   father.f.f.f.f:
< 
< putint(V: var Integer):< 
<    inner(putint)
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:ConsoleIF]
< **** ENC:OI.getVqual:[2:ConsoleIF]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< inner: 
<    %basic 101
<    in inner: ref Object
< **** Pattern:getVqual: inner :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 101
<    in inner: ref Object
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inner(putint)
< **   OI:getQual:savedOI:inner(putint)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: inner(putint)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "Schedule" IV:"Schedule"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "QS" IV:"QS.insert(Q)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: QS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: QS on: 0 Items 
< **   father: QS.insert(Q)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< QS: obj Qualifications
< **** DataItem:getVqual: QS: obj Qualifications
< [0:tinyY]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Qualifications on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 0 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: QS
< **   OI:getQual:savedOI:QS
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: QS
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "insert(Q)" IV:"QS.insert(Q)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: QS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: QS on: 0 Items 
< **   father: QS.insert(Q)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< QS: obj Qualifications
< **** DataItem:getVqual: QS: obj Qualifications
< [0:tinyY]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Qualifications on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 0 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: QS
< **   OI:getQual:savedOI:QS
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: QS
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: insert(Q) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:added:isNest:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Qualifications)]
< **** koks: insert(Q) on: 0 Items 
< **   father: QS.insert(Q)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Qualifications)]
< **** pathToSuper: "SetLib.Set(#Qualification)" of:DOG:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Qualification) :isImplSuper=False
< **   pathToSuper:E:"Set(#Qualification)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Qualification)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:tinyY,nest(Qualifications),r:Set]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Qualifications),r:Set]
< ---
< 
< insert:: 
<    head := link(e,head)
< **** Pattern:getVqual: insert :isVirtual:True
< [0:tinyY,nest(Qualifications),r:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Qualifications),r:Set]
< **** newFindBinding: 
< insert:: 
<    head := link(e,head)
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Qualifications),r:Set]
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Qualifications)]
< **   checkDOG: Qualifications 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< father:
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Qualification)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< insert:: 
<    head := link(e,head)
< **** newFindBinding:found: head := link(e,head)
< **** PTN:getVqual:gotBinding: head := link(e,head)
< 
< **** getVqual:cont:afterATd:qual:head := link(e,head)
< [0:tinyY,nest(Qualifications),r:Set&]
< **** savedOGS:save:was:[0:tinyY,nest(Qualifications&),r:Set&]
< **   OI: insert(Q)
< **   OI:getQual:savedOI:insert(Q)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Qualifications&),r:Set&]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: insert(Q)
< **   qual: head := link(e,head)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Qualifications),r:Set&]
< **** OI:getOIqual: "Q" IV:"Q"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: Q on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Q on: 0 Items 
< **   father: Q
< **   father.f.f.f.f:
< QS.insert(Q)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< Q: obj Qualification(17)
< **** DataItem:getVqual: Q: obj Qualification(17)
< [0:tinyY]
< **** ObjectGenerator:getVqual: Qualification(17)
< **   hasVirtualArgs: False
< **** INV:getVqual:Qualification(17)
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Qualification(17) on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualification(17) on: 0 Items 
< **   father: Qualification(17)
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualification: 
<    %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
< ...
< **** Pattern:getVqual: Qualification :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualification(17)
< **   OI:getQual:savedOI:Qualification(17)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualification(17)
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: Q
< **   OI:getQual:savedOI:Q
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Q
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "A" IV:"A"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: A on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: A on: 0 Items 
< **   father: A
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< A: ref Alarm
< **** DataItem:getVqual: A: ref Alarm
< [0:tinyY]
< **** ObjectGenerator:getVqual: Alarm
< **   hasVirtualArgs: False
< **** INV:getVqual:Alarm
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Alarm on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Alarm on: 0 Items 
< **   father: Alarm
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Alarm :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarm
< **   OI:getQual:savedOI:Alarm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarm
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: A
< **   OI:getQual:savedOI:A
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: A
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "Q" IV:"Q"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: Q on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Q on: 0 Items 
< **   father: Q
< **   father.f.f.f.f:
< Alarm("OverHeat",Q)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< Q: obj Qualification(17)
< **** DataItem:getVqual: Q: obj Qualification(17)
< [0:tinyY]
< **** ObjectGenerator:getVqual: Qualification(17)
< **   hasVirtualArgs: False
< **** INV:getVqual:Qualification(17)
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Qualification(17) on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualification(17) on: 0 Items 
< **   father: Qualification(17)
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualification: 
<    %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
< ...
< **** Pattern:getVqual: Qualification :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualification(17)
< **   OI:getQual:savedOI:Qualification(17)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualification(17)
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: Q
< **   OI:getQual:savedOI:Q
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Q
< **   qual: 
< %globals
<    in Q: var integer
<    print: 
<       "Qualification:".print
<       putint(Q)
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "E1" IV:"E1"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: E1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: E1 on: 0 Items 
< **   father: E1
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< E1: ref Expert
< **** DataItem:getVqual: E1: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E1
< **   OI:getQual:savedOI:E1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: E1
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "QS" IV:"QS"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: QS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: QS on: 0 Items 
< **   father: QS
< **   father.f.f.f.f:
< Expert("John",QS)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< QS: obj Qualifications
< **** DataItem:getVqual: QS: obj Qualifications
< [0:tinyY]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Qualifications on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 0 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: QS
< **   OI:getQual:savedOI:QS
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: QS
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "ES1" IV:"ES1.insert(E1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES1 on: 0 Items 
< **   father: ES1.insert(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES1: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES1: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES1
< **   OI:getQual:savedOI:ES1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES1
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "insert(E1)" IV:"ES1.insert(E1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES1 on: 0 Items 
< **   father: ES1.insert(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES1: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES1: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES1
< **   OI:getQual:savedOI:ES1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES1
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: insert(E1) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:added:isNest:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Experts)]
< **** koks: insert(E1) on: 0 Items 
< **   father: ES1.insert(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Experts)]
< **** pathToSuper: "SetLib.Set(#Expert)" of:DOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Expert) :isImplSuper=False
< **   pathToSuper:E:"Set(#Expert)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Expert)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:tinyY,nest(Experts),r:Set]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set]
< ---
< 
< insert:: 
<    head := link(e,head)
< **** Pattern:getVqual: insert :isVirtual:True
< [0:tinyY,nest(Experts),r:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set]
< **** newFindBinding: 
< insert:: 
<    head := link(e,head)
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Experts),r:Set]
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< insert:: 
<    head := link(e,head)
< **** newFindBinding:found: head := link(e,head)
< **** PTN:getVqual:gotBinding: head := link(e,head)
< 
< **** getVqual:cont:afterATd:qual:head := link(e,head)
< [0:tinyY,nest(Experts),r:Set&]
< **** savedOGS:save:was:[0:tinyY,nest(Experts&),r:Set&]
< **   OI: insert(E1)
< **   OI:getQual:savedOI:insert(E1)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: insert(E1)
< **   qual: head := link(e,head)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts),r:Set&]
< **** OI:getOIqual: "E1" IV:"E1"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: E1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: E1 on: 0 Items 
< **   father: E1
< **   father.f.f.f.f:
< ES1.insert(E1)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< E1: ref Expert
< **** DataItem:getVqual: E1: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E1
< **   OI:getQual:savedOI:E1
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: E1
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "E1" IV:"E1"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: E1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: E1 on: 0 Items 
< **   father: E1
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< E1: ref Expert
< **** DataItem:getVqual: E1: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E1
< **   OI:getQual:savedOI:E1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: E1
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "QS" IV:"QS"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: QS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: QS on: 0 Items 
< **   father: QS
< **   father.f.f.f.f:
< Expert("Laura",QS)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< QS: obj Qualifications
< **** DataItem:getVqual: QS: obj Qualifications
< [0:tinyY]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Qualifications on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 0 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: QS
< **   OI:getQual:savedOI:QS
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: QS
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "ES1" IV:"ES1.insert(E1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES1 on: 0 Items 
< **   father: ES1.insert(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES1: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES1: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES1
< **   OI:getQual:savedOI:ES1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES1
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "insert(E1)" IV:"ES1.insert(E1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES1 on: 0 Items 
< **   father: ES1.insert(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES1: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES1: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES1
< **   OI:getQual:savedOI:ES1
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES1
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: insert(E1) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:added:isNest:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Experts)]
< **** koks: insert(E1) on: 0 Items 
< **   father: ES1.insert(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Experts)]
< **** pathToSuper: "SetLib.Set(#Expert)" of:DOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Expert) :isImplSuper=False
< **   pathToSuper:E:"Set(#Expert)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Expert)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:tinyY,nest(Experts),r:Set]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set]
< ---
< 
< insert:: 
<    head := link(e,head)
< **** Pattern:getVqual: insert :isVirtual:True
< [0:tinyY,nest(Experts),r:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set]
< **** newFindBinding: 
< insert:: 
<    head := link(e,head)
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Experts),r:Set]
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< insert:: 
<    head := link(e,head)
< **** newFindBinding:found: head := link(e,head)
< **** PTN:getVqual:gotBinding: head := link(e,head)
< 
< **** getVqual:cont:afterATd:qual:head := link(e,head)
< [0:tinyY,nest(Experts),r:Set&]
< **** savedOGS:save:was:[0:tinyY,nest(Experts&),r:Set&]
< **   OI: insert(E1)
< **   OI:getQual:savedOI:insert(E1)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: insert(E1)
< **   qual: head := link(e,head)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts),r:Set&]
< **** OI:getOIqual: "E1" IV:"E1"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: E1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: E1 on: 0 Items 
< **   father: E1
< **   father.f.f.f.f:
< ES1.insert(E1)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< E1: ref Expert
< **** DataItem:getVqual: E1: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E1
< **   OI:getQual:savedOI:E1
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: E1
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "S" IV:"S.add(Period(0,8),ES1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: S on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: S on: 0 Items 
< **   father: S.add(Period(0,8),ES1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< S: obj Schedule
< **** DataItem:getVqual: S: obj Schedule
< [0:tinyY]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: S
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "add(Period(0,8),ES1)" IV:"S.add(Period(0,8),ES1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: S on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: S on: 0 Items 
< **   father: S.add(Period(0,8),ES1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< S: obj Schedule
< **** DataItem:getVqual: S: obj Schedule
< [0:tinyY]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: S
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: add(Period(0,8),ES1) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** getVqual:added:isNest:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY,nest(Schedule)]
< **** koks: add(Period(0,8),ES1) on: 0 Items 
< **   father: S.add(Period(0,8),ES1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Schedule)]
< **** pathToSuper: "MapLib.Map(#Period,#Experts)" of:DOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   pathToSuper:DOG.super.scanSons:i=1:E:MapLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Map(#Period,#Experts) :isImplSuper=False
< **   pathToSuper:E:"Map(#Period,#Experts)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Map(#Period,#Experts)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   PRE:result:[0:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map]
< ---
< 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **** Pattern:getVqual: add :isVirtual:False
< [0:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< [0:tinyY,nest(Schedule),r:Map]
< **** savedOGS:save:was:[0:tinyY,nest(Schedule&),r:Map]
< **   OI: add(Period(0,8),ES1)
< **   OI:getQual:savedOI:add(Period(0,8),ES1)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: add(Period(0,8),ES1)
< **   qual: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **** OI:getOIqual: "ES1" IV:"ES1"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES1 on: 0 Items 
< **   father: ES1
< **   father.f.f.f.f:
< S.add(Period(0,8),ES1)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES1: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES1: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES1
< **   OI:getQual:savedOI:ES1
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES1
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "E2" IV:"E2"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: E2 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: E2 on: 0 Items 
< **   father: E2
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< E2: ref Expert
< **** DataItem:getVqual: E2: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E2
< **   OI:getQual:savedOI:E2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: E2
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "QS" IV:"QS"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: QS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: QS on: 0 Items 
< **   father: QS
< **   father.f.f.f.f:
< Expert("Surayya",QS)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< QS: obj Qualifications
< **** DataItem:getVqual: QS: obj Qualifications
< [0:tinyY]
< **** ObjectGenerator:getVqual: Qualifications
< **   hasVirtualArgs: True
< **** INV:getVqual:Qualifications
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Qualifications on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Qualifications on: 0 Items 
< **   father: Qualifications
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Qualifications: SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Qualifications :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Qualifications
< **   OI:getQual:savedOI:Qualifications
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Qualifications
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: QS
< **   OI:getQual:savedOI:QS
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: QS
< **   qual: 
< SetLib.Set(#Qualification)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "ES2" IV:"ES2.insert(E2)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES2 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES2 on: 0 Items 
< **   father: ES2.insert(E2)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES2: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES2: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES2
< **   OI:getQual:savedOI:ES2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES2
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "insert(E2)" IV:"ES2.insert(E2)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES2 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES2 on: 0 Items 
< **   father: ES2.insert(E2)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES2: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES2: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES2
< **   OI:getQual:savedOI:ES2
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES2
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: insert(E2) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:added:isNest:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Experts)]
< **** koks: insert(E2) on: 0 Items 
< **   father: ES2.insert(E2)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Experts)]
< **** pathToSuper: "SetLib.Set(#Expert)" of:DOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Expert) :isImplSuper=False
< **   pathToSuper:E:"Set(#Expert)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Expert)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:tinyY,nest(Experts),r:Set]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set]
< ---
< 
< insert:: 
<    head := link(e,head)
< **** Pattern:getVqual: insert :isVirtual:True
< [0:tinyY,nest(Experts),r:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set]
< **** newFindBinding: 
< insert:: 
<    head := link(e,head)
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Experts),r:Set]
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< insert:: 
<    head := link(e,head)
< **** newFindBinding:found: head := link(e,head)
< **** PTN:getVqual:gotBinding: head := link(e,head)
< 
< **** getVqual:cont:afterATd:qual:head := link(e,head)
< [0:tinyY,nest(Experts),r:Set&]
< **** savedOGS:save:was:[0:tinyY,nest(Experts&),r:Set&]
< **   OI: insert(E2)
< **   OI:getQual:savedOI:insert(E2)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: insert(E2)
< **   qual: head := link(e,head)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts),r:Set&]
< **** OI:getOIqual: "E2" IV:"E2"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: E2 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: E2 on: 0 Items 
< **   father: E2
< **   father.f.f.f.f:
< ES2.insert(E2)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< E2: ref Expert
< **** DataItem:getVqual: E2: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E2
< **   OI:getQual:savedOI:E2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: E2
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "S" IV:"S.add(Period(8,16),ES2)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: S on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: S on: 0 Items 
< **   father: S.add(Period(8,16),ES2)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< S: obj Schedule
< **** DataItem:getVqual: S: obj Schedule
< [0:tinyY]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: S
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "add(Period(8,16),ES2)" IV:"S.add(Period(8,16),ES2)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: S on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: S on: 0 Items 
< **   father: S.add(Period(8,16),ES2)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< S: obj Schedule
< **** DataItem:getVqual: S: obj Schedule
< [0:tinyY]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: S
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: add(Period(8,16),ES2) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** getVqual:added:isNest:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY,nest(Schedule)]
< **** koks: add(Period(8,16),ES2) on: 0 Items 
< **   father: S.add(Period(8,16),ES2)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Schedule)]
< **** pathToSuper: "MapLib.Map(#Period,#Experts)" of:DOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   pathToSuper:DOG.super.scanSons:i=1:E:MapLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Map(#Period,#Experts) :isImplSuper=False
< **   pathToSuper:E:"Map(#Period,#Experts)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Map(#Period,#Experts)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   PRE:result:[0:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map]
< ---
< 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **** Pattern:getVqual: add :isVirtual:False
< [0:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< [0:tinyY,nest(Schedule),r:Map]
< **** savedOGS:save:was:[0:tinyY,nest(Schedule&),r:Map]
< **   OI: add(Period(8,16),ES2)
< **   OI:getQual:savedOI:add(Period(8,16),ES2)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: add(Period(8,16),ES2)
< **   qual: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **** OI:getOIqual: "ES2" IV:"ES2"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES2 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES2 on: 0 Items 
< **   father: ES2
< **   father.f.f.f.f:
< S.add(Period(8,16),ES2)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES2: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES2: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES2
< **   OI:getQual:savedOI:ES2
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES2
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "S" IV:"S.add(Period(16,24),ES1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: S on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: S on: 0 Items 
< **   father: S.add(Period(16,24),ES1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< S: obj Schedule
< **** DataItem:getVqual: S: obj Schedule
< [0:tinyY]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: S
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "add(Period(16,24),ES1)" IV:"S.add(Period(16,24),ES1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: S on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: S on: 0 Items 
< **   father: S.add(Period(16,24),ES1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< S: obj Schedule
< **** DataItem:getVqual: S: obj Schedule
< [0:tinyY]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: S
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: add(Period(16,24),ES1) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** getVqual:added:isNest:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY,nest(Schedule)]
< **** koks: add(Period(16,24),ES1) on: 0 Items 
< **   father: S.add(Period(16,24),ES1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Schedule)]
< **** pathToSuper: "MapLib.Map(#Period,#Experts)" of:DOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   pathToSuper:DOG.super.scanSons:i=1:E:MapLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Map(#Period,#Experts) :isImplSuper=False
< **   pathToSuper:E:"Map(#Period,#Experts)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Map(#Period,#Experts)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   PRE:result:[0:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map]
< ---
< 
< add: 
<    in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
< ...
< **** Pattern:getVqual: add :isVirtual:False
< [0:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< [0:tinyY,nest(Schedule),r:Map]
< **** savedOGS:save:was:[0:tinyY,nest(Schedule&),r:Map]
< **   OI: add(Period(16,24),ES1)
< **   OI:getQual:savedOI:add(Period(16,24),ES1)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule&),r:Map]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: add(Period(16,24),ES1)
< **   qual: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule),r:Map]
< **** OI:getOIqual: "ES1" IV:"ES1"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: ES1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: ES1 on: 0 Items 
< **   father: ES1
< **   father.f.f.f.f:
< S.add(Period(16,24),ES1)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< ES1: obj Experts --SetLib.Set(#Expert){}
< **** DataItem:getVqual: ES1: obj Experts --SetLib.Set(#Expert){}
< [0:tinyY]
< **** ObjectGenerator:getVqual: Experts --SetLib.Set(#Expert){}
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts --SetLib.Set(#Expert){}
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Experts --SetLib.Set(#Expert){} on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Experts --SetLib.Set(#Expert){} on: 0 Items 
< **   father: Experts --SetLib.Set(#Expert){}
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts --SetLib.Set(#Expert){}
< **   OI:getQual:savedOI:Experts --SetLib.Set(#Expert){}
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts --SetLib.Set(#Expert){}
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES1
< **   OI:getQual:savedOI:ES1
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: ES1
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "AS" IV:"AS.insert(A)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: AS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: AS on: 0 Items 
< **   father: AS.insert(A)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< AS: obj Alarms
< **** DataItem:getVqual: AS: obj Alarms
< [0:tinyY]
< **** ObjectGenerator:getVqual: Alarms
< **   hasVirtualArgs: True
< **** INV:getVqual:Alarms
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Alarms on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Alarms on: 0 Items 
< **   father: Alarms
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarms: SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** Pattern:getVqual: Alarms :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarms
< **   OI:getQual:savedOI:Alarms
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarms
< **   qual: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: AS
< **   OI:getQual:savedOI:AS
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: AS
< **   qual: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "insert(A)" IV:"AS.insert(A)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: AS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: AS on: 0 Items 
< **   father: AS.insert(A)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< AS: obj Alarms
< **** DataItem:getVqual: AS: obj Alarms
< [0:tinyY]
< **** ObjectGenerator:getVqual: Alarms
< **   hasVirtualArgs: True
< **** INV:getVqual:Alarms
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Alarms on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Alarms on: 0 Items 
< **   father: Alarms
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarms: SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** Pattern:getVqual: Alarms :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarms
< **   OI:getQual:savedOI:Alarms
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarms
< **   qual: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: AS
< **   OI:getQual:savedOI:AS
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: AS
< **   qual: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: insert(A) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< 
< **** getVqual:added:isNest:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY,nest(Alarms)]
< **** koks: insert(A) on: 0 Items 
< **   father: AS.insert(A)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(Alarms)]
< **** pathToSuper: "SetLib.Set(#Alarm)" of:DOG:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Alarm) :isImplSuper=False
< **   pathToSuper:E:"Set(#Alarm)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Alarm)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:tinyY,nest(Alarms),r:Set]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Alarms),r:Set]
< ---
< 
< insert:: 
<    head := link(e,head)
< **** Pattern:getVqual: insert :isVirtual:True
< [0:tinyY,nest(Alarms),r:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Alarms),r:Set]
< **** newFindBinding: 
< insert:: 
<    head := link(e,head)
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Alarms),r:Set]
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:tinyY,nest(Alarms)]
< **   checkDOG: Alarms 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< father:
< Alarms: SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **   Ex: Set(#Alarm)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< insert:: 
<    head := link(e,head)
< **** newFindBinding:found: head := link(e,head)
< **** PTN:getVqual:gotBinding: head := link(e,head)
< 
< **** getVqual:cont:afterATd:qual:head := link(e,head)
< [0:tinyY,nest(Alarms),r:Set&]
< **** savedOGS:save:was:[0:tinyY,nest(Alarms&),r:Set&]
< **   OI: insert(A)
< **   OI:getQual:savedOI:insert(A)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Alarms&),r:Set&]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: insert(A)
< **   qual: head := link(e,head)
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Alarms),r:Set&]
< **** OI:getOIqual: "A" IV:"A"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: A on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: A on: 0 Items 
< **   father: A
< **   father.f.f.f.f:
< AS.insert(A)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< A: ref Alarm
< **** DataItem:getVqual: A: ref Alarm
< [0:tinyY]
< **** ObjectGenerator:getVqual: Alarm
< **   hasVirtualArgs: False
< **** INV:getVqual:Alarm
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Alarm on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Alarm on: 0 Items 
< **   father: Alarm
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarm: 
<    in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Alarm :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarm
< **   OI:getQual:savedOI:Alarm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarm
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: A
< **   OI:getQual:savedOI:A
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: A
< **   qual: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "P" IV:"P.expertIsOnDutyR(E1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: P on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: P on: 0 Items 
< **   father: P.expertIsOnDutyR(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< P: obj Plant(AS,S)
<    
< **** DataItem:getVqual: 
< P: obj Plant(AS,S)
<    
< [0:tinyY]
< **** ObjectGenerator:getVqual: 
< Plant(AS,S)
<    
< **   hasVirtualArgs: False
< 
< **** getVqual:cont:afterATd:qual:
< Plant(AS,S)
<    
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: P
< **   OI:getQual:savedOI:P
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: P
< **   qual: 
< Plant(AS,S)
<    
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "expertIsOnDutyR(E1)" IV:"P.expertIsOnDutyR(E1)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: P on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: P on: 0 Items 
< **   father: P.expertIsOnDutyR(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< P: obj Plant(AS,S)
<    
< **** DataItem:getVqual: 
< P: obj Plant(AS,S)
<    
< [0:tinyY]
< **** ObjectGenerator:getVqual: 
< Plant(AS,S)
<    
< **   hasVirtualArgs: False
< 
< **** getVqual:cont:afterATd:qual:
< Plant(AS,S)
<    
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: P
< **   OI:getQual:savedOI:P
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: P
< **   qual: 
< Plant(AS,S)
<    
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: expertIsOnDutyR(E1) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< Plant(AS,S)
<    
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< Plant(AS,S)
<    
< 
< **** getVqual:added:isNest:
< Plant(AS,S)
<    
< [0:tinyY,nest(P)]
< **** koks: expertIsOnDutyR(E1) on: 0 Items 
< **   father: P.expertIsOnDutyR(E1)
< **   father.f.f.f.f:
< 
< tinyY: obj 
<    %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
< ...
< **** PRE: [0:tinyY,nest(P)]
< **** pathToSuper: "Plant(AS,S)" of:DOG:
< Plant(AS,S)
<    
< **   pathToSuper:DOG.super.scanSons:i=1:E:Plant(AS,S) :isImplSuper=False
< **   pathToSuper:E:"Plant(AS,S)" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Plant(AS,S)" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **   PRE:result:[0:tinyY,nest(P),Plant]
< 
< **** getVqual:B2:
< [0:tinyY,nest(P),Plant]
< ---
< 
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< **** Pattern:getVqual: expertIsOnDutyR :isVirtual:False
< [0:tinyY,nest(P),Plant]
< 
< **** getVqual:cont:afterATd:qual:
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< [0:tinyY,nest(P),Plant]
< **** savedOGS:save:was:[0:tinyY,nest(P),Plant]
< **   OI: expertIsOnDutyR(E1)
< **   OI:getQual:savedOI:expertIsOnDutyR(E1)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(P),Plant]
< **   OGS:[0:tinyY]
< **** DataItem:getVqual: out fp: ref Periods
< [0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **** ObjectGenerator:getVqual: Periods
< **   hasVirtualArgs: True
< **** INV:getVqual:Periods
< **   OGs: [0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< 
< **** OI:getVqual: Periods on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **   encOG: 
< Plant(AS,S)
<    
< **** koks: Periods on: 2 Items 
< **   father: Periods
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(P),Plant,nest(expertIsOnDutyR)]
< **   ENC:result:[1:tinyY,nest(P),Plant]
< **** ENC:OI.getVqual:[2:tinyY,nest(P),Plant]
< **** pathToSuper: "Plant(AS,S)" of:DOG:
< Plant(AS,S)
<    
< **   pathToSuper:DOG.super.scanSons:i=1:E:Plant(AS,S) :isImplSuper=False
< **   pathToSuper:E:"Plant(AS,S)" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Plant(AS,S)" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **   ENC:pred:  pred.DOG: 
< Plant(AS,S)
<    
< **   OGsuper: 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** ENC:OI.getVqual:[3:tinyY,nest(P)]
< **   ENC:result:[3:tinyY]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** Pattern:getVqual: Periods :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Periods
< **   OI:getQual:savedOI:Periods
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Periods
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getVqual:return: out fp: ref Periods
< **   qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
<          current.print
<          put('T')
< [0:tinyY]
< **** OI:getVqual:end: expertIsOnDutyR(E1)
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "E1" IV:"E1"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: E1 on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: E1 on: 0 Items 
< **   father: E1
< **   father.f.f.f.f:
< P.expertIsOnDutyR(E1)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< E1: ref Expert
< **** DataItem:getVqual: E1: ref Expert
< [0:tinyY]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Expert on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Expert on: 0 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: E1
< **   OI:getQual:savedOI:E1
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: E1
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "inner(Collection)" IV:"inner(Collection)"
< **   origin.encOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< 
< **** OI:getVqual: inner(Collection) on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Collection]
< **   encOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **** OI:viaInclude:on=2 BETA %Include BETA
< **   OI: inner(Collection)
< **   encOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS:[0:Collection]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(Collection)
< **   encOG: 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   OGS:[0:Collection]
< **** ENC:OI.viaInclude:[0:Collection]
< **   ENC:result:[0:Collections]
< **** viaInclude:GOT:
< [0:Collections,nest(Collection)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Collections,nest(Collection)]
< **** savedOGS:save:was:[0:Collections,nest(Collection)]
< **   OI: inner(Collection)
< **   OI:getQual:savedOI:inner(Collection)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(Collection)]
< **   OGS:[0:Collections,nest(Collection)]
< **** OI:getVqual:end: inner(Collection)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Collections,nest(Collection)]
< **** OI:getOIqual: "inner(scan)" IV:"inner(scan)"
< **   origin.encOG: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< 
< **** OI:getVqual: inner(scan) on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: inner(scan)
< **   encOG: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   OGS:[0:scan]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(scan)
< **   encOG: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   OGS:[0:scan]
< **** ENC:OI.viaInclude:[0:scan]
< **   ENC:result:[0:Collection]
< **** viaInclude:GOT:
< [0:Collection,nest(scan)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Collection,nest(scan)]
< **** savedOGS:save:was:[0:Collection,nest(scan)]
< **   OI: inner(scan)
< **   OI:getQual:savedOI:inner(scan)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collection,nest(scan)]
< **   OGS:[0:Collection,nest(scan)]
< **** OI:getVqual:end: inner(scan)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Collection,nest(scan)]
< **** OI:getOIqual: "inner(insert)" IV:"inner(insert)"
< **   origin.encOG: 
< in e: ref elm
<    inner(insert)
< 
< **** OI:getVqual: inner(insert) on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:insert]
< **   encOG: 
< in e: ref elm
<    inner(insert)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: inner(insert)
< **   encOG: 
< in e: ref elm
<    inner(insert)
< **   OGS:[0:insert]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(insert)
< **   encOG: 
< in e: ref elm
<    inner(insert)
< **   OGS:[0:insert]
< **** ENC:OI.viaInclude:[0:insert]
< **   ENC:result:[0:Collection]
< **** viaInclude:GOT:
< [0:Collection,nest(insert)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Collection,nest(insert)]
< **** savedOGS:save:was:[0:Collection,nest(insert)]
< **   OI: inner(insert)
< **   OI:getQual:savedOI:inner(insert)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collection,nest(insert)]
< **   OGS:[0:Collection,nest(insert)]
< **** OI:getVqual:end: inner(insert)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Collection,nest(insert)]
< **** OI:getOIqual: "inner(has)" IV:"inner(has)"
< **   origin.encOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< 
< **** OI:getVqual: inner(has) on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has]
< **   encOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: inner(has)
< **   encOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   OGS:[0:has]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(has)
< **   encOG: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   OGS:[0:has]
< **** ENC:OI.viaInclude:[0:has]
< **   ENC:result:[0:Collection]
< **** viaInclude:GOT:
< [0:Collection,nest(has)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Collection,nest(has)]
< **** savedOGS:save:was:[0:Collection,nest(has)]
< **   OI: inner(has)
< **   OI:getQual:savedOI:inner(has)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collection,nest(has)]
< **   OGS:[0:Collection,nest(has)]
< **** OI:getVqual:end: inner(has)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Collection,nest(has)]
< **** OI:getOIqual: "inner(remove)" IV:"inner(remove)"
< **   origin.encOG: 
< in E: ref elm
<    inner(remove)
< 
< **** OI:getVqual: inner(remove) on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:remove]
< **   encOG: 
< in E: ref elm
<    inner(remove)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: inner(remove)
< **   encOG: 
< in E: ref elm
<    inner(remove)
< **   OGS:[0:remove]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(remove)
< **   encOG: 
< in E: ref elm
<    inner(remove)
< **   OGS:[0:remove]
< **** ENC:OI.viaInclude:[0:remove]
< **   ENC:result:[0:Collection]
< **** viaInclude:GOT:
< [0:Collection,nest(remove)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Collection,nest(remove)]
< **** savedOGS:save:was:[0:Collection,nest(remove)]
< **   OI: inner(remove)
< **   OI:getQual:savedOI:inner(remove)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collection,nest(remove)]
< **   OGS:[0:Collection,nest(remove)]
< **** OI:getVqual:end: inner(remove)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Collection,nest(remove)]
< **** OI:getOIqual: "inner(Set)" IV:"inner(Set)"
< **   origin.encOG: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** OI:getVqual: inner(Set) on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: inner(Set)
< **   encOG: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   OGS:[0:Set]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(Set)
< **   encOG: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   OGS:[0:Set]
< **** ENC:OI.viaInclude:[0:Set]
< **   ENC:result:[0:SetLib]
< **** viaInclude:GOT:
< [0:SetLib,nest(Set)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:SetLib,nest(Set)]
< **** savedOGS:save:was:[0:SetLib,nest(Set)]
< **   OI: inner(Set)
< **   OI:getQual:savedOI:inner(Set)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:SetLib,nest(Set)]
< **   OGS:[0:SetLib,nest(Set)]
< **** OI:getVqual:end: inner(Set)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:SetLib,nest(Set)]
< **** OI:getOIqual: "B" IV:"B"
< **   origin.encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** OI:getVqual: B on=0 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:has]
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** koks: B on: 0 Items 
< **   father: B
< **   father.f.f.f.f:
< 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** getVqual:B2:
< [0:has,has]
< ---
< out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:has,has]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGS:[0:has,has]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGS:[0:has,has]
< **** ENC:OI.viaInclude:[0:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.viaInclude:[1:has]
< **   ENC:result:[1:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< **   ENC:result:[0:Set,Collection]
< **** viaInclude:GOT:
< [0:Set,Collection,nest(has)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection,nest(has)]
< **** savedOGS:save:False[0:Set,Collection,nest(has)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest(has)]
< **   OGS:[0:Set,Collection,nest(has)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest(has)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set,Collection,nest(has)]
< **** savedOGS:save:was:[0:Set,Collection,nest(has)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest(has)]
< **   OGS:[0:has]
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest(has)]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** OI:getVqual: nxt on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** koks: nxt on: 0 Items 
< **   father: nxt
< **   father.f.f.f.f:
< 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:scan]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "head" IV:"head"
< **   origin.encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** OI:getVqual: head on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** koks: head on: 1 Items 
< **   father: head
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Set]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Set]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:scan]
< **** OI:getVqual:end: head
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "nxt" IV:"nxt =/= none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: nxt on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: nxt on: 1 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:Loop]
< **   ENC:result:[1:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Loop]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "=/= none" IV:"nxt =/= none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: nxt on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: nxt on: 1 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:Loop]
< **   ENC:result:[1:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Loop]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** OI:getVqual: =/= none on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Set]
< **   encOG:
< in e: ref elm
<    in next: ref link
< 
< **** getVqual:added:isNest:
< in e: ref elm
<    in next: ref link
< [0:Set,nest(link)]
< **** koks: =/= none on: 0 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** PRE: [0:Set,nest(link)]
< **** pathToSuper: "" of:DOG:
< in e: ref elm
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   PRE:result:[0:Set,nest(link),Object]
< 
< **** getVqual:B2:
< [0:Set,nest(link),Object]
< ---
< 
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: =/=   :isVirtual:False
< [0:Set,nest(link),Object]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< [0:Set,nest(link),Object]
< **** savedOGS:save:was:[0:Set,nest(link),Object]
< **   OI: =/= none
< **   OI:getQual:savedOI:=/= none
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(link),Object]
< **   OGS:[0:Set]
< **** DataItem:getVqual: out V: var boolean
< [0:Set,nest(link),Object,nest(=/=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Set,nest(link),Object,nest(=/=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link),Object,nest(=/=)]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,nest(link),Object,nest(=/=)]
< **   ENC:result:[1:Set,nest(link),Object]
< **** ENC:OI.getVqual:[2:Set,nest(link),Object]
< **** pathToSuper: "" of:DOG:
< in e: ref elm
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in e: ref elm
<    in next: ref link
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Set,nest(link)]
< **   ENC:result:[3:Set]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Set]
< **** OI:getVqual:end: =/= none
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "=/= none" IV:"nxt =/= none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: nxt on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: nxt on: 1 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:Loop]
< **   ENC:result:[1:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Loop]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** OI:getVqual: =/= none on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Set]
< **   encOG:
< in e: ref elm
<    in next: ref link
< 
< **** getVqual:added:isNest:
< in e: ref elm
<    in next: ref link
< [0:Set,nest(link)]
< **** koks: =/= none on: 0 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** PRE: [0:Set,nest(link)]
< **** pathToSuper: "" of:DOG:
< in e: ref elm
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   PRE:result:[0:Set,nest(link),Object]
< 
< **** getVqual:B2:
< [0:Set,nest(link),Object]
< ---
< 
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: =/=   :isVirtual:False
< [0:Set,nest(link),Object]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< [0:Set,nest(link),Object]
< **** savedOGS:save:was:[0:Set,nest(link),Object]
< **   OI: =/= none
< **   OI:getQual:savedOI:=/= none
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,nest(link),Object]
< **   OGS:[0:Set]
< **** DataItem:getVqual: out V: var boolean
< [0:Set,nest(link),Object,nest(=/=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Set,nest(link),Object,nest(=/=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link),Object,nest(=/=)]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,nest(link),Object,nest(=/=)]
< **   ENC:result:[1:Set,nest(link),Object]
< **** ENC:OI.getVqual:[2:Set,nest(link),Object]
< **** pathToSuper: "" of:DOG:
< in e: ref elm
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in e: ref elm
<    in next: ref link
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Set,nest(link)]
< **   ENC:result:[3:Set]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Set]
< **** OI:getVqual:end: =/= none
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "none" IV:"none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: none on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: none
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   OGS:[0:Loop]
< ***** viaInclude:notTop: none name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: none
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   OGS:[0:Loop]
< **** ENC:OI.viaInclude:[0:Loop]
< **   ENC:result:[0:scan]
< **** viaInclude:GOT:
< [0:scan,nest(Loop)]
< **** Pattern:getVqual: none :isVirtual:False
< [0:scan,nest(Loop)]
< **** savedOGS:save:was:[0:scan,nest(Loop)]
< **   OI: none
< **   OI:getQual:savedOI:none
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:scan,nest(Loop)]
< **   OGS:[0:scan,nest(Loop)]
< **** OI:getVqual:end: none
< **   qual: 
< %basic 19
<    none_x: var integer
< ObjectGenerator
< **   OGS:[0:scan,nest(Loop)]
< **** OI:getOIqual: "current" IV:"current"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: current on=2 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: current on: 2 Items 
< **   father: current
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:$146]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< **** PRE: [0:scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   innerDOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:result:[0:scan,scan]
< 
< **** getVqual:B2:
< [0:scan,scan]
< ---
< current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan,scan]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan,scan]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan,scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[1:scan,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   innerDOG: 
< if (nxt =/= none) :then 
<       current := nxt.e
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   ENC:pred:  pred.DOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[2:scan]
< **   ENC:result:[2:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Set,Collection]
< **   ENC:result:[1:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:$146]
< **** OI:getVqual:end: current
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getOIqual: "nxt" IV:"nxt.e"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt.e
< **   father.f.f.f.f:
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** ENC:OI.getVqual:[1:$146]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:$146]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "e" IV:"nxt.e"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt.e
< **   father.f.f.f.f:
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** ENC:OI.getVqual:[1:$146]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:$146]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** OI:getVqual: e on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Set]
< **   encOG:
< in e: ref elm
<    in next: ref link
< 
< **** getVqual:added:isNest:
< in e: ref elm
<    in next: ref link
< [0:Set,nest(link)]
< **** koks: e on: 0 Items 
< **   father: nxt.e
< **   father.f.f.f.f:
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** getVqual:B2:
< [0:Set,nest(link)]
< ---
< in e: ref elm
< **** DataItem:getVqual: in e: ref elm
< [0:Set,nest(link)]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:Set,nest(link)]
< 
< **** OI:getVqual: elm on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link)]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    in next: ref link
< **** ENC:OI.getVqual:[1:Set,nest(link)]
< **   ENC:result:[1:Set]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set]
< **** OI:getVqual:end: e
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getOIqual: "inner(scan)" IV:"inner(scan)"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: inner(scan) on=6 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OI:viaInclude:on=6 BETA %Include BETA
< **   OI: inner(scan)
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$146]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(scan)
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$146]
< **** ENC:OI.viaInclude:[0:$146]
< **   ENC:result:[0:Loop]
< **** viaInclude:GOT:
< [0:Loop,nest($146)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Loop,nest($146)]
< **** savedOGS:save:was:[0:Loop,nest($146)]
< **   OI: inner(scan)
< **   OI:getQual:savedOI:inner(scan)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Loop,nest($146)]
< **   OGS:[0:Loop,nest($146)]
< **** OI:getVqual:end: inner(scan)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Loop,nest($146)]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:$146]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:$146]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "nxt" IV:"nxt.next"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt.next
< **   father.f.f.f.f:
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** ENC:OI.getVqual:[1:$146]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:$146]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "next" IV:"nxt.next"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt.next
< **   father.f.f.f.f:
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** ENC:OI.getVqual:[1:$146]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:$146]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** OI:getVqual: next on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Set]
< **   encOG:
< in e: ref elm
<    in next: ref link
< 
< **** getVqual:added:isNest:
< in e: ref elm
<    in next: ref link
< [0:Set,nest(link)]
< **** koks: next on: 0 Items 
< **   father: nxt.next
< **   father.f.f.f.f:
< 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** getVqual:B2:
< [0:Set,nest(link)]
< ---
< in next: ref link
< **** DataItem:getVqual: in next: ref link
< [0:Set,nest(link)]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Set,nest(link)]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,nest(link)]
< **   encOG: 
< in e: ref elm
<    in next: ref link
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in e: ref elm
<    in next: ref link
< **** ENC:OI.getVqual:[1:Set,nest(link)]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: next
< **   OI:getQual:savedOI:next
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: next
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "restart(Loop)" IV:"restart(Loop)"
< **   origin.encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: restart(Loop) on=6 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$146]
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OI:viaInclude:on=6 BETA %Include BETA
< **   OI: restart(Loop)
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$146]
< ***** viaInclude:notTop: restart name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: restart(Loop)
< **   encOG: 
< current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$146]
< **** ENC:OI.viaInclude:[0:$146]
< **   ENC:result:[0:Loop]
< **** viaInclude:GOT:
< [0:Loop,nest($146)]
< **** Pattern:getVqual: restart(V: var integer) :isVirtual:False
< [0:Loop,nest($146)]
< **** savedOGS:save:was:[0:Loop,nest($146)]
< **   OI: restart(Loop)
< **   OI:getQual:savedOI:restart(Loop)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Loop,nest($146)]
< **   OGS:[0:Loop,nest($146)]
< **** OI:getVqual:end: restart(Loop)
< **   qual: 
< -- odd parameter type!
<    %basic 102
< ObjectGenerator
< **   OGS:[0:Loop,nest($146)]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: nxt := nxt
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$147]
< **   encOG: nxt := nxt
< **** koks: nxt on: 2 Items 
< **   father: nxt
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt.e
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:$147]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: nxt := nxt
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:$147]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: nxt := nxt
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$147]
< **   encOG: nxt := nxt
< **** koks: nxt on: 2 Items 
< **   father: nxt
< **   father.f.f.f.f:
< nxt := nxt
< **** ENC:OI.getVqual:[1:$147]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref link
< **** DataItem:getVqual: nxt: ref link
< [0:scan]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: nxt := nxt
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:$147]
< **** OI:getVqual:end: nxt
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "scan" IV:"scan"
< **   origin.encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** OI:getVqual: scan on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has]
< **   encOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** koks: scan on: 1 Items 
< **   father: scan
< **   father.f.f.f.f:
< 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **** ENC:OI.getVqual:[1:has]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **** Pattern:getVqual: scan :isVirtual:True
< [0:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set]
< **** newFindBinding: 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **** searchBinding: 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **** newFindBinding:found: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** PTN:getVqual:gotBinding: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** getVqual:cont:afterATd:qual:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< [0:Set&]
< **** savedOGS:save:was:[0:Set&]
< **   OI: scan
< **   OI:getQual:savedOI:scan
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set&]
< **   OGS:[0:has]
< **** OI:getVqual:end: scan
< **   qual: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< ObjectGenerator
< **   OGS:[0:Set&]
< **** OI:getOIqual: "current" IV:"current == e"
< **   origin.encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** OI:getVqual: current on=0 pn=2 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$113]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: current on: 0 Items 
< **   father: current == e
< **   father.f.f.f.f:
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< **** PRE: [0:scan$113]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   PRE:result:[0:scan$113,scan]
< **** PRE: [0:scan$113,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:result:[0:scan$113,scan,scan]
< 
< **** getVqual:B2:
< [0:scan$113,scan,scan]
< ---
< current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan$113,scan,scan]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan$113,scan,scan]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$113,scan,scan]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[1:scan$113,scan,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   ENC:pred:  pred.DOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[2:scan$113,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   OGsuper: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[3:scan$113]
< **   ENC:result:[3:has]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:has]
< **   ENC:result:[3:Set]
< **   ENC:result:[2:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Set,Collection]
< **   ENC:result:[1:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:scan$113]
< **** OI:getVqual:end: current
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getOIqual: "== e" IV:"current == e"
< **   origin.encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** OI:getVqual: current on=0 pn=2 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$113]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: current on: 0 Items 
< **   father: current == e
< **   father.f.f.f.f:
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< **** PRE: [0:scan$113]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   PRE:result:[0:scan$113,scan]
< **** PRE: [0:scan$113,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:result:[0:scan$113,scan,scan]
< 
< **** getVqual:B2:
< [0:scan$113,scan,scan]
< ---
< current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan$113,scan,scan]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan$113,scan,scan]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$113,scan,scan]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[1:scan$113,scan,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   ENC:pred:  pred.DOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[2:scan$113,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   OGsuper: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[3:scan$113]
< **   ENC:result:[3:has]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:has]
< **   ENC:result:[3:Set]
< **   ENC:result:[2:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Set,Collection]
< **   ENC:result:[1:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:scan$113]
< **** OI:getVqual:end: current
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** OI:getVqual: == e on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Set,Collection&]
< **   encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Set,Collection&]
< **   encOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:added:isNest:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&,nest(Object)]
< **** koks: == e on: 0 Items 
< **   father: current == e
< **   father.f.f.f.f:
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< 
< **** getVqual:B2:
< [0:Set,Collection&,nest(Object)]
< ---
< 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: ==   :isVirtual:False
< [0:Set,Collection&,nest(Object)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< [0:Set,Collection&,nest(Object)]
< **** savedOGS:save:was:[0:Set,Collection&,nest(Object)]
< **   OI: == e
< **   OI:getQual:savedOI:== e
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&,nest(Object)]
< **   OGS:[0:Set,Collection&]
< **** DataItem:getVqual: out V: var boolean
< [0:Set,Collection&,nest(Object),nest(==)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Set,Collection&,nest(Object),nest(==)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,Collection&,nest(Object),nest(==)]
< **   encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,Collection&,nest(Object),nest(==)]
< **   ENC:result:[1:Set,Collection&,nest(Object)]
< **** ENC:OI.getVqual:[2:Set,Collection&,nest(Object)]
< **   ENC:result:[2:Set,Collection&]
< 
< **** getVqual:B2:
< [0:Set,Collection&]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Set,Collection&]
< **** OI:getVqual:end: == e
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getOIqual: "== e" IV:"current == e"
< **   origin.encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** OI:getVqual: current on=0 pn=2 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$113]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: current on: 0 Items 
< **   father: current == e
< **   father.f.f.f.f:
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< **** PRE: [0:scan$113]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   PRE:result:[0:scan$113,scan]
< **** PRE: [0:scan$113,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:result:[0:scan$113,scan,scan]
< 
< **** getVqual:B2:
< [0:scan$113,scan,scan]
< ---
< current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan$113,scan,scan]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan$113,scan,scan]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$113,scan,scan]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[1:scan$113,scan,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   ENC:pred:  pred.DOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[2:scan$113,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   OGsuper: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[3:scan$113]
< **   ENC:result:[3:has]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[3:has]
< **   ENC:result:[3:Set]
< **   ENC:result:[2:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Set,Collection]
< **   ENC:result:[1:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:scan$113]
< **** OI:getVqual:end: current
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** OI:getVqual: == e on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Set,Collection&]
< **   encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Set,Collection&]
< **   encOG:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:added:isNest:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&,nest(Object)]
< **** koks: == e on: 0 Items 
< **   father: current == e
< **   father.f.f.f.f:
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< 
< **** getVqual:B2:
< [0:Set,Collection&,nest(Object)]
< ---
< 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: ==   :isVirtual:False
< [0:Set,Collection&,nest(Object)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< [0:Set,Collection&,nest(Object)]
< **** savedOGS:save:was:[0:Set,Collection&,nest(Object)]
< **   OI: == e
< **   OI:getQual:savedOI:== e
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&,nest(Object)]
< **   OGS:[0:Set,Collection&]
< **** DataItem:getVqual: out V: var boolean
< [0:Set,Collection&,nest(Object),nest(==)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Set,Collection&,nest(Object),nest(==)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set,Collection&,nest(Object),nest(==)]
< **   encOG: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Set,Collection&,nest(Object),nest(==)]
< **   ENC:result:[1:Set,Collection&,nest(Object)]
< **** ENC:OI.getVqual:[2:Set,Collection&,nest(Object)]
< **   ENC:result:[2:Set,Collection&]
< 
< **** getVqual:B2:
< [0:Set,Collection&]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Set,Collection&]
< **** OI:getVqual:end: == e
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getOIqual: "e" IV:"e"
< **   origin.encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< 
< **** OI:getVqual: e on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$113]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: e on: 1 Items 
< **   father: e
< **   father.f.f.f.f:
< current == e
< **** ENC:OI.getVqual:[1:scan$113]
< **   ENC:result:[1:has]
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** getVqual:B2:
< [0:has,has]
< ---
< in E: ref elm
< **** DataItem:getVqual: in E: ref elm
< [0:has,has]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[1:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.getVqual:[2:has]
< **   ENC:result:[2:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Set,Collection]
< **   ENC:result:[1:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:scan$113]
< **** OI:getVqual:end: e
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getOIqual: "B" IV:"B"
< **   origin.encOG: 
< B := true
<    leave(has)
< 
< **** OI:getVqual: B on=2 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$114]
< **   encOG: 
< B := true
<    leave(has)
< **** koks: B on: 2 Items 
< **   father: B
< **   father.f.f.f.f:
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< **** ENC:OI.getVqual:[1:$114]
< **   ENC:result:[1:scan$113]
< **** ENC:OI.getVqual:[2:scan$113]
< **   ENC:result:[2:has]
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** getVqual:B2:
< [0:has,has]
< ---
< out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:has,has]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: 
< B := true
<    leave(has)
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: 
< B := true
<    leave(has)
< **   OGS:[0:has,has]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< B := true
<    leave(has)
< **   OGS:[0:has,has]
< **** ENC:OI.viaInclude:[0:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.viaInclude:[1:has]
< **   ENC:result:[1:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< **   ENC:result:[0:Set,Collection]
< **** viaInclude:GOT:
< [0:Set,Collection,nest($114)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection,nest($114)]
< **** savedOGS:save:False[0:Set,Collection,nest($114)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($114)]
< **   OGS:[0:Set,Collection,nest($114)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($114)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set,Collection,nest($114)]
< **** savedOGS:save:was:[0:Set,Collection,nest($114)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($114)]
< **   OGS:[0:$114]
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($114)]
< **** OI:getOIqual: "leave(has)" IV:"leave(has)"
< **   origin.encOG: 
< B := true
<    leave(has)
< 
< **** OI:getVqual: leave(has) on=6 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$114]
< **   encOG: 
< B := true
<    leave(has)
< **** OI:viaInclude:on=6 BETA %Include BETA
< **   OI: leave(has)
< **   encOG: 
< B := true
<    leave(has)
< **   OGS:[0:$114]
< ***** viaInclude:notTop: leave name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: leave(has)
< **   encOG: 
< B := true
<    leave(has)
< **   OGS:[0:$114]
< **** ENC:OI.viaInclude:[0:$114]
< **   ENC:result:[0:scan$113]
< **** viaInclude:GOT:
< [0:scan$113,nest($114)]
< **** Pattern:getVqual: leave(V: var integer) :isVirtual:False
< [0:scan$113,nest($114)]
< **** savedOGS:save:was:[0:scan$113,nest($114)]
< **   OI: leave(has)
< **   OI:getQual:savedOI:leave(has)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:scan$113,nest($114)]
< **   OGS:[0:scan$113,nest($114)]
< **** OI:getVqual:end: leave(has)
< **   qual: %basic 103
< ObjectGenerator
< **   OGS:[0:scan$113,nest($114)]
< **** OI:getOIqual: "B" IV:"B"
< **   origin.encOG: B := B
< 
< **** OI:getVqual: B on=2 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$115]
< **   encOG: B := B
< **** koks: B on: 2 Items 
< **   father: B
< **   father.f.f.f.f:
< 
< if (current == e) :then 
<    B := true
<    leave(has)
< :else 
<    B := B
< **** ENC:OI.getVqual:[1:$115]
< **   ENC:result:[1:scan$113]
< **** ENC:OI.getVqual:[2:scan$113]
< **   ENC:result:[2:has]
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** getVqual:B2:
< [0:has,has]
< ---
< out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:has,has]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: B := B
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: B := B
< **   OGS:[0:has,has]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: B := B
< **   OGS:[0:has,has]
< **** ENC:OI.viaInclude:[0:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.viaInclude:[1:has]
< **   ENC:result:[1:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< **   ENC:result:[0:Set,Collection]
< **** viaInclude:GOT:
< [0:Set,Collection,nest($115)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection,nest($115)]
< **** savedOGS:save:False[0:Set,Collection,nest($115)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($115)]
< **   OGS:[0:Set,Collection,nest($115)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($115)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set,Collection,nest($115)]
< **** savedOGS:save:was:[0:Set,Collection,nest($115)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($115)]
< **   OGS:[0:$115]
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($115)]
< **** OI:getOIqual: "B" IV:"B"
< **   origin.encOG: B := B
< 
< **** OI:getVqual: B on=2 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$115]
< **   encOG: B := B
< **** koks: B on: 2 Items 
< **   father: B
< **   father.f.f.f.f:
< B := B
< **** ENC:OI.getVqual:[1:$115]
< **   ENC:result:[1:scan$113]
< **** ENC:OI.getVqual:[2:scan$113]
< **   ENC:result:[2:has]
< **** PRE: [0:has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **   PRE:result:[0:has,has]
< 
< **** getVqual:B2:
< [0:has,has]
< ---
< out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:has,has]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:has,has]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:has,has]
< **   encOG: B := B
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: B := B
< **   OGS:[0:has,has]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: B := B
< **   OGS:[0:has,has]
< **** ENC:OI.viaInclude:[0:has,has]
< **** pathToSuper: "" of:DOG:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   innerDOG: 
< scan
<    if (current == e) :then 
<       B := true
<       leave(has)
<    :else 
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< has:< 
<    in E: ref elm
<    out B: var boolean
<    inner(has)
< **   ENC:pred:  pred.DOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   OGsuper: 
< in E: ref elm
<    out B: var boolean
<    inner(has)
< **** ENC:OI.viaInclude:[1:has]
< **   ENC:result:[1:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [0:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[0:Set,Collection]
< **   ENC:result:[0:Set,Collection]
< **** viaInclude:GOT:
< [0:Set,Collection,nest($115)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Set,Collection,nest($115)]
< **** savedOGS:save:False[0:Set,Collection,nest($115)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($115)]
< **   OGS:[0:Set,Collection,nest($115)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($115)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Set,Collection,nest($115)]
< **** savedOGS:save:was:[0:Set,Collection,nest($115)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection,nest($115)]
< **   OGS:[0:$115]
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection,nest($115)]
< **** OI:getOIqual: "head" IV:"head"
< **   origin.encOG: head := link(e,head)
< 
< **** OI:getVqual: head on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:insert]
< **   encOG: head := link(e,head)
< **** koks: head on: 1 Items 
< **   father: head
< **   father.f.f.f.f:
< 
< insert:: 
<    head := link(e,head)
< **** ENC:OI.getVqual:[1:insert]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Set]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Set]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: head := link(e,head)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:insert]
< **** OI:getVqual:end: head
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "link(e,head)" IV:"link(e,head)"
< **   origin.encOG: head := link(e,head)
< 
< **** OI:getVqual: link(e,head) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:insert]
< **   encOG: head := link(e,head)
< **** koks: link(e,head) on: 1 Items 
< **   father: link(e,head)
< **   father.f.f.f.f:
< head := link(e,head)
< **** ENC:OI.getVqual:[1:insert]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: link(e,head)
< **   OI:getQual:savedOI:link(e,head)
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:insert]
< **** OI:getVqual:end: link(e,head)
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "e" IV:"e"
< **   origin.encOG: head := link(e,head)
< 
< **** OI:getVqual: e on=0 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:insert]
< **   encOG: head := link(e,head)
< **** koks: e on: 0 Items 
< **   father: e
< **   father.f.f.f.f:
< link(e,head)
< **** PRE: [0:insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< in e: ref elm
<    inner(insert)
< **   PRE:result:[0:insert,insert]
< 
< **** getVqual:B2:
< [0:insert,insert]
< ---
< in e: ref elm
< **** DataItem:getVqual: in e: ref elm
< [0:insert,insert]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:insert,insert]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:insert,insert]
< **   encOG: head := link(e,head)
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[1:insert,insert]
< **** pathToSuper: "" of:DOG:head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< insert:< 
<    in e: ref elm
<    inner(insert)
< **   ENC:pred:  pred.DOG: head := link(e,head)
< **   OGsuper: 
< in e: ref elm
<    inner(insert)
< **** ENC:OI.getVqual:[2:insert]
< **   ENC:result:[2:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   innerDOG: head := link(e,head)
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Set,Collection]
< **   ENC:result:[1:Set,Collection]
< 
< **** getVqual:B2:
< [0:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Set]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   Ex: Collection
< **   Ex.OGs.super:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   checkDOG: Collection 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< father:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< 
<  ==== FOUND BINDING: =====
< in elm:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:False[0:Set,Collection&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:Set,Collection&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Set,Collection&]
< **** savedOGS:save:was:[0:Set,Collection&]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set,Collection&]
< **   OGS:[0:insert]
< **** OI:getVqual:end: e
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Set,Collection&]
< **** OI:getOIqual: "head" IV:"head"
< **   origin.encOG: head := link(e,head)
< 
< **** OI:getVqual: head on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:insert]
< **   encOG: head := link(e,head)
< **** koks: head on: 1 Items 
< **   father: head
< **   father.f.f.f.f:
< link(e,head)
< **** ENC:OI.getVqual:[1:insert]
< **   ENC:result:[1:Set]
< 
< **** getVqual:B2:
< [0:Set]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Set]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Set]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Set]
< **   encOG: head := link(e,head)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** getVqual:B2:
< [0:Set]
< ---
< 
< link: 
<    in e: ref elm
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:False[0:Set]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:Set]
< **** OI:getVqual:end: link
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< 
< **** getVqual:cont:afterATd:qual:
< in e: ref elm
<    in next: ref link
< [0:Set]
< **** savedOGS:save:was:[0:Set]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Set]
< **   OGS:[0:insert]
< **** OI:getVqual:end: head
< **   qual: 
< in e: ref elm
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Set]
< **** OI:getOIqual: "get[inx]" IV:"get[inx]"
< **   origin.encOG: put(get[inx])
< 
< **** OI:getVqual: get[inx] on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$104]
< **   encOG: put(get[inx])
< **** koks: get[inx] on: 3 Items 
< **   father: get[inx]
< **   father.f.f.f.f:
< put(get[inx])
< **** ENC:OI.getVqual:[1:repeat$104]
< **   ENC:result:[1:for:to:repeat$106]
< **** ENC:OI.getVqual:[2:for:to:repeat$106]
< **   ENC:result:[2:print]
< **** ENC:OI.getVqual:[3:print]
< **   ENC:result:[3:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: get[inx]
< **   OI:getQual:savedOI:get[inx]
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:repeat$104]
< **** DataItem:getVqual: out ch: var char
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: put(get[inx])
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: put(get[inx])
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: put(get[inx])
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$104)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:String,nest(repeat$104)]
< **** savedOGS:save:False[0:String,nest(repeat$104)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$104)]
< **   OGS:[0:String,nest(repeat$104)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$104)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:String,nest(repeat$104)]
< **** OI:getVqual:end: get[inx]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$104)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: put(get[inx])
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$104]
< **   encOG: put(get[inx])
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< get[inx]
< **** ENC:OI.getVqual:[1:repeat$104]
< **   ENC:result:[1:for:to:repeat$106]
< **** PRE: [0:for:to:repeat$106]
< **** pathToSuper: "
< for(1):to(length):repeat
<    put(get[inx])
< 
< " of:DOG:
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   innerDOG: put(get[inx])
< *** got:innerDOG:1 put(get[inx])**   pathToSuper:E:"
< for(1):to(length):repeat
<    put(get[inx])
< 
< " E.on=3 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(length):repeat
<    put(get[inx])
< 
< " :on=3:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:3,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$106,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$106,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$106,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$106,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$106,for:to:repeat]
< **   encOG: put(get[inx])
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$106,for:to:repeat]
< **** pathToSuper: "
< for(1):to(length):repeat
<    put(get[inx])
< 
< " of:DOG:
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   innerDOG: put(get[inx])
< *** got:innerDOG:1 put(get[inx])**   pathToSuper:E:"
< for(1):to(length):repeat
<    put(get[inx])
< 
< " E.on=3 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(length):repeat
<    put(get[inx])
< 
< " :on=3:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$106]
< **   ENC:result:[2:print]
< **   ENC:[pnx=0]oENC[onx=3]
< **** ENC:OI.getVqual:[2:print]
< **   ENC:result:[2:String]
< **** ENC:OI.getVqual:[3:String]
< **   ENC:result:[3:StringLib]
< **** ENC:OI.getVqual:[4:StringLib]
< **   ENC:result:[4:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:repeat$104]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "length" IV:"length"
< **   origin.encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< 
< **** OI:getVqual: length on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:print]
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** koks: length on: 1 Items 
< **   father: length
< **   father.f.f.f.f:
< 
< for(1):to(length):repeat
<    put(get[inx])
< 
< **** ENC:OI.getVqual:[1:print]
< **   ENC:result:[1:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: length
< **   OI:getQual:savedOI:length
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:print]
< **** DataItem:getVqual: out V: var integer
< [0:String,nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(length)]
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   OGS:[0:String,nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< gogo: 
<       "gogo\n".print
<    for(1):to(length):repeat
<       put(get[inx])
<    
< **   OGS:[0:String,nest(length)]
< **** ENC:OI.viaInclude:[0:String,nest(length)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(print)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(print)]
< **** savedOGS:save:False[0:String,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(print)]
< **   OGS:[0:String,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(print)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:String,nest(print)]
< **** OI:getVqual:end: length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(print)]
< **** DataItem:getVqual: in name: var StringLib.String
< [0:Expert]
< **** ObjectGenerator:getVqual: StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:StringLib.String
< **   OGs: [0:Expert]
< 
< **** OI:getVqual: StringLib on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Expert]
< **   encOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **** OI:viaInclude:on=2 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: StringLib
< **   encOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS:[0:Expert]
< ***** viaInclude:notTop: StringLib name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: StringLib
< **   encOG: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< **   OGS:[0:Expert]
< **** ENC:OI.viaInclude:[0:Expert]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(Expert)]
< **** savedOGS:save:False[0:tinyY,nest(Expert)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Expert)]
< **   OGS:[0:tinyY,nest(Expert)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Expert)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Expert)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY,nest(Expert)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:tinyY]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:tinyY,nest(Expert),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: StringLib.String
< **   father.f.f.f.f:
< 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(Expert),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:tinyY,nest(Expert),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:tinyY,nest(Expert),nest(StringLib)]
< **** savedOGS:save:False[0:tinyY,nest(Expert),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Expert),nest(StringLib)]
< **   OGS:[0:tinyY,nest(Expert),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Expert),nest(StringLib)]
< **** DataItem:getVqual: in descr: var StringLib.String
< [0:Alarm]
< **** ObjectGenerator:getVqual: StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:StringLib.String
< **   OGs: [0:Alarm]
< 
< **** OI:getVqual: StringLib on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Alarm]
< **   encOG: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **** OI:viaInclude:on=2 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: StringLib
< **   encOG: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **   OGS:[0:Alarm]
< ***** viaInclude:notTop: StringLib name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: StringLib
< **   encOG: 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< **   OGS:[0:Alarm]
< **** ENC:OI.viaInclude:[0:Alarm]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(Alarm)]
< **** savedOGS:save:False[0:tinyY,nest(Alarm)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Alarm)]
< **   OGS:[0:tinyY,nest(Alarm)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Alarm)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Alarm)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY,nest(Alarm)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:tinyY]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:tinyY,nest(Alarm),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: StringLib.String
< **   father.f.f.f.f:
< 
< in descr: var StringLib.String
<    in reqQuali: ref Qualification
<    %globals
<    print: 
<       "alarm: ".print
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(Alarm),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:tinyY,nest(Alarm),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:tinyY,nest(Alarm),nest(StringLib)]
< **** savedOGS:save:False[0:tinyY,nest(Alarm),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Alarm),nest(StringLib)]
< **   OGS:[0:tinyY,nest(Alarm),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Alarm),nest(StringLib)]
< **** OI:getOIqual: "R" IV:"R"
< **   origin.encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:getVqual: R on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** koks: R on: 0 Items 
< **   father: R
< **   father.f.f.f.f:
< 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< 
< **** getVqual:B2:
< [0:select]
< ---
< out R: ref SetLib.Set(#Domain)
< **** DataItem:getVqual: out R: ref SetLib.Set(#Domain)
< [0:select]
< **** ObjectGenerator:getVqual: SetLib.Set(#Domain)
< **   hasVirtualArgs: True
< **** INV:getVqual:SetLib.Set(#Domain)
< **   OGs: [0:select]
< 
< **** OI:getVqual: SetLib on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** koks: SetLib on: 3 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** ENC:OI.getVqual:[1:select]
< **   ENC:result:[1:Map]
< **** ENC:OI.getVqual:[2:Map]
< **   ENC:result:[2:MapLib]
< **** ENC:OI.getVqual:[3:MapLib]
< **   ENC:result:[3:Collections]
< 
< **** getVqual:B2:
< [0:Collections]
< ---
< 
< --SetLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections]
< **** savedOGS:save:False[0:Collections]
< **   OI: SetLib
< **   OI:getQual:savedOI:SetLib
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections]
< **   OGS:[0:Collections]
< **** OI:getVqual:end: SetLib
< **   qual: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections]
< 
< **** OI:getVqual: Set(#Domain) on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Collections]
< **   encOG: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Collections]
< **   encOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< 
< **** getVqual:added:isNest:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections,nest(SetLib)]
< **** koks: Set(#Domain) on: 0 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** getVqual:B2:
< [0:Collections,nest(SetLib)]
< ---
< 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** Pattern:getVqual: Set :isVirtual:False
< [0:Collections,nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib)]
< **** savedOGS:save:False[0:Collections,nest(SetLib)]
< **   OI: Set(#Domain)
< **   OI:getQual:savedOI:Set(#Domain)
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS:[0:Collections,nest(SetLib)]
< **** OI:getVqual:end: Set(#Domain)
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib)]
< **** savedOGS:save:was:[0:Collections,nest(SetLib)]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS:[0:select]
< **** OI:getVqual:end: R
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< **** OI:getOIqual: "done" IV:"done"
< **   origin.encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:getVqual: done on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** koks: done on: 0 Items 
< **   father: done
< **   father.f.f.f.f:
< 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< 
< **** getVqual:B2:
< [0:select]
< ---
< done: var boolean -- inner(select) and done for test purposes
< **** DataItem:getVqual: done: var boolean -- inner(select) and done for test purposes
< [0:select]
< **** ObjectGenerator:getVqual: boolean -- inner(select) and done for test purposes
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean -- inner(select) and done for test purposes
< **   OGs: [0:select]
< 
< **** OI:getVqual: boolean -- inner(select) and done for test purposes on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: boolean -- inner(select) and done for test purposes
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGS:[0:select]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean -- inner(select) and done for test purposes
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGS:[0:select]
< **** ENC:OI.viaInclude:[0:select]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(select)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map,nest(select)]
< **** savedOGS:save:False[0:Map,nest(select)]
< **   OI: boolean -- inner(select) and done for test purposes
< **   OI:getQual:savedOI:boolean -- inner(select) and done for test purposes
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(select)]
< **   OGS:[0:Map,nest(select)]
< **** OI:getVqual:end: boolean -- inner(select) and done for test purposes
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(select)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Map,nest(select)]
< **** savedOGS:save:was:[0:Map,nest(select)]
< **   OI: done
< **   OI:getQual:savedOI:done
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(select)]
< **   OGS:[0:select]
< **** OI:getVqual:end: done
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map,nest(select)]
< **** OI:getOIqual: "inner(select)" IV:"inner(select)"
< **   origin.encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:getVqual: inner(select) on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: inner(select)
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGS:[0:select]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(select)
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **   OGS:[0:select]
< **** ENC:OI.viaInclude:[0:select]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(select)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Map,nest(select)]
< **** savedOGS:save:was:[0:Map,nest(select)]
< **   OI: inner(select)
< **   OI:getQual:savedOI:inner(select)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(select)]
< **   OGS:[0:Map,nest(select)]
< **** OI:getVqual:end: inner(select)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Map,nest(select)]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OI:getVqual: nxt on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** koks: nxt on: 0 Items 
< **   father: nxt
< **   father.f.f.f.f:
< 
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:scan]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "head" IV:"head"
< **   origin.encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OI:getVqual: head on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** koks: head on: 1 Items 
< **   father: head
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:scan]
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "loop" IV:"loop"
< **   origin.encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< 
< **** OI:getVqual: loop on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** koks: loop on: 0 Items 
< **   father: loop
< **   father.f.f.f.f:
< 
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< 
< **** getVqual:B2:
< [0:scan]
< ---
< 
< Loop: 
<    if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
< ...
< **** Pattern:getVqual: Loop :isVirtual:False
< [0:scan]
< 
< **** getVqual:cont:afterATd:qual:
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< [0:scan]
< **** savedOGS:save:was:[0:scan]
< **   OI: loop
< **   OI:getQual:savedOI:loop
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:scan]
< **   OGS:[0:scan]
< **** OI:getVqual:end: loop
< **   qual: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< ObjectGenerator
< **   OGS:[0:scan]
< **** OI:getOIqual: "Entry" IV:"Entry"
< **   origin.encOG: 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** OI:getVqual: Entry on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **** koks: Entry on: 0 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: pattern [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "nxt" IV:"nxt =/= none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: nxt on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: nxt on: 1 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:Loop]
< **   ENC:result:[1:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Loop]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "=/= none" IV:"nxt =/= none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: nxt on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: nxt on: 1 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:Loop]
< **   ENC:result:[1:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Loop]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: =/= none on=0 pn=2 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< Entry
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< Entry
<    in next: ref link
< 
< **** getVqual:added:isNest:
< Entry
<    in next: ref link
< [0:Map,nest(link)]
< **** koks: =/= none on: 0 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** PRE: [0:Map,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map,nest(link),Entry]
< **** PRE: [0:Map,nest(link),Entry]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   PRE:result:[0:Map,nest(link),Entry,Object]
< 
< **** getVqual:B2:
< [0:Map,nest(link),Entry,Object]
< ---
< 
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: =/=   :isVirtual:False
< [0:Map,nest(link),Entry,Object]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< [0:Map,nest(link),Entry,Object]
< **** savedOGS:save:was:[0:Map,nest(link),Entry,Object]
< **   OI: =/= none
< **   OI:getQual:savedOI:=/= none
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(link),Entry,Object]
< **   OGS:[0:Map]
< **** DataItem:getVqual: out V: var boolean
< [0:Map,nest(link),Entry,Object,nest(=/=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Map,nest(link),Entry,Object,nest(=/=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry,Object,nest(=/=)]
< **   encOG: 
< Entry
<    in next: ref link
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry,Object,nest(=/=)]
< **   ENC:result:[1:Map,nest(link),Entry,Object]
< **** ENC:OI.getVqual:[2:Map,nest(link),Entry,Object]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[4:Map,nest(link)]
< **   ENC:result:[4:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[3:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Map]
< **** OI:getVqual:end: =/= none
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "=/= none" IV:"nxt =/= none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: nxt on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: nxt on: 1 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:Loop]
< **   ENC:result:[1:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Loop]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: =/= none on=0 pn=2 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< Entry
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< Entry
<    in next: ref link
< 
< **** getVqual:added:isNest:
< Entry
<    in next: ref link
< [0:Map,nest(link)]
< **** koks: =/= none on: 0 Items 
< **   father: nxt =/= none
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** PRE: [0:Map,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map,nest(link),Entry]
< **** PRE: [0:Map,nest(link),Entry]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   PRE:result:[0:Map,nest(link),Entry,Object]
< 
< **** getVqual:B2:
< [0:Map,nest(link),Entry,Object]
< ---
< 
< =/=  : 
<    %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: =/=   :isVirtual:False
< [0:Map,nest(link),Entry,Object]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< [0:Map,nest(link),Entry,Object]
< **** savedOGS:save:was:[0:Map,nest(link),Entry,Object]
< **   OI: =/= none
< **   OI:getQual:savedOI:=/= none
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(link),Entry,Object]
< **   OGS:[0:Map]
< **** DataItem:getVqual: out V: var boolean
< [0:Map,nest(link),Entry,Object,nest(=/=)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Map,nest(link),Entry,Object,nest(=/=)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry,Object,nest(=/=)]
< **   encOG: 
< Entry
<    in next: ref link
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 57
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry,Object,nest(=/=)]
< **   ENC:result:[1:Map,nest(link),Entry,Object]
< **** ENC:OI.getVqual:[2:Map,nest(link),Entry,Object]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[4:Map,nest(link)]
< **   ENC:result:[4:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[3:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Map]
< **** OI:getVqual:end: =/= none
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "none" IV:"none"
< **   origin.encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< 
< **** OI:getVqual: none on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Loop]
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: none
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   OGS:[0:Loop]
< ***** viaInclude:notTop: none name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: none
< **   encOG: 
< if (nxt =/= none) :then 
<       current := nxt
<       inner(scan)
<       nxt := nxt.next
<       restart(Loop)
< ...
< **   OGS:[0:Loop]
< **** ENC:OI.viaInclude:[0:Loop]
< **   ENC:result:[0:scan]
< **** viaInclude:GOT:
< [0:scan,nest(Loop)]
< **** Pattern:getVqual: none :isVirtual:False
< [0:scan,nest(Loop)]
< **** savedOGS:save:was:[0:scan,nest(Loop)]
< **   OI: none
< **   OI:getQual:savedOI:none
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:scan,nest(Loop)]
< **   OGS:[0:scan,nest(Loop)]
< **** OI:getVqual:end: none
< **   qual: 
< %basic 19
<    none_x: var integer
< ObjectGenerator
< **   OGS:[0:scan,nest(Loop)]
< **** OI:getOIqual: "current" IV:"current"
< **   origin.encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: current on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$122]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: current on: 2 Items 
< **   father: current
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:$122]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$122]
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$122]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt
< **   father.f.f.f.f:
< 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** ENC:OI.getVqual:[1:$122]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$122]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "inner(scan)" IV:"inner(scan)"
< **   origin.encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: inner(scan) on=6 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$122]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OI:viaInclude:on=6 BETA %Include BETA
< **   OI: inner(scan)
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$122]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(scan)
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$122]
< **** ENC:OI.viaInclude:[0:$122]
< **   ENC:result:[0:Loop]
< **** viaInclude:GOT:
< [0:Loop,nest($122)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:Loop,nest($122)]
< **** savedOGS:save:was:[0:Loop,nest($122)]
< **   OI: inner(scan)
< **   OI:getQual:savedOI:inner(scan)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Loop,nest($122)]
< **   OGS:[0:Loop,nest($122)]
< **** OI:getVqual:end: inner(scan)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:Loop,nest($122)]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$122]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:$122]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$122]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "nxt" IV:"nxt.next"
< **   origin.encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$122]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt.next
< **   father.f.f.f.f:
< 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** ENC:OI.getVqual:[1:$122]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$122]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "next" IV:"nxt.next"
< **   origin.encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$122]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: nxt on: 2 Items 
< **   father: nxt.next
< **   father.f.f.f.f:
< 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** ENC:OI.getVqual:[1:$122]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$122]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: next on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< Entry
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< Entry
<    in next: ref link
< 
< **** getVqual:added:isNest:
< Entry
<    in next: ref link
< [0:Map,nest(link)]
< **** koks: next on: 0 Items 
< **   father: nxt.next
< **   father.f.f.f.f:
< 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** getVqual:B2:
< [0:Map,nest(link)]
< ---
< in next: ref link
< **** DataItem:getVqual: in next: ref link
< [0:Map,nest(link)]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map,nest(link)]
< 
< **** OI:getVqual: link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link)]
< **   encOG: 
< Entry
<    in next: ref link
< **** koks: link on: 1 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< Entry
<    in next: ref link
< **** ENC:OI.getVqual:[1:Map,nest(link)]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: next
< **   OI:getQual:savedOI:next
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: next
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "restart(Loop)" IV:"restart(Loop)"
< **   origin.encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< 
< **** OI:getVqual: restart(Loop) on=6 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$122]
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **** OI:viaInclude:on=6 BETA %Include BETA
< **   OI: restart(Loop)
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$122]
< ***** viaInclude:notTop: restart name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: restart(Loop)
< **   encOG: 
< current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< **   OGS:[0:$122]
< **** ENC:OI.viaInclude:[0:$122]
< **   ENC:result:[0:Loop]
< **** viaInclude:GOT:
< [0:Loop,nest($122)]
< **** Pattern:getVqual: restart(V: var integer) :isVirtual:False
< [0:Loop,nest($122)]
< **** savedOGS:save:was:[0:Loop,nest($122)]
< **   OI: restart(Loop)
< **   OI:getQual:savedOI:restart(Loop)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Loop,nest($122)]
< **   OGS:[0:Loop,nest($122)]
< **** OI:getVqual:end: restart(Loop)
< **   qual: 
< -- odd parameter type!
<    %basic 102
< ObjectGenerator
< **   OGS:[0:Loop,nest($122)]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: nxt := nxt
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$123]
< **   encOG: nxt := nxt
< **** koks: nxt on: 2 Items 
< **   father: nxt
< **   father.f.f.f.f:
< 
< if (nxt =/= none) :then 
<    current := nxt
<    inner(scan)
<    nxt := nxt.next
<    restart(Loop)
< ...
< **** ENC:OI.getVqual:[1:$123]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: nxt := nxt
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$123]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "nxt" IV:"nxt"
< **   origin.encOG: nxt := nxt
< 
< **** OI:getVqual: nxt on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$123]
< **   encOG: nxt := nxt
< **** koks: nxt on: 2 Items 
< **   father: nxt
< **   father.f.f.f.f:
< nxt := nxt
< **** ENC:OI.getVqual:[1:$123]
< **   ENC:result:[1:Loop]
< **** ENC:OI.getVqual:[2:Loop]
< **   ENC:result:[2:scan]
< 
< **** getVqual:B2:
< [0:scan]
< ---
< nxt: ref Link
< **** DataItem:getVqual: nxt: ref Link
< [0:scan]
< **** ObjectGenerator:getVqual: Link
< **   hasVirtualArgs: False
< **** INV:getVqual:Link
< **   OGs: [0:scan]
< 
< **** OI:getVqual: Link on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan]
< **   encOG: nxt := nxt
< **** koks: Link on: 1 Items 
< **   father: Link
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Link
< **   OI:getQual:savedOI:Link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: nxt
< **   OI:getQual:savedOI:nxt
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$123]
< **** OI:getVqual:end: nxt
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "scan" IV:"scan"
< **   origin.encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** OI:getVqual: scan on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** koks: scan on: 1 Items 
< **   father: scan
< **   father.f.f.f.f:
< 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< **** ENC:OI.getVqual:[1:select]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **** Pattern:getVqual: scan :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: scan
< **   OI:getQual:savedOI:scan
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:select]
< **** OI:getVqual:end: scan
< **   qual: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "pred(current.inx,current.elm)" IV:"pred(current.inx,current.elm)"
< **   origin.encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OI:getVqual: pred(current.inx,current.elm) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: pred(current.inx,current.elm) on: 1 Items 
< **   father: pred(current.inx,current.elm)
< **   father.f.f.f.f:
< 
< if (pred(current.inx,current.elm)) :then 
<    R.insert(current.inx)
<    inner(select)
< **** ENC:OI.getVqual:[1:scan$124]
< **   ENC:result:[1:select]
< 
< **** getVqual:B2:
< [0:select]
< ---
< 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** Pattern:getVqual: pred :isVirtual:True
< [0:select]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:select]
< **** newFindBinding: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** searchBinding: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< [0:select]
< **   checkDOG: select 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< father:
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** newFindBinding:found: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** PTN:getVqual:gotBinding: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< 
< **** getVqual:cont:afterATd:qual:
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< [0:select&]
< **** savedOGS:save:was:[0:select&]
< **   OI: pred(current.inx,current.elm)
< **   OI:getQual:savedOI:pred(current.inx,current.elm)
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select&]
< **   OGS:[0:scan$124]
< **** DataItem:getVqual: out V: var Boolean
< [0:select&,nest(pred)]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:select&,nest(pred)]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select&,nest(pred)]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGS:[0:select&,nest(pred)]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGS:[0:select&,nest(pred)]
< **** ENC:OI.viaInclude:[0:select&,nest(pred)]
< **   ENC:result:[0:select&]
< **** viaInclude:GOT:
< [0:select&,nest(scan$124)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:select&,nest(scan$124)]
< **** savedOGS:save:False[0:select&,nest(scan$124)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select&,nest(scan$124)]
< **   OGS:[0:select&,nest(scan$124)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select&,nest(scan$124)]
< **** OI:getVqual:return: out V: var Boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:select&,nest(scan$124)]
< **** OI:getVqual:end: pred(current.inx,current.elm)
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select&,nest(scan$124)]
< **** OI:getOIqual: "pred(current.inx,current.elm)" IV:"pred(current.inx,current.elm)"
< **   origin.encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OI:getVqual: pred(current.inx,current.elm) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: pred(current.inx,current.elm) on: 1 Items 
< **   father: pred(current.inx,current.elm)
< **   father.f.f.f.f:
< 
< if (pred(current.inx,current.elm)) :then 
<    R.insert(current.inx)
<    inner(select)
< **** ENC:OI.getVqual:[1:scan$124]
< **   ENC:result:[1:select]
< 
< **** getVqual:B2:
< [0:select]
< ---
< 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** Pattern:getVqual: pred :isVirtual:True
< [0:select]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:select]
< **** newFindBinding: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** searchBinding: 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< [0:select]
< **   checkDOG: select 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< father:
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< 
<  ==== FOUND BINDING: =====
< 
< in pred:< 
<    in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** newFindBinding:found: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< **** PTN:getVqual:gotBinding: 
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< 
< **** getVqual:cont:afterATd:qual:
< in IX: ref Domain
<    in E: ref Range
<    out V: var Boolean
< [0:select&]
< **** savedOGS:save:was:[0:select&]
< **   OI: pred(current.inx,current.elm)
< **   OI:getQual:savedOI:pred(current.inx,current.elm)
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select&]
< **   OGS:[0:scan$124]
< **** DataItem:getVqual: out V: var Boolean
< [0:select&,nest(pred)]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:select&,nest(pred)]
< 
< **** OI:getVqual: Boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select&,nest(pred)]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: Boolean
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGS:[0:select&,nest(pred)]
< ***** viaInclude:notTop: Boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Boolean
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGS:[0:select&,nest(pred)]
< **** ENC:OI.viaInclude:[0:select&,nest(pred)]
< **   ENC:result:[0:select&]
< **** viaInclude:GOT:
< [0:select&,nest(scan$124)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:select&,nest(scan$124)]
< **** savedOGS:save:False[0:select&,nest(scan$124)]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select&,nest(scan$124)]
< **   OGS:[0:select&,nest(scan$124)]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select&,nest(scan$124)]
< **** OI:getVqual:return: out V: var Boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:select&,nest(scan$124)]
< **** OI:getVqual:end: pred(current.inx,current.elm)
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select&,nest(scan$124)]
< **** OI:getOIqual: "current" IV:"current.inx"
< **   origin.encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OI:getVqual: current on=0 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: current on: 0 Items 
< **   father: current.inx
< **   father.f.f.f.f:
< pred(current.inx,current.elm)
< **** PRE: [0:scan$124]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   PRE:result:[0:scan$124,scan]
< 
< **** getVqual:B2:
< [0:scan$124,scan]
< ---
< current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan$124,scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan$124,scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124,scan]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan$124,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGsuper: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:select]
< **   ENC:result:[2:Map]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:scan$124]
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "inx" IV:"current.inx"
< **   origin.encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OI:getVqual: current on=0 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: current on: 0 Items 
< **   father: current.inx
< **   father.f.f.f.f:
< pred(current.inx,current.elm)
< **** PRE: [0:scan$124]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   PRE:result:[0:scan$124,scan]
< 
< **** getVqual:B2:
< [0:scan$124,scan]
< ---
< current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan$124,scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan$124,scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124,scan]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan$124,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGsuper: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:select]
< **   ENC:result:[2:Map]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:scan$124]
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: inx on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< in inx: ref Domain
<    in elm: ref Range
< 
< **** getVqual:added:isNest:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map,nest(Entry)]
< **** koks: inx on: 0 Items 
< **   father: current.inx
< **   father.f.f.f.f:
< pred(current.inx,current.elm)
< 
< **** getVqual:B2:
< [0:Map,nest(Entry)]
< ---
< in inx: ref Domain
< **** DataItem:getVqual: in inx: ref Domain
< [0:Map,nest(Entry)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:Map,nest(Entry)]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(Entry)]
< **   encOG: 
< in inx: ref Domain
<    in elm: ref Range
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[1:Map,nest(Entry)]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Domain
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: inx
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OI:getOIqual: "current" IV:"current.elm"
< **   origin.encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OI:getVqual: current on=0 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: current on: 0 Items 
< **   father: current.elm
< **   father.f.f.f.f:
< pred(current.inx,current.elm)
< **** PRE: [0:scan$124]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   PRE:result:[0:scan$124,scan]
< 
< **** getVqual:B2:
< [0:scan$124,scan]
< ---
< current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan$124,scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan$124,scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124,scan]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan$124,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGsuper: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:select]
< **   ENC:result:[2:Map]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:scan$124]
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "elm" IV:"current.elm"
< **   origin.encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< 
< **** OI:getVqual: current on=0 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: current on: 0 Items 
< **   father: current.elm
< **   father.f.f.f.f:
< pred(current.inx,current.elm)
< **** PRE: [0:scan$124]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   PRE:result:[0:scan$124,scan]
< 
< **** getVqual:B2:
< [0:scan$124,scan]
< ---
< current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan$124,scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan$124,scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124,scan]
< **   encOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan$124,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGsuper: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:select]
< **   ENC:result:[2:Map]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:scan$124]
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: elm on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< in inx: ref Domain
<    in elm: ref Range
< 
< **** getVqual:added:isNest:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map,nest(Entry)]
< **** koks: elm on: 0 Items 
< **   father: current.elm
< **   father.f.f.f.f:
< pred(current.inx,current.elm)
< 
< **** getVqual:B2:
< [0:Map,nest(Entry)]
< ---
< in elm: ref Range
< **** DataItem:getVqual: in elm: ref Range
< [0:Map,nest(Entry)]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:Map,nest(Entry)]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(Entry)]
< **   encOG: 
< in inx: ref Domain
<    in elm: ref Range
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[1:Map,nest(Entry)]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Range
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: elm
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OI:getOIqual: "R" IV:"R.insert(current.inx)"
< **   origin.encOG: 
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:getVqual: R on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$126]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: R on: 2 Items 
< **   father: R.insert(current.inx)
< **   father.f.f.f.f:
< 
< if (pred(current.inx,current.elm)) :then 
<    R.insert(current.inx)
<    inner(select)
< **** ENC:OI.getVqual:[1:$126]
< **   ENC:result:[1:scan$124]
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< 
< **** getVqual:B2:
< [0:select]
< ---
< out R: ref SetLib.Set(#Domain)
< **** DataItem:getVqual: out R: ref SetLib.Set(#Domain)
< [0:select]
< **** ObjectGenerator:getVqual: SetLib.Set(#Domain)
< **   hasVirtualArgs: True
< **** INV:getVqual:SetLib.Set(#Domain)
< **   OGs: [0:select]
< 
< **** OI:getVqual: SetLib on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: SetLib on: 3 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** ENC:OI.getVqual:[1:select]
< **   ENC:result:[1:Map]
< **** ENC:OI.getVqual:[2:Map]
< **   ENC:result:[2:MapLib]
< **** ENC:OI.getVqual:[3:MapLib]
< **   ENC:result:[3:Collections]
< 
< **** getVqual:B2:
< [0:Collections]
< ---
< 
< --SetLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections]
< **** savedOGS:save:False[0:Collections]
< **   OI: SetLib
< **   OI:getQual:savedOI:SetLib
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections]
< **   OGS:[0:Collections]
< **** OI:getVqual:end: SetLib
< **   qual: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections]
< 
< **** OI:getVqual: Set(#Domain) on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Collections]
< **   encOG: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Collections]
< **   encOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< 
< **** getVqual:added:isNest:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections,nest(SetLib)]
< **** koks: Set(#Domain) on: 0 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** getVqual:B2:
< [0:Collections,nest(SetLib)]
< ---
< 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** Pattern:getVqual: Set :isVirtual:False
< [0:Collections,nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib)]
< **** savedOGS:save:False[0:Collections,nest(SetLib)]
< **   OI: Set(#Domain)
< **   OI:getQual:savedOI:Set(#Domain)
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS:[0:Collections,nest(SetLib)]
< **** OI:getVqual:end: Set(#Domain)
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib)]
< **** savedOGS:save:was:[0:Collections,nest(SetLib)]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS:[0:$126]
< **** OI:getVqual:end: R
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< **** OI:getOIqual: "insert(current.inx)" IV:"R.insert(current.inx)"
< **   origin.encOG: 
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:getVqual: R on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$126]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: R on: 2 Items 
< **   father: R.insert(current.inx)
< **   father.f.f.f.f:
< 
< if (pred(current.inx,current.elm)) :then 
<    R.insert(current.inx)
<    inner(select)
< **** ENC:OI.getVqual:[1:$126]
< **   ENC:result:[1:scan$124]
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< 
< **** getVqual:B2:
< [0:select]
< ---
< out R: ref SetLib.Set(#Domain)
< **** DataItem:getVqual: out R: ref SetLib.Set(#Domain)
< [0:select]
< **** ObjectGenerator:getVqual: SetLib.Set(#Domain)
< **   hasVirtualArgs: True
< **** INV:getVqual:SetLib.Set(#Domain)
< **   OGs: [0:select]
< 
< **** OI:getVqual: SetLib on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:select]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: SetLib on: 3 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** ENC:OI.getVqual:[1:select]
< **   ENC:result:[1:Map]
< **** ENC:OI.getVqual:[2:Map]
< **   ENC:result:[2:MapLib]
< **** ENC:OI.getVqual:[3:MapLib]
< **   ENC:result:[3:Collections]
< 
< **** getVqual:B2:
< [0:Collections]
< ---
< 
< --SetLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections]
< **** savedOGS:save:False[0:Collections]
< **   OI: SetLib
< **   OI:getQual:savedOI:SetLib
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections]
< **   OGS:[0:Collections]
< **** OI:getVqual:end: SetLib
< **   qual: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections]
< 
< **** OI:getVqual: Set(#Domain) on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Collections]
< **   encOG: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Collections]
< **   encOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< 
< **** getVqual:added:isNest:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:Collections,nest(SetLib)]
< **** koks: Set(#Domain) on: 0 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** getVqual:B2:
< [0:Collections,nest(SetLib)]
< ---
< 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** Pattern:getVqual: Set :isVirtual:False
< [0:Collections,nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib)]
< **** savedOGS:save:False[0:Collections,nest(SetLib)]
< **   OI: Set(#Domain)
< **   OI:getQual:savedOI:Set(#Domain)
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS:[0:Collections,nest(SetLib)]
< **** OI:getVqual:end: Set(#Domain)
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib)]
< **** savedOGS:save:was:[0:Collections,nest(SetLib)]
< **   OI: R
< **   OI:getQual:savedOI:R
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib)]
< **   OGS:[0:$126]
< **** OI:getVqual:end: R
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib)]
< 
< **** OI:getVqual: insert(current.inx) on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Collections,nest(SetLib)]
< **   encOG: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Collections,nest(SetLib)]
< **   encOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
< **** getVqual:added:isNest:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:Collections,nest(SetLib),nest(Set)]
< **** koks: insert(current.inx) on: 0 Items 
< **   father: R.insert(current.inx)
< **   father.f.f.f.f:
< 
< if (pred(current.inx,current.elm)) :then 
<    R.insert(current.inx)
<    inner(select)
< 
< **** getVqual:B2:
< [0:Collections,nest(SetLib),nest(Set)]
< ---
< 
< insert:: 
<    head := link(e,head)
< **** Pattern:getVqual: insert :isVirtual:True
< [0:Collections,nest(SetLib),nest(Set)]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Collections,nest(SetLib),nest(Set)]
< **** newFindBinding: 
< insert:: 
<    head := link(e,head)
< **** searchBinding: 
< insert:: 
<    head := link(e,head)
< [0:Collections,nest(SetLib),nest(Set)]
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< insert:: 
<    head := link(e,head)
< **** newFindBinding:found: head := link(e,head)
< **** PTN:getVqual:gotBinding: head := link(e,head)
< 
< **** getVqual:cont:afterATd:qual:head := link(e,head)
< [0:Collections,nest(SetLib),nest(Set&)]
< **** savedOGS:save:was:[0:Collections,nest(SetLib),nest(Set&)]
< **   OI: insert(current.inx)
< **   OI:getQual:savedOI:insert(current.inx)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Collections,nest(SetLib),nest(Set&)]
< **   OGS:[0:Collections,nest(SetLib)]
< **** OI:getVqual:end: insert(current.inx)
< **   qual: head := link(e,head)
< ObjectGenerator
< **   OGS:[0:Collections,nest(SetLib),nest(Set&)]
< **** OI:getOIqual: "current" IV:"current.inx"
< **   origin.encOG: 
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:getVqual: current on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$126]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: current on: 1 Items 
< **   father: current.inx
< **   father.f.f.f.f:
< R.insert(current.inx)
< **** ENC:OI.getVqual:[1:$126]
< **   ENC:result:[1:scan$124]
< **** PRE: [0:scan$124]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   innerDOG: 
< R.insert(current.inx)
<    inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   PRE:result:[0:scan$124,scan]
< 
< **** getVqual:B2:
< [0:scan$124,scan]
< ---
< current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan$124,scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan$124,scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124,scan]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan$124,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   innerDOG: 
< R.insert(current.inx)
<    inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGsuper: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:select]
< **   ENC:result:[2:Map]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$126]
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "inx" IV:"current.inx"
< **   origin.encOG: 
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:getVqual: current on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:$126]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: current on: 1 Items 
< **   father: current.inx
< **   father.f.f.f.f:
< R.insert(current.inx)
< **** ENC:OI.getVqual:[1:$126]
< **   ENC:result:[1:scan$124]
< **** PRE: [0:scan$124]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   innerDOG: 
< R.insert(current.inx)
<    inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **   PRE:result:[0:scan$124,scan]
< 
< **** getVqual:B2:
< [0:scan$124,scan]
< ---
< current: ref Entry
< **** DataItem:getVqual: current: ref Entry
< [0:scan$124,scan]
< **** ObjectGenerator:getVqual: Entry
< **   hasVirtualArgs: False
< **** INV:getVqual:Entry
< **   OGs: [0:scan$124,scan]
< 
< **** OI:getVqual: Entry on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$124,scan]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** koks: Entry on: 1 Items 
< **   father: Entry
< **   father.f.f.f.f:
< 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[1:scan$124,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   innerDOG: 
< R.insert(current.inx)
<    inner(select)
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< scan: 
<    current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    if (pred(current.inx,current.elm)) :then 
<       R.insert(current.inx)
<       inner(select)
< **   OGsuper: 
< current: ref Entry
<    nxt: ref Link
<    Loop: 
<       if (nxt =/= none) :then 
<          current := nxt
< ...
< **** ENC:OI.getVqual:[2:scan$124]
< **   ENC:result:[2:select]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:select]
< **   ENC:result:[2:Map]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **** Pattern:getVqual: Entry :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: Entry
< **   OI:getQual:savedOI:Entry
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: Entry
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$126]
< **** OI:getVqual:end: current
< **   qual: 
< in inx: ref Domain
<    in elm: ref Range
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: inx on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< in inx: ref Domain
<    in elm: ref Range
< 
< **** getVqual:added:isNest:
< in inx: ref Domain
<    in elm: ref Range
< [0:Map,nest(Entry)]
< **** koks: inx on: 0 Items 
< **   father: current.inx
< **   father.f.f.f.f:
< R.insert(current.inx)
< 
< **** getVqual:B2:
< [0:Map,nest(Entry)]
< ---
< in inx: ref Domain
< **** DataItem:getVqual: in inx: ref Domain
< [0:Map,nest(Entry)]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:Map,nest(Entry)]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(Entry)]
< **   encOG: 
< in inx: ref Domain
<    in elm: ref Range
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[1:Map,nest(Entry)]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Domain
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: inx
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OI:getOIqual: "inner(select)" IV:"inner(select)"
< **   origin.encOG: 
< R.insert(current.inx)
<    inner(select)
< 
< **** OI:getVqual: inner(select) on=6 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$126]
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **** OI:viaInclude:on=6 BETA %Include BETA
< **   OI: inner(select)
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **   OGS:[0:$126]
< ***** viaInclude:notTop: inner name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: inner(select)
< **   encOG: 
< R.insert(current.inx)
<    inner(select)
< **   OGS:[0:$126]
< **** ENC:OI.viaInclude:[0:$126]
< **   ENC:result:[0:scan$124]
< **** viaInclude:GOT:
< [0:scan$124,nest($126)]
< **** Pattern:getVqual: inner :isVirtual:False
< [0:scan$124,nest($126)]
< **** savedOGS:save:was:[0:scan$124,nest($126)]
< **   OI: inner(select)
< **   OI:getQual:savedOI:inner(select)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:scan$124,nest($126)]
< **   OGS:[0:scan$124,nest($126)]
< **** OI:getVqual:end: inner(select)
< **   qual: 
< %basic 101
<    in inner: ref Object
< ObjectGenerator
< **   OGS:[0:scan$124,nest($126)]
< **** OI:getOIqual: "MapLib" IV:"MapLib.Map(#Period,#Experts)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: MapLib on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OI:viaInclude:on=0 Collections %visible Collections
< **   OI: MapLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY]
< ***** viaInclude:notTop: MapLib name: Collections ObjectInvocation_Unary Collections name: 1 
< %visible Collections Property
< **** OI:viaInclude:on=1 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: MapLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY]
< ***** viaInclude:notTop: Collections name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: MapLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY]
< **** ENC:OI.viaInclude:[0:tinyY]
< **   ENC:result:[0:workspace]
< **** viaInclude:GOT:
< [0:workspace,nest(tinyY)]
< **** savedOGS:save:False[0:workspace,nest(tinyY)]
< **   OI: MapLib
< **   OI:getQual:savedOI:MapLib
< **   IT: pattern [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:workspace,nest(tinyY)]
< **   OGS:[0:workspace,nest(tinyY)]
< **** OI:getVqual:end: MapLib
< **   qual: 
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< ObjectGenerator
< **   OGS:[0:workspace,nest(tinyY)]
< **** OI:getOIqual: "Map(#Period,#Experts)" IV:"MapLib.Map(#Period,#Experts)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: MapLib on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** OI:viaInclude:on=0 Collections %visible Collections
< **   OI: MapLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY]
< ***** viaInclude:notTop: MapLib name: Collections ObjectInvocation_Unary Collections name: 1 
< %visible Collections Property
< **** OI:viaInclude:on=1 LIB %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: MapLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY]
< ***** viaInclude:notTop: Collections name: LIB ObjectInvocation_Unary LIB name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: MapLib
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **   OGS:[0:tinyY]
< **** ENC:OI.viaInclude:[0:tinyY]
< **   ENC:result:[0:workspace]
< **** viaInclude:GOT:
< [0:workspace,nest(tinyY)]
< **** savedOGS:save:False[0:workspace,nest(tinyY)]
< **   OI: MapLib
< **   OI:getQual:savedOI:MapLib
< **   IT: pattern [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:workspace,nest(tinyY)]
< **   OGS:[0:workspace,nest(tinyY)]
< **** OI:getVqual:end: MapLib
< **   qual: 
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< ObjectGenerator
< **   OGS:[0:workspace,nest(tinyY)]
< 
< **** OI:getVqual: Map(#Period,#Experts) on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:workspace,nest(tinyY)]
< **   encOG: 
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:workspace,nest(tinyY)]
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:workspace]
< **   encOG:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< 
< **** getVqual:added:isNest:
< %requires SetLib
<    %include StringLib
<    Map: 
<       in Domain:< Object
<       in Range:< Object
< ...
< [0:workspace,nest(tinyY),nest(MapLib)]
< **** koks: Map(#Period,#Experts) on: 0 Items 
< **   father: MapLib.Map(#Period,#Experts)
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:workspace,nest(tinyY),nest(MapLib)]
< ---
< 
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **** Pattern:getVqual: Map :isVirtual:False
< [0:workspace,nest(tinyY),nest(MapLib)]
< 
< **** getVqual:cont:afterATd:qual:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< [0:workspace,nest(tinyY),nest(MapLib)]
< **** savedOGS:save:False[0:workspace,nest(tinyY),nest(MapLib)]
< **   OI: Map(#Period,#Experts)
< **   OI:getQual:savedOI:Map(#Period,#Experts)
< **   IT: pattern [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:workspace,nest(tinyY),nest(MapLib)]
< **   OGS:[0:workspace,nest(tinyY),nest(MapLib)]
< **** OI:getVqual:end: Map(#Period,#Experts)
< **   qual: 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< ObjectGenerator
< **   OGS:[0:workspace,nest(tinyY),nest(MapLib)]
< **** OI:getOIqual: "Plant(AS,S)" IV:"Plant(AS,S)"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: Plant(AS,S) on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Plant(AS,S) on: 0 Items 
< **   father: Plant(AS,S)
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Plant: 
<    in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
< ...
< **** Pattern:getVqual: Plant :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Plant(AS,S)
< **   OI:getQual:savedOI:Plant(AS,S)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Plant(AS,S)
< **   qual: 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "AS" IV:"AS"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: AS on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: AS on: 0 Items 
< **   father: AS
< **   father.f.f.f.f:
< Plant(AS,S)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< AS: obj Alarms
< **** DataItem:getVqual: AS: obj Alarms
< [0:tinyY]
< **** ObjectGenerator:getVqual: Alarms
< **   hasVirtualArgs: True
< **** INV:getVqual:Alarms
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Alarms on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Alarms on: 0 Items 
< **   father: Alarms
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Alarms: SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< **** Pattern:getVqual: Alarms :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Alarms
< **   OI:getQual:savedOI:Alarms
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Alarms
< **   qual: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: AS
< **   OI:getQual:savedOI:AS
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: AS
< **   qual: 
< SetLib.Set(#Alarm)
<    print: 
<       scan
<          current.print
<          put(',')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "S" IV:"S"
< **   origin.encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** OI:getVqual: S on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: S on: 0 Items 
< **   father: S
< **   father.f.f.f.f:
< Plant(AS,S)
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< S: obj Schedule
< **** DataItem:getVqual: S: obj Schedule
< [0:tinyY]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:tinyY]
< 
< **** OI:getVqual: Schedule on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< **** koks: Schedule on: 0 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< %requires Collections, MapLib, SetLib
<    %visible Collections
<    Qualification: 
<       %globals
<       in Q: var integer
< ...
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: S
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "head" IV:"head == none"
< **   origin.encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OI:getVqual: head on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** koks: head on: 1 Items 
< **   father: head == none
< **   father.f.f.f.f:
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **** ENC:OI.getVqual:[1:add]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:add]
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "== none" IV:"head == none"
< **   origin.encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OI:getVqual: head on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** koks: head on: 1 Items 
< **   father: head == none
< **   father.f.f.f.f:
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **** ENC:OI.getVqual:[1:add]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:add]
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: == none on=0 pn=2 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< Entry
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< Entry
<    in next: ref link
< 
< **** getVqual:added:isNest:
< Entry
<    in next: ref link
< [0:Map,nest(link)]
< **** koks: == none on: 0 Items 
< **   father: head == none
< **   father.f.f.f.f:
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **** PRE: [0:Map,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map,nest(link),Entry]
< **** PRE: [0:Map,nest(link),Entry]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   PRE:result:[0:Map,nest(link),Entry,Object]
< 
< **** getVqual:B2:
< [0:Map,nest(link),Entry,Object]
< ---
< 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: ==   :isVirtual:False
< [0:Map,nest(link),Entry,Object]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< [0:Map,nest(link),Entry,Object]
< **** savedOGS:save:was:[0:Map,nest(link),Entry,Object]
< **   OI: == none
< **   OI:getQual:savedOI:== none
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(link),Entry,Object]
< **   OGS:[0:Map]
< **** DataItem:getVqual: out V: var boolean
< [0:Map,nest(link),Entry,Object,nest(==)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Map,nest(link),Entry,Object,nest(==)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry,Object,nest(==)]
< **   encOG: 
< Entry
<    in next: ref link
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry,Object,nest(==)]
< **   ENC:result:[1:Map,nest(link),Entry,Object]
< **** ENC:OI.getVqual:[2:Map,nest(link),Entry,Object]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[4:Map,nest(link)]
< **   ENC:result:[4:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[3:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Map]
< **** OI:getVqual:end: == none
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "== none" IV:"head == none"
< **   origin.encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OI:getVqual: head on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** koks: head on: 1 Items 
< **   father: head == none
< **   father.f.f.f.f:
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **** ENC:OI.getVqual:[1:add]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:add]
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** OI:getVqual: == none on=0 pn=2 isNest=True getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: 
< Entry
<    in next: ref link
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Map]
< **   encOG:
< Entry
<    in next: ref link
< 
< **** getVqual:added:isNest:
< Entry
<    in next: ref link
< [0:Map,nest(link)]
< **** koks: == none on: 0 Items 
< **   father: head == none
< **   father.f.f.f.f:
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **** PRE: [0:Map,nest(link)]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< in inx: ref Domain
<    in elm: ref Range
< **   PRE:result:[0:Map,nest(link),Entry]
< **** PRE: [0:Map,nest(link),Entry]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   PRE:onx,pnx,isR:0,0,False OGx:
< 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **   PRE:result:[0:Map,nest(link),Entry,Object]
< 
< **** getVqual:B2:
< [0:Map,nest(link),Entry,Object]
< ---
< 
< ==  : 
<    %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** Pattern:getVqual: ==   :isVirtual:False
< [0:Map,nest(link),Entry,Object]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< [0:Map,nest(link),Entry,Object]
< **** savedOGS:save:was:[0:Map,nest(link),Entry,Object]
< **   OI: == none
< **   OI:getQual:savedOI:== none
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(link),Entry,Object]
< **   OGS:[0:Map]
< **** DataItem:getVqual: out V: var boolean
< [0:Map,nest(link),Entry,Object,nest(==)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:Map,nest(link),Entry,Object,nest(==)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map,nest(link),Entry,Object,nest(==)]
< **   encOG: 
< Entry
<    in next: ref link
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 56
<    in objx: ref Object
<    out V: var boolean
< **** ENC:OI.getVqual:[1:Map,nest(link),Entry,Object,nest(==)]
< **   ENC:result:[1:Map,nest(link),Entry,Object]
< **** ENC:OI.getVqual:[2:Map,nest(link),Entry,Object]
< **** pathToSuper: "" of:DOG:
< in inx: ref Domain
<    in elm: ref Range
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=False
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Object: 
<    %ID Object
<    %basic 64
<    %public
<    ==  : 
< ...
< **   ENC:pred:  pred.DOG: 
< in inx: ref Domain
<    in elm: ref Range
< **   OGsuper: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** ENC:OI.getVqual:[3:Map,nest(link),Entry]
< **** pathToSuper: "Entry" of:DOG:
< Entry
<    in next: ref link
< **   pathToSuper:DOG.super.scanSons:i=1:E:Entry :isImplSuper=False
< **   pathToSuper:E:"Entry" E.on=0 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Entry" :on=0:pn=0:isR=False:ptn.isVirt=False ptn:
< Entry: 
<    in inx: ref Domain
<    in elm: ref Range
< **   ENC:pred:  pred.DOG: 
< Entry
<    in next: ref link
< **   OGsuper: 
< in inx: ref Domain
<    in elm: ref Range
< **** ENC:OI.getVqual:[4:Map,nest(link)]
< **   ENC:result:[4:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[3:Map]
< **   ENC:[pnx=0]oENC[onx=0]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getVqual:return: out V: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:Map]
< **** OI:getVqual:end: == none
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "none" IV:"none"
< **   origin.encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< 
< **** OI:getVqual: none on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: none
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS:[0:add]
< ***** viaInclude:notTop: none name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: none
< **   encOG: 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **   OGS:[0:add]
< **** ENC:OI.viaInclude:[0:add]
< **   ENC:result:[0:Map]
< **** viaInclude:GOT:
< [0:Map,nest(add)]
< **** Pattern:getVqual: none :isVirtual:False
< [0:Map,nest(add)]
< **** savedOGS:save:was:[0:Map,nest(add)]
< **   OI: none
< **   OI:getQual:savedOI:none
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map,nest(add)]
< **   OGS:[0:Map,nest(add)]
< **** OI:getVqual:end: none
< **   qual: 
< %basic 19
<    none_x: var integer
< ObjectGenerator
< **   OGS:[0:Map,nest(add)]
< **** OI:getOIqual: "head" IV:"head"
< **   origin.encOG: head := link(S,D,none)
< 
< **** OI:getVqual: head on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$99]
< **   encOG: head := link(S,D,none)
< **** koks: head on: 2 Items 
< **   father: head
< **   father.f.f.f.f:
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **** ENC:OI.getVqual:[1:$99]
< **   ENC:result:[1:add]
< **** ENC:OI.getVqual:[2:add]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: head := link(S,D,none)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$99]
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "link(S,D,none)" IV:"link(S,D,none)"
< **   origin.encOG: head := link(S,D,none)
< 
< **** OI:getVqual: link(S,D,none) on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$99]
< **   encOG: head := link(S,D,none)
< **** koks: link(S,D,none) on: 2 Items 
< **   father: link(S,D,none)
< **   father.f.f.f.f:
< head := link(S,D,none)
< **** ENC:OI.getVqual:[1:$99]
< **   ENC:result:[1:add]
< **** ENC:OI.getVqual:[2:add]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: link(S,D,none)
< **   OI:getQual:savedOI:link(S,D,none)
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$99]
< **** OI:getVqual:end: link(S,D,none)
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "S" IV:"S"
< **   origin.encOG: head := link(S,D,none)
< 
< **** OI:getVqual: S on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$99]
< **   encOG: head := link(S,D,none)
< **** koks: S on: 1 Items 
< **   father: S
< **   father.f.f.f.f:
< link(S,D,none)
< **** ENC:OI.getVqual:[1:$99]
< **   ENC:result:[1:add]
< 
< **** getVqual:B2:
< [0:add]
< ---
< in S: ref Domain
< **** DataItem:getVqual: in S: ref Domain
< [0:add]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:add]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: head := link(S,D,none)
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:add]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Domain
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$99]
< **** OI:getVqual:end: S
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OI:getOIqual: "D" IV:"D"
< **   origin.encOG: head := link(S,D,none)
< 
< **** OI:getVqual: D on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$99]
< **   encOG: head := link(S,D,none)
< **** koks: D on: 1 Items 
< **   father: D
< **   father.f.f.f.f:
< link(S,D,none)
< **** ENC:OI.getVqual:[1:$99]
< **   ENC:result:[1:add]
< 
< **** getVqual:B2:
< [0:add]
< ---
< in D: ref Range
< **** DataItem:getVqual: in D: ref Range
< [0:add]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:add]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: head := link(S,D,none)
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:add]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Range
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: D
< **   OI:getQual:savedOI:D
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$99]
< **** OI:getVqual:end: D
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OI:getOIqual: "none" IV:"none"
< **   origin.encOG: head := link(S,D,none)
< 
< **** OI:getVqual: none on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$99]
< **   encOG: head := link(S,D,none)
< **** OI:viaInclude:on=5 BETA %Include BETA
< **   OI: none
< **   encOG: head := link(S,D,none)
< **   OGS:[0:$99]
< ***** viaInclude:notTop: none name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: none
< **   encOG: head := link(S,D,none)
< **   OGS:[0:$99]
< **** ENC:OI.viaInclude:[0:$99]
< **   ENC:result:[0:add]
< **** viaInclude:GOT:
< [0:add,nest($99)]
< **** Pattern:getVqual: none :isVirtual:False
< [0:add,nest($99)]
< **** savedOGS:save:was:[0:add,nest($99)]
< **   OI: none
< **   OI:getQual:savedOI:none
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:add,nest($99)]
< **   OGS:[0:add,nest($99)]
< **** OI:getVqual:end: none
< **   qual: 
< %basic 19
<    none_x: var integer
< ObjectGenerator
< **   OGS:[0:add,nest($99)]
< **** OI:getOIqual: "head" IV:"head"
< **   origin.encOG: head := link(S,D,head)
< 
< **** OI:getVqual: head on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$102]
< **   encOG: head := link(S,D,head)
< **** koks: head on: 2 Items 
< **   father: head
< **   father.f.f.f.f:
< 
< if (head == none) :then 
<    head := link(S,D,none)
< :else 
<    head := link(S,D,head)
< **** ENC:OI.getVqual:[1:$102]
< **   ENC:result:[1:add]
< **** ENC:OI.getVqual:[2:add]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: head := link(S,D,head)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$102]
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "link(S,D,head)" IV:"link(S,D,head)"
< **   origin.encOG: head := link(S,D,head)
< 
< **** OI:getVqual: link(S,D,head) on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$102]
< **   encOG: head := link(S,D,head)
< **** koks: link(S,D,head) on: 2 Items 
< **   father: link(S,D,head)
< **   father.f.f.f.f:
< head := link(S,D,head)
< **** ENC:OI.getVqual:[1:$102]
< **   ENC:result:[1:add]
< **** ENC:OI.getVqual:[2:add]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map&]
< **   OI: link(S,D,head)
< **   OI:getQual:savedOI:link(S,D,head)
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$102]
< **** OI:getVqual:end: link(S,D,head)
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "S" IV:"S"
< **   origin.encOG: head := link(S,D,head)
< 
< **** OI:getVqual: S on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$102]
< **   encOG: head := link(S,D,head)
< **** koks: S on: 1 Items 
< **   father: S
< **   father.f.f.f.f:
< link(S,D,head)
< **** ENC:OI.getVqual:[1:$102]
< **   ENC:result:[1:add]
< 
< **** getVqual:B2:
< [0:add]
< ---
< in S: ref Domain
< **** DataItem:getVqual: in S: ref Domain
< [0:add]
< **** ObjectGenerator:getVqual: Domain
< **   hasVirtualArgs: False
< **** INV:getVqual:Domain
< **   OGs: [0:add]
< 
< **** OI:getVqual: Domain on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: head := link(S,D,head)
< **** koks: Domain on: 1 Items 
< **   father: Domain
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:add]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Domain:< Object
< **** Pattern:getVqual: Domain :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Domain:< Object
< **** searchBinding: in Domain:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Domain:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Domain
< **   OI:getQual:savedOI:Domain
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Domain
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$102]
< **** OI:getVqual:end: S
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OI:getOIqual: "D" IV:"D"
< **   origin.encOG: head := link(S,D,head)
< 
< **** OI:getVqual: D on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$102]
< **   encOG: head := link(S,D,head)
< **** koks: D on: 1 Items 
< **   father: D
< **   father.f.f.f.f:
< link(S,D,head)
< **** ENC:OI.getVqual:[1:$102]
< **   ENC:result:[1:add]
< 
< **** getVqual:B2:
< [0:add]
< ---
< in D: ref Range
< **** DataItem:getVqual: in D: ref Range
< [0:add]
< **** ObjectGenerator:getVqual: Range
< **   hasVirtualArgs: False
< **** INV:getVqual:Range
< **   OGs: [0:add]
< 
< **** OI:getVqual: Range on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:add]
< **   encOG: head := link(S,D,head)
< **** koks: Range on: 1 Items 
< **   father: Range
< **   father.f.f.f.f:
< 
< in S: ref Domain
<    in D: ref Range
<    if (head == none) :then 
<       head := link(S,D,none)
<    :else 
< ...
< **** ENC:OI.getVqual:[1:add]
< **   ENC:result:[1:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< in Range:< Object
< **** Pattern:getVqual: Range :isVirtual:True
< [0:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Map]
< **** newFindBinding: in Range:< Object
< **** searchBinding: in Range:< Object
< [0:Map]
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< in Range:< Object
< **** newFindBinding:found: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< **** PTN:getVqual:gotBinding: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:False[0:Map&]
< **   OI: Range
< **   OI:getQual:savedOI:Range
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:Map&]
< **** OI:getVqual:end: Range
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< 
< **** getVqual:cont:afterATd:qual:
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< [0:Map&]
< **** savedOGS:save:was:[0:Map&]
< **   OI: D
< **   OI:getQual:savedOI:D
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map&]
< **   OGS:[0:$102]
< **** OI:getVqual:end: D
< **   qual: 
< %ID Object
<    %basic 64
<    %public
<    ==  : 
<       %basic 56
< ...
< ObjectGenerator
< **   OGS:[0:Map&]
< **** OI:getOIqual: "head" IV:"head"
< **   origin.encOG: head := link(S,D,head)
< 
< **** OI:getVqual: head on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$102]
< **   encOG: head := link(S,D,head)
< **** koks: head on: 2 Items 
< **   father: head
< **   father.f.f.f.f:
< link(S,D,head)
< **** ENC:OI.getVqual:[1:$102]
< **   ENC:result:[1:add]
< **** ENC:OI.getVqual:[2:add]
< **   ENC:result:[2:Map]
< 
< **** getVqual:B2:
< [0:Map]
< ---
< head: ref link
< **** DataItem:getVqual: head: ref link
< [0:Map]
< **** ObjectGenerator:getVqual: link
< **   hasVirtualArgs: False
< **** INV:getVqual:link
< **   OGs: [0:Map]
< 
< **** OI:getVqual: link on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Map]
< **   encOG: head := link(S,D,head)
< **** koks: link on: 0 Items 
< **   father: link
< **   father.f.f.f.f:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< 
< **** getVqual:B2:
< [0:Map]
< ---
< 
< link: Entry
<    in next: ref link
< **** Pattern:getVqual: link :isVirtual:False
< [0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:False[0:Map]
< **   OI: link
< **   OI:getQual:savedOI:link
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:Map]
< **** OI:getVqual:end: link
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< 
< **** getVqual:cont:afterATd:qual:
< Entry
<    in next: ref link
< [0:Map]
< **** savedOGS:save:was:[0:Map]
< **   OI: head
< **   OI:getQual:savedOI:head
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Map]
< **   OGS:[0:$102]
< **** OI:getVqual:end: head
< **   qual: 
< Entry
<    in next: ref link
< ObjectGenerator
< **   OGS:[0:Map]
< **** OI:getOIqual: "fp" IV:"fp"
< **   origin.encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:getVqual: fp on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: fp on: 0 Items 
< **   father: fp
< **   father.f.f.f.f:
< 
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< 
< **** getVqual:B2:
< [0:expertIsOnDutyR]
< ---
< out fp: ref Periods
< **** DataItem:getVqual: out fp: ref Periods
< [0:expertIsOnDutyR]
< **** ObjectGenerator:getVqual: Periods
< **   hasVirtualArgs: True
< **** INV:getVqual:Periods
< **   OGs: [0:expertIsOnDutyR]
< 
< **** OI:getVqual: Periods on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: Periods on: 2 Items 
< **   father: Periods
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:expertIsOnDutyR]
< **   ENC:result:[1:Plant]
< **** ENC:OI.getVqual:[2:Plant]
< **   ENC:result:[2:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** Pattern:getVqual: Periods :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Periods
< **   OI:getQual:savedOI:Periods
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Periods
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: fp
< **   OI:getQual:savedOI:fp
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:expertIsOnDutyR]
< **** OI:getVqual:end: fp
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "fp" IV:"fp.print"
< **   origin.encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:getVqual: fp on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: fp on: 0 Items 
< **   father: fp.print
< **   father.f.f.f.f:
< 
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< 
< **** getVqual:B2:
< [0:expertIsOnDutyR]
< ---
< out fp: ref Periods
< **** DataItem:getVqual: out fp: ref Periods
< [0:expertIsOnDutyR]
< **** ObjectGenerator:getVqual: Periods
< **   hasVirtualArgs: True
< **** INV:getVqual:Periods
< **   OGs: [0:expertIsOnDutyR]
< 
< **** OI:getVqual: Periods on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: Periods on: 2 Items 
< **   father: Periods
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:expertIsOnDutyR]
< **   ENC:result:[1:Plant]
< **** ENC:OI.getVqual:[2:Plant]
< **   ENC:result:[2:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** Pattern:getVqual: Periods :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Periods
< **   OI:getQual:savedOI:Periods
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Periods
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: fp
< **   OI:getQual:savedOI:fp
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:expertIsOnDutyR]
< **** OI:getVqual:end: fp
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "print" IV:"fp.print"
< **   origin.encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:getVqual: fp on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: fp on: 0 Items 
< **   father: fp.print
< **   father.f.f.f.f:
< 
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< 
< **** getVqual:B2:
< [0:expertIsOnDutyR]
< ---
< out fp: ref Periods
< **** DataItem:getVqual: out fp: ref Periods
< [0:expertIsOnDutyR]
< **** ObjectGenerator:getVqual: Periods
< **   hasVirtualArgs: True
< **** INV:getVqual:Periods
< **   OGs: [0:expertIsOnDutyR]
< 
< **** OI:getVqual: Periods on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: Periods on: 2 Items 
< **   father: Periods
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:expertIsOnDutyR]
< **   ENC:result:[1:Plant]
< **** ENC:OI.getVqual:[2:Plant]
< **   ENC:result:[2:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **** Pattern:getVqual: Periods :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Periods
< **   OI:getQual:savedOI:Periods
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Periods
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: fp
< **   OI:getQual:savedOI:fp
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:expertIsOnDutyR]
< **** OI:getVqual:end: fp
< **   qual: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: print on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< 
< **** getVqual:added:isNest:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< [0:tinyY,nest(Periods)]
< **** koks: print on: 0 Items 
< **   father: fp.print
< **   father.f.f.f.f:
< 
< expertIsOnDutyR: 
<    in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(Periods)]
< ---
< 
< print: 
<    put('E')
<    scan
<       put('R')
<       current.print
< ...
< **** Pattern:getVqual: print :isVirtual:False
< [0:tinyY,nest(Periods)]
< 
< **** getVqual:cont:afterATd:qual:
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< [0:tinyY,nest(Periods)]
< **** savedOGS:save:was:[0:tinyY,nest(Periods)]
< **   OI: print
< **   OI:getQual:savedOI:print
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Periods)]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: print
< **   qual: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Periods)]
< **** OI:getOIqual: "B" IV:"B"
< **   origin.encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:getVqual: B on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$108]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: B on: 0 Items 
< **   father: B
< **   father.f.f.f.f:
< 
< select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< 
< **** getVqual:B2:
< [0:$108]
< ---
< out B: var boolean
< **** DataItem:getVqual: out B: var boolean
< [0:$108]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:$108]
< 
< **** OI:getVqual: boolean on=5 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$108]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** OI:viaInclude:on=5 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: boolean
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   OGS:[0:$108]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **   OGS:[0:$108]
< **** ENC:OI.viaInclude:[0:$108]
< **   ENC:result:[0:select$129]
< **** viaInclude:GOT:
< [0:select$129,nest($108)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:select$129,nest($108)]
< **** savedOGS:save:False[0:select$129,nest($108)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select$129,nest($108)]
< **   OGS:[0:select$129,nest($108)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select$129,nest($108)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:select$129,nest($108)]
< **** savedOGS:save:was:[0:select$129,nest($108)]
< **   OI: B
< **   OI:getQual:savedOI:B
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:select$129,nest($108)]
< **   OGS:[0:$108]
< **** OI:getVqual:end: B
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:select$129,nest($108)]
< **** OI:getOIqual: "ES" IV:"ES.has(ep)"
< **   origin.encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:getVqual: ES on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$108]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: ES on: 0 Items 
< **   father: ES.has(ep)
< **   father.f.f.f.f:
< 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** getVqual:B2:
< [0:$108]
< ---
< in ES: ref Experts
< **** DataItem:getVqual: in ES: ref Experts
< [0:$108]
< **** ObjectGenerator:getVqual: Experts
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts
< **   OGs: [0:$108]
< 
< **** OI:getVqual: Experts on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$108]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: Experts on: 4 Items 
< **   father: Experts
< **   father.f.f.f.f:
< 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** ENC:OI.getVqual:[1:$108]
< **   ENC:result:[1:select$129]
< **** ENC:OI.getVqual:[2:select$129]
< **   ENC:result:[2:expertIsOnDutyR]
< **** ENC:OI.getVqual:[3:expertIsOnDutyR]
< **   ENC:result:[3:Plant]
< **** ENC:OI.getVqual:[4:Plant]
< **   ENC:result:[4:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts
< **   OI:getQual:savedOI:Experts
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES
< **   OI:getQual:savedOI:ES
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:$108]
< **** OI:getVqual:end: ES
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "has(ep)" IV:"ES.has(ep)"
< **   origin.encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:getVqual: ES on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$108]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: ES on: 0 Items 
< **   father: ES.has(ep)
< **   father.f.f.f.f:
< 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** getVqual:B2:
< [0:$108]
< ---
< in ES: ref Experts
< **** DataItem:getVqual: in ES: ref Experts
< [0:$108]
< **** ObjectGenerator:getVqual: Experts
< **   hasVirtualArgs: True
< **** INV:getVqual:Experts
< **   OGs: [0:$108]
< 
< **** OI:getVqual: Experts on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$108]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: Experts on: 4 Items 
< **   father: Experts
< **   father.f.f.f.f:
< 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** ENC:OI.getVqual:[1:$108]
< **   ENC:result:[1:select$129]
< **** ENC:OI.getVqual:[2:select$129]
< **   ENC:result:[2:expertIsOnDutyR]
< **** ENC:OI.getVqual:[3:expertIsOnDutyR]
< **   ENC:result:[3:Plant]
< **** ENC:OI.getVqual:[4:Plant]
< **   ENC:result:[4:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** Pattern:getVqual: Experts :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Experts
< **   OI:getQual:savedOI:Experts
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Experts
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ES
< **   OI:getQual:savedOI:ES
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:$108]
< **** OI:getVqual:end: ES
< **   qual: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: has(ep) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< 
< **** getVqual:added:isNest:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< [0:tinyY,nest(Experts)]
< **** koks: has(ep) on: 0 Items 
< **   father: ES.has(ep)
< **   father.f.f.f.f:
< 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** PRE: [0:tinyY,nest(Experts)]
< **** pathToSuper: "SetLib.Set(#Expert)" of:DOG:
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Expert) :isImplSuper=False
< **   pathToSuper:E:"Set(#Expert)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Expert)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:tinyY,nest(Experts),r:Set]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Experts),r:Set]
< ---
< 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **** Pattern:getVqual: has :isVirtual:True
< [0:tinyY,nest(Experts),r:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Experts),r:Set]
< **** newFindBinding: 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **** searchBinding: 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< [0:tinyY,nest(Experts),r:Set]
< **** searchBinding: 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< [0:tinyY,nest(Experts)]
< **   checkDOG: Experts 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< father:
< Experts: SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   Ex: Set(#Expert)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< has::< 
<    B := false
<    scan
<       if (current == e) :then 
<          B := true
< ...
< **** newFindBinding:found: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< **** PTN:getVqual:gotBinding: 
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< 
< **** getVqual:cont:afterATd:qual:
< B := false
<    scan
<       if (current == e) :then 
<          B := true
<          leave(has)
< ...
< [0:tinyY,nest(Experts),r:Set&]
< **** savedOGS:save:was:[0:tinyY,nest(Experts&),r:Set&]
< **   OI: has(ep)
< **   OI:getQual:savedOI:has(ep)
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts&),r:Set&]
< **   OGS:[0:tinyY]
< **** DataItem:getVqual: out B: var boolean
< [0:tinyY,nest(Experts),r:Set&,nest(has)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:tinyY,nest(Experts),r:Set&,nest(has)]
< 
< **** OI:getVqual: boolean on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Experts),r:Set&,nest(has)]
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: boolean
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OGS:[0:tinyY,nest(Experts),r:Set&,nest(has)]
< ***** viaInclude:notTop: boolean name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: boolean
< **   encOG: 
< SetLib.Set(#Expert)
<    print: 
<       scan
<          current.print
< **   OGS:[0:tinyY,nest(Experts),r:Set&,nest(has)]
< **** ENC:OI.viaInclude:[0:tinyY,nest(Experts),r:Set&,nest(has)]
< **   ENC:result:[0:tinyY,nest(Experts),r:Set&]
< **** viaInclude:GOT:
< [0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **** savedOGS:save:False[0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **   OGS:[0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **** OI:getVqual:end: has(ep)
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Experts),r:Set&,nest(Experts)]
< **** OI:getOIqual: "ep" IV:"ep"
< **   origin.encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< 
< **** OI:getVqual: ep on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$108]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: ep on: 2 Items 
< **   father: ep
< **   father.f.f.f.f:
< ES.has(ep)
< **** ENC:OI.getVqual:[1:$108]
< **   ENC:result:[1:select$129]
< **** ENC:OI.getVqual:[2:select$129]
< **   ENC:result:[2:expertIsOnDutyR]
< 
< **** getVqual:B2:
< [0:expertIsOnDutyR]
< ---
< in ep: ref Expert
< **** DataItem:getVqual: in ep: ref Expert
< [0:expertIsOnDutyR]
< **** ObjectGenerator:getVqual: Expert
< **   hasVirtualArgs: False
< **** INV:getVqual:Expert
< **   OGs: [0:expertIsOnDutyR]
< 
< **** OI:getVqual: Expert on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)
< **** koks: Expert on: 2 Items 
< **   father: Expert
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:expertIsOnDutyR]
< **   ENC:result:[1:Plant]
< **** ENC:OI.getVqual:[2:Plant]
< **   ENC:result:[2:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Expert: 
<    in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
< ...
< **** Pattern:getVqual: Expert :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Expert
< **   OI:getQual:savedOI:Expert
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Expert
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: ep
< **   OI:getQual:savedOI:ep
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:$108]
< **** OI:getVqual:end: ep
< **   qual: 
< in name: var StringLib.String
<    in quali: ref Qualifications
<    %globals
<    print: 
<       "Expert:".print
< ...
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "theSchedule" IV:"theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))"
< **   origin.encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:getVqual: theSchedule on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: theSchedule on: 1 Items 
< **   father: theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:expertIsOnDutyR]
< **   ENC:result:[1:Plant]
< 
< **** getVqual:B2:
< [0:Plant]
< ---
< in theSchedule: ref Schedule
< **** DataItem:getVqual: in theSchedule: ref Schedule
< [0:Plant]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:Plant]
< 
< **** OI:getVqual: Schedule on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: Schedule on: 1 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** ENC:OI.getVqual:[1:Plant]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: theSchedule
< **   OI:getQual:savedOI:theSchedule
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:expertIsOnDutyR]
< **** OI:getVqual:end: theSchedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< **** OI:getOIqual: "select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))" IV:"theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))"
< **   origin.encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< 
< **** OI:getVqual: theSchedule on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:expertIsOnDutyR]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: theSchedule on: 1 Items 
< **   father: theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** ENC:OI.getVqual:[1:expertIsOnDutyR]
< **   ENC:result:[1:Plant]
< 
< **** getVqual:B2:
< [0:Plant]
< ---
< in theSchedule: ref Schedule
< **** DataItem:getVqual: in theSchedule: ref Schedule
< [0:Plant]
< **** ObjectGenerator:getVqual: Schedule
< **   hasVirtualArgs: True
< **** INV:getVqual:Schedule
< **   OGs: [0:Plant]
< 
< **** OI:getVqual: Schedule on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Plant]
< **   encOG: 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** koks: Schedule on: 1 Items 
< **   father: Schedule
< **   father.f.f.f.f:
< 
< in theAlarms: ref Alarms
<    in theSchedule: ref Schedule
<    PlantInvA: 
<       out B: var Boolean
<       B := theSchedule.forAll(
< ...
< **** ENC:OI.getVqual:[1:Plant]
< **   ENC:result:[1:tinyY]
< 
< **** getVqual:B2:
< [0:tinyY]
< ---
< 
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** Pattern:getVqual: Schedule :isVirtual:False
< [0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:False[0:tinyY]
< **   OI: Schedule
< **   OI:getQual:savedOI:Schedule
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:tinyY]
< **** OI:getVqual:end: Schedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** getVqual:cont:afterATd:qual:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY]
< **** savedOGS:save:was:[0:tinyY]
< **   OI: theSchedule
< **   OI:getQual:savedOI:theSchedule
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY]
< **   OGS:[0:expertIsOnDutyR]
< **** OI:getVqual:end: theSchedule
< **   qual: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< ObjectGenerator
< **   OGS:[0:tinyY]
< 
< **** OI:getVqual: select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)) on=0 pn=1 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY]
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY]
< **   encOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< 
< **** getVqual:added:isNest:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< [0:tinyY,nest(Schedule)]
< **** koks: select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep)) on: 0 Items 
< **   father: theSchedule.select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   father.f.f.f.f:
< 
< in ep: ref Expert
<    out fp: ref Periods
<    put('Q')
<    fp := theSchedule.select(
<       in p: ref Period
< ...
< **** PRE: [0:tinyY,nest(Schedule)]
< **** pathToSuper: "MapLib.Map(#Period,#Experts)" of:DOG:
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   pathToSuper:DOG.super.scanSons:i=1:E:MapLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Map(#Period,#Experts) :isImplSuper=False
< **   pathToSuper:E:"Map(#Period,#Experts)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Map(#Period,#Experts)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   PRE:result:[0:tinyY,nest(Schedule),r:Map]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),r:Map]
< ---
< 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< **** Pattern:getVqual: select :isVirtual:True
< [0:tinyY,nest(Schedule),r:Map]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:tinyY,nest(Schedule),r:Map]
< **** newFindBinding: 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< **** searchBinding: 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< [0:tinyY,nest(Schedule),r:Map]
< **** searchBinding: 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< [0:tinyY,nest(Schedule)]
< **   checkDOG: Schedule 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< father:
< Schedule: MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   Ex: Map(#Period,#Experts)
< **   Ex.OGs.super:
< 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< **   currentArg: in Domain:< Object
< **   currentArg: in Range:< Object
< **   checkDOG: Map 
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< father:
< Map: 
<    in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
< ...
< 
<  ==== FOUND BINDING: =====
< 
< select:< 
<    in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
< ...
< **** newFindBinding:found: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** PTN:getVqual:gotBinding: 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< [0:tinyY,nest(Schedule),r:Map&]
< **** savedOGS:save:was:[0:tinyY,nest(Schedule),r:Map&]
< **   OI: select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   OI:getQual:savedOI:
< select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule),r:Map&]
< **   OGS:[0:tinyY]
< **** DataItem:getVqual: out R: ref SetLib.Set(#Domain)
< [0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **** ObjectGenerator:getVqual: SetLib.Set(#Domain)
< **   hasVirtualArgs: True
< **** INV:getVqual:SetLib.Set(#Domain)
< **   OGs: [0:tinyY,nest(Schedule),r:Map&,nest(select)]
< 
< **** OI:getVqual: SetLib on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule),r:Map&,nest(select)]
< **   encOG: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **** koks: SetLib on: 3 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< **** ENC:OI.getVqual:[1:tinyY,nest(Schedule),r:Map&,nest(select)]
< **   ENC:result:[1:tinyY,nest(Schedule),r:Map&]
< **** ENC:OI.getVqual:[2:tinyY,nest(Schedule),r:Map&]
< **** Remote:[2:tinyY,nest(Schedule)]
< **   DOGx: 
< MapLib.Map(#Period,#Experts)
<    dum: var integer
< **   remote:scanSons:E:"MapLib" E.ATd.label:ModuleItem E.on: 0 E.pn: 0 E.ATd:
< --MapLib
< 
< **   remote:first:
< **** append:label: ModuleItem dcl: 
< --MapLib
< 
< **   isEmpty: False
< **   hasVargs: False
< **   append:END:
< **** remote:got:superDOG:
< in Domain:< Object
<    in Range:< Object
<    Entry: 
<       in inx: ref Domain
<       in elm: ref Range
< ...
< remote:[2:tinyY,nest(Schedule),nest(MapLib)]
< **** remote:END[2:tinyY,nest(Schedule),nest(MapLib)]
< **   ENC:result:[2:tinyY,nest(Schedule),nest(MapLib)]
< **** ENC:OI.getVqual:[3:tinyY,nest(Schedule),nest(MapLib)]
< **   ENC:result:[3:tinyY,nest(Schedule)]
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule)]
< ---
< 
< --SetLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:tinyY,nest(Schedule)]
< **** savedOGS:save:False[0:tinyY,nest(Schedule)]
< **   OI: SetLib
< **   OI:getQual:savedOI:SetLib
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule)]
< **   OGS:[0:tinyY,nest(Schedule)]
< **** OI:getVqual:end: SetLib
< **   qual: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule)]
< 
< **** OI:getVqual: Set(#Domain) on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:tinyY,nest(Schedule)]
< **   encOG: 
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:tinyY,nest(Schedule)]
< **   encOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:tinyY]
< **   encOG:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< 
< **** getVqual:added:isNest:
< Set: Collection
<       %globals
<       has::< 
<          B := false
<          scan
< ...
< [0:tinyY,nest(Schedule),nest(SetLib)]
< **** koks: Set(#Domain) on: 0 Items 
< **   father: SetLib.Set(#Domain)
< **   father.f.f.f.f:
< 
< in pred:< 
<       in IX: ref Domain
<       in E: ref Range
<       out V: var Boolean
<    out R: ref SetLib.Set(#Domain)
< ...
< 
< **** getVqual:B2:
< [0:tinyY,nest(Schedule),nest(SetLib)]
< ---
< 
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **** Pattern:getVqual: Set :isVirtual:False
< [0:tinyY,nest(Schedule),nest(SetLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< [0:tinyY,nest(Schedule),nest(SetLib)]
< **** savedOGS:save:False[0:tinyY,nest(Schedule),nest(SetLib)]
< **   OI: Set(#Domain)
< **   OI:getQual:savedOI:Set(#Domain)
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(Schedule),nest(SetLib)]
< **   OGS:[0:tinyY,nest(Schedule),nest(SetLib)]
< **** OI:getVqual:end: Set(#Domain)
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule),nest(SetLib)]
< **** OI:getVqual:return: out R: ref SetLib.Set(#Domain)
< **   qual:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
<          if (current == e) :then 
<             B := true
<             leave(has)
<          :else 
<             B := B
<    isEmpty: 
<       out B: var Boolean
<       B := head == none
<    insert:: 
<       head := link(e,head)
<    remove:: 
<       "\nObs! Set:remove:not implemented!\n".print
<    card: 
<       out N: var integer
<       scan
<          N := N + 1
<    clear: 
<       head := none
<    scan:: 
<       nxt: ref link
<       nxt := head
<       scanTail: 
<          current: ref elm
<          nxtt: ref link
<          nxtt := this(scan).nxt.next
<          loop: do 
<             if (nxtt =/= none) :then 
<                current := nxtt.e
<                inner(scanTail)
<                nxtt := nxtt.next
<                restart(loop)
<       Loop: do 
<          if (nxt =/= none) :then 
<             current := nxt.e
<             inner(scan)
<             nxt := nxt.next
<             restart(Loop)
<          :else 
<             nxt := nxt
<    forAllX: 
<       current: ref elm
<       scan
<          (this(forAllX)).current := current
<          inner(forAllX)
<          -- can we make forAll, exists, reduce the same for Set, OrderedList, etc?
<    forAll: 
<       in pred:< 
<          in x: ref Object
<          out V: var Boolean
<       out B: var Boolean
<       B := true
<       scan
<          B := B && pred(current)
<    exists: 
<       in Fxx:< 
<          in x: ref elm
<          out V: var Boolean
<       out B: var Boolean
<       scan
<          BBB: var Boolean
<          BBB := Fxx(current)
<          if (BBB) :then 
<             B := true
<             leave(scan)
<          :else 
<             B := B
<    reduce: 
<       in F:< 
<          in x: ref Object
<          in b: var Boolean
<          out z: var Boolean
<       in IV: var Boolean
<       out V: var Boolean
<       V := IV
<       scan
<          V := F(current,V)
<    link: 
<       in e: ref elm
<       in next: ref link
<    head: ref link
<    inner(Set)
< [0:tinyY,nest(Schedule),nest(SetLib)]
< **** OI:getVqual:end: 
< select(
<    in p: ref Period
<    in ES: ref Experts
<    out B: var boolean
<    B := ES.has(ep))
< **   qual: 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(Schedule),nest(SetLib)]
< **** OI:getOIqual: "scan" IV:"scan"
< **   origin.encOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< 
< **** OI:getVqual: scan on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:print]
< **   encOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **** koks: scan on: 1 Items 
< **   father: scan
< **   father.f.f.f.f:
< 
< print: 
<    put('E')
<    scan
<       put('R')
<       current.print
< ...
< **** ENC:OI.getVqual:[1:print]
< **   ENC:result:[1:Periods]
< **** PRE: [0:Periods]
< **** pathToSuper: "SetLib.Set(#Period)" of:DOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   innerDOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Period) :isImplSuper=False
< **   pathToSuper:E:"Set(#Period)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Period)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[0:Periods,r:Set]
< 
< **** getVqual:B2:
< [0:Periods,r:Set]
< ---
< 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **** Pattern:getVqual: scan :isVirtual:True
< [0:Periods,r:Set]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Periods,r:Set]
< **** newFindBinding: 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **** searchBinding: 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< [0:Periods,r:Set]
< **** searchBinding: 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< [0:Periods]
< **   checkDOG: Periods 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< father:
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   Ex: Set(#Period)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   checkDOG: Set 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< father:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< 
<  ==== FOUND BINDING: =====
< 
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **** newFindBinding:found: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** PTN:getVqual:gotBinding: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< 
< **** getVqual:cont:afterATd:qual:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< [0:Periods,r:Set&]
< **** savedOGS:save:was:[0:Periods,r:Set&]
< **   OI: scan
< **   OI:getQual:savedOI:scan
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Periods,r:Set&]
< **   OGS:[0:print]
< **** OI:getVqual:end: scan
< **   qual: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< ObjectGenerator
< **   OGS:[0:Periods,r:Set&]
< **** OI:getOIqual: "current" IV:"current.print"
< **   origin.encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** OI:getVqual: current on=0 pn=2 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$131]
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** koks: current on: 0 Items 
< **   father: current.print
< **   father.f.f.f.f:
< 
< put('E')
< scan
<    put('R')
<    current.print
<    put('T')
< **** PRE: [0:scan$131]
< **** pathToSuper: "scan" of:DOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=1 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   PRE:onx,pnx,isR:1,1,False OGx:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   PRE:result:[0:scan$131,scan]
< **** PRE: [0:scan$131,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:result:[0:scan$131,scan,scan]
< 
< **** getVqual:B2:
< [0:scan$131,scan,scan]
< ---
< current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan$131,scan,scan]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan$131,scan,scan]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$131,scan,scan]
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[1:scan$131,scan,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   ENC:pred:  pred.DOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[2:scan$131,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=1 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **   OGsuper: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[3:scan$131]
< **   ENC:result:[3:print]
< **   ENC:[pnx=1]oENC[onx=1]
< **** ENC:OI.getVqual:[3:print]
< **   ENC:result:[3:Periods]
< **** PRE: [2:Periods]
< **** pathToSuper: "SetLib.Set(#Period)" of:DOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   innerDOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Period) :isImplSuper=False
< **   pathToSuper:E:"Set(#Period)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Period)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[2:Periods,r:Set]
< **   ENC:result:[2:Periods,r:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Periods,r:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Periods,r:Set,Collection]
< **   ENC:result:[1:Periods,r:Set,Collection]
< 
< **** getVqual:B2:
< [0:Periods,r:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Periods,r:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Periods,r:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Periods,r:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Periods,r:Set]
< **** searchBinding: in elm:< Object
< [0:Periods]
< **   checkDOG: Periods 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< father:
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   Ex: Set(#Period)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Period
< 
< ==== FOUND BINDING IN ARG: 
< #Period
< **** newFindBinding:found: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:Periods&,r:Set,Collection]
< **** savedOGS:save:False[0:Periods&,r:Set,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Periods&,r:Set,Collection]
< **   OGS:[0:Periods&,r:Set,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:Periods&,r:Set,Collection]
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:Periods&,r:Set,Collection]
< **** savedOGS:save:was:[0:Periods&,r:Set,Collection]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Periods&,r:Set,Collection]
< **   OGS:[0:scan$131]
< **** OI:getVqual:end: current
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:Periods&,r:Set,Collection]
< **** OI:getOIqual: "print" IV:"current.print"
< **   origin.encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** OI:getVqual: current on=0 pn=2 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$131]
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** koks: current on: 0 Items 
< **   father: current.print
< **   father.f.f.f.f:
< 
< put('E')
< scan
<    put('R')
<    current.print
<    put('T')
< **** PRE: [0:scan$131]
< **** pathToSuper: "scan" of:DOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=1 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   PRE:onx,pnx,isR:1,1,False OGx:
< 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   PRE:result:[0:scan$131,scan]
< **** PRE: [0:scan$131,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:onx,pnx,isR:0,1,False OGx:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   PRE:result:[0:scan$131,scan,scan]
< 
< **** getVqual:B2:
< [0:scan$131,scan,scan]
< ---
< current: ref elm
< **** DataItem:getVqual: current: ref elm
< [0:scan$131,scan,scan]
< **** ObjectGenerator:getVqual: elm
< **   hasVirtualArgs: False
< **** INV:getVqual:elm
< **   OGs: [0:scan$131,scan,scan]
< 
< **** OI:getVqual: elm on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:scan$131,scan,scan]
< **   encOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **** koks: elm on: 1 Items 
< **   father: elm
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[1:scan$131,scan,scan]
< **** pathToSuper: "" of:DOG:
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E: :isImplSuper=True
< **   pathToSuper:E:"" E.on=0 E.pn=0 DOG.super.pn=1 isR=False
< **   pathToSuper:end:super.last: "" :on=0:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:< 
<    %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **   ENC:pred:  pred.DOG: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **   OGsuper: 
< %OSDvisibility skipInternal
<    current: ref elm
<    inner(scan)
< **** ENC:OI.getVqual:[2:scan$131,scan]
< **** pathToSuper: "scan" of:DOG:
< scan
<    put('R')
<    current.print
<    put('T')
< **   pathToSuper:DOG.super.scanSons:i=1:E:scan :isImplSuper=False
< **   pathToSuper:E:"scan" E.on=1 E.pn=1 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "scan" :on=1:pn=1:isR=False:ptn.isVirt=True ptn:
< scan:: 
<    nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
< ...
< **   ENC:pred:  pred.DOG: 
< scan
<    put('R')
<    current.print
<    put('T')
< **   OGsuper: 
< nxt: ref link
<    nxt := head
<    scanTail: 
<       current: ref elm
<       nxtt: ref link
< ...
< **** ENC:OI.getVqual:[3:scan$131]
< **   ENC:result:[3:print]
< **   ENC:[pnx=1]oENC[onx=1]
< **** ENC:OI.getVqual:[3:print]
< **   ENC:result:[3:Periods]
< **** PRE: [2:Periods]
< **** pathToSuper: "SetLib.Set(#Period)" of:DOG:
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   innerDOG: 
< put('E')
<    scan
<       put('R')
<       current.print
<       put('T')
< **   pathToSuper:DOG.super.scanSons:i=1:E:SetLib :isImplSuper=False
< **   pathToSuper:DOG.super.scanSons:i=2:E:Set(#Period) :isImplSuper=False
< **   pathToSuper:E:"Set(#Period)" E.on=0 E.pn=0 DOG.super.pn=0 isR=True
< **   pathToSuper:end:super.last: "Set(#Period)" :on=0:pn=0:isR=True:ptn.isVirt=False ptn:
< Set: Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:onx,pnx,isR:0,0,True OGx:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   PRE:result:[2:Periods,r:Set]
< **   ENC:result:[2:Periods,r:Set]
< **   ENC:[pnx=1]oENC[onx=0]
< **** PRE: [1:Periods,r:Set]
< **** pathToSuper: "Collection" of:DOG:
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   pathToSuper:DOG.super.scanSons:i=1:E:Collection :isImplSuper=False
< **   pathToSuper:E:"Collection" E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "Collection" :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< Collection: 
<    %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %id "Collection"
<    %globals
<    in elm:< Object
<    scan:< 
<       %OSDvisibility skipInternal
< ...
< **   PRE:result:[1:Periods,r:Set,Collection]
< **   ENC:result:[1:Periods,r:Set,Collection]
< 
< **** getVqual:B2:
< [0:Periods,r:Set,Collection]
< ---
< in elm:< Object
< **** Pattern:getVqual: elm :isVirtual:True
< [0:Periods,r:Set,Collection]
< **   PTN:getVqual:isVirtual:OGS: 
< [0:Periods,r:Set,Collection]
< **** newFindBinding: in elm:< Object
< **** searchBinding: in elm:< Object
< [0:Periods,r:Set,Collection]
< **** searchBinding: in elm:< Object
< [0:Periods,r:Set]
< **** searchBinding: in elm:< Object
< [0:Periods]
< **   checkDOG: Periods 
< SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< father:
< Periods: SetLib.Set(#Period)
<    print: 
<       put('E')
<       scan
<          put('R')
< ...
< **   Ex: Set(#Period)
< **   Ex.OGs.super:
< 
< Collection
<    %globals
<    has::< 
<       B := false
<       scan
< ...
< **   currentArg: in elm:< Object
< **   superArg: ObjectGenerator #Period
< 
< ==== FOUND BINDING IN ARG: 
< #Period
< **** newFindBinding:found: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **** PTN:getVqual:gotBinding: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:Periods&,r:Set,Collection]
< **** savedOGS:save:False[0:Periods&,r:Set,Collection]
< **   OI: elm
< **   OI:getQual:savedOI:elm
< **   IT: ref [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Periods&,r:Set,Collection]
< **   OGS:[0:Periods&,r:Set,Collection]
< **** OI:getVqual:end: elm
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:Periods&,r:Set,Collection]
< 
< **** getVqual:cont:afterATd:qual:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:Periods&,r:Set,Collection]
< **** savedOGS:save:was:[0:Periods&,r:Set,Collection]
< **   OI: current
< **   OI:getQual:savedOI:current
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Periods&,r:Set,Collection]
< **   OGS:[0:scan$131]
< **** OI:getVqual:end: current
< **   qual: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ObjectGenerator
< **   OGS:[0:Periods&,r:Set,Collection]
< 
< **** OI:getVqual: print on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:Periods&,r:Set,Collection]
< **   encOG: 
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:Periods&,r:Set,Collection]
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:Periods&,r:Set]
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< **   OI:getVqual:findEnc:i=3 OGSz:[0:Periods&]
< **   encOG:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< ***** OI:getVqual:findEnc:match!:
< [0:Periods&]
< 
< **** getVqual:added:isNest:
< in start: var integer
<    in end: var integer
<    %globals
<    print: 
<       "Period:".print
< ...
< [0:Periods&,nest(Period)]
< **** koks: print on: 0 Items 
< **   father: current.print
< **   father.f.f.f.f:
< 
< put('E')
< scan
<    put('R')
<    current.print
<    put('T')
< 
< **** getVqual:B2:
< [0:Periods&,nest(Period)]
< ---
< 
< print: 
<    "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
< ...
< **** Pattern:getVqual: print :isVirtual:False
< [0:Periods&,nest(Period)]
< 
< **** getVqual:cont:afterATd:qual:
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< [0:Periods&,nest(Period)]
< **** savedOGS:save:was:[0:Periods&,nest(Period)]
< **   OI: print
< **   OI:getQual:savedOI:print
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:Periods&,nest(Period)]
< **   OGS:[0:Periods&,r:Set,Collection]
< **** OI:getVqual:end: print
< **   qual: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< ObjectGenerator
< **   OGS:[0:Periods&,nest(Period)]
< **** OI:getOIqual: "start" IV:"start"
< **   origin.encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:getVqual: start on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:print]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** koks: start on: 1 Items 
< **   father: start
< **   father.f.f.f.f:
< putint(start)
< **** ENC:OI.getVqual:[1:print]
< **   ENC:result:[1:Period]
< 
< **** getVqual:B2:
< [0:Period]
< ---
< in start: var integer
< **** DataItem:getVqual: in start: var integer
< [0:Period]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Period]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Period]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   OGS:[0:Period]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   OGS:[0:Period]
< **** ENC:OI.viaInclude:[0:Period]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(print)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(print)]
< **** savedOGS:save:False[0:tinyY,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(print)]
< **   OGS:[0:tinyY,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:tinyY,nest(print)]
< **** savedOGS:save:was:[0:tinyY,nest(print)]
< **   OI: start
< **   OI:getQual:savedOI:start
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(print)]
< **   OGS:[0:print]
< **** OI:getVqual:end: start
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(print)]
< **** OI:getOIqual: "end" IV:"end"
< **   origin.encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< 
< **** OI:getVqual: end on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:print]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** koks: end on: 1 Items 
< **   father: end
< **   father.f.f.f.f:
< putint(end)
< **** ENC:OI.getVqual:[1:print]
< **   ENC:result:[1:Period]
< 
< **** getVqual:B2:
< [0:Period]
< ---
< in end: var integer
< **** DataItem:getVqual: in end: var integer
< [0:Period]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:Period]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:Period]
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **** OI:viaInclude:on=2 BETA %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib
< **   OI: integer
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   OGS:[0:Period]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< "Period:".print
<    putint(start)
<    put(',')
<    put('Y')
<    putint(end)
< ...
< **   OGS:[0:Period]
< **** ENC:OI.viaInclude:[0:Period]
< **   ENC:result:[0:tinyY]
< **** viaInclude:GOT:
< [0:tinyY,nest(print)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:tinyY,nest(print)]
< **** savedOGS:save:False[0:tinyY,nest(print)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(print)]
< **   OGS:[0:tinyY,nest(print)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(print)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:tinyY,nest(print)]
< **** savedOGS:save:was:[0:tinyY,nest(print)]
< **   OI: end
< **   OI:getQual:savedOI:end
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:tinyY,nest(print)]
< **   OGS:[0:print]
< **** OI:getVqual:end: end
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:tinyY,nest(print)]
< **** OI:getOIqual: "isNeg" IV:"isNeg"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: isNeg on: 0 Items 
< **   father: isNeg
< **   father.f.f.f.f:
< 
< putint: 
<    %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
< ...
< 
< **** getVqual:B2:
< [0:putint]
< ---
< isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:putint]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "V" IV:"V < 0"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: V on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: V on: 0 Items 
< **   father: V < 0
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "< 0" IV:"V < 0"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: V on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: V on: 0 Items 
< **   father: V < 0
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: < 0 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: < 0 on: 0 Items 
< **   father: V < 0
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< <  : 
<    %basic 51
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: <   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 51
<    in V: var integer
<    out B: var boolean
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: < 0
< **   OI:getQual:savedOI:< 0
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out B: var boolean
< [0:BETA,nest(integer),nest(<)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:BETA,nest(integer),nest(<)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(<)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 51
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(<)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:BETA]
< **** OI:getVqual:end: < 0
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "isNeg" IV:"isNeg"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: isNeg on: 0 Items 
< **   father: isNeg
< **   father.f.f.f.f:
< 
< if (isNeg) :then 
<    V := 0 - V
< 
< **** getVqual:B2:
< [0:putint]
< ---
< isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:putint]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "isNeg" IV:"isNeg"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: isNeg on: 0 Items 
< **   father: isNeg
< **   father.f.f.f.f:
< 
< if (isNeg) :then 
<    V := 0 - V
< 
< **** getVqual:B2:
< [0:putint]
< ---
< isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:putint]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "isNeg" IV:"isNeg"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: isNeg on: 0 Items 
< **   father: isNeg
< **   father.f.f.f.f:
< 
< if (isNeg) :then 
<    put('-')
< 
< **** getVqual:B2:
< [0:putint]
< ---
< isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:putint]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "isNeg" IV:"isNeg"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: isNeg on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: isNeg on: 0 Items 
< **   father: isNeg
< **   father.f.f.f.f:
< 
< if (isNeg) :then 
<    put('-')
< 
< **** getVqual:B2:
< [0:putint]
< ---
< isNeg: var Boolean
< **** DataItem:getVqual: isNeg: var Boolean
< [0:putint]
< **** ObjectGenerator:getVqual: Boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:Boolean
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Boolean on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: Boolean on: 1 Items 
< **   father: Boolean
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Boolean
< **   OI:getQual:savedOI:Boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: isNeg
< **   OI:getQual:savedOI:isNeg
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: isNeg
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "V" IV:"V"
< **   origin.encOG: V := 0 - V
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$136]
< **   encOG: V := 0 - V
< **** koks: V on: 1 Items 
< **   father: V
< **   father.f.f.f.f:
< 
< if (isNeg) :then 
<    V := 0 - V
< **** ENC:OI.getVqual:[1:$136]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: V := 0 - V
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$136]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "- V" IV:"0 - V"
< **   origin.encOG: V := 0 - V
< 
< **** OI:getVqual: - V on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:$136]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:$136]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:$136,nest(integer)]
< **** koks: - V on: 0 Items 
< **   father: 0 - V
< **   father.f.f.f.f:
< V := 0 - V
< 
< **** getVqual:B2:
< [0:$136,nest(integer)]
< ---
< 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: -   :isVirtual:False
< [0:$136,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 62
<    in V: var integer
<    out R: var integer
< [0:$136,nest(integer)]
< **** savedOGS:save:was:[0:integer]
< **   OI: - V
< **   OI:getQual:savedOI:- V
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:integer]
< **   OGS:[0:$136]
< **** DataItem:getVqual: out R: var integer
< [0:$136,nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:$136,nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$136,nest(integer),nest(-)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:$136,nest(integer),nest(-)]
< **   ENC:result:[1:$136,nest(integer)]
< **** ENC:OI.getVqual:[2:$136,nest(integer)]
< **   ENC:result:[2:$136]
< 
< **** getVqual:B2:
< [0:$136]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:$136]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:$136]
< **** savedOGS:save:False[0:$136]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:$136]
< **   OGS:[0:$136]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:$136]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:$136]
< **** OI:getVqual:end: - V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:$136]
< **** OI:getOIqual: "V" IV:"V"
< **   origin.encOG: V := 0 - V
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$136]
< **   encOG: V := 0 - V
< **** koks: V on: 1 Items 
< **   father: V
< **   father.f.f.f.f:
< 0 - V
< **** ENC:OI.getVqual:[1:$136]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: V := 0 - V
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$136]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: L on: 1 Items 
< **   father: L
< **   father.f.f.f.f:
< 
< loop: do 
<    L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "L" IV:"L + 1"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: L on: 1 Items 
< **   father: L + 1
< **   father.f.f.f.f:
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "+ 1" IV:"L + 1"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: L on: 1 Items 
< **   father: L + 1
< **   father.f.f.f.f:
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: + 1 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: + 1 on: 0 Items 
< **   father: L + 1
< **   father.f.f.f.f:
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: + 1
< **   OI:getQual:savedOI:+ 1
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out R: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: + 1
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "D" IV:"D.put(V /% 10):at[L]"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: D on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: D on: 1 Items 
< **   father: D.put(V /% 10):at[L]
< **   father.f.f.f.f:
< 
< loop: do 
<    L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< D: obj Indexed(20,#integer)
< **** DataItem:getVqual: D: obj Indexed(20,#integer)
< [0:putint]
< **** ObjectGenerator:getVqual: Indexed(20,#integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(20,#integer)
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Indexed(20,#integer) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: Indexed(20,#integer) on: 1 Items 
< **   father: Indexed(20,#integer)
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Indexed(20,#integer)
< **   OI:getQual:savedOI:Indexed(20,#integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Indexed(20,#integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: D
< **   OI:getQual:savedOI:D
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: D
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "put(V /% 10):at[L]" IV:"D.put(V /% 10):at[L]"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: D on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: D on: 1 Items 
< **   father: D.put(V /% 10):at[L]
< **   father.f.f.f.f:
< 
< loop: do 
<    L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< D: obj Indexed(20,#integer)
< **** DataItem:getVqual: D: obj Indexed(20,#integer)
< [0:putint]
< **** ObjectGenerator:getVqual: Indexed(20,#integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(20,#integer)
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Indexed(20,#integer) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: Indexed(20,#integer) on: 1 Items 
< **   father: Indexed(20,#integer)
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Indexed(20,#integer)
< **   OI:getQual:savedOI:Indexed(20,#integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Indexed(20,#integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: D
< **   OI:getQual:savedOI:D
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: D
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: put(V /% 10):at[L] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** getVqual:added:isNest:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA,nest(Indexed)]
< **** koks: put(V /% 10):at[L] on: 0 Items 
< **   father: D.put(V /% 10):at[L]
< **   father.f.f.f.f:
< 
< loop: do 
<    L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
< ...
< 
< **** getVqual:B2:
< [0:BETA,nest(Indexed)]
< ---
< 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **** Pattern:getVqual: put(V: var integer):at[inx: var integer] :isVirtual:False
< [0:BETA,nest(Indexed)]
< 
< **** getVqual:cont:afterATd:qual:%basic 115
< [0:BETA,nest(Indexed)]
< **** savedOGS:save:was:[0:BETA,nest(Indexed)]
< **   OI: put(V /% 10):at[L]
< **   OI:getQual:savedOI:put(V /% 10):at[L]
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(Indexed)]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: put(V /% 10):at[L]
< **   qual: %basic 115
< ObjectGenerator
< **   OGS:[0:BETA,nest(Indexed)]
< **** OI:getOIqual: "V" IV:"V /% 10"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V /% 10
< **   father.f.f.f.f:
< D.put(V /% 10):at[L]
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "/% 10" IV:"V /% 10"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V /% 10
< **   father.f.f.f.f:
< D.put(V /% 10):at[L]
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: /% 10 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: /% 10 on: 0 Items 
< **   father: V /% 10
< **   father.f.f.f.f:
< D.put(V /% 10):at[L]
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< /%  : 
<    %basic 69
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: /%   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 69
<    in V: var integer
<    out R: var integer
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: /% 10
< **   OI:getQual:savedOI:/% 10
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out R: var integer
< [0:BETA,nest(integer),nest(/%)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(/%)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(/%)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 69
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(/%)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: /% 10
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: L on: 1 Items 
< **   father: L
< **   father.f.f.f.f:
< D.put(V /% 10):at[L]
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "V" IV:"V"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V
< **   father.f.f.f.f:
< 
< loop: do 
<    L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
< ...
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "V" IV:"V // 10"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V // 10
< **   father.f.f.f.f:
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "// 10" IV:"V // 10"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V // 10
< **   father.f.f.f.f:
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: // 10 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: // 10 on: 0 Items 
< **   father: V // 10
< **   father.f.f.f.f:
< 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< //  : 
<    %basic 68
<    in V: var integer
<    out B: var integer
< **** Pattern:getVqual: //   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 68
<    in V: var integer
<    out B: var integer
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: // 10
< **   OI:getQual:savedOI:// 10
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out B: var integer
< [0:BETA,nest(integer),nest(//)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(//)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(//)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 68
<    in V: var integer
<    out B: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(//)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out B: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: // 10
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "V" IV:"V > 0"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V > 0
< **   father.f.f.f.f:
< 
< if (V > 0) :then 
<    restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "> 0" IV:"V > 0"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V > 0
< **   father.f.f.f.f:
< 
< if (V > 0) :then 
<    restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: > 0 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: > 0 on: 0 Items 
< **   father: V > 0
< **   father.f.f.f.f:
< 
< if (V > 0) :then 
<    restart(loop)
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: >   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 53
<    in V: var integer
<    out B: var boolean
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: > 0
< **   OI:getQual:savedOI:> 0
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out B: var boolean
< [0:BETA,nest(integer),nest(>)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:BETA,nest(integer),nest(>)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(>)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(>)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:BETA]
< **** OI:getVqual:end: > 0
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "> 0" IV:"V > 0"
< **   origin.encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:loop]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: V on: 1 Items 
< **   father: V > 0
< **   father.f.f.f.f:
< 
< if (V > 0) :then 
<    restart(loop)
< **** ENC:OI.getVqual:[1:loop]
< **   ENC:result:[1:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< in V: var integer
< **** DataItem:getVqual: in V: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< L := L + 1
<    D.put(V /% 10):at[L]
<    V := V // 10
<    if (V > 0) :then 
<       restart(loop)
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:loop]
< **** OI:getVqual:end: V
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: > 0 on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: > 0 on: 0 Items 
< **   father: V > 0
< **   father.f.f.f.f:
< 
< if (V > 0) :then 
<    restart(loop)
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< >  : 
<    %basic 53
<    in V: var integer
<    out B: var boolean
< **** Pattern:getVqual: >   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 53
<    in V: var integer
<    out B: var boolean
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: > 0
< **   OI:getQual:savedOI:> 0
< **   IT: Invocation [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out B: var boolean
< [0:BETA,nest(integer),nest(>)]
< **** ObjectGenerator:getVqual: boolean
< **   hasVirtualArgs: False
< **** INV:getVqual:boolean
< **   OGs: [0:BETA,nest(integer),nest(>)]
< 
< **** OI:getVqual: boolean on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(>)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: boolean on: 2 Items 
< **   father: boolean
< **   father.f.f.f.f:
< 
< %basic 53
<    in V: var integer
<    out B: var boolean
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(>)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Boolean: value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< **** Pattern:getVqual: Boolean :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: boolean
< **   OI:getQual:savedOI:boolean
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: boolean
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out B: var boolean
< **   qual:
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
<    _thisBasicValue: var Universal
<    &&  : 
<       %basic 70
<       in B: var boolean
<       out R: var boolean
<    ||  : 
<       %basic 63
<       in B: var boolean
<       out R: var boolean
<    =?  : 
<       %basic 50
<       in B: var boolean
<       out R: var boolean
<    not: 
<       %basic 65
<       out R: var boolean
< [0:BETA]
< **** OI:getVqual:end: > 0
< **   qual: 
< value
<    %id "Boolean"
<    %globals inSub
<    %basic 4, 8
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "restart(loop)" IV:"restart(loop)"
< **   origin.encOG: restart(loop)
< 
< **** OI:getVqual: restart(loop) on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:$156]
< **   encOG: restart(loop)
< **** koks: restart(loop) on: 3 Items 
< **   father: restart(loop)
< **   father.f.f.f.f:
< 
< if (V > 0) :then 
<    restart(loop)
< **** ENC:OI.getVqual:[1:$156]
< **   ENC:result:[1:loop]
< **** ENC:OI.getVqual:[2:loop]
< **   ENC:result:[2:putint]
< **** ENC:OI.getVqual:[3:putint]
< **   ENC:result:[3:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< restart(V: var integer):  -- odd parameter type!
<    %basic 102
< **** Pattern:getVqual: restart(V: var integer) :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< -- odd parameter type!
<    %basic 102
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: restart(loop)
< **   OI:getQual:savedOI:restart(loop)
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:$156]
< **** OI:getVqual:end: restart(loop)
< **   qual: 
< -- odd parameter type!
<    %basic 102
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "i" IV:"i"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: i on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: i on: 0 Items 
< **   father: i
< **   father.f.f.f.f:
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< 
< **** getVqual:B2:
< [0:repeat$139]
< ---
< i: var integer
< **** DataItem:getVqual: i: var integer
< [0:repeat$139]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:repeat$139]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 3 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** ENC:OI.getVqual:[1:repeat$139]
< **   ENC:result:[1:for:to:repeat$142]
< **** ENC:OI.getVqual:[2:for:to:repeat$142]
< **   ENC:result:[2:putint]
< **** ENC:OI.getVqual:[3:putint]
< **   ENC:result:[3:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "L" IV:"L + 1 - inx"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: L on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: L on: 2 Items 
< **   father: L + 1 - inx
< **   father.f.f.f.f:
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** ENC:OI.getVqual:[1:repeat$139]
< **   ENC:result:[1:for:to:repeat$142]
< **** ENC:OI.getVqual:[2:for:to:repeat$142]
< **   ENC:result:[2:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "+ 1 - inx" IV:"L + 1 - inx"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: L on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: L on: 2 Items 
< **   father: L + 1 - inx
< **   father.f.f.f.f:
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** ENC:OI.getVqual:[1:repeat$139]
< **   ENC:result:[1:for:to:repeat$142]
< **** ENC:OI.getVqual:[2:for:to:repeat$142]
< **   ENC:result:[2:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: + 1 - inx on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA,nest(integer)]
< **** koks: + 1 - inx on: 0 Items 
< **   father: L + 1 - inx
< **   father.f.f.f.f:
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** getVqual:B2:
< [0:BETA,nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:BETA,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:BETA,nest(integer)]
< **** savedOGS:save:was:[0:BETA,nest(integer)]
< **   OI: + 1 - inx
< **   OI:getQual:savedOI:+ 1 - inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA,nest(integer)]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out R: var integer
< [0:BETA,nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(integer),nest(+)]
< **   ENC:result:[1:BETA,nest(integer)]
< **** ENC:OI.getVqual:[2:BETA,nest(integer)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: + 1 - inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "- inx" IV:"1 - inx"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: - inx on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:repeat$139]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:repeat$139,nest(integer)]
< **** koks: - inx on: 0 Items 
< **   father: 1 - inx
< **   father.f.f.f.f:
< L + 1 - inx
< 
< **** getVqual:B2:
< [0:repeat$139,nest(integer)]
< ---
< 
< -  : 
<    %basic 62
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: -   :isVirtual:False
< [0:repeat$139,nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 62
<    in V: var integer
<    out R: var integer
< [0:repeat$139,nest(integer)]
< **** savedOGS:save:was:[0:integer]
< **   OI: - inx
< **   OI:getQual:savedOI:- inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:integer]
< **   OGS:[0:repeat$139]
< **** DataItem:getVqual: out R: var integer
< [0:repeat$139,nest(integer),nest(-)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:repeat$139,nest(integer),nest(-)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139,nest(integer),nest(-)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 62
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:repeat$139,nest(integer),nest(-)]
< **   ENC:result:[1:repeat$139,nest(integer)]
< **** ENC:OI.getVqual:[2:repeat$139,nest(integer)]
< **   ENC:result:[2:repeat$139]
< 
< **** getVqual:B2:
< [0:repeat$139]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:repeat$139]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:repeat$139]
< **** savedOGS:save:False[0:repeat$139]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:repeat$139]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:repeat$139]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:repeat$139]
< **** OI:getVqual:end: - inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:repeat$139]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< 1 - inx
< **** ENC:OI.getVqual:[1:repeat$139]
< **   ENC:result:[1:for:to:repeat$142]
< **** PRE: [0:for:to:repeat$142]
< **** pathToSuper: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " of:DOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   innerDOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< *** got:innerDOG:1 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:1,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$142,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$142,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$142,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$142,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$142,for:to:repeat]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$142,for:to:repeat]
< **** pathToSuper: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " of:DOG:
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   innerDOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< *** got:innerDOG:1 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " E.on=1 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< " :on=1:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$142]
< **   ENC:result:[2:putint]
< **   ENC:[pnx=0]oENC[onx=1]
< **** ENC:OI.getVqual:[2:putint]
< **   ENC:result:[2:BETA]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "+ D.get[i]" IV:"'0' + D.get[i]"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: + D.get[i] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:repeat$139]
< **   encOG:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:repeat$139,nest(char)]
< **** koks: + D.get[i] on: 0 Items 
< **   father: '0' + D.get[i]
< **   father.f.f.f.f:
< put('0' + D.get[i])
< 
< **** getVqual:B2:
< [0:repeat$139,nest(char)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var char
<    out R: var char
< **** Pattern:getVqual: +   :isVirtual:False
< [0:repeat$139,nest(char)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var char
<    out R: var char
< [0:repeat$139,nest(char)]
< **** savedOGS:save:was:[0:char]
< **   OI: + D.get[i]
< **   OI:getQual:savedOI:+ D.get[i]
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:char]
< **   OGS:[0:repeat$139]
< **** DataItem:getVqual: out R: var char
< [0:repeat$139,nest(char),nest(+)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:repeat$139,nest(char),nest(+)]
< 
< **** OI:getVqual: char on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139,nest(char),nest(+)]
< **   encOG: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** koks: char on: 2 Items 
< **   father: char
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var char
<    out R: var char
< **** ENC:OI.getVqual:[1:repeat$139,nest(char),nest(+)]
< **   ENC:result:[1:repeat$139,nest(char)]
< **** ENC:OI.getVqual:[2:repeat$139,nest(char)]
< **   ENC:result:[2:repeat$139]
< 
< **** getVqual:B2:
< [0:repeat$139]
< ---
< 
< char: value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< **** Pattern:getVqual: char :isVirtual:False
< [0:repeat$139]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< [0:repeat$139]
< **** savedOGS:save:False[0:repeat$139]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:repeat$139]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:repeat$139]
< **** OI:getVqual:return: out R: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:repeat$139]
< **** OI:getVqual:end: + D.get[i]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:repeat$139]
< **** OI:getOIqual: "D" IV:"D.get[i]"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: D on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: D on: 2 Items 
< **   father: D.get[i]
< **   father.f.f.f.f:
< '0' + D.get[i]
< **** ENC:OI.getVqual:[1:repeat$139]
< **   ENC:result:[1:for:to:repeat$142]
< **** ENC:OI.getVqual:[2:for:to:repeat$142]
< **   ENC:result:[2:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< D: obj Indexed(20,#integer)
< **** DataItem:getVqual: D: obj Indexed(20,#integer)
< [0:putint]
< **** ObjectGenerator:getVqual: Indexed(20,#integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(20,#integer)
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Indexed(20,#integer) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: Indexed(20,#integer) on: 1 Items 
< **   father: Indexed(20,#integer)
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Indexed(20,#integer)
< **   OI:getQual:savedOI:Indexed(20,#integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Indexed(20,#integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: D
< **   OI:getQual:savedOI:D
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: D
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "get[i]" IV:"D.get[i]"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: D on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: D on: 2 Items 
< **   father: D.get[i]
< **   father.f.f.f.f:
< '0' + D.get[i]
< **** ENC:OI.getVqual:[1:repeat$139]
< **   ENC:result:[1:for:to:repeat$142]
< **** ENC:OI.getVqual:[2:for:to:repeat$142]
< **   ENC:result:[2:putint]
< 
< **** getVqual:B2:
< [0:putint]
< ---
< D: obj Indexed(20,#integer)
< **** DataItem:getVqual: D: obj Indexed(20,#integer)
< [0:putint]
< **** ObjectGenerator:getVqual: Indexed(20,#integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(20,#integer)
< **   OGs: [0:putint]
< 
< **** OI:getVqual: Indexed(20,#integer) on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: Indexed(20,#integer) on: 1 Items 
< **   father: Indexed(20,#integer)
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< Indexed: 
<    %globals
<    %basic 114
<    %public
<    in range: var Integer
< ...
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: Indexed(20,#integer)
< **   OI:getQual:savedOI:Indexed(20,#integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: Indexed(20,#integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: D
< **   OI:getQual:savedOI:D
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: D
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** OI:getVqual: get[i] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:BETA]
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:BETA]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** getVqual:added:isNest:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:BETA,nest(Indexed)]
< **** koks: get[i] on: 0 Items 
< **   father: D.get[i]
< **   father.f.f.f.f:
< '0' + D.get[i]
< 
< **** getVqual:B2:
< [0:BETA,nest(Indexed)]
< ---
< 
< get[inx: var integer]: 
<    %basic 116
<    out V: var integer
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:BETA,nest(Indexed)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 116
<    out V: var integer
< [0:BETA,nest(Indexed)]
< **** savedOGS:save:was:[0:BETA]
< **   OI: get[i]
< **   OI:getQual:savedOI:get[i]
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** DataItem:getVqual: out V: var integer
< [0:BETA,nest(Indexed),nest(get)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:BETA,nest(Indexed),nest(get)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:BETA,nest(Indexed),nest(get)]
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 116
<    out V: var integer
< **** ENC:OI.getVqual:[1:BETA,nest(Indexed),nest(get)]
< **   ENC:result:[1:BETA,nest(Indexed)]
< **** ENC:OI.getVqual:[2:BETA,nest(Indexed)]
< **   ENC:result:[2:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:BETA]
< **** OI:getVqual:end: get[i]
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "i" IV:"i"
< **   origin.encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< **** OI:getVqual: i on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: i on: 0 Items 
< **   father: i
< **   father.f.f.f.f:
< D.get[i]
< 
< **** getVqual:B2:
< [0:repeat$139]
< ---
< i: var integer
< **** DataItem:getVqual: i: var integer
< [0:repeat$139]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:repeat$139]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$139]
< **   encOG: 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** koks: integer on: 3 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< **** ENC:OI.getVqual:[1:repeat$139]
< **   ENC:result:[1:for:to:repeat$142]
< **** ENC:OI.getVqual:[2:for:to:repeat$142]
< **   ENC:result:[2:putint]
< **** ENC:OI.getVqual:[3:putint]
< **   ENC:result:[3:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:repeat$139]
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< 
< **** OI:getVqual: L on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: L on: 0 Items 
< **   father: L
< **   father.f.f.f.f:
< 
< for(1):to(L):repeat
<    i: var integer
<    i := L + 1 - inx
<    put('0' + D.get[i])
< 
< 
< **** getVqual:B2:
< [0:putint]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:putint]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:putint]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:putint]
< **   encOG: 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %globals
<    in V: var integer
<    D: obj Indexed(20,#integer)
<    L: var integer
<    isNeg: var Boolean
< ...
< **** ENC:OI.getVqual:[1:putint]
< **   ENC:result:[1:BETA]
< 
< **** getVqual:B2:
< [0:BETA]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:False[0:BETA]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:BETA]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:BETA]
< **** savedOGS:save:was:[0:BETA]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:BETA]
< **   OGS:[0:putint]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:BETA]
< **** DataItem:getVqual: in S: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** OI:getVqual: L on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** koks: L on: 0 Items 
< **   father: L
< **   father.f.f.f.f:
< 
< +  : 
<    in S: var String
<    out V: var String
<    L: var integer
<    L := Length
< ...
< 
< **** getVqual:B2:
< [0:+]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:+]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   OGS:[0:+]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   OGS:[0:+]
< **** ENC:OI.viaInclude:[0:+]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(+)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(+)]
< **** savedOGS:save:False[0:String,nest(+)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(+)]
< **   OGS:[0:String,nest(+)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(+)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(+)]
< **** savedOGS:save:was:[0:String,nest(+)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(+)]
< **   OGS:[0:+]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(+)]
< **** OI:getOIqual: "Length" IV:"Length"
< **   origin.encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< 
< **** OI:getVqual: Length on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** koks: Length on: 1 Items 
< **   father: Length
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: Length
< **   OI:getQual:savedOI:Length
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:+]
< **** DataItem:getVqual: out V: var integer
< [0:String,nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(length)]
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   OGS:[0:String,nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **   OGS:[0:String,nest(length)]
< **** ENC:OI.viaInclude:[0:String,nest(length)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(+)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(+)]
< **** savedOGS:save:False[0:String,nest(+)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(+)]
< **   OGS:[0:String,nest(+)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(+)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:String,nest(+)]
< **** OI:getVqual:end: Length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(+)]
< **** OI:getOIqual: "L" IV:"L + S.length"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: L on: 1 Items 
< **   father: L + S.length
< **   father.f.f.f.f:
< Indexed(L + S.length,Integer)
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:+]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:+]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:+]
< **** ENC:OI.viaInclude:[0:+]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(doplus)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(doplus)]
< **** savedOGS:save:False[0:String,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:String,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(doplus)]
< **** savedOGS:save:was:[0:String,nest(doplus)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< **** OI:getOIqual: "+ S.length" IV:"L + S.length"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: L on: 1 Items 
< **   father: L + S.length
< **   father.f.f.f.f:
< Indexed(L + S.length,Integer)
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:+]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:+]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:+]
< **** ENC:OI.viaInclude:[0:+]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(doplus)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(doplus)]
< **** savedOGS:save:False[0:String,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:String,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(doplus)]
< **** savedOGS:save:was:[0:String,nest(doplus)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< 
< **** OI:getVqual: + S.length on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:String,nest(doplus)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:String,nest(doplus)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:String]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(doplus),nest(integer)]
< **** koks: + S.length on: 0 Items 
< **   father: L + S.length
< **   father.f.f.f.f:
< Indexed(L + S.length,Integer)
< 
< **** getVqual:B2:
< [0:String,nest(doplus),nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:String,nest(doplus),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:String,nest(doplus),nest(integer)]
< **** savedOGS:save:was:[0:String,nest(doplus),nest(integer)]
< **   OI: + S.length
< **   OI:getQual:savedOI:+ S.length
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus),nest(integer)]
< **   OGS:[0:String,nest(doplus)]
< **** DataItem:getVqual: out R: var integer
< [0:String,nest(doplus),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(doplus),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(doplus),nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:String,nest(doplus),nest(integer),nest(+)]
< **   ENC:result:[1:String,nest(doplus),nest(integer)]
< **** ENC:OI.getVqual:[2:String,nest(doplus),nest(integer)]
< **   ENC:result:[2:String,nest(doplus)]
< 
< **** getVqual:B2:
< [0:String,nest(doplus)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(doplus)]
< **** savedOGS:save:False[0:String,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:String,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:String,nest(doplus)]
< **** OI:getVqual:end: + S.length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< **** OI:getOIqual: "S" IV:"S.length"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: S on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: S on: 1 Items 
< **   father: S.length
< **   father.f.f.f.f:
< L + S.length
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< in S: var String
< **** DataItem:getVqual: in S: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OI:getOIqual: "length" IV:"S.length"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: S on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: S on: 1 Items 
< **   father: S.length
< **   father.f.f.f.f:
< L + S.length
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< in S: var String
< **** DataItem:getVqual: in S: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** OI:getVqual: length on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:StringLib]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:StringLib]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** getVqual:added:isNest:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib,nest(String)]
< **** koks: length on: 0 Items 
< **   father: S.length
< **   father.f.f.f.f:
< L + S.length
< 
< **** getVqual:B2:
< [0:StringLib,nest(String)]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:StringLib,nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:StringLib,nest(String)]
< **** savedOGS:save:was:[0:StringLib,nest(String)]
< **   OI: length
< **   OI:getQual:savedOI:length
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(String)]
< **   OGS:[0:StringLib]
< **** DataItem:getVqual: out V: var integer
< [0:StringLib,nest(String),nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(String),nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(String),nest(length)]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:StringLib,nest(String),nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:StringLib,nest(String),nest(length)]
< **** ENC:OI.viaInclude:[0:StringLib,nest(String),nest(length)]
< **   ENC:result:[0:StringLib,nest(String)]
< **** viaInclude:GOT:
< [0:StringLib,nest(String),nest(String)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(String),nest(String)]
< **** savedOGS:save:False[0:StringLib,nest(String),nest(String)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(String),nest(String)]
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:end: length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getOIqual: "V" IV:"V"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: V on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: V on: 1 Items 
< **   father: V
< **   father.f.f.f.f:
< 
< doplus: do 
<    e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
< ...
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< out V: var String
< **** DataItem:getVqual: out V: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: V
< **   OI:getQual:savedOI:V
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: V
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OI:getOIqual: "T" IV:"T.asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: T on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: T on: 0 Items 
< **   father: T.asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   father.f.f.f.f:
< 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< T: obj Indexed(L + S.length,Integer)
< **** DataItem:getVqual: T: obj Indexed(L + S.length,Integer)
< [0:doplus]
< **** ObjectGenerator:getVqual: Indexed(L + S.length,Integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(L + S.length,Integer)
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: Indexed(L + S.length,Integer) on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: Indexed name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(doplus)]
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:+,nest(doplus)]
< **** savedOGS:save:False[0:+,nest(doplus)]
< **   OI: Indexed(L + S.length,Integer)
< **   OI:getQual:savedOI:Indexed(L + S.length,Integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:+,nest(doplus)]
< **** OI:getVqual:end: Indexed(L + S.length,Integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(doplus)]
< **** savedOGS:save:was:[0:+,nest(doplus)]
< **   OI: T
< **   OI:getQual:savedOI:T
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: T
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< **** OI:getOIqual: "asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]" IV:"T.asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: T on=0 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: T on: 0 Items 
< **   father: T.asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   father.f.f.f.f:
< 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< T: obj Indexed(L + S.length,Integer)
< **** DataItem:getVqual: T: obj Indexed(L + S.length,Integer)
< [0:doplus]
< **** ObjectGenerator:getVqual: Indexed(L + S.length,Integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(L + S.length,Integer)
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: Indexed(L + S.length,Integer) on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: Indexed name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(doplus)]
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:+,nest(doplus)]
< **** savedOGS:save:False[0:+,nest(doplus)]
< **   OI: Indexed(L + S.length,Integer)
< **   OI:getQual:savedOI:Indexed(L + S.length,Integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:+,nest(doplus)]
< **** OI:getVqual:end: Indexed(L + S.length,Integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(doplus)]
< **** savedOGS:save:was:[0:+,nest(doplus)]
< **   OI: T
< **   OI:getQual:savedOI:T
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus)]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: T
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(doplus)]
< 
< **** OI:getVqual: asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:+,nest(doplus)]
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:+,nest(doplus)]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:+]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** getVqual:added:isNest:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(doplus),nest(Indexed)]
< **** koks: asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length] on: 0 Items 
< **   father: T.asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   father.f.f.f.f:
< 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** getVqual:B2:
< [0:+,nest(doplus),nest(Indexed)]
< ---
< 
< asString: 
<    %basic 118
<    out S: var LIB.StringLib.String
< **** Pattern:getVqual: asString :isVirtual:False
< [0:+,nest(doplus),nest(Indexed)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 118
<    out S: var LIB.StringLib.String
< [0:+,nest(doplus),nest(Indexed)]
< **** savedOGS:save:was:[0:+,nest(doplus),nest(Indexed)]
< **   OI: asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   OI:getQual:savedOI:
< asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(doplus),nest(Indexed)]
< **   OGS:[0:+,nest(doplus)]
< **** DataItem:getVqual: out S: var LIB.StringLib.String
< [0:+,nest(doplus),nest(Indexed),nest(asString)]
< **** ObjectGenerator:getVqual: LIB.StringLib.String
< **   hasVirtualArgs: False
< **** INV:getVqual:LIB.StringLib.String
< **   OGs: [0:+,nest(doplus),nest(Indexed),nest(asString)]
< 
< **** OI:getVqual: LIB on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+,nest(doplus),nest(Indexed),nest(asString)]
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **** koks: LIB on: 3 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< %basic 118
<    out S: var LIB.StringLib.String
< **** ENC:OI.getVqual:[1:+,nest(doplus),nest(Indexed),nest(asString)]
< **   ENC:result:[1:+,nest(doplus),nest(Indexed)]
< **** ENC:OI.getVqual:[2:+,nest(doplus),nest(Indexed)]
< **   ENC:result:[2:+,nest(doplus)]
< **** ENC:OI.getVqual:[3:+,nest(doplus)]
< **   ENC:result:[3:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< 
< --LIB
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:+]
< **** savedOGS:save:False[0:+]
< **   OI: LIB
< **   OI:getQual:savedOI:LIB
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+]
< **   OGS:[0:+]
< **** OI:getVqual:end: LIB
< **   qual: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< ObjectGenerator
< **   OGS:[0:+]
< 
< **** OI:getVqual: StringLib on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:+]
< **   encOG:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< 
< **** getVqual:added:isNest:
< %id "LIB"
<    %module BETA
<    %Include BETA
<    x_dummy_LIB: var integer
<    --AgentSystem
< ...
< [0:+,nest(LIB)]
< **** koks: StringLib on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** getVqual:B2:
< [0:+,nest(LIB)]
< ---
< 
< --StringLib
< 
< 
< **** getVqual:cont:afterATd:qual:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:+,nest(LIB)]
< **** savedOGS:save:False[0:+,nest(LIB)]
< **   OI: StringLib
< **   OI:getQual:savedOI:StringLib
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(LIB)]
< **   OGS:[0:+,nest(LIB)]
< **** OI:getVqual:end: StringLib
< **   qual: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(LIB)]
< 
< **** OI:getVqual: String on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:+,nest(LIB)]
< **   encOG: 
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:+,nest(LIB)]
< **   encOG:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< 
< **** getVqual:added:isNest:
< %id "String module"
<    %module LIB
<    %public
<    String: Value
<       %id "String pattern"
< ...
< [0:+,nest(LIB),nest(StringLib)]
< **** koks: String on: 0 Items 
< **   father: LIB.StringLib.String
< **   father.f.f.f.f:
< 
< %basic 118
<    out S: var LIB.StringLib.String
< 
< **** getVqual:B2:
< [0:+,nest(LIB),nest(StringLib)]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:+,nest(LIB),nest(StringLib)]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:+,nest(LIB),nest(StringLib)]
< **** savedOGS:save:False[0:+,nest(LIB),nest(StringLib)]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(LIB),nest(StringLib)]
< **   OGS:[0:+,nest(LIB),nest(StringLib)]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(LIB),nest(StringLib)]
< **** OI:getVqual:return: out S: var LIB.StringLib.String
< **   qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
<    length: 
<       out V: var integer
<       V := get[0] -- actually an index error, accessing length
<    get[inx: var integer]: 
<       %basic 117
<       out ch: var char
<    +  : 
<       in S: var String
<       out V: var String
<       L: var integer
<       L := Length
<       doplus: do 
<          e: var integer
<          i: var integer
<          T: obj Indexed(L + S.length,Integer)
<          for(1):to(L):repeat
<             e := get[inx]
<             T.put(e):at[inx]
<          
<          for(1):to(S.length):repeat
<             e := S.get[inx]
<             i := L + inx
<             T.put(e):at[i]
<          
<          V := T.asString
<          -- V: obj Indexed(Length + S.length)
<          -- V := T[1:length] + S.T[1:S.length]
<    asLowerCase: 
<       in T: var String
<       --.. primitive or ?
<    scan: 
<       %Public
<       current: var char
<       for(1):to(length):repeat
<          current := get[inx]
<          inner(scan)
<       
<    print: 
<       gogo: 
<          "gogo\n".print
<       for(1):to(length):repeat
<          put(get[inx])
<       
<    =  :: 
<       loop: do 
<          c1: var char
<          c2: var char
<          L: var integer
<          L := length
<          if (L <> Veq.length) :then 
<             leave(loop)
<          beq := true
<          for(1):to(length):repeat
<             c1 := get[inx]
<             c2 := Veq.get[inx]
<             if (c1 <> c2) :then 
<                Beq := false
<                leave(loop)
<          
<    <>  : 
<       in V: var String
<       out B: var boolean
<       B := this(String) = V
<       B := B.not
<    <=  :: 
<       loop: obj 
<          matchEq: 
<             inx: var integer
<             c1: var char
<             c2: var char
<             isEmpty: do 
<                if (L1 = 0) :then 
<                   Beq := L1 <= L2
<                   leave(matchEq)
<                if (L2 = 0) :then 
<                   Beq := false
<                   leave(matchEq)
<             loop: do 
<                inx := inx + 1
<                c1 := get[inx]
<                c2 := Veq.get[inx]
<                if (c1 = c2) :then 
<                   if (inx < L) :then 
<                      restart(loop)
<             doit: do 
<                if (c1 = c2) :then 
<                   Beq := L1 <= L2
<                   leave(matchEq)
<                :else 
<                   Beq := c1 < c2
<                   leave(matchEq)
<          L: var integer
<          L1: var integer
<          L2: var integer
<          L1 := length
<          -- min length of this and V
<          L2 := Veq.length
<          if (L1 < L2) :then 
<             L := L1
<          :else 
<             L := L2
<          matchEq
< [0:+,nest(LIB),nest(StringLib)]
< **** OI:getVqual:end: 
< asString
< -- V: obj Indexed(Length + S.length)
< -- V := T[1:length] + S.T[1:S.length]
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(LIB),nest(StringLib)]
< **** OI:getOIqual: "e" IV:"e"
< **   origin.encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual: e on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$159]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: e on: 2 Items 
< **   father: e
< **   father.f.f.f.f:
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **** ENC:OI.getVqual:[1:repeat$159]
< **   ENC:result:[1:for:to:repeat$160]
< **** ENC:OI.getVqual:[2:for:to:repeat$160]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< e: var integer
< **** DataItem:getVqual: e: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$159)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$159)]
< **** savedOGS:save:False[0:+,nest(repeat$159)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$159)]
< **** savedOGS:save:was:[0:+,nest(repeat$159)]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:repeat$159]
< **** OI:getVqual:end: e
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getOIqual: "get[inx]" IV:"get[inx]"
< **   origin.encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual: get[inx] on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$159]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: get[inx] on: 4 Items 
< **   father: get[inx]
< **   father.f.f.f.f:
< 
< e := get[inx]
<    T.put(e):at[inx]
< **** ENC:OI.getVqual:[1:repeat$159]
< **   ENC:result:[1:for:to:repeat$160]
< **** ENC:OI.getVqual:[2:for:to:repeat$160]
< **   ENC:result:[2:doplus]
< **** ENC:OI.getVqual:[3:doplus]
< **   ENC:result:[3:+]
< **** ENC:OI.getVqual:[4:+]
< **   ENC:result:[4:String]
< 
< **** getVqual:B2:
< [0:String]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:String]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:String]
< **** savedOGS:save:was:[0:String]
< **   OI: get[inx]
< **   OI:getQual:savedOI:get[inx]
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String]
< **   OGS:[0:repeat$159]
< **** DataItem:getVqual: out ch: var char
< [0:String,nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:String,nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(get)]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:String,nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:String,nest(get)]
< **** ENC:OI.viaInclude:[0:String,nest(get)]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$159)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:String,nest(repeat$159)]
< **** savedOGS:save:False[0:String,nest(repeat$159)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$159)]
< **   OGS:[0:String,nest(repeat$159)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$159)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:String,nest(repeat$159)]
< **** OI:getVqual:end: get[inx]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$159)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$159]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< get[inx]
< **** ENC:OI.getVqual:[1:repeat$159]
< **   ENC:result:[1:for:to:repeat$160]
< **** PRE: [0:for:to:repeat$160]
< **** pathToSuper: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " of:DOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   innerDOG: 
< e := get[inx]
<    T.put(e):at[inx]
< *** got:innerDOG:1 
< e := get[inx]
<    T.put(e):at[inx]
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:4,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$160,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$160,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$160,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$160,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$160,for:to:repeat]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$160,for:to:repeat]
< **** pathToSuper: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " of:DOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   innerDOG: 
< e := get[inx]
<    T.put(e):at[inx]
< *** got:innerDOG:1 
< e := get[inx]
<    T.put(e):at[inx]
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$160]
< **   ENC:result:[2:doplus]
< **   ENC:[pnx=0]oENC[onx=4]
< **** ENC:OI.getVqual:[2:doplus]
< **   ENC:result:[2:+]
< **** ENC:OI.getVqual:[3:+]
< **   ENC:result:[3:String]
< **** ENC:OI.getVqual:[4:String]
< **   ENC:result:[4:StringLib]
< **** ENC:OI.getVqual:[5:StringLib]
< **   ENC:result:[5:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:repeat$159]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "T" IV:"T.put(e):at[inx]"
< **   origin.encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual: T on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$159]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: T on: 2 Items 
< **   father: T.put(e):at[inx]
< **   father.f.f.f.f:
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **** ENC:OI.getVqual:[1:repeat$159]
< **   ENC:result:[1:for:to:repeat$160]
< **** ENC:OI.getVqual:[2:for:to:repeat$160]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< T: obj Indexed(L + S.length,Integer)
< **** DataItem:getVqual: T: obj Indexed(L + S.length,Integer)
< [0:doplus]
< **** ObjectGenerator:getVqual: Indexed(L + S.length,Integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(L + S.length,Integer)
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: Indexed(L + S.length,Integer) on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: Indexed name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$159)]
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:+,nest(repeat$159)]
< **** savedOGS:save:False[0:+,nest(repeat$159)]
< **   OI: Indexed(L + S.length,Integer)
< **   OI:getQual:savedOI:Indexed(L + S.length,Integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getVqual:end: Indexed(L + S.length,Integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(repeat$159)]
< **** savedOGS:save:was:[0:+,nest(repeat$159)]
< **   OI: T
< **   OI:getQual:savedOI:T
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:repeat$159]
< **** OI:getVqual:end: T
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getOIqual: "put(e):at[inx]" IV:"T.put(e):at[inx]"
< **   origin.encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual: T on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$159]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: T on: 2 Items 
< **   father: T.put(e):at[inx]
< **   father.f.f.f.f:
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **** ENC:OI.getVqual:[1:repeat$159]
< **   ENC:result:[1:for:to:repeat$160]
< **** ENC:OI.getVqual:[2:for:to:repeat$160]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< T: obj Indexed(L + S.length,Integer)
< **** DataItem:getVqual: T: obj Indexed(L + S.length,Integer)
< [0:doplus]
< **** ObjectGenerator:getVqual: Indexed(L + S.length,Integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(L + S.length,Integer)
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: Indexed(L + S.length,Integer) on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: Indexed name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$159)]
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:+,nest(repeat$159)]
< **** savedOGS:save:False[0:+,nest(repeat$159)]
< **   OI: Indexed(L + S.length,Integer)
< **   OI:getQual:savedOI:Indexed(L + S.length,Integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getVqual:end: Indexed(L + S.length,Integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(repeat$159)]
< **** savedOGS:save:was:[0:+,nest(repeat$159)]
< **   OI: T
< **   OI:getQual:savedOI:T
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:repeat$159]
< **** OI:getVqual:end: T
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< 
< **** OI:getVqual: put(e):at[inx] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:+,nest(repeat$159)]
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:+,nest(repeat$159)]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:+]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** getVqual:added:isNest:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(repeat$159),nest(Indexed)]
< **** koks: put(e):at[inx] on: 0 Items 
< **   father: T.put(e):at[inx]
< **   father.f.f.f.f:
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< 
< **** getVqual:B2:
< [0:+,nest(repeat$159),nest(Indexed)]
< ---
< 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **** Pattern:getVqual: put(V: var integer):at[inx: var integer] :isVirtual:False
< [0:+,nest(repeat$159),nest(Indexed)]
< 
< **** getVqual:cont:afterATd:qual:%basic 115
< [0:+,nest(repeat$159),nest(Indexed)]
< **** savedOGS:save:was:[0:+,nest(repeat$159),nest(Indexed)]
< **   OI: put(e):at[inx]
< **   OI:getQual:savedOI:put(e):at[inx]
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159),nest(Indexed)]
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getVqual:end: put(e):at[inx]
< **   qual: %basic 115
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159),nest(Indexed)]
< **** OI:getOIqual: "e" IV:"e"
< **   origin.encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual: e on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$159]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: e on: 2 Items 
< **   father: e
< **   father.f.f.f.f:
< T.put(e):at[inx]
< **** ENC:OI.getVqual:[1:repeat$159]
< **   ENC:result:[1:for:to:repeat$160]
< **** ENC:OI.getVqual:[2:for:to:repeat$160]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< e: var integer
< **** DataItem:getVqual: e: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$159)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$159)]
< **** savedOGS:save:False[0:+,nest(repeat$159)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$159)]
< **** savedOGS:save:was:[0:+,nest(repeat$159)]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$159)]
< **   OGS:[0:repeat$159]
< **** OI:getVqual:end: e
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$159)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$159]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< T.put(e):at[inx]
< **** ENC:OI.getVqual:[1:repeat$159]
< **   ENC:result:[1:for:to:repeat$160]
< **** PRE: [0:for:to:repeat$160]
< **** pathToSuper: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " of:DOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   innerDOG: 
< e := get[inx]
<    T.put(e):at[inx]
< *** got:innerDOG:1 
< e := get[inx]
<    T.put(e):at[inx]
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:4,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$160,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$160,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$160,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$160,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$160,for:to:repeat]
< **   encOG: 
< e := get[inx]
<    T.put(e):at[inx]
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$160,for:to:repeat]
< **** pathToSuper: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " of:DOG:
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   innerDOG: 
< e := get[inx]
<    T.put(e):at[inx]
< *** got:innerDOG:1 
< e := get[inx]
<    T.put(e):at[inx]
< **   pathToSuper:E:"
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$160]
< **   ENC:result:[2:doplus]
< **   ENC:[pnx=0]oENC[onx=4]
< **** ENC:OI.getVqual:[2:doplus]
< **   ENC:result:[2:+]
< **** ENC:OI.getVqual:[3:+]
< **   ENC:result:[3:String]
< **** ENC:OI.getVqual:[4:String]
< **   ENC:result:[4:StringLib]
< **** ENC:OI.getVqual:[5:StringLib]
< **   ENC:result:[5:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:repeat$159]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "L" IV:"L"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: L on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: L on: 1 Items 
< **   father: L
< **   father.f.f.f.f:
< 
< for(1):to(L):repeat
<    e := get[inx]
<    T.put(e):at[inx]
< 
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:+]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:+]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **   OGS:[0:+]
< **** ENC:OI.viaInclude:[0:+]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(doplus)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(doplus)]
< **** savedOGS:save:False[0:String,nest(doplus)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:String,nest(doplus)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(doplus)]
< **** savedOGS:save:was:[0:String,nest(doplus)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(doplus)]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(doplus)]
< **** OI:getOIqual: "e" IV:"e"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: e on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: e on: 2 Items 
< **   father: e
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< e: var integer
< **** DataItem:getVqual: e: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$161)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$161)]
< **** savedOGS:save:False[0:+,nest(repeat$161)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$161)]
< **** savedOGS:save:was:[0:+,nest(repeat$161)]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: e
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getOIqual: "S" IV:"S.get[inx]"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: S on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: S on: 3 Items 
< **   father: S.get[inx]
< **   father.f.f.f.f:
< 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< **** ENC:OI.getVqual:[3:doplus]
< **   ENC:result:[3:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< in S: var String
< **** DataItem:getVqual: in S: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OI:getOIqual: "get[inx]" IV:"S.get[inx]"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: S on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: S on: 3 Items 
< **   father: S.get[inx]
< **   father.f.f.f.f:
< 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< **** ENC:OI.getVqual:[3:doplus]
< **   ENC:result:[3:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< in S: var String
< **** DataItem:getVqual: in S: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** OI:getVqual: get[inx] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:StringLib]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:StringLib]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** getVqual:added:isNest:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib,nest(String)]
< **** koks: get[inx] on: 0 Items 
< **   father: S.get[inx]
< **   father.f.f.f.f:
< 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** getVqual:B2:
< [0:StringLib,nest(String)]
< ---
< 
< get[inx: var integer]: 
<    %basic 117
<    out ch: var char
< **** Pattern:getVqual: get[inx: var integer] :isVirtual:False
< [0:StringLib,nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 117
<    out ch: var char
< [0:StringLib,nest(String)]
< **** savedOGS:save:was:[0:StringLib,nest(String)]
< **   OI: get[inx]
< **   OI:getQual:savedOI:get[inx]
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(String)]
< **   OGS:[0:StringLib]
< **** DataItem:getVqual: out ch: var char
< [0:StringLib,nest(String),nest(get)]
< **** ObjectGenerator:getVqual: char
< **   hasVirtualArgs: False
< **** INV:getVqual:char
< **   OGs: [0:StringLib,nest(String),nest(get)]
< 
< **** OI:getVqual: char on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(String),nest(get)]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: char
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:StringLib,nest(String),nest(get)]
< ***** viaInclude:notTop: char name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: char
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:StringLib,nest(String),nest(get)]
< **** ENC:OI.viaInclude:[0:StringLib,nest(String),nest(get)]
< **   ENC:result:[0:StringLib,nest(String)]
< **** viaInclude:GOT:
< [0:StringLib,nest(String),nest(String)]
< **** Pattern:getVqual: char :isVirtual:False
< [0:StringLib,nest(String),nest(String)]
< **** savedOGS:save:False[0:StringLib,nest(String),nest(String)]
< **   OI: char
< **   OI:getQual:savedOI:char
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(String),nest(String)]
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:end: char
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:return: out ch: var char
< **   qual:
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var char
<       out R: var char
<    -  : 
<       %basic 62
<       in V: var char
<       out R: var char
<    =?  : 
<       %basic 50
<       in V: var char
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var char
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var char
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var char
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var char
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var char
<       out B: var boolean
< [0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:end: get[inx]
< **   qual: 
< value
<    %id "char"
<    %globals
<    %basic 3, 16
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< S.get[inx]
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** PRE: [0:for:to:repeat$162]
< **** pathToSuper: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " of:DOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   innerDOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< *** got:innerDOG:1 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   pathToSuper:E:"
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:4,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$162,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$162,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$162,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$162,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$162,for:to:repeat]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$162,for:to:repeat]
< **** pathToSuper: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " of:DOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   innerDOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< *** got:innerDOG:1 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   pathToSuper:E:"
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< **   ENC:[pnx=0]oENC[onx=4]
< **** ENC:OI.getVqual:[2:doplus]
< **   ENC:result:[2:+]
< **** ENC:OI.getVqual:[3:+]
< **   ENC:result:[3:String]
< **** ENC:OI.getVqual:[4:String]
< **   ENC:result:[4:StringLib]
< **** ENC:OI.getVqual:[5:StringLib]
< **   ENC:result:[5:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "i" IV:"i"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: i on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: i on: 2 Items 
< **   father: i
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< i: var integer
< **** DataItem:getVqual: i: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$161)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$161)]
< **** savedOGS:save:False[0:+,nest(repeat$161)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$161)]
< **** savedOGS:save:was:[0:+,nest(repeat$161)]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getOIqual: "L" IV:"L + inx"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: L on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: L on: 3 Items 
< **   father: L + inx
< **   father.f.f.f.f:
< 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< **** ENC:OI.getVqual:[3:doplus]
< **   ENC:result:[3:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:+]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:+]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:+]
< **** ENC:OI.viaInclude:[0:+]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$161)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(repeat$161)]
< **** savedOGS:save:False[0:String,nest(repeat$161)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$161)]
< **   OGS:[0:String,nest(repeat$161)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(repeat$161)]
< **** savedOGS:save:was:[0:String,nest(repeat$161)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$161)]
< **** OI:getOIqual: "+ inx" IV:"L + inx"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: L on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: L on: 3 Items 
< **   father: L + inx
< **   father.f.f.f.f:
< 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< **** ENC:OI.getVqual:[3:doplus]
< **   ENC:result:[3:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< L: var integer
< **** DataItem:getVqual: L: var integer
< [0:+]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:+]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:+]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:+]
< **** ENC:OI.viaInclude:[0:+]
< **   ENC:result:[0:String]
< **** viaInclude:GOT:
< [0:String,nest(repeat$161)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(repeat$161)]
< **** savedOGS:save:False[0:String,nest(repeat$161)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$161)]
< **   OGS:[0:String,nest(repeat$161)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(repeat$161)]
< **** savedOGS:save:was:[0:String,nest(repeat$161)]
< **   OI: L
< **   OI:getQual:savedOI:L
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: L
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$161)]
< 
< **** OI:getVqual: + inx on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:String,nest(repeat$161)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:String,nest(repeat$161)]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:String]
< **   encOG:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< 
< **** getVqual:added:isNest:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(repeat$161),nest(integer)]
< **** koks: + inx on: 0 Items 
< **   father: L + inx
< **   father.f.f.f.f:
< 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** getVqual:B2:
< [0:String,nest(repeat$161),nest(integer)]
< ---
< 
< +  : 
<    %basic 61
<    in V: var integer
<    out R: var integer
< **** Pattern:getVqual: +   :isVirtual:False
< [0:String,nest(repeat$161),nest(integer)]
< 
< **** getVqual:cont:afterATd:qual:
< %basic 61
<    in V: var integer
<    out R: var integer
< [0:String,nest(repeat$161),nest(integer)]
< **** savedOGS:save:was:[0:String,nest(repeat$161),nest(integer)]
< **   OI: + inx
< **   OI:getQual:savedOI:+ inx
< **   IT: Assign [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$161),nest(integer)]
< **   OGS:[0:String,nest(repeat$161)]
< **** DataItem:getVqual: out R: var integer
< [0:String,nest(repeat$161),nest(integer),nest(+)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:String,nest(repeat$161),nest(integer),nest(+)]
< 
< **** OI:getVqual: integer on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:String,nest(repeat$161),nest(integer),nest(+)]
< **   encOG: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** koks: integer on: 2 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %basic 61
<    in V: var integer
<    out R: var integer
< **** ENC:OI.getVqual:[1:String,nest(repeat$161),nest(integer),nest(+)]
< **   ENC:result:[1:String,nest(repeat$161),nest(integer)]
< **** ENC:OI.getVqual:[2:String,nest(repeat$161),nest(integer)]
< **   ENC:result:[2:String,nest(repeat$161)]
< 
< **** getVqual:B2:
< [0:String,nest(repeat$161)]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:String,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:String,nest(repeat$161)]
< **** savedOGS:save:False[0:String,nest(repeat$161)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:String,nest(repeat$161)]
< **   OGS:[0:String,nest(repeat$161)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$161)]
< **** OI:getVqual:return: out R: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:String,nest(repeat$161)]
< **** OI:getVqual:end: + inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:String,nest(repeat$161)]
< **** OI:getOIqual: "inx" IV:"inx"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: inx on=1 pn=1 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: inx on: 1 Items 
< **   father: inx
< **   father.f.f.f.f:
< L + inx
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** PRE: [0:for:to:repeat$162]
< **** pathToSuper: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " of:DOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   innerDOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< *** got:innerDOG:1 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   pathToSuper:E:"
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   PRE:onx,pnx,isR:4,0,False OGx:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **   PRE:result:[0:for:to:repeat$162,for:to:repeat]
< 
< **** getVqual:B2:
< [0:for:to:repeat$162,for:to:repeat]
< ---
< inx: var integer
< **** DataItem:getVqual: inx: var integer
< [0:for:to:repeat$162,for:to:repeat]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:for:to:repeat$162,for:to:repeat]
< 
< **** OI:getVqual: integer on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:for:to:repeat$162,for:to:repeat]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: integer on: 1 Items 
< **   father: integer
< **   father.f.f.f.f:
< 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[1:for:to:repeat$162,for:to:repeat]
< **** pathToSuper: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " of:DOG:
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   innerDOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< *** got:innerDOG:1 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   pathToSuper:E:"
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " E.on=4 E.pn=0 DOG.super.pn=0 isR=False
< **   pathToSuper:end:super.last: "
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< " :on=4:pn=0:isR=False:ptn.isVirt=False ptn:
< for(first: var integer):to(last: var integer):repeat{repeat:< object}: 
<    %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
< ...
< **   ENC:pred:  pred.DOG: 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **   OGsuper: 
< %OSDvisibility skipInternal
<    %globals inSub
<    inx: var integer
<    inx := first
<    _doIt: do 
< ...
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< **   ENC:[pnx=0]oENC[onx=4]
< **** ENC:OI.getVqual:[2:doplus]
< **   ENC:result:[2:+]
< **** ENC:OI.getVqual:[3:+]
< **   ENC:result:[3:String]
< **** ENC:OI.getVqual:[4:String]
< **   ENC:result:[4:StringLib]
< **** ENC:OI.getVqual:[5:StringLib]
< **   ENC:result:[5:LIB]
< **   ENC:result:[1:LIB]
< 
< **** getVqual:B2:
< [0:LIB]
< ---
< 
< integer: value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< **** Pattern:getVqual: integer :isVirtual:False
< [0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:False[0:LIB]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:LIB]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:LIB]
< **** savedOGS:save:was:[0:LIB]
< **   OI: inx
< **   OI:getQual:savedOI:inx
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:LIB]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: inx
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:LIB]
< **** OI:getOIqual: "T" IV:"T.put(e):at[i]"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: T on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: T on: 2 Items 
< **   father: T.put(e):at[i]
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< T: obj Indexed(L + S.length,Integer)
< **** DataItem:getVqual: T: obj Indexed(L + S.length,Integer)
< [0:doplus]
< **** ObjectGenerator:getVqual: Indexed(L + S.length,Integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(L + S.length,Integer)
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: Indexed(L + S.length,Integer) on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: Indexed name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$161)]
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:+,nest(repeat$161)]
< **** savedOGS:save:False[0:+,nest(repeat$161)]
< **   OI: Indexed(L + S.length,Integer)
< **   OI:getQual:savedOI:Indexed(L + S.length,Integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getVqual:end: Indexed(L + S.length,Integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(repeat$161)]
< **** savedOGS:save:was:[0:+,nest(repeat$161)]
< **   OI: T
< **   OI:getQual:savedOI:T
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: T
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getOIqual: "put(e):at[i]" IV:"T.put(e):at[i]"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: T on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: T on: 2 Items 
< **   father: T.put(e):at[i]
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< T: obj Indexed(L + S.length,Integer)
< **** DataItem:getVqual: T: obj Indexed(L + S.length,Integer)
< [0:doplus]
< **** ObjectGenerator:getVqual: Indexed(L + S.length,Integer)
< **   hasVirtualArgs: True
< **** INV:getVqual:Indexed(L + S.length,Integer)
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: Indexed(L + S.length,Integer) on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: Indexed name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: Indexed(L + S.length,Integer)
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$161)]
< **** Pattern:getVqual: Indexed :isVirtual:False
< [0:+,nest(repeat$161)]
< **** savedOGS:save:False[0:+,nest(repeat$161)]
< **   OI: Indexed(L + S.length,Integer)
< **   OI:getQual:savedOI:Indexed(L + S.length,Integer)
< **   IT: obj [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getVqual:end: Indexed(L + S.length,Integer)
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(repeat$161)]
< **** savedOGS:save:was:[0:+,nest(repeat$161)]
< **   OI: T
< **   OI:getQual:savedOI:T
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: T
< **   qual: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< 
< **** OI:getVqual: put(e):at[i] on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:+,nest(repeat$161)]
< **   encOG: 
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:+,nest(repeat$161)]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< **   OI:getVqual:findEnc:i=2 OGSz:[0:+]
< **   encOG:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< 
< **** getVqual:added:isNest:
< %globals
<    %basic 114
<    %public
<    in range: var Integer
<    in elm:< Object
< ...
< [0:+,nest(repeat$161),nest(Indexed)]
< **** koks: put(e):at[i] on: 0 Items 
< **   father: T.put(e):at[i]
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< 
< **** getVqual:B2:
< [0:+,nest(repeat$161),nest(Indexed)]
< ---
< 
< put(V: var integer):at[inx: var integer]: 
<    %basic 115
< **** Pattern:getVqual: put(V: var integer):at[inx: var integer] :isVirtual:False
< [0:+,nest(repeat$161),nest(Indexed)]
< 
< **** getVqual:cont:afterATd:qual:%basic 115
< [0:+,nest(repeat$161),nest(Indexed)]
< **** savedOGS:save:was:[0:+,nest(repeat$161),nest(Indexed)]
< **   OI: put(e):at[i]
< **   OI:getQual:savedOI:put(e):at[i]
< **   IT: Items [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161),nest(Indexed)]
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getVqual:end: put(e):at[i]
< **   qual: %basic 115
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161),nest(Indexed)]
< **** OI:getOIqual: "e" IV:"e"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: e on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: e on: 2 Items 
< **   father: e
< **   father.f.f.f.f:
< T.put(e):at[i]
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< e: var integer
< **** DataItem:getVqual: e: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$161)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$161)]
< **** savedOGS:save:False[0:+,nest(repeat$161)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$161)]
< **** savedOGS:save:was:[0:+,nest(repeat$161)]
< **   OI: e
< **   OI:getQual:savedOI:e
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: e
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getOIqual: "i" IV:"i"
< **   origin.encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** OI:getVqual: i on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:repeat$161]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** koks: i on: 2 Items 
< **   father: i
< **   father.f.f.f.f:
< T.put(e):at[i]
< **** ENC:OI.getVqual:[1:repeat$161]
< **   ENC:result:[1:for:to:repeat$162]
< **** ENC:OI.getVqual:[2:for:to:repeat$162]
< **   ENC:result:[2:doplus]
< 
< **** getVqual:B2:
< [0:doplus]
< ---
< i: var integer
< **** DataItem:getVqual: i: var integer
< [0:doplus]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:doplus]
< 
< **** OI:getVqual: integer on=4 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **** OI:viaInclude:on=4 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< **   OGS:[0:doplus]
< **** ENC:OI.viaInclude:[0:doplus]
< **   ENC:result:[0:+]
< **** viaInclude:GOT:
< [0:+,nest(repeat$161)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:+,nest(repeat$161)]
< **** savedOGS:save:False[0:+,nest(repeat$161)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< 
< **** getVqual:cont:afterATd:qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< [0:+,nest(repeat$161)]
< **** savedOGS:save:was:[0:+,nest(repeat$161)]
< **   OI: i
< **   OI:getQual:savedOI:i
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:+,nest(repeat$161)]
< **   OGS:[0:repeat$161]
< **** OI:getVqual:end: i
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:+,nest(repeat$161)]
< **** OI:getOIqual: "S" IV:"S.length"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: S on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: S on: 1 Items 
< **   father: S.length
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< in S: var String
< **** DataItem:getVqual: in S: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< **** OI:getOIqual: "length" IV:"S.length"
< **   origin.encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< 
< **** OI:getVqual: S on=1 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:doplus]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: S on: 1 Items 
< **   father: S.length
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< **** ENC:OI.getVqual:[1:doplus]
< **   ENC:result:[1:+]
< 
< **** getVqual:B2:
< [0:+]
< ---
< in S: var String
< **** DataItem:getVqual: in S: var String
< [0:+]
< **** ObjectGenerator:getVqual: String
< **   hasVirtualArgs: False
< **** INV:getVqual:String
< **   OGs: [0:+]
< 
< **** OI:getVqual: String on=2 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:+]
< **   encOG: 
< e: var integer
<    i: var integer
<    T: obj Indexed(L + S.length,Integer)
<    for(1):to(L):repeat
<       e := get[inx]
< ...
< **** koks: String on: 2 Items 
< **   father: String
< **   father.f.f.f.f:
< 
< in S: var String
<    out V: var String
<    L: var integer
<    L := Length
<    doplus: do 
< ...
< **** ENC:OI.getVqual:[1:+]
< **   ENC:result:[1:String]
< **** ENC:OI.getVqual:[2:String]
< **   ENC:result:[2:StringLib]
< 
< **** getVqual:B2:
< [0:StringLib]
< ---
< 
< String: Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** Pattern:getVqual: String :isVirtual:False
< [0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:False[0:StringLib]
< **   OI: String
< **   OI:getQual:savedOI:String
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:StringLib]
< **** OI:getVqual:end: String
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** getVqual:cont:afterATd:qual:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib]
< **** savedOGS:save:was:[0:StringLib]
< **   OI: S
< **   OI:getQual:savedOI:S
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib]
< **   OGS:[0:doplus]
< **** OI:getVqual:end: S
< **   qual: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib]
< 
< **** OI:getVqual: length on=0 pn=0 isNest=True getRtnQual=False
< **   OGS:continued:[0:StringLib]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OI:getVqual:findEnc:i=1 OGSz:[0:StringLib]
< **   encOG:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< 
< **** getVqual:added:isNest:
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< [0:StringLib,nest(String)]
< **** koks: length on: 0 Items 
< **   father: S.length
< **   father.f.f.f.f:
< 
< for(1):to(S.length):repeat
<    e := S.get[inx]
<    i := L + inx
<    T.put(e):at[i]
< 
< 
< **** getVqual:B2:
< [0:StringLib,nest(String)]
< ---
< 
< length: 
<    out V: var integer
<    V := get[0] -- actually an index error, accessing length
< **** Pattern:getVqual: length :isVirtual:False
< [0:StringLib,nest(String)]
< 
< **** getVqual:cont:afterATd:qual:
< out V: var integer
<    V := get[0] -- actually an index error, accessing length
< [0:StringLib,nest(String)]
< **** savedOGS:save:was:[0:StringLib,nest(String)]
< **   OI: length
< **   OI:getQual:savedOI:length
< **   IT: Arguments [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(String)]
< **   OGS:[0:StringLib]
< **** DataItem:getVqual: out V: var integer
< [0:StringLib,nest(String),nest(length)]
< **** ObjectGenerator:getVqual: integer
< **   hasVirtualArgs: False
< **** INV:getVqual:integer
< **   OGs: [0:StringLib,nest(String),nest(length)]
< 
< **** OI:getVqual: integer on=3 pn=0 isNest=False getRtnQual=False
< **   OGS:continued:[0:StringLib,nest(String),nest(length)]
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **** OI:viaInclude:on=3 BETA %Include BETA
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:StringLib,nest(String),nest(length)]
< ***** viaInclude:notTop: integer name: BETA ObjectInvocation_Unary BETA name: 1 
< %Include BETA Property
< **** OI:viaInclude:on=1 at:top
< **   OI: integer
< **   encOG: 
< Value
<    %id "String pattern"
<    %OSDvisibility disguised
<    %basic 5
<    %public
< ...
< **   OGS:[0:StringLib,nest(String),nest(length)]
< **** ENC:OI.viaInclude:[0:StringLib,nest(String),nest(length)]
< **   ENC:result:[0:StringLib,nest(String)]
< **** viaInclude:GOT:
< [0:StringLib,nest(String),nest(String)]
< **** Pattern:getVqual: integer :isVirtual:False
< [0:StringLib,nest(String),nest(String)]
< **** savedOGS:save:False[0:StringLib,nest(String),nest(String)]
< **   OI: integer
< **   OI:getQual:savedOI:integer
< **   IT: var [savedOGS <> none and IT.isDecl: ]
< **   savedOGS: [0:StringLib,nest(String),nest(String)]
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:end: integer
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:return: out V: var integer
< **   qual:
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
<    _thisBasicValue: var Universal
<    +  : 
<       %basic 61
<       in V: var integer
<       out R: var integer
<    -  : 
<       %basic 62
<       in V: var integer
<       out R: var integer
<    *  : 
<       %basic 66
<       in V: var integer
<       out R: var integer
<    /  : 
<       %basic 67
<       in V: var integer
<       out R: var integer
<    //  : 
<       %basic 68
<       in V: var integer
<       out B: var integer
<    /%  : 
<       %basic 69
<       in V: var integer
<       out R: var integer
<    =?  : 
<       %basic 50
<       in V: var integer
<       out B: var boolean
<    <  : 
<       %basic 51
<       in V: var integer
<       out B: var boolean
<    <=?  : 
<       %basic 52
<       in V: var integer
<       out B: var boolean
<    >  : 
<       %basic 53
<       in V: var integer
<       out B: var boolean
<    >=  : 
<       %basic 54
<       in V: var integer
<       out B: var boolean
<    <>  : 
<       %basic 55
<       in V: var integer
<       out B: var boolean
<    cmpAndSwap: 
<       %basic 14
<       in V: var integer
<       out res: var integer
< [0:StringLib,nest(String),nest(String)]
< **** OI:getVqual:end: length
< **   qual: 
< value
<    %ID integer
<    %basic 1, 32
<    %globals
<    %public
< ...
< ObjectGenerator
< **   OGS:[0:StringLib,nest(String),nest(String)]
< **** MI:MD.isIncluded: BETA False
< **** MI:MD.isIncluded: DK True
< **** MI:MD.isIncluded: LIB False
< **** MI:MD.isIncluded: AgentSystem True
< **** MI:MD.isIncluded: Associations True
< **** MI:MD.isIncluded: BasicIO False
< **** MI:MD.isIncluded: BasicSystemLib True
< **** MI:MD.isIncluded: COsystem True
< **** MI:MD.isIncluded: Collections False
< **** MI:MD.isIncluded: BoundedBufferLib True
< **** MI:MD.isIncluded: List True
< **** MI:MD.isIncluded: MapLib False
< **** MI:MD.isIncluded: OrderedList True
< **** MI:MD.isIncluded: QueueLib True
< **** MI:MD.isIncluded: SetLib False
< **** MI:MD.isIncluded: SimpleList True
< **** MI:MD.isIncluded: Compiler True
< **** MI:MD.isIncluded: Complex True
< **** MI:MD.isIncluded: DateTimeLib True
< **** MI:MD.isIncluded: Dimensions False
< **** MI:MD.isIncluded: Acceleration True
< **** MI:MD.isIncluded: AmountOfSubstance True
< **** MI:MD.isIncluded: AngularAcceleration True
< **** MI:MD.isIncluded: Area True
< **** MI:MD.isIncluded: Currency True
< **** MI:MD.isIncluded: Density True
< **** MI:MD.isIncluded: ElectricCurrent True
< **** MI:MD.isIncluded: ElectricFrequency True
< **** MI:MD.isIncluded: ElectricPower True
< **** MI:MD.isIncluded: ElectricVoltage True
< **** MI:MD.isIncluded: Energy True
< **** MI:MD.isIncluded: Force True
< **** MI:MD.isIncluded: Length True
< **** MI:MD.isIncluded: LuminousIntensity True
< **** MI:MD.isIncluded: MagneticFluxDensity True
< **** MI:MD.isIncluded: Mass True
< **** MI:MD.isIncluded: MassFlowRate True
< **** MI:MD.isIncluded: MeterPowerN True
< **** MI:MD.isIncluded: RadioNuclide True
< **** MI:MD.isIncluded: Temperature True
< **** MI:MD.isIncluded: ThermodynamicTemperature True
< **** MI:MD.isIncluded: Time True
< **** MI:MD.isIncluded: Velocity True
< **** MI:MD.isIncluded: Volume True
< **** MI:MD.isIncluded: EMC2array True
< **** MI:MD.isIncluded: Embedded True
< **** MI:MD.isIncluded: FileSys True
< **** MI:MD.isIncluded: ForkJoinSystem True
< **** MI:MD.isIncluded: MetaSystem True
< **** MI:MD.isIncluded: MonitorSystemLib True
< **** MI:MD.isIncluded: NonBlockingIO True
< **** MI:MD.isIncluded: RandomNumberGeneratorLib True
< **** MI:MD.isIncluded: SimpleConcurrentProcesses True
< **** MI:MD.isIncluded: Socket True
< **** MI:MD.isIncluded: SocketSystem True
< **** MI:MD.isIncluded: StringLib False
< **** MI:MD.isIncluded: Xarray True
< **** MI:MD.isIncluded: OOPM True
< **** MI:MD.isIncluded: Sequential True
< **** MI:MD.isIncluded: no True
< **** MI:MD.isIncluded: workspace False
< **** MI:MD.isIncluded: AbstractEx True
< **** MI:MD.isIncluded: AccessEx True
< **** MI:MD.isIncluded: ApplyPred True
< **** MI:MD.isIncluded: ArduinoEx True
< **** MI:MD.isIncluded: ArmBasicSys True
< **** MI:MD.isIncluded: ArmLed True
< **** MI:MD.isIncluded: ArmMultiCore True
< **** MI:MD.isIncluded: CAStest True
< **** MI:MD.isIncluded: CAStestCore True
< **** MI:MD.isIncluded: CoroutineEx True
< **** MI:MD.isIncluded: CppEx True
< **** MI:MD.isIncluded: DumpObjEx True
< **** MI:MD.isIncluded: Errors True
< **** MI:MD.isIncluded: FoolishUnitEx True
< **** MI:MD.isIncluded: ForkGC True
< **** MI:MD.isIncluded: FuncVirtExVclass True
< **** MI:MD.isIncluded: FunctionalVirtEx True
< **** MI:MD.isIncluded: Jurgen True
< **** MI:MD.isIncluded: LLVMex True
< **** MI:MD.isIncluded: ListLiteralEx True
< **** MI:MD.isIncluded: LockTestCore True
< **** MI:MD.isIncluded: MVRsystem True
< **** MI:MD.isIncluded: MapEx True
< **** MI:MD.isIncluded: MiniVal True
< **** MI:MD.isIncluded: NewInner True
< **** MI:MD.isIncluded: NewSyntax True
< **** MI:MD.isIncluded: NoneEx True
< **** MI:MD.isIncluded: ObjectAndValues True
< **** MI:MD.isIncluded: ReadersSingleWriter True
< **** MI:MD.isIncluded: RemoteSuperVC True
< **** MI:MD.isIncluded: Restrictions True
< **** MI:MD.isIncluded: SlideEx True
< **** MI:MD.isIncluded: Sub1 True
< **** MI:MD.isIncluded: TST True
< **** MI:MD.isIncluded: TstBreak True
< **** MI:MD.isIncluded: UnitIssues True
< **** MI:MD.isIncluded: UnitKindEx True
< **** MI:MD.isIncluded: UnitTest True
< **** MI:MD.isIncluded: ValueArray True
< **** MI:MD.isIncluded: ValueConv True
< **** MI:MD.isIncluded: ValueEx True
< **** MI:MD.isIncluded: ValueItemEx True
< **** MI:MD.isIncluded: ValueTypes True
< **** MI:MD.isIncluded: VirtError True
< **** MI:MD.isIncluded: VirtualEx True
< **** MI:MD.isIncluded: Visibility True
< **** MI:MD.isIncluded: demo True
< **** MI:MD.isIncluded: embodyex True
< **** MI:MD.isIncluded: qbetaCmp True
< **** MI:MD.isIncluded: test True
< **** MI:MD.isIncluded: tiny True
< **** MI:MD.isIncluded: tinyA True
< **** MI:MD.isIncluded: tinyAA True
< **** MI:MD.isIncluded: tinyAB True
< **** MI:MD.isIncluded: tinyAC True
< **** MI:MD.isIncluded: tinyB True
< **** MI:MD.isIncluded: tinyC True
< **** MI:MD.isIncluded: tinyD True
< **** MI:MD.isIncluded: tinyE True
< **** MI:MD.isIncluded: tinyF True
< **** MI:MD.isIncluded: tinyG True
< **** MI:MD.isIncluded: tinyH True
< **** MI:MD.isIncluded: tinyI True
< **** MI:MD.isIncluded: tinyJ True
< **** MI:MD.isIncluded: tinyP True
< **** MI:MD.isIncluded: tinyQ True
< **** MI:MD.isIncluded: tinyR True
< **** MI:MD.isIncluded: tinyS True
< **** MI:MD.isIncluded: tinyV True
< **** MI:MD.isIncluded: tinyW True
< **** MI:MD.isIncluded: tinyX True
< **** MI:MD.isIncluded: tinyY False
< **** MI:MD.isIncluded: tinyZ True
< 
< XXX
< QWERPeriod:0,Y8U
< TRPeriod:16,Y24U
< T
