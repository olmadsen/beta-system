 -- QBETA 
 -- OG:markForCodeGen: "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" 
 -- OG:Qalloc: "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" qDes ... 0 
 -- OG:Qalloc:A:  "BETAworld"  super:  ""  marked:  true "BETAworld: obj {   %id "BETAworld";   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   - ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BETAworld" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 1 IS.newDescNo: 1 objSize: 0 1: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--wo ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: error 
 -- ModuleItem:Qalloc:  --BETA{} 
 -- Qalloc:module: BETA 
 -- Module:alloc:off: 2 BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public; ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --DK{} 
 -- ModuleItem:Qalloc:  --LIB{} 
 -- Qalloc:module: LIB 
 -- Module:alloc:off: 3 LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsyst ...} 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --OOPM{} 
 -- ModuleItem:Qalloc:  --Sequential{} 
 -- ModuleItem:Qalloc:  --no{} 
 -- ModuleItem:Qalloc:  --workspace{} 
 -- Qalloc:module: workspace 
 -- Module:alloc:off: 4 workspace: obj {   %id "workspace";   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--A ...} 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 1 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no; ...}" 
 -- IS.newDescNo: 1 IS.objSize: 4 "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace; ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  1 "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--n ...}" 
 -- ObjTmpStack:add: "BETAworld" : "%id "BETAworld"{   %modules BETA, LIB, LIB.StringLib, LIB.BasicIo;   error: ;      %basic 999;   --BETA;--DK;--LIB;--OOPM;--Sequential;--no ...}" 
 -- items:markForCodeGen: "%id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;}" 
 -- markItem: "%id "BETAworld"" Property 
 -- markItem: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" Property 
 -- OG:markForCodeGen: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;          ...}" 
 -- OG:Qalloc: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;          ...}" q ... 0 
 -- OG:Qalloc:A:  "BETA"  super:  ""  marked:  true "BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;         %basic 56;  ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BETA" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 2 IS.newDescNo: 2 objSize: 0 1: 1 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   % ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 2 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;       ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Object 
 -- Pattern:Qalloc: Value 
 -- Pattern:Qalloc: universal 
 -- Pattern:Qalloc: integer 
 -- Pattern:Qalloc: Boolean 
 -- Pattern:Qalloc: False 
 -- Pattern:Qalloc:B: False 
 -- Pattern:Qalloc: True 
 -- Pattern:Qalloc:B: True 
 -- Pattern:Qalloc: char 
 -- Pattern:Qalloc: universalFloat 
 -- Pattern:Qalloc: float 
 -- Pattern:Qalloc: put 
 -- Pattern:Qalloc: _put 
 -- Pattern:Qalloc: _get 
 -- Pattern:Qalloc: _iget 
 -- Pattern:Qalloc:B: _iget 
 -- Pattern:Qalloc: _kbhit 
 -- Pattern:Qalloc:B: _kbhit 
 -- Pattern:Qalloc: none 
 -- Pattern:Qalloc: immutable 
 -- Pattern:Qalloc: unique 
 -- Pattern:Qalloc:B: unique 
 -- Pattern:Qalloc: inner 
 -- Pattern:Qalloc: this 
 -- Pattern:Qalloc: disable 
 -- Pattern:Qalloc: enable 
 -- Pattern:Qalloc: fork 
 -- Pattern:Qalloc: sleep 
 -- Pattern:Qalloc: SuperCore 
 -- Pattern:Qalloc:B: SuperCore 
 -- Pattern:Qalloc: SuperScheduler 
 -- Pattern:Qalloc:B: SuperScheduler 
 -- Pattern:Qalloc: GeneralProcess 
 -- Pattern:Qalloc:B: GeneralProcess 
 -- Pattern:Qalloc: thisCoreIdx 
 -- Pattern:Qalloc: thisCore 
 -- Pattern:Qalloc: inSub 
 -- Pattern:Qalloc: method 
 -- Pattern:Qalloc:B: method 
 -- Pattern:Qalloc: disguised 
 -- Pattern:Qalloc:B: disguised 
 -- Pattern:Qalloc: SkipInternal 
 -- Pattern:Qalloc:B: SkipInternal 
 -- Pattern:Qalloc: Show 
 -- Pattern:Qalloc:B: Show 
 -- Pattern:Qalloc: Array 
 -- Pattern:Qalloc: Indexed 
 -- Pattern:Qalloc: IndexedRef 
 -- Pattern:Qalloc: restart 
 -- Pattern:Qalloc: leave 
 -- Pattern:Qalloc: if:then 
 -- Pattern:Qalloc: if:then:else 
 -- Pattern:Qalloc:B: if:then:else 
 -- Pattern:Qalloc: cycle 
 -- Pattern:Qalloc:B: cycle 
 -- Pattern:Qalloc: for:to:repeat 
 -- Pattern:Qalloc:B: for:to:repeat 
 -- Pattern:Qalloc: Condition 
 -- Pattern:Qalloc:B: Condition 
 -- Pattern:Qalloc: while:repeat 
 -- Pattern:Qalloc:B: while:repeat 
 -- Pattern:Qalloc: switch 
 -- Pattern:Qalloc:B: switch 
 -- Pattern:Qalloc: rswitch 
 -- Pattern:Qalloc:B: rswitch 
 -- dataitem:qalloc: "ascii" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 1 ...}" 
 -- OG:Qalloc: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   nu ...}" q ... 0 
 -- OG:Qalloc:A:  "ascii"  super:  ""  marked:  false "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   null: val 0;  ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "ascii" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 3 IS.newDescNo: 3 objSize: 0 1: 1 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');n ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 3 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;nu ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: asciiFoo 
 -- Pattern:Qalloc:B: asciiFoo 
 -- Pattern:Qalloc: asciiBar 
 -- Pattern:Qalloc:B: asciiBar 
 -- dataitem:qalloc: "nl" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "cr" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "null" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "newline" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Pattern:Qalloc: isLetter 
 -- Pattern:Qalloc:B: isLetter 
 -- Pattern:Qalloc: isDigit 
 -- Pattern:Qalloc:B: isDigit 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- OG:Qalloc: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}"  marked:  false "newline := nl -- Win:<cr><lf>, Unix:<lf>, ..." s ... n ... 
 -- Invocation:Qalloc: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- ObjectInvocation:Qalloc: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- name: "nl" 
 -- Arguments "-- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:Qalloc:SuperAlloc: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var inte ...}" 
 -- OG:Qalloc: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" q ... 0 
 -- OG:Qalloc:A:  "integer"  super:  "value"  marked:  false "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;  ...}" s ... v ... 
 -- Invocation:Qalloc: "value" 
 -- ObjectInvocation:Qalloc: "value" 
 -- name: "value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:Qalloc:SuperAlloc: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      in ...}" 
 -- OG:Qalloc: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;    ...}" q ... 0 
 -- OG:Qalloc:A:  "Value"  super:  ""  marked:  false "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      o ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;      %basic 5 ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Value" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 4 IS.newDescNo: 4 objSize: 0 1: 1 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 4 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;    ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc: <= 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 4 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :<  ...}" 
 -- IS.newDescNo: 4 IS.objSize: 0 "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;   %basic 5 ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  4 "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inn ...}" 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   ...}" 
 -- super:  "value" 
 -- E:  "value" 
 -- OG:Qalloc:B: "integer" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 5 IS.newDescNo: 5 objSize: 0 1: 1 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var inte ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 5 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integ ...}" 
 -- Items:Qalloc:super: "value" size: 0 "integer" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: * 
 -- Pattern:Qalloc: / 
 -- Pattern:Qalloc: // 
 -- Pattern:Qalloc: /% 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <=? 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc: cmpAndSwap 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 5 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var i ...}" 
 -- IS.newDescNo: 5 IS.objSize: 1 "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  :  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  5 "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var int ...}" 
 -- OG:super:  "nl: val 10" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- super:  "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- E:  "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 3 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 1 ...}" 
 -- IS.newDescNo: 3 IS.objSize: 5 "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;null: val  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  3 "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 1 ...}" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: newline 
 -- Pattern:Qalloc:B: newline 
 -- Pattern:Qalloc: int2chars 
 -- Pattern:Qalloc:B: int2chars 
 -- Pattern:Qalloc: putint 
 -- Pattern:Qalloc:B: putint 
 -- Pattern:Qalloc: exp 
 -- Pattern:Qalloc:B: exp 
 -- Pattern:Qalloc: sqrt 
 -- Pattern:Qalloc: cbrt 
 -- Pattern:Qalloc: log 
 -- Pattern:Qalloc: putFloat 
 -- Pattern:Qalloc: putFloatX 
 -- Pattern:Qalloc:B: putFloatX 
 -- Pattern:Qalloc: ConsoleIF 
 -- Pattern:Qalloc:B: ConsoleIF 
 -- dataitem:qalloc: "console" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "console: ref ConsoleIF" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 2 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;   ...}" 
 -- IS.newDescNo: 2 IS.objSize: 3 "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 5 ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  2 "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;  ...}" 
 -- ObjTmpStack:add: "BETA" : "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      = ...}" 
 -- items:markForCodeGen: "%ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;       ...}" 
 -- markItem: "%ID BETA" Property 
 -- markItem: "%OSDvisibility disguised" Property 
 -- markItem: "%module LIB, LIB.StringLib" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "ascii" :descNo: 3 :OG.primNo: 0 
 -- OG:markForCodeGen: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   nu ...}" 
 -- OG:Qalloc: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   nu ...}" q ... 3 
 -- ObjTmpStack:add: "ascii" : "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;    ...}" 
 -- items:markForCodeGen: "asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;null: val 0;newlin ...}" 
 -- DataItem:markForCodeGen: "nl" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "10" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10" 
 -- "10" true 
 -- 
 -- OG:markSuper: "10" 
 -- Invocation:markForCodeGen: "10" 
 -- OG:markForCodeGen: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "value" 
 -- "value" true 
 -- 
 -- OG:markSuper: "value" 
 -- Invocation:markForCodeGen: "value" 
 -- ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- Pattern:markForCodeGen: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;       ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;    ...}" 
 -- OG:Qalloc: "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );   <=  :< ;    ...}" q ... 4 
 -- ObjTmpStack:add: "Value" : "%ID Value{   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(=  ...}" 
 -- items:markForCodeGen: "%ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;   %basic 52;   in  ...}" 
 -- markItem: "%ID Value" Property 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 21" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- items:markForCodeGen: "" 
 -- Pattern:markForCodeGen: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" 
 -- OG:Qalloc: "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      out R: var ...}" q ... 5 
 -- ObjTmpStack:add: "integer" : "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- items:markForCodeGen: "%ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %bas ...}" 
 -- markItem: "%ID integer" Property 
 -- markItem: "%basic 1, 32" Property 
 -- markItem: "%globals" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Universal" 
 -- "Universal" true 
 -- 
 -- OG:markSuper: "Universal" 
 -- Invocation:markForCodeGen: "Universal" 
 -- ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- Pattern:markForCodeGen: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in  ...}" 
 -- OG:Qalloc: "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in  ...}" q ... 0 
 -- OG:Qalloc:A:  "universal"  super:  "Value"  marked:  true "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;  ...}" s ... V ... 
 -- Invocation:Qalloc: "Value" 
 -- ObjectInvocation:Qalloc: "Value" 
 -- name: "Value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      %basic 62;      in V: var inte ...}" 
 -- super:  "Value" 
 -- E:  "Value" 
 -- OG:Qalloc:B: "universal" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 6 IS.newDescNo: 6 objSize: 0 1: 1 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %b ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 6 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var in ...}" 
 -- Items:Qalloc:super: "Value" size: 0 "universal" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 6 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: va ...}" 
 -- IS.newDescNo: 6 IS.objSize: 0 "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  6 "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;     ...}" 
 -- ObjTmpStack:add: "universal" : "Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      out R: var integer;   -  : ;      ...}" 
 -- items:markForCodeGen: "%ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   out R:  ...}" 
 -- markItem: "%ID universal" Property 
 -- markItem: "%basic 1, 32" Property 
 -- markItem: "%globals" Property 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Universal"  IS.isEmpty:  true 
 -- not ObjDesc:  "10"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "cr" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "13" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "13" 
 -- "13" true 
 -- 
 -- OG:markSuper: "13" 
 -- Invocation:markForCodeGen: "13" 
 -- not ObjDesc:  "13"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "null" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "newline" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- Pattern:markForCodeGen: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "value" 
 -- "value" true 
 -- 
 -- OG:markSuper: "value" 
 -- Invocation:markForCodeGen: "value" 
 -- ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var cha ...}" 
 -- OG:Qalloc: "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var cha ...}" q ... 0 
 -- OG:Qalloc:A:  "char"  super:  "value"  marked:  true "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" s ... v ... 
 -- Invocation:Qalloc: "value" 
 -- ObjectInvocation:Qalloc: "value" 
 -- name: "value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: var char;   -  : ; ...}" 
 -- super:  "value" 
 -- E:  "value" 
 -- OG:Qalloc:B: "char" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 7 IS.newDescNo: 7 objSize: 0 1: 1 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char; ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 7 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ...}" 
 -- Items:Qalloc:super: "value" size: 0 "char" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <=? 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 7 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char; ...}" 
 -- IS.newDescNo: 7 IS.objSize: 1 "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %ba ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  7 "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char ...}" 
 -- ObjTmpStack:add: "char" : "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      ...}" 
 -- items:markForCodeGen: "%id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %basic 62;  ...}" 
 -- markItem: "%id "char"" Property 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 3, 16" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Universal" 
 -- "Universal" true 
 -- 
 -- OG:markSuper: "Universal" 
 -- Invocation:markForCodeGen: "Universal" 
 -- ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Universal"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- markItem: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" Assign 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: var char" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" true 
 -- 
 -- DataItem:markForCodeGen: "console" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "ConsoleIF" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "ConsoleIF" 
 -- "ConsoleIF" false 
 -- 
 -- OG:markForCodeGen: "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- OG:Qalloc: "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" qDescno:  0 
 -- OG:Qalloc:A:  "ConsoleIF"  super:  ""  marked:  true "ConsoleIF: {   put:< ;      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Inte ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "ConsoleIF" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 8 IS.newDescNo: 8 objSize: 0 1: 1 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(pu ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 8 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: put 
 -- Pattern:Qalloc:B: put 
 -- Pattern:Qalloc: puttext 
 -- Pattern:Qalloc:B: puttext 
 -- Pattern:Qalloc: putint 
 -- Pattern:Qalloc:B: putint 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 8 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- IS.newDescNo: 8 IS.objSize: 1 "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- OG:Qalloc:end: IS.newDescNo:  8 "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- ObjTmpStack:add: "ConsoleIF" : "put:< {      ...;   puttext(T: var LIB.StringLib.String):< ;      inner(puttext);   putint(V: var Integer):< ;      inner(putint)}" 
 -- items:markForCodeGen: "put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)}" 
 -- Pattern:markForCodeGen: "put:< {   ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "..." 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "..." 
 -- OG:Qalloc: "..." qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  ""  marked:  true "put:< {   ...}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "..." 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "put" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 9 IS.newDescNo: 9 objSize: 0 1: 1 "..." 
 -- Items:Qalloc:objSize: 0  newDescNo: 9 "..." 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 9 "..." 
 -- IS.newDescNo: 9 IS.objSize: 1 "..." 
 -- OG:Qalloc:end: IS.newDescNo:  9 "..." 
 -- ObjTmpStack:add: "put" : "..." 
 -- items:markForCodeGen: "..." 
 -- markItem: "..." Dots 
 -- Pattern:markForCodeGen: "puttext(T: var LIB.StringLib.String):< {   inner(puttext)}" 
 -- items:markForCodeGen: "%$B "("{T: var LIB.StringLib.String;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- OG:markForCodeGen: "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an index er ...}" 
 -- OG:Qalloc: "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an index er ...}" q ... 0 
 -- OG:Qalloc:A:  "String"  super:  "Value"  marked:  true "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: v ...}" s ... V ... 
 -- Invocation:Qalloc: "Value" 
 -- ObjectInvocation:Qalloc: "Value" 
 -- name: "Value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an index error, access ...}" 
 -- super:  "Value" 
 -- E:  "Value" 
 -- OG:Qalloc:B: "String" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 10 IS.newDescNo: 10 objSize: 0 1: 1 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0 ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 10 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index e ...}" 
 -- Items:Qalloc:super: "Value" size: 0 "String" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- Pattern:Qalloc: length 
 -- Pattern:Qalloc:B: length 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc:B: + 
 -- Pattern:Qalloc: asLowerCase 
 -- Pattern:Qalloc:B: asLowerCase 
 -- Pattern:Qalloc: scan 
 -- Pattern:Qalloc:B: scan 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc:B: = 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc:B: <> 
 -- Pattern:Qalloc: <= 
 -- Pattern:Qalloc:B: <= 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 10 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an ind ...}" 
 -- IS.newDescNo: 10 IS.objSize: 0 "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index error, ac ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  10 "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] - ...}" 
 -- ObjTmpStack:add: "String" : "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- act ...}" 
 -- items:markForCodeGen: "%id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index error, accessing l ...}" 
 -- markItem: "%id "String pattern"" Property 
 -- markItem: "%OSDvisibility disguised" Property 
 -- markItem: "%basic 5" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "=  :: {   loop: do ;      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave( ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq := true ...}" 
 -- OG:Qalloc: "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq := true ...}" q ... 0 
 -- OG:Qalloc:A:  "="  super:  ""  marked:  true "=  :: {   loop: do ;      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:Qalloc:SuperAlloc: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc: "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  ""  marked:  false "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 11 IS.newDescNo: 11 objSize: 0 1: 1 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 11 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(= )" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(= )"  marked:  false "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" super:  inner(= ) 
 -- Invocation:Qalloc: "inner(= )" 
 -- ObjectInvocation:Qalloc: "inner(= )" 
 -- name: "inner" 
 -- Arguments "inner(= )" 
 -- OG:Qalloc: "= " qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "= "  marked:  false "inner(= )" super:  =  
 -- Invocation:Qalloc: "= " 
 -- ObjectInvocation:Qalloc: "= " 
 -- name: "=" 
 -- Arguments "" 
 -- OG:Qalloc: "" qDescno:  0 
 -- OG:Qalloc:A:  "emptyOG"  super:  ""  marked:  false "" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "= " 
 -- super:  "= " 
 -- E:  "= " 
 -- OG:Qalloc:end: IS.newDescNo:  0 "= " 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 101{in inner: ref Object} 
 -- OG:Qalloc:SuperAlloc: "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc: "%basic 101{   in inner: ref Object}" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  ""  marked:  false "inner: {   %basic 101;   in inner: ref Object}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 101{   in inner: ref Object}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "inner" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 12 IS.newDescNo: 12 objSize: 0 1: 1 "%basic 101{in inner: ref Object}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 12 "%basic 101{in inner: ref Object}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "inner" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in inner: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 12 "%basic 101{in inner: ref Object}" 
 -- IS.newDescNo: 12 IS.objSize: 2 "%basic 101{in inner: ref Object}" 
 -- OG:Qalloc:end: IS.newDescNo:  12 "%basic 101{   in inner: ref Object}" 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(= )" 
 -- super:  "inner(= )" 
 -- E:  "inner(= )" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(= )" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 11 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- IS.newDescNo: 11 IS.objSize: 5 "%basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )}" 
 -- OG:Qalloc:end: IS.newDescNo:  11 "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);      beq := true;      for( ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 13 IS.newDescNo: 13 objSize: 0 1: 1 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 13 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq  ...}" 
 -- Items:Qalloc:super: "" size: 5 "=" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 13 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);    ...}" 
 -- IS.newDescNo: 13 IS.objSize: 5 "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true; ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  13 "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(l ...}" 
 -- ObjTmpStack:add: "=  " : "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);    ...}" 
 -- items:markForCodeGen: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1) ...}" 
 -- OG:markForCodeGen: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repe ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      ...}" 
 -- OG:Qalloc: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      ...}" q ... 0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  true "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      c1 := get[ ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 14 IS.newDescNo: 14 objSize: 0 1: 1 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 14 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repea ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "c1" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "c2" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length"  marked:  false "L := length" super:  length 
 -- Invocation:Qalloc: "length" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:Qalloc:SuperAlloc: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  ""  marked:  false "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "length" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 15 IS.newDescNo: 15 objSize: 0 1: 1 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 15 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "get[0] -- actually an index error, accessing length" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[0] -- actually an index error, accessing length"  marked:  false "V := get[0] -- actually an index error, accessing length" super:  get[0 ... 
 -- Invocation:Qalloc: "get[0] -- actually an index error, accessing length" 
 -- ObjectInvocation:Qalloc: "get[0] -- actually an index error, accessing length" 
 -- name: "get" 
 -- Arguments "get[0]" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "get[0]" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 117{out ch: var char} 
 -- OG:Qalloc:SuperAlloc: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc: "%basic 117{   out ch: var char}" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  ""  marked:  false "get[inx: var integer]: {   %basic 117;   out ch: var char}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 117{   out ch: var char}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "get" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 16 IS.newDescNo: 16 objSize: 0 1: 1 "%basic 117{out ch: var char}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 16 "%basic 117{out ch: var char}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "["{inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "["{inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "ch" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 16 "%basic 117{out ch: var char}" 
 -- IS.newDescNo: 16 IS.objSize: 3 "%basic 117{out ch: var char}" 
 -- OG:Qalloc:end: IS.newDescNo:  16 "%basic 117{   out ch: var char}" 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[0] -- actually an index error, accessing length" 
 -- super:  "get[0] -- actually an index error, accessing length" 
 -- E:  "get[0] -- actually an index error, accessing length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[0] -- actually an index error, accessing length" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 15 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- IS.newDescNo: 15 IS.objSize: 2 "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:end: IS.newDescNo:  15 "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length" 
 -- super:  "length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length" 
 -- OG:Qalloc: "if (L <> Veq.length) :then {   leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L <> Veq.length) :then {   leave(loop)}"  marked:  false "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:Qalloc: "(L <> Veq.length)" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  "(L <> Veq.length)"  marked:  false "if (L <> Veq.length) :then {   leave(loop)}" super:  (L <> Veq.length) 
 -- Invocation:Qalloc: "(L <> Veq.length)" 
 -- Invocation:Qalloc: "L <> Veq.length" 
 -- BinaryExp:Qalloc: "L <> Veq.length" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<> Veq.length" 
 -- name: "<>" 
 -- Arguments "Veq.length" 
 -- OG:Qalloc: "Veq.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "Veq.length"  marked:  false "Veq.length" super:  Veq.length 
 -- Invocation:Qalloc: "Veq.length" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.length" 
 -- super:  "Veq.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.length" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 55{in V: var integer;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 55{   in V: var integer;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  ""  marked:  false "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 55{   in V: var integer;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<>" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 17 IS.newDescNo: 17 objSize: 0 1: 1 "%basic 55{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 17 "%basic 55{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 17 "%basic 55{in V: var integer;out B: var boolean}" 
 -- IS.newDescNo: 17 IS.objSize: 5 "%basic 55{in V: var integer;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  17 "%basic 55{   in V: var integer;   out B: var boolean}" 
 -- OG:super:  "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L <> Veq.length)" 
 -- super:  "(L <> Veq.length)" 
 -- E:  "(L <> Veq.length)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L <> Veq.length)" 
 -- OG:Qalloc: "leave(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L <> Veq.length) :then {   leave(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 18 IS.newDescNo: 18 objSize: 0 1: 1 "leave(loop)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 18 "leave(loop)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "leave(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(loop)"  marked:  false "leave(loop)" super:  leave(loop) 
 -- Invocation:Qalloc: "leave(loop)" 
 -- ObjectInvocation:Qalloc: "leave(loop)" 
 -- name: "leave" 
 -- Arguments "leave(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "leave(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  14 4 c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1) ...} 
 -- OG:super:  "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length) ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 103 
 -- OG:Qalloc:SuperAlloc: "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc: "%basic 103" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  ""  marked:  false "leave(V: var integer): {   %basic 103}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 103" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "leave" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 19 IS.newDescNo: 19 objSize: 0 1: 1 "%basic 103" 
 -- Items:Qalloc:objSize: 0  newDescNo: 19 "%basic 103" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 19 "%basic 103" 
 -- IS.newDescNo: 19 IS.objSize: 2 "%basic 103" 
 -- OG:Qalloc:end: IS.newDescNo:  19 "%basic 103" 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop)" 
 -- super:  "leave(loop)" 
 -- E:  "leave(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 18 "leave(loop)" 
 -- IS.newDescNo: 18 IS.objSize: 1 "leave(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  18 "leave(loop)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:Qalloc:SuperAlloc: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then"  super:  ""  marked:  false "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" super ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57; ...} 
 -- OG:Qalloc:SuperAlloc: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "if:then" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 20 IS.newDescNo: 20 objSize: 0 1: 1 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 20 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "%$B "("{cond: var boolean;%$S "):then{";thenPart:< object;%$E "}"}" 
 -- dataitem:qalloc: "cond" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: thenPart 
 -- Pattern:Qalloc:B: thenPart 
 -- (OG.super.desc).newDescNo = 0 
 -- OG:Qalloc: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref O ...}" q ... 0 
 -- OG:Qalloc:A:  "Object"  super:  ""  marked:  false "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boo ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  false  IS.superDesc.newDescNo:  
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref Object;      ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Object" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 21 IS.newDescNo: 21 objSize: 0 1: 1 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %b ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 21 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- OG:Qalloc: "inner(Object)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(Object)"  marked:  false "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %b ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(Object)" 
 -- ObjectInvocation:Qalloc: "inner(Object)" 
 -- name: "inner" 
 -- Arguments "inner(Object)" 
 -- OG:Qalloc: "Object" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "Object"  marked:  false "inner(Object)" super:  Object 
 -- Invocation:Qalloc: "Object" 
 -- ObjectInvocation:Qalloc: "Object" 
 -- name: "Object" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Object" 
 -- super:  "Object" 
 -- E:  "Object" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Object" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Object)" 
 -- super:  "inner(Object)" 
 -- E:  "inner(Object)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Object)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 21 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx:  ...}" 
 -- IS.newDescNo: 21 IS.objSize: 1 "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref Object;  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  21 "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 5 ...}" 
 -- Pattern:qalloc:super:descNo: 21 thenPart:< object 
 -- Pattern:Qalloc: thenPart$22 
 -- Pattern:Qalloc:B: thenPart$22 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "%$B "("{cond: var boolean;%$S "):then{";thenPart:< object;%$E "}"}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 20 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- IS.newDescNo: 20 IS.objSize: 1 "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- OG:Qalloc:end: IS.newDescNo:  20 "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L <> Veq.length) :then {   leave(loop)}" 
 -- super:  "if (L <> Veq.length) :then {   leave(loop)}" 
 -- E:  "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L <> Veq.length) :then {   leave(loop)}" 
 -- Invocation:Qalloc: "beq" 
 -- ObjectInvocation:Qalloc: "beq" 
 -- name: "beq" 
 -- Arguments "" 
 -- OG:Qalloc: "true" qDescno:  0 
 -- OG:Qalloc:A:  "True"  super:  "true"  marked:  false "beq := true" super:  true 
 -- Invocation:Qalloc: "true" 
 -- ObjectInvocation:Qalloc: "true" 
 -- name: "true" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{out B: var boolean;B := 1} 
 -- OG:Qalloc:SuperAlloc: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 1}" qDescno:  0 
 -- OG:Qalloc:A:  "True"  super:  ""  marked:  false "True: {   %globals;   out B: var boolean;   B := 1}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   out B: var boolean;   B := 1}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "True" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 23 IS.newDescNo: 23 objSize: 0 1: 1 "%globals{out B: var boolean;B := 1}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 23 "%globals{out B: var boolean;B := 1}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "B := 1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 23 "%globals{out B: var boolean;B := 1}" 
 -- IS.newDescNo: 23 IS.objSize: 1 "%globals{out B: var boolean;B := 1}" 
 -- OG:Qalloc:end: IS.newDescNo:  23 "%globals{   out B: var boolean;   B := 1}" 
 -- OG:super:  "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "true" 
 -- super:  "true" 
 -- E:  "true" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "true" 
 -- OG:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"   ... false "c ..." s ... f ... 
 -- Invocation:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- ObjectInvocation:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      lea ...}" s ... 1 ... 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length"  marked:  false "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      ...}" s ... l ... 
 -- Invocation:Qalloc: "length" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length" 
 -- super:  "length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length" 
 -- OG:Qalloc: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      lea ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 24 IS.newDescNo: 24 objSize: 0 1: 1 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 24 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- Items:Qalloc:super: "" size: 1 "repeat$24" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "c1 := get[inx]" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- OG:Qalloc: "Veq.get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "Veq.get[inx]"  marked:  false "c2 := Veq.get[inx]" super:  Veq.get[inx] 
 -- Invocation:Qalloc: "Veq.get[inx]" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.get[inx]" 
 -- super:  "Veq.get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.get[inx]" 
 -- OG:Qalloc: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}"  marked:  false "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := ...}" s ... i ... 
 -- Invocation:Qalloc: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:Qalloc: "(c1 <> c2)" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  "(c1 <> c2)"  marked:  false "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" super:  (c1 <> c2) 
 -- Invocation:Qalloc: "(c1 <> c2)" 
 -- Invocation:Qalloc: "c1 <> c2" 
 -- BinaryExp:Qalloc: "c1 <> c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<> c2" 
 -- name: "<>" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 55{in V: var char;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 55{   in V: var char;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<>"  super:  ""  marked:  false "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 55{   in V: var char;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<>" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 25 IS.newDescNo: 25 objSize: 0 1: 1 "%basic 55{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 25 "%basic 55{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 25 "%basic 55{in V: var char;out B: var boolean}" 
 -- IS.newDescNo: 25 IS.objSize: 5 "%basic 55{in V: var char;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  25 "%basic 55{   in V: var char;   out B: var boolean}" 
 -- OG:super:  "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 <> c2)" 
 -- super:  "(c1 <> c2)" 
 -- E:  "(c1 <> c2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 <> c2)" 
 -- OG:Qalloc: "Beq := false{   leave(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := false{   leave(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 26 IS.newDescNo: 26 objSize: 0 1: 1 "Beq := false{leave(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 26 "Beq := false{leave(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "false" qDescno:  0 
 -- OG:Qalloc:A:  "False"  super:  "false"  marked:  false "Beq := false" super:  false 
 -- Invocation:Qalloc: "false" 
 -- ObjectInvocation:Qalloc: "false" 
 -- name: "false" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{out B: var boolean;B := 0} 
 -- OG:Qalloc:SuperAlloc: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 0}" qDescno:  0 
 -- OG:Qalloc:A:  "False"  super:  ""  marked:  false "False: {   %globals;   out B: var boolean;   B := 0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   out B: var boolean;   B := 0}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "False" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 27 IS.newDescNo: 27 objSize: 0 1: 1 "%globals{out B: var boolean;B := 0}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 27 "%globals{out B: var boolean;B := 0}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Invocation:Qalloc: "B" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "B := 0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 27 "%globals{out B: var boolean;B := 0}" 
 -- IS.newDescNo: 27 IS.objSize: 1 "%globals{out B: var boolean;B := 0}" 
 -- OG:Qalloc:end: IS.newDescNo:  27 "%globals{   out B: var boolean;   B := 0}" 
 -- OG:super:  "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "false" 
 -- super:  "false" 
 -- E:  "false" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "false" 
 -- OG:Qalloc: "leave(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(loop)"  marked:  false "Beq := false{leave(loop)}" super:  leave(loop) 
 -- Invocation:Qalloc: "leave(loop)" 
 -- ObjectInvocation:Qalloc: "leave(loop)" 
 -- name: "leave" 
 -- Arguments "leave(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "leave(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  14 4 c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1) ...} 
 -- OG:super:  "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length) ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(loop)" 
 -- super:  "leave(loop)" 
 -- E:  "leave(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 26 "Beq := false{leave(loop)}" 
 -- IS.newDescNo: 26 IS.objSize: 1 "Beq := false{leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  26 "Beq := false{   leave(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- super:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- E:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 24 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- IS.newDescNo: 24 IS.objSize: 1 "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  24 "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;     ...} 
 -- OG:Qalloc:SuperAlloc: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx  ...}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := i ...}" q ... 0 
 -- OG:Qalloc:A:  "for:to:repeat"  super:  ""  marked:  false "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globa ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := inx + 1;     ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "for:to:repeat" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 28 IS.newDescNo: 28 objSize: 0 1: 1 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :th ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 28 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      i ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "%$B "("{first: var integer;%$S "):to(";last: var integer;%$S "):repeat{";repeat:< object;%$E "}"}" 
 -- dataitem:qalloc: "first" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "last" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: repeat 
 -- Pattern:Qalloc:B: repeat 
 -- Pattern:Qalloc: repeat$29 
 -- Pattern:Qalloc:B: repeat$29 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{first: var integer;%$S "):to(";last: var integer;%$S "):repeat{";repeat:< object;%$E "}"}" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "first" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "first"  marked:  false "inx := first" super:  first 
 -- Invocation:Qalloc: "first" 
 -- ObjectInvocation:Qalloc: "first" 
 -- name: "first" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "first: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "first" 
 -- super:  "first" 
 -- E:  "first" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "first" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 28 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;    ...}" 
 -- IS.newDescNo: 28 IS.objSize: 3 "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      inx := in ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  28 "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         re ...}" 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- super:  "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- E:  "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 30 IS.newDescNo: 30 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 30 "" 
 -- Items:Qalloc:super: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" size: 3 "for:to:repea ..." 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 30 "" 
 -- IS.newDescNo: 30 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  30 "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 14 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):r ...}" 
 -- IS.newDescNo: 14 IS.objSize: 4 "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repeat;   c1  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  14 "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):t ...}" 
 -- ObjTmpStack:add: "loop" : "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(lengt ...}" 
 -- items:markForCodeGen: "c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repeat;   c1 := get[in ...}" 
 -- DataItem:markForCodeGen: "c1" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c2" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- Pattern:markForCodeGen: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var in ...}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "L := length" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length" 
 -- "length" false 
 -- 
 -- OG:markSuper: "length" 
 -- Invocation:markForCodeGen: "length" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- Pattern:markForCodeGen: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc: "out V: var integer{   V := get[0] -- actually an index error, accessing length}" qDescno:  15 
 -- ObjTmpStack:add: "length" : "out V: var integer{   V := get[0] -- actually an index error, accessing length}" 
 -- items:markForCodeGen: "out V: var integer{V := get[0] -- actually an index error, accessing length}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "V := get[0] -- actually an index error, accessing length" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "out V: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "length"  IS.isEmpty:  true 
 -- markItem: "if (L <> Veq.length) :then {   leave(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L <> Veq.length) :then {   leave(loop)}" 
 -- "if (L <> Veq.length) :then {   leave(loop)}" true 
 -- 
 -- OG:markSuper: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- Invocation:markForCodeGen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:markForCodeGen: "(L <> Veq.length)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L <> Veq.length)" 
 -- "(L <> Veq.length)" true 
 -- 
 -- OG:markSuper: "(L <> Veq.length)" 
 -- Invocation:markForCodeGen: "(L <> Veq.length)" 
 -- Invocation:markForCodeGen: "L <> Veq.length" 
 -- BinaryExp:markForCodeGen: "L <> Veq.length" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<> Veq.length"  ATd: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "Veq.length" 
 -- OG:markForCodeGen: "Veq.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Veq.length" 
 -- "Veq" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "Veq.length" 
 -- Invocation:markForCodeGen: "Veq.length" 
 -- ObjectInvocation:markForCodeGen: "Veq"  ATd: "in Veq: var this(Value)" 
 -- DataItem:markForCodeGen: "Veq" :descNo: 0 :OG.primNo: 18 
 -- OG:markForCodeGen: "this(Value)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "this(Value)" 
 -- "this(Value)" true 
 -- 
 -- OG:markSuper: "this(Value)" 
 -- Invocation:markForCodeGen: "this(Value)" 
 -- ObjectInvocation:markForCodeGen: "this(Value)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- Pattern:markForCodeGen: "this: {   %basic 18;   in this: ref Object}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%basic 18{   in this: ref Object}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%basic 18{   in this: ref Object}" 
 -- OG:Qalloc: "%basic 18{   in this: ref Object}" qDescno:  0 
 -- OG:Qalloc:A:  "this"  super:  ""  marked:  true "this: {   %basic 18;   in this: ref Object}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 18{   in this: ref Object}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "this" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 31 IS.newDescNo: 31 objSize: 0 1: 1 "%basic 18{in this: ref Object}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 31 "%basic 18{in this: ref Object}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "this" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in this: ref Object" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 31 "%basic 18{in this: ref Object}" 
 -- IS.newDescNo: 31 IS.objSize: 2 "%basic 18{in this: ref Object}" 
 -- OG:Qalloc:end: IS.newDescNo:  31 "%basic 18{   in this: ref Object}" 
 -- ObjTmpStack:add: "this" : "%basic 18{   in this: ref Object}" 
 -- items:markForCodeGen: "%basic 18{in this: ref Object}" 
 -- markItem: "%basic 18" Property 
 -- DataItem:markForCodeGen: "this" :descNo: 0 :OG.primNo: 64 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- OG:markForCodeGen: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in obj ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref O ...}" 
 -- OG:Qalloc: "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      in objx: ref O ...}" q ... 21 
 -- ObjTmpStack:add: "Object" : "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;    ...}" 
 -- items:markForCodeGen: "%ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref Object;   out V:  ...}" 
 -- markItem: "%ID Object" Property 
 -- markItem: "%basic 64" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "X_asString:<  -- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "-- does not wokr, problem with virtual in Object" 
 -- "" false 
 -- 
 -- OG:markIS: "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- OG:Qalloc: "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" qDescno:  0 
 -- OG:Qalloc:A:  "X_asString"  super:  "-- does not wokr, problem with virtual in Object"  marked:  true "X_asString:<  -- does not wokr, problem with virtual in Object{   ou ...}" s ... - ... 
 -- Invocation:Qalloc: "-- does not wokr, problem with virtual in Object" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- super:  "-- does not wokr, problem with virtual in Object" 
 -- E:  "" 
 -- OG:Qalloc:B: "X_asString" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 32 IS.newDescNo: 32 objSize: 0 1: 1 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 32 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: true  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out S: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(X_asString)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(X_asString)"  marked:  false "out S: var LIB.StringLib.String{inner(X_asString)}" super:  inner(X_asString) 
 -- Invocation:Qalloc: "inner(X_asString)" 
 -- ObjectInvocation:Qalloc: "inner(X_asString)" 
 -- name: "inner" 
 -- Arguments "inner(X_asString)" 
 -- OG:Qalloc: "X_asString" qDescno:  0 
 -- OG:Qalloc:A:  "X_asString"  super:  "X_asString"  marked:  false "inner(X_asString)" super:  X_asString 
 -- Invocation:Qalloc: "X_asString" 
 -- ObjectInvocation:Qalloc: "X_asString" 
 -- name: "X_asString" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  32 2 out S: var LIB.StringLib.String{inner(X_asString)} 
 -- OG:super:  "X_asString:<  -- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "X_asString" 
 -- super:  "X_asString" 
 -- E:  "X_asString" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "X_asString" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(X_asString)" 
 -- super:  "inner(X_asString)" 
 -- E:  "inner(X_asString)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(X_asString)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 32 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- IS.newDescNo: 32 IS.objSize: 2 "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- OG:Qalloc:end: IS.newDescNo:  32 "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- ObjTmpStack:add: "X_asString" : "-- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)}" 
 -- items:markForCodeGen: "out S: var LIB.StringLib.String{inner(X_asString)}" 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- OG:markSuper: "LIB.StringLib.String" 
 -- Invocation:markForCodeGen: "LIB.StringLib.String" 
 -- ObjectInvocation:markForCodeGen: "LIB"  ATd: "--LIB{}" 
 -- OG:markForCodeGen: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collecti ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Co ...}" 
 -- OG:Qalloc: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Co ...}" q ... 0 
 -- OG:Qalloc:A:  "LIB"  super:  ""  marked:  true "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--Basic ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Compiler;--Co ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "LIB" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 33 IS.newDescNo: 33 objSize: 0 1: 1 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--Basi ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 33 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;-- ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "x_dummy_LIB" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --AgentSystem{} 
 -- ModuleItem:Qalloc:  --Associations{} 
 -- ModuleItem:Qalloc:  --BasicIO{} 
 -- Qalloc:module: BasicIO 
 -- Module:alloc:off: 3 BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;   ...} 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --BasicSystemLib{} 
 -- ModuleItem:Qalloc:  --COsystem{} 
 -- ModuleItem:Qalloc:  --Collections{} 
 -- ModuleItem:Qalloc:  --Compiler{} 
 -- ModuleItem:Qalloc:  --Complex{} 
 -- ModuleItem:Qalloc:  --DateTimeLib{} 
 -- ModuleItem:Qalloc:  --Dimensions{} 
 -- Qalloc:module: Dimensions 
 -- Module:alloc:off: 4 Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;       ...} 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --EMC2array{} 
 -- ModuleItem:Qalloc:  --Embedded{} 
 -- ModuleItem:Qalloc:  --FileSys{} 
 -- ModuleItem:Qalloc:  --ForkJoinSystem{} 
 -- ModuleItem:Qalloc:  --MetaSystem{} 
 -- ModuleItem:Qalloc:  --MonitorSystemLib{} 
 -- ModuleItem:Qalloc:  --NonBlockingIO{} 
 -- ModuleItem:Qalloc:  --RandomNumberGeneratorLib{} 
 -- ModuleItem:Qalloc:  --SimpleConcurrentProcesses{} 
 -- ModuleItem:Qalloc:  --Socket{} 
 -- ModuleItem:Qalloc:  --SocketSystem{} 
 -- ModuleItem:Qalloc:  --StringLib{} 
 -- Qalloc:module: StringLib 
 -- Module:alloc:off: 5 StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basi ...} 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --Xarray{} 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 33 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsyste ...}" 
 -- IS.newDescNo: 33 IS.objSize: 5 "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collecti ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  33 "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsys ...}" 
 -- ObjTmpStack:add: "LIB" : "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Co ...}" 
 -- items:markForCodeGen: "%id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Com ...}" 
 -- markItem: "%id "LIB"" Property 
 -- markItem: "%module BETA" Property 
 -- markItem: "%Include BETA" Property 
 -- DataItem:markForCodeGen: "x_dummy_LIB" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;        ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: v ...}" 
 -- OG:Qalloc: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: v ...}" q ... 0 
 -- OG:Qalloc:A:  "BasicIO"  super:  ""  marked:  true "BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: var integer; ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "BasicIO" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 34 IS.newDescNo: 34 objSize: 0 1: 1 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M : ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 34 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res:  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Lock 
 -- Pattern:Qalloc:B: Lock 
 -- dataitem:qalloc: "keyboard" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ; ...}" 
 -- OG:Qalloc: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;   ...}" q ... 0 
 -- OG:Qalloc:A:  "keyboard"  super:  ""  marked:  false "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj I ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;         ch : ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "keyboard" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 35 IS.newDescNo: 35 objSize: 0 1: 1 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 35 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: v ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: readLine 
 -- Pattern:Qalloc:B: readLine 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 35 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      c ...}" 
 -- IS.newDescNo: 35 IS.objSize: 1 "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char; ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  35 "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;   ...}" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "screen" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- OG:Qalloc: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" qDescno:  0 
 -- OG:Qalloc:A:  "screen"  super:  ""  marked:  false "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      i ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "screen" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 36 IS.newDescNo: 36 objSize: 0 1: 1 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 36 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "L" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "L: obj Lock" 
 -- OG:Qalloc: "Lock" qDescno:  0 
 -- OG:Qalloc:A:  "Lock"  super:  "Lock"  marked:  false "L: obj Lock" super:  Lock 
 -- Invocation:Qalloc: "Lock" 
 -- ObjectInvocation:Qalloc: "Lock" 
 -- name: "Lock" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;   ...} 
 -- OG:Qalloc:SuperAlloc: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;  ...}" 
 -- OG:Qalloc: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;    ...}" q ... 0 
 -- OG:Qalloc:A:  "Lock"  super:  ""  marked:  false "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      lo ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;         res : ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Lock" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 37 IS.newDescNo: 37 objSize: 0 1: 1 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      di ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 37 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;   ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "dummy" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "M" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc:B: get 
 -- Pattern:Qalloc: free 
 -- Pattern:Qalloc:B: free 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 37 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 1 ...}" 
 -- IS.newDescNo: 37 IS.objSize: 3 "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  37 "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable; ...}" 
 -- OG:super:  "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Lock" 
 -- super:  "Lock" 
 -- E:  "Lock" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Lock" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: init 
 -- Pattern:Qalloc:B: init 
 -- Pattern:Qalloc: display 
 -- Pattern:Qalloc:B: display 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 36 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- IS.newDescNo: 36 IS.objSize: 2 "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- OG:Qalloc:end: IS.newDescNo:  36 "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 34 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      r ...}" 
 -- IS.newDescNo: 34 IS.objSize: 3 "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var inte ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  34 "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      ...}" 
 -- ObjTmpStack:add: "BasicIO" : "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get ...}" 
 -- items:markForCodeGen: "%module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      ...}" 
 -- markItem: "%module LIB.StringLib" Property 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "keyboard" :descNo: 35 :OG.primNo: 0 
 -- OG:markForCodeGen: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;   ...}" 
 -- OG:Qalloc: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;   ...}" q ... 35 
 -- ObjTmpStack:add: "keyboard" : "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;      ...}" 
 -- items:markForCodeGen: "%Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch  ...}" 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "screen" :descNo: 36 :OG.primNo: 0 
 -- OG:markForCodeGen: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- OG:Qalloc: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" qDescno:  36 
 -- ObjTmpStack:add: "screen" : "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 -- items:markForCodeGen: "L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Lock" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Lock" 
 -- "Lock" false 
 -- 
 -- OG:markSuper: "Lock" 
 -- Invocation:markForCodeGen: "Lock" 
 -- ObjectInvocation:markForCodeGen: "Lock"  ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: ...}" 
 -- Pattern:markForCodeGen: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res : ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;    ...}" 
 -- OG:Qalloc: "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;         res := 17;    ...}" q ... 37 
 -- ObjTmpStack:add: "Lock" : "dummy: var integer{   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;        ...}" 
 -- items:markForCodeGen: "dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpA ...}" 
 -- DataItem:markForCodeGen: "dummy" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- DataItem:markForCodeGen: "M" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Lock"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- OG:markForCodeGen: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;     ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %pu ...}" 
 -- OG:Qalloc: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %pu ...}" q ... 0 
 -- OG:Qalloc:A:  "Dimensions"  super:  ""  marked:  true "Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryU ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %public;       ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Dimensions" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 38 IS.newDescNo: 38 objSize: 0 1: 1 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value; ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 38 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Dimension 
 -- Pattern:Qalloc:B: Dimension 
 -- ModuleItem:Qalloc:  --Acceleration{} 
 -- ModuleItem:Qalloc:  --AmountOfSubstance{} 
 -- ModuleItem:Qalloc:  --AngularAcceleration{} 
 -- ModuleItem:Qalloc:  --Area{} 
 -- Qalloc:module: Area 
 -- Module:alloc:off: 2 Area: obj Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --Currency{} 
 -- ModuleItem:Qalloc:  --Density{} 
 -- ModuleItem:Qalloc:  --ElectricCurrent{} 
 -- ModuleItem:Qalloc:  --ElectricFrequency{} 
 -- ModuleItem:Qalloc:  --ElectricPower{} 
 -- ModuleItem:Qalloc:  --ElectricVoltage{} 
 -- ModuleItem:Qalloc:  --Energy{} 
 -- ModuleItem:Qalloc:  --Force{} 
 -- ModuleItem:Qalloc:  --Length{} 
 -- Qalloc:module: Length 
 -- Module:alloc:off: 3 Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisU ...} 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --LuminousIntensity{} 
 -- ModuleItem:Qalloc:  --MagneticFluxDensity{} 
 -- ModuleItem:Qalloc:  --Mass{} 
 -- ModuleItem:Qalloc:  --MassFlowRate{} 
 -- ModuleItem:Qalloc:  --MeterPowerN{} 
 -- ModuleItem:Qalloc:  --RadioNuclide{} 
 -- ModuleItem:Qalloc:  --Temperature{} 
 -- Qalloc:module: Temperature 
 -- Module:alloc:off: 4 Temperature: obj Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;  ...} 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --ThermodynamicTemperature{} 
 -- ModuleItem:Qalloc:  --Time{} 
 -- Qalloc:module: Time 
 -- Module:alloc:off: 5 Time: obj Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      ...} 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --Velocity{} 
 -- Qalloc:module: Velocity 
 -- Module:alloc:off: 6 Velocity: obj Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;       ...} 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --Volume{} 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 38 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;  ...}" 
 -- IS.newDescNo: 38 IS.objSize: 6 "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  38 "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %un ...}" 
 -- ObjTmpStack:add: "Dimensions" : "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %uni ...}" 
 -- items:markForCodeGen: "%domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      ma ...}" 
 -- markItem: "%domain_boundary" Property 
 -- markItem: "%public" Property 
 -- OG:markForCodeGen: "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Public;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Dimension" 
 -- "Dimension" false 
 -- 
 -- OG:markSuper: "Dimension" 
 -- Invocation:markForCodeGen: "Dimension" 
 -- ObjectInvocation:markForCodeGen: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;     ...}" 
 -- Pattern:markForCodeGen: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;     ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%dimension "-top-"{   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:< Unit;   ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%dimension "-top-"{   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:< Unit;      argU ...}" 
 -- OG:Qalloc: "%dimension "-top-"{   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:< Unit;      argU ...}" q ... 0 
 -- OG:Qalloc:A:  "Dimension"  super:  ""  marked:  true "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;   ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%dimension "-top-"{   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:< Unit;      argUnit:< Unit; ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Dimension" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 39 IS.newDescNo: 39 objSize: 0 1: 1 "%dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Floa ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 39 "%dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;    ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- (OG.super.desc).newDescNo = 0 
 -- OG:Qalloc: "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;      out R: ...}" q ... 0 
 -- OG:Qalloc:A:  "Unit"  super:  "Value"  marked:  false "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ...}" s ... V ... 
 -- Invocation:Qalloc: "Value" 
 -- ObjectInvocation:Qalloc: "Value" 
 -- name: "Value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;      out R: var thisUn ...}" 
 -- super:  "Value" 
 -- E:  "Value" 
 -- OG:Qalloc:B: "Unit" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 40 IS.newDescNo: 40 objSize: 0 1: 1 "%unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 40 "%unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUnit;   out R: var  ...}" 
 -- Items:Qalloc:super: "Value" size: 0 "Unit" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "magnitude" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$41 
 -- Pattern:Qalloc:B: thisUnit$41 
 -- Pattern:Qalloc: argUnit 
 -- Pattern:Qalloc:B: argUnit 
 -- Pattern:Qalloc: argUnit$42 
 -- Pattern:Qalloc:B: argUnit$42 
 -- Pattern:Qalloc: resUnit 
 -- Pattern:Qalloc:B: resUnit 
 -- Pattern:Qalloc: resUnit$43 
 -- Pattern:Qalloc:B: resUnit$43 
 -- Pattern:Qalloc: +? 
 -- Pattern:Qalloc:B: +? 
 -- Pattern:Qalloc: -? 
 -- Pattern:Qalloc:B: -? 
 -- Pattern:Qalloc: *? 
 -- Pattern:Qalloc:B: *? 
 -- Pattern:Qalloc: /? 
 -- Pattern:Qalloc:B: /? 
 -- Pattern:Qalloc: ^? 
 -- Pattern:Qalloc:B: ^? 
 -- Pattern:Qalloc: *** 
 -- Pattern:Qalloc:B: *** 
 -- Pattern:Qalloc: =+ 
 -- Pattern:Qalloc:B: =+ 
 -- Pattern:Qalloc: min 
 -- Pattern:Qalloc:B: min 
 -- Pattern:Qalloc: max 
 -- Pattern:Qalloc:B: max 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 40 "%unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUnit;   out R:  ...}" 
 -- IS.newDescNo: 40 IS.objSize: 2 "%unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUnit;   out R: var thisUnit ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  40 "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var ...}" 
 -- Pattern:qalloc:super:descNo: 40 PrimaryUnit:< Unit 
 -- Pattern:Qalloc: PrimaryUnit$44 
 -- Pattern:Qalloc:B: PrimaryUnit$44 
 -- Pattern:Qalloc: Unit 
 -- Pattern:Qalloc:B: Unit 
 -- Pattern:Qalloc: symbol 
 -- Pattern:Qalloc:B: symbol 
 -- Pattern:Qalloc: MultArgL 
 -- Pattern:Qalloc:B: MultArgL 
 -- Pattern:Qalloc: MultArgL$45 
 -- Pattern:Qalloc:B: MultArgL$45 
 -- Pattern:Qalloc: MultArgR 
 -- Pattern:Qalloc:B: MultArgR 
 -- Pattern:Qalloc: MultArgR$46 
 -- Pattern:Qalloc:B: MultArgR$46 
 -- Pattern:Qalloc: MultRes 
 -- Pattern:Qalloc:B: MultRes 
 -- Pattern:Qalloc: MultRes$47 
 -- Pattern:Qalloc:B: MultRes$47 
 -- Pattern:Qalloc: gMult 
 -- Pattern:Qalloc:B: gMult 
 -- OG:Qalloc: "inner(Dimension)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(Dimension)"  marked:  false "%dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var F ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(Dimension)" 
 -- ObjectInvocation:Qalloc: "inner(Dimension)" 
 -- name: "inner" 
 -- Arguments "inner(Dimension)" 
 -- OG:Qalloc: "Dimension" qDescno:  0 
 -- OG:Qalloc:A:  "Dimension"  super:  "Dimension"  marked:  false "inner(Dimension)" super:  Dimension 
 -- Invocation:Qalloc: "Dimension" 
 -- ObjectInvocation:Qalloc: "Dimension" 
 -- name: "Dimension" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 %dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   th ...} 
 -- OG:super:  "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:<  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Dimension" 
 -- super:  "Dimension" 
 -- E:  "Dimension" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Dimension" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Dimension)" 
 -- super:  "inner(Dimension)" 
 -- E:  "inner(Dimension)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Dimension)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 39 "%dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit ...}" 
 -- IS.newDescNo: 39 IS.objSize: 1 "%dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit: ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  39 "%dimension "-top-"{   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      this ...}" 
 -- ObjTmpStack:add: "Dimension" : "%dimension "-top-"{   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUn ...}" 
 -- items:markForCodeGen: "%dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   ...}" 
 -- markItem: "%dimension "-top-"" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:< Unit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- Pattern:markForCodeGen: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var th ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;     ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;      out R: ...}" 
 -- OG:Qalloc: "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;      out R: ...}" q ... 40 
 -- ObjTmpStack:add: "Unit" : "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUn ...}" 
 -- items:markForCodeGen: "%unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUnit;   out R: var thisUnit;   R.mag ...}" 
 -- markItem: "%unit "U", 1" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "magnitude" :descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "Float" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Float" 
 -- "Float" true 
 -- 
 -- OG:markSuper: "Float" 
 -- Invocation:markForCodeGen: "Float" 
 -- ObjectInvocation:markForCodeGen: "Float"  ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var flo ...}" 
 -- Pattern:markForCodeGen: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var flo ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ; ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;      %b ...}" 
 -- OG:Qalloc: "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;      %b ...}" q ... 0 
 -- OG:Qalloc:A:  "float"  super:  "Value"  marked:  true "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V:  ...}" s ... V ... 
 -- Invocation:Qalloc: "Value" 
 -- ObjectInvocation:Qalloc: "Value" 
 -- name: "Value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;      %basic 110;   ...}" 
 -- super:  "Value" 
 -- E:  "Value" 
 -- OG:Qalloc:B: "float" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 48 IS.newDescNo: 48 objSize: 0 1: 1 "%globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var f ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 48 "%globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  : ;   %basic 110 ...}" 
 -- Items:Qalloc:super: "Value" size: 0 "float" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: + 
 -- Pattern:Qalloc: - 
 -- Pattern:Qalloc: * 
 -- Pattern:Qalloc: / 
 -- Pattern:Qalloc: = 
 -- Pattern:Qalloc: < 
 -- Pattern:Qalloc: <= 
 -- Pattern:Qalloc: > 
 -- Pattern:Qalloc: >= 
 -- Pattern:Qalloc: <> 
 -- Pattern:Qalloc: ^ 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 48 "%globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  : ;   %basic ...}" 
 -- IS.newDescNo: 48 IS.objSize: 2 "%globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  : ;   %basic 110;   in V ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  48 "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var f ...}" 
 -- ObjTmpStack:add: "float" : "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;  ...}" 
 -- items:markForCodeGen: "%globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  : ;   %basic 110;   in V: var flo ...}" 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 9" Property 
 -- DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "Float" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Float" 
 -- "Float" true 
 -- 
 -- OG:markSuper: "Float" 
 -- Invocation:markForCodeGen: "Float" 
 -- ObjectInvocation:markForCodeGen: "Float"  ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var flo ...}" 
 -- Pattern:markForCodeGen: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var flo ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Float"  IS.isEmpty:  true 
 -- markItem: "%public" Property 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Float"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "thisUnit:< Unit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- Pattern:markForCodeGen: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var th ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Unit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "argUnit:< Unit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Unit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "resUnit:< Unit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Unit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out base: var PrimaryUnit{   inner(toPrimary)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out base: var PrimaryUnit{   inner(toPrimary)}" 
 -- OG:Qalloc: "out base: var PrimaryUnit{   inner(toPrimary)}" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  ""  marked:  true "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out base: var PrimaryUnit{   inner(toPrimary)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "toPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 49 IS.newDescNo: 49 objSize: 0 1: 1 "out base: var PrimaryUnit{inner(toPrimary)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 49 "out base: var PrimaryUnit{inner(toPrimary)}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "base" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "PrimaryUnit:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "PrimaryUnit:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "PrimaryUnit:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(toPrimary)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(toPrimary)"  marked:  false "out base: var PrimaryUnit{inner(toPrimary)}" super:  inner(toPrimary) 
 -- Invocation:Qalloc: "inner(toPrimary)" 
 -- ObjectInvocation:Qalloc: "inner(toPrimary)" 
 -- name: "inner" 
 -- Arguments "inner(toPrimary)" 
 -- OG:Qalloc: "toPrimary" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  "toPrimary"  marked:  false "inner(toPrimary)" super:  toPrimary 
 -- Invocation:Qalloc: "toPrimary" 
 -- ObjectInvocation:Qalloc: "toPrimary" 
 -- name: "toPrimary" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 out base: var PrimaryUnit{inner(toPrimary)} 
 -- OG:super:  "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "toPrimary" 
 -- super:  "toPrimary" 
 -- E:  "toPrimary" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "toPrimary" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(toPrimary)" 
 -- super:  "inner(toPrimary)" 
 -- E:  "inner(toPrimary)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(toPrimary)" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 49 "out base: var PrimaryUnit{inner(toPrimary)}" 
 -- IS.newDescNo: 49 IS.objSize: 5 "out base: var PrimaryUnit{inner(toPrimary)}" 
 -- OG:Qalloc:end: IS.newDescNo:  49 "out base: var PrimaryUnit{   inner(toPrimary)}" 
 -- ObjTmpStack:add: "toPrimary" : "out base: var PrimaryUnit{   inner(toPrimary)}" 
 -- items:markForCodeGen: "out base: var PrimaryUnit{inner(toPrimary)}" 
 -- DataItem:markForCodeGen: "base" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "PrimaryUnit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "PrimaryUnit" 
 -- "PrimaryUnit" false 
 -- 
 -- OG:markSuper: "PrimaryUnit" 
 -- Invocation:markForCodeGen: "PrimaryUnit" 
 -- ObjectInvocation:markForCodeGen: "PrimaryUnit"  ATd: "PrimaryUnit:< Unit" 
 -- Pattern:markForCodeGen: "PrimaryUnit:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "PrimaryUnit"  IS.isEmpty:  true 
 -- markItem: "inner(toPrimary)" ObjectGenerator 
 -- Pattern:markForCodeGen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in base: var PrimaryUnit{   inner(fromPrimary)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in base: var PrimaryUnit{   inner(fromPrimary)}" 
 -- OG:Qalloc: "in base: var PrimaryUnit{   inner(fromPrimary)}" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  ""  marked:  true "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in base: var PrimaryUnit{   inner(fromPrimary)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fromPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 50 IS.newDescNo: 50 objSize: 0 1: 1 "in base: var PrimaryUnit{inner(fromPrimary)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 50 "in base: var PrimaryUnit{inner(fromPrimary)}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "base" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "PrimaryUnit:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "PrimaryUnit:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "PrimaryUnit:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(fromPrimary)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(fromPrimary)"  marked:  false "in base: var PrimaryUnit{inner(fromPrimary)}" super:  inner(fromPrimary) 
 -- Invocation:Qalloc: "inner(fromPrimary)" 
 -- ObjectInvocation:Qalloc: "inner(fromPrimary)" 
 -- name: "inner" 
 -- Arguments "inner(fromPrimary)" 
 -- OG:Qalloc: "fromPrimary" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  "fromPrimary"  marked:  false "inner(fromPrimary)" super:  fromPrimary 
 -- Invocation:Qalloc: "fromPrimary" 
 -- ObjectInvocation:Qalloc: "fromPrimary" 
 -- name: "fromPrimary" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 5 in base: var PrimaryUnit{inner(fromPrimary)} 
 -- OG:super:  "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "fromPrimary" 
 -- super:  "fromPrimary" 
 -- E:  "fromPrimary" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "fromPrimary" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(fromPrimary)" 
 -- super:  "inner(fromPrimary)" 
 -- E:  "inner(fromPrimary)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(fromPrimary)" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 50 "in base: var PrimaryUnit{inner(fromPrimary)}" 
 -- IS.newDescNo: 50 IS.objSize: 5 "in base: var PrimaryUnit{inner(fromPrimary)}" 
 -- OG:Qalloc:end: IS.newDescNo:  50 "in base: var PrimaryUnit{   inner(fromPrimary)}" 
 -- ObjTmpStack:add: "fromPrimary" : "in base: var PrimaryUnit{   inner(fromPrimary)}" 
 -- items:markForCodeGen: "in base: var PrimaryUnit{inner(fromPrimary)}" 
 -- DataItem:markForCodeGen: "base" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "PrimaryUnit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "PrimaryUnit" 
 -- "PrimaryUnit" false 
 -- 
 -- OG:markSuper: "PrimaryUnit" 
 -- Invocation:markForCodeGen: "PrimaryUnit" 
 -- ObjectInvocation:markForCodeGen: "PrimaryUnit"  ATd: "PrimaryUnit:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "PrimaryUnit"  IS.isEmpty:  true 
 -- markItem: "inner(fromPrimary)" ObjectGenerator 
 -- Pattern:markForCodeGen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""Unit:".print{   inner(print);   put(':');   putFloat(magnitude)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""Unit:".print{   inner(print);   put(':');   putFloat(magnitude)}" 
 -- OG:Qalloc: ""Unit:".print{   inner(print);   put(':');   putFloat(magnitude)}" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  true "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Unit:".print{   inner(print);   put(':');   putFloat(magnitude)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 51 IS.newDescNo: 51 objSize: 0 1: 1 ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 51 ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Unit:".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Unit:".print"  marked:  false ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" super:  "Unit:".print 
 -- Invocation:Qalloc: ""Unit:".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:Qalloc:SuperAlloc: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 52 IS.newDescNo: 52 objSize: 0 1: 1 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 52 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: gogo 
 -- Pattern:Qalloc:B: gogo 
 -- OG:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(length):repeat{   put(get[inx]);}"  marked:  false "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]); ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- ObjectInvocation:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(length):repeat{   put(get[inx]);}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length"  marked:  false "for(1):to(length):repeat{   put(get[inx]);}" super:  length 
 -- Invocation:Qalloc: "length" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length" 
 -- super:  "length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length" 
 -- OG:Qalloc: "put(get[inx])" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(length):repeat{   put(get[inx]);}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(get[inx])" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 53 IS.newDescNo: 53 objSize: 0 1: 1 "put(get[inx])" 
 -- Items:Qalloc:objSize: 0  newDescNo: 53 "put(get[inx])" 
 -- Items:Qalloc:super: "" size: 1 "repeat$53" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- OG:Qalloc: "put(get[inx])" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put(get[inx])"  marked:  false "put(get[inx])" super:  put(get[inx]) 
 -- Invocation:Qalloc: "put(get[inx])" 
 -- ObjectInvocation:Qalloc: "put(get[inx])" 
 -- name: "put" 
 -- Arguments "put(get[inx])" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "put(get[inx])" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{%basic 2;in ch: val char} 
 -- OG:Qalloc:SuperAlloc: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "-- to be eliminated"  marked:  false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" super:  -- to be eliminated 
 -- Invocation:Qalloc: "-- to be eliminated" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- super:  "-- to be eliminated" 
 -- E:  "" 
 -- OG:Qalloc:B: "put" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 54 IS.newDescNo: 54 objSize: 0 1: 1 "%globals{%basic 2;in ch: val char}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 54 "%globals{%basic 2;in ch: val char}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "ch" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 54 "%globals{%basic 2;in ch: val char}" 
 -- IS.newDescNo: 54 IS.objSize: 1 "%globals{%basic 2;in ch: val char}" 
 -- OG:Qalloc:end: IS.newDescNo:  54 "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(get[inx])" 
 -- super:  "put(get[inx])" 
 -- E:  "put(get[inx])" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(get[inx])" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 53 "put(get[inx])" 
 -- IS.newDescNo: 53 IS.objSize: 1 "put(get[inx])" 
 -- OG:Qalloc:end: IS.newDescNo:  53 "put(get[inx])" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(length):repeat{   put(get[inx]);}" 
 -- super:  "for(1):to(length):repeat{   put(get[inx]);}" 
 -- E:  "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 55 IS.newDescNo: 55 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 55 "" 
 -- Items:Qalloc:super: "for(1):to(length):repeat{   put(get[inx]);}" size: 3 "for:to:repeat$55" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 55 "" 
 -- IS.newDescNo: 55 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  55 "for(1):to(length):repeat{   put(get[inx]);}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 52 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- IS.newDescNo: 52 IS.objSize: 1 "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- OG:Qalloc:end: IS.newDescNo:  52 "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Unit:".print" 
 -- super:  ""Unit:".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Unit:".print" 
 -- OG:Qalloc: "inner(print)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(print)"  marked:  false ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" super:  inner(print) 
 -- Invocation:Qalloc: "inner(print)" 
 -- ObjectInvocation:Qalloc: "inner(print)" 
 -- name: "inner" 
 -- Arguments "inner(print)" 
 -- OG:Qalloc: "print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "print"  marked:  false "inner(print)" super:  print 
 -- Invocation:Qalloc: "print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:super:  "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "print" 
 -- super:  "print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "print" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(print)" 
 -- super:  "inner(print)" 
 -- E:  "inner(print)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(print)" 
 -- OG:Qalloc: "put(':')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put(':')"  marked:  false ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" super:  put(':') 
 -- Invocation:Qalloc: "put(':')" 
 -- ObjectInvocation:Qalloc: "put(':')" 
 -- name: "put" 
 -- Arguments "put(':')" 
 -- OG:Qalloc: "':'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "':'"  marked:  false "put(':')" super:  ':' 
 -- Invocation:Qalloc: "':'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "':'" 
 -- super:  "':'" 
 -- E:  "':'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "':'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(':')" 
 -- super:  "put(':')" 
 -- E:  "put(':')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(':')" 
 -- OG:Qalloc: "putFloat(magnitude)" qDescno:  0 
 -- OG:Qalloc:A:  "putFloat"  super:  "putFloat(magnitude)"  marked:  false ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" super:  putFloat(magnitude) 
 -- Invocation:Qalloc: "putFloat(magnitude)" 
 -- ObjectInvocation:Qalloc: "putFloat(magnitude)" 
 -- name: "putFloat" 
 -- Arguments "putFloat(magnitude)" 
 -- OG:Qalloc: "magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "magnitude"  marked:  false "putFloat(magnitude)" super:  magnitude 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude" 
 -- super:  "magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 142{in X: var Float;out V: var integer} 
 -- OG:Qalloc:SuperAlloc: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" 
 -- OG:Qalloc: "%basic 142{   in X: var Float;   out V: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "putFloat"  super:  ""  marked:  false "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 142{   in X: var Float;   out V: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "putFloat" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 56 IS.newDescNo: 56 objSize: 0 1: 1 "%basic 142{in X: var Float;out V: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 56 "%basic 142{in X: var Float;out V: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "X" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 56 "%basic 142{in X: var Float;out V: var integer}" 
 -- IS.newDescNo: 56 IS.objSize: 4 "%basic 142{in X: var Float;out V: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  56 "%basic 142{   in X: var Float;   out V: var integer}" 
 -- OG:super:  "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putFloat(magnitude)" 
 -- super:  "putFloat(magnitude)" 
 -- E:  "putFloat(magnitude)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "putFloat(magnitude)" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 51 ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" 
 -- IS.newDescNo: 51 IS.objSize: 3 ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" 
 -- OG:Qalloc:end: IS.newDescNo:  51 ""Unit:".print{   inner(print);   put(':');   putFloat(magnitude)}" 
 -- ObjTmpStack:add: "print" : ""Unit:".print{   inner(print);   put(':');   putFloat(magnitude)}" 
 -- items:markForCodeGen: ""Unit:".print{inner(print);put(':');putFloat(magnitude)}" 
 -- markItem: ""Unit:".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Unit:".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Unit:".print" 
 -- ""Unit:"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Unit:".print" 
 -- Invocation:markForCodeGen: ""Unit:".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Pattern:markForCodeGen: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc: "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" qDescno:  52 
 -- ObjTmpStack:add: "print" : "gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- items:markForCodeGen: "gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);}" 
 -- markItem: "for(1):to(length):repeat{   put(get[inx]);}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(length):repeat{   put(get[inx]);}" 
 -- "for(1):to(length):repeat{   put(get[inx]);}" false 
 -- 
 -- OG:markSuper: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- Invocation:markForCodeGen: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(length):repeat{   put(get[inx]);}"  ATd: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibi ...}" 
 -- Pattern:markForCodeGen: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   in ...}" 
 -- items:markForCodeGen: "%$B "("{first: var integer;%$S "):to(";last: var integer;%$S "):repeat{";repeat:< object;%$E "}"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "first" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$S "):to("" Property 
 -- DataItem:markForCodeGen: "last" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "%$S "):repeat{"" Property 
 -- Pattern:markForCodeGen: "repeat:< object" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "object" 
 -- "object" true 
 -- 
 -- not ObjDesc:  "object"  IS.isEmpty:  true 
 -- markItem: "%$E "}"" Property 
 -- OG:markForCodeGen: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;          ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := i ...}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := first;   _doIt: do ;      if (inx <= last) :then ;         repeat;         inx := i ...}" q ... 28 
 -- ObjTmpStack:add: "for(first: var integer):to(last: var integer):repeat{repeat:< object}" : "%OSDvisibility skipInternal{   %globals inSub;   inx: var integer;   inx := fir ...}" 
 -- items:markForCodeGen: "%OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      inx := inx + 1;    ...}" 
 -- markItem: "%OSDvisibility skipInternal" Property 
 -- markItem: "%globals inSub" Property 
 -- DataItem:markForCodeGen: "inx" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "inx := first" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "first" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "first" 
 -- "first" true 
 -- 
 -- OG:markForCodeGen: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- OG:Qalloc: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" qDescno:  0 
 -- OG:Qalloc:A:  "_doIt"  super:  ""  marked:  true "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "_doIt" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 57 IS.newDescNo: 57 objSize: 0 1: 1 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 57 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}"  marked:  false "if (inx <= last) :then {  ...}" s ... i ... 
 -- Invocation:Qalloc: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:Qalloc: "(inx <= last)" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  "(inx <= last)"  marked:  false "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" super:  (inx <= l ... 
 -- Invocation:Qalloc: "(inx <= last)" 
 -- Invocation:Qalloc: "inx <= last" 
 -- BinaryExp:Qalloc: "inx <= last" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<= last" 
 -- name: "<=" 
 -- Arguments "last" 
 -- OG:Qalloc: "last" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "last"  marked:  false "last" super:  last 
 -- Invocation:Qalloc: "last" 
 -- ObjectInvocation:Qalloc: "last" 
 -- name: "last" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "last: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "last" 
 -- super:  "last" 
 -- E:  "last" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "last" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc: "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  ""  marked:  false "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 58 IS.newDescNo: 58 objSize: 0 1: 1 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 58 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 58 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- IS.newDescNo: 58 IS.objSize: 5 "%basic 52{in Veq: var this(Value);out Beq: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  58 "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:super:  "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(inx <= last)" 
 -- super:  "(inx <= last)" 
 -- E:  "(inx <= last)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(inx <= last)" 
 -- OG:Qalloc: "repeat{   inx := inx + 1;   restart(_doIt)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 59 IS.newDescNo: 59 objSize: 0 1: 1 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 59 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "repeat" qDescno:  0 
 -- OG:Qalloc:A:  "Object"  super:  "repeat"  marked:  false "repeat{inx := inx + 1;restart(_doIt)}" super:  repeat 
 -- Invocation:Qalloc: "repeat" 
 -- ObjectInvocation:Qalloc: "repeat" 
 -- name: "repeat" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:super:  "repeat:< object" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "repeat" 
 -- super:  "repeat" 
 -- E:  "repeat" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "repeat" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "inx + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "inx + 1"  marked:  false "inx := inx + 1" super:  inx + 1 
 -- Invocation:Qalloc: "inx + 1" 
 -- BinaryExp:Qalloc: "inx + 1" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 61{in V: var integer;out R: var integer} 
 -- OG:Qalloc:SuperAlloc: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc: "%basic 61{   in V: var integer;   out R: var integer}" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  ""  marked:  false "+  : {   %basic 61;   in V: var integer;   out R: var integer}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 61{   in V: var integer;   out R: var integer}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "+" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 60 IS.newDescNo: 60 objSize: 0 1: 1 "%basic 61{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 60 "%basic 61{in V: var integer;out R: var integer}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 60 "%basic 61{in V: var integer;out R: var integer}" 
 -- IS.newDescNo: 60 IS.objSize: 5 "%basic 61{in V: var integer;out R: var integer}" 
 -- OG:Qalloc:end: IS.newDescNo:  60 "%basic 61{   in V: var integer;   out R: var integer}" 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx + 1" 
 -- super:  "inx + 1" 
 -- E:  "inx + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx + 1" 
 -- OG:Qalloc: "restart(_doIt)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(_doIt)"  marked:  false "repeat{inx := inx + 1;restart(_doIt)}" super:  restart(_doIt) 
 -- Invocation:Qalloc: "restart(_doIt)" 
 -- ObjectInvocation:Qalloc: "restart(_doIt)" 
 -- name: "restart" 
 -- Arguments "restart(_doIt)" 
 -- OG:Qalloc: "_doIt" qDescno:  0 
 -- OG:Qalloc:A:  "_doIt"  super:  "_doIt"  marked:  false "restart(_doIt)" super:  _doIt 
 -- Invocation:Qalloc: "_doIt" 
 -- ObjectInvocation:Qalloc: "_doIt" 
 -- name: "_doIt" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  57 1 if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx} 
 -- OG:super:  "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "_doIt" 
 -- super:  "_doIt" 
 -- E:  "_doIt" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "_doIt" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 102 
 -- OG:Qalloc:SuperAlloc: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc: "-- odd parameter type!{   %basic 102}" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "-- odd parameter type!"  marked:  false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" super:  -- odd parameter type! 
 -- Invocation:Qalloc: "-- odd parameter type!" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- odd parameter type!{   %basic 102}" 
 -- super:  "-- odd parameter type!" 
 -- E:  "" 
 -- OG:Qalloc:B: "restart" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 61 IS.newDescNo: 61 objSize: 0 1: 1 "%basic 102" 
 -- Items:Qalloc:objSize: 0  newDescNo: 61 "%basic 102" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var integer;%$E ")"}" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 61 "%basic 102" 
 -- IS.newDescNo: 61 IS.objSize: 2 "%basic 102" 
 -- OG:Qalloc:end: IS.newDescNo:  61 "-- odd parameter type!{   %basic 102}" 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(_doIt)" 
 -- super:  "restart(_doIt)" 
 -- E:  "restart(_doIt)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(_doIt)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 59 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- IS.newDescNo: 59 IS.objSize: 1 "repeat{inx := inx + 1;restart(_doIt)}" 
 -- OG:Qalloc:end: IS.newDescNo:  59 "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- OG:Qalloc: "inx := inx" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx := inx" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 62 IS.newDescNo: 62 objSize: 0 1: 1 "inx := inx" 
 -- Items:Qalloc:objSize: 0  newDescNo: 62 "inx := inx" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "inx := inx" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 62 "inx := inx" 
 -- IS.newDescNo: 62 IS.objSize: 1 "inx := inx" 
 -- OG:Qalloc:end: IS.newDescNo:  62 "inx := inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- super:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- E:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 57 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- IS.newDescNo: 57 IS.objSize: 1 "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:Qalloc:end: IS.newDescNo:  57 "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- ObjTmpStack:add: "_doIt" : "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- items:markForCodeGen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- markItem: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" ObjectGenerator 
 -- OG:markForCodeGen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" true 
 -- 
 -- OG:markSuper: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- Invocation:markForCodeGen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:markForCodeGen: "(inx <= last)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(inx <= last)" 
 -- "(inx <= last)" true 
 -- 
 -- OG:markSuper: "(inx <= last)" 
 -- Invocation:markForCodeGen: "(inx <= last)" 
 -- Invocation:markForCodeGen: "inx <= last" 
 -- BinaryExp:markForCodeGen: "inx <= last" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<= last"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:args:markForCodgen: "last" 
 -- OG:markForCodeGen: "last" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "last" 
 -- "last" true 
 -- 
 -- not ObjDesc:  "(inx <= last)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- OG:Qalloc: "repeat{   inx := inx + 1;   restart(_doIt)}" qDescno:  59 
 -- ObjTmpStack:add: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 -- items:markForCodeGen: "repeat{inx := inx + 1;restart(_doIt)}" 
 -- markItem: "repeat" ObjectGenerator 
 -- OG:markForCodeGen: "repeat" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "repeat" 
 -- "repeat" false 
 -- 
 -- OG:markSuper: "repeat" 
 -- Invocation:markForCodeGen: "repeat" 
 -- ObjectInvocation:markForCodeGen: "repeat"  ATd: "repeat:< object" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "repeat"  IS.isEmpty:  true 
 -- markItem: "inx := inx + 1" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "inx + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx + 1" 
 -- "inx + 1" true 
 -- 
 -- OG:markSuper: "inx + 1" 
 -- Invocation:markForCodeGen: "inx + 1" 
 -- BinaryExp:markForCodeGen: "inx + 1" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- Pattern:markForCodeGen: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "inx + 1"  IS.isEmpty:  true 
 -- markItem: "restart(_doIt)" ObjectGenerator 
 -- OG:markForCodeGen: "inx := inx" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inx := inx" 
 -- OG:Qalloc: "inx := inx" qDescno:  62 
 -- ObjTmpStack:add: "inx := inx" 
 -- items:markForCodeGen: "inx := inx" 
 -- markItem: "inx := inx" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- OG:markForCodeGen: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- OG:Qalloc: "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" qDescno:  20 
 -- ObjTmpStack:add: "if(cond: var boolean):then{thenPart:< object}" : "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- items:markForCodeGen: "%OSDvisibility skipInternal{%basic 100;%globals inSub}" 
 -- markItem: "%OSDvisibility skipInternal" Property 
 -- markItem: "%basic 100" Property 
 -- markItem: "%globals inSub" Property 
 -- not ObjDesc:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length" 
 -- "length" false 
 -- 
 -- OG:markSuper: "length" 
 -- Invocation:markForCodeGen: "length" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "put(get[inx])" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "put(get[inx])" 
 -- OG:Qalloc: "put(get[inx])" qDescno:  53 
 -- ObjTmpStack:add: "put(get[inx])" 
 -- items:markForCodeGen: "put(get[inx])" 
 -- markItem: "put(get[inx])" ObjectGenerator 
 -- OG:markForCodeGen: "put(get[inx])" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put(get[inx])" 
 -- "put(get[inx])" true 
 -- 
 -- OG:markSuper: "put(get[inx])" 
 -- Invocation:markForCodeGen: "put(get[inx])" 
 -- ObjectInvocation:markForCodeGen: "put(get[inx])"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Pattern:markForCodeGen: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "-- to be eliminated" 
 -- "" false 
 -- 
 -- OG:markIS: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc: "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" qDescno:  54 
 -- ObjTmpStack:add: "put" : "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- items:markForCodeGen: "%globals{%basic 2;in ch: val char}" 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 2" Property 
 -- DataItem:markForCodeGen: "ch" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "put(get[inx])" 
 -- arg:   "get[inx]" 
 -- not ObjDesc:  "put(get[inx])"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "length" 
 -- arg:   "put(get[inx])" 
 -- OG:markIS: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- OG:Qalloc: "for(1):to(length):repeat{   put(get[inx]);}" qDescno:  55 
 -- ObjTmpStack:add: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Unit:".print"  IS.isEmpty:  true 
 -- markItem: "inner(print)" ObjectGenerator 
 -- markItem: "put(':')" ObjectGenerator 
 -- OG:markForCodeGen: "put(':')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put(':')" 
 -- "put(':')" true 
 -- 
 -- OG:markSuper: "put(':')" 
 -- Invocation:markForCodeGen: "put(':')" 
 -- ObjectInvocation:markForCodeGen: "put(':')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put(':')" 
 -- OG:markForCodeGen: "':'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "':'" 
 -- "':'" true 
 -- 
 -- OG:markSuper: "':'" 
 -- Invocation:markForCodeGen: "':'" 
 -- not ObjDesc:  "':'"  IS.isEmpty:  true 
 -- arg:   "':'" 
 -- not ObjDesc:  "put(':')"  IS.isEmpty:  true 
 -- markItem: "putFloat(magnitude)" ObjectGenerator 
 -- OG:markForCodeGen: "putFloat(magnitude)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "putFloat(magnitude)" 
 -- "putFloat(magnitude)" true 
 -- 
 -- OG:markSuper: "putFloat(magnitude)" 
 -- Invocation:markForCodeGen: "putFloat(magnitude)" 
 -- ObjectInvocation:markForCodeGen: "putFloat(magnitude)"  ATd: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" 
 -- Pattern:markForCodeGen: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%basic 142{   in X: var Float;   out V: var integer}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%basic 142{   in X: var Float;   out V: var integer}" 
 -- OG:Qalloc: "%basic 142{   in X: var Float;   out V: var integer}" qDescno:  56 
 -- ObjTmpStack:add: "putFloat" : "%basic 142{   in X: var Float;   out V: var integer}" 
 -- items:markForCodeGen: "%basic 142{in X: var Float;out V: var integer}" 
 -- markItem: "%basic 142" Property 
 -- DataItem:markForCodeGen: "X" :descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "Float" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Float" 
 -- "Float" true 
 -- 
 -- OG:markSuper: "Float" 
 -- Invocation:markForCodeGen: "Float" 
 -- ObjectInvocation:markForCodeGen: "Float"  ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var flo ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Float"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "putFloat(magnitude)" 
 -- OG:markForCodeGen: "magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "magnitude" 
 -- "magnitude" true 
 -- 
 -- arg:   "magnitude" 
 -- not ObjDesc:  "putFloat(magnitude)"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Unit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   out T: var StringLib.String;   inner(Symbol)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   out T: var StringLib.String;   inner(Symbol)}" 
 -- OG:Qalloc: "%globals{   out T: var StringLib.String;   inner(Symbol)}" qDescno:  0 
 -- OG:Qalloc:A:  "symbol"  super:  ""  marked:  true "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   out T: var StringLib.String;   inner(Symbol)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "symbol" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 63 IS.newDescNo: 63 objSize: 0 1: 1 "%globals{out T: var StringLib.String;inner(Symbol)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 63 "%globals{out T: var StringLib.String;inner(Symbol)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "T" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out T: var StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(Symbol)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(Symbol)"  marked:  false "%globals{out T: var StringLib.String;inner(Symbol)}" super:  inner(Symbol) 
 -- Invocation:Qalloc: "inner(Symbol)" 
 -- ObjectInvocation:Qalloc: "inner(Symbol)" 
 -- name: "inner" 
 -- Arguments "inner(Symbol)" 
 -- OG:Qalloc: "Symbol" qDescno:  0 
 -- OG:Qalloc:A:  "symbol"  super:  "Symbol"  marked:  false "inner(Symbol)" super:  Symbol 
 -- Invocation:Qalloc: "Symbol" 
 -- ObjectInvocation:Qalloc: "Symbol" 
 -- name: "Symbol" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  63 2 %globals{out T: var StringLib.String;inner(Symbol)} 
 -- OG:super:  "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Symbol" 
 -- super:  "Symbol" 
 -- E:  "Symbol" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Symbol" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(Symbol)" 
 -- super:  "inner(Symbol)" 
 -- E:  "inner(Symbol)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(Symbol)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 63 "%globals{out T: var StringLib.String;inner(Symbol)}" 
 -- IS.newDescNo: 63 IS.objSize: 2 "%globals{out T: var StringLib.String;inner(Symbol)}" 
 -- OG:Qalloc:end: IS.newDescNo:  63 "%globals{   out T: var StringLib.String;   inner(Symbol)}" 
 -- ObjTmpStack:add: "symbol" : "%globals{   out T: var StringLib.String;   inner(Symbol)}" 
 -- items:markForCodeGen: "%globals{out T: var StringLib.String;inner(Symbol)}" 
 -- markItem: "%globals" Property 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "StringLib.String" 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- not ObjDesc:  "StringLib.String"  IS.isEmpty:  true 
 -- markItem: "inner(Symbol)" ObjectGenerator 
 -- Pattern:markForCodeGen: "MultArgL:< Unit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Unit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "MultArgR:< Unit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Unit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "MultRes:< Unit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Unit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in L: var MultArgL{   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in L: var MultArgL{   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" 
 -- OG:Qalloc: "in L: var MultArgL{   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" qDescno:  0 
 -- OG:Qalloc:A:  "gMult"  super:  ""  marked:  true "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in L: var MultArgL{   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "gMult" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 64 IS.newDescNo: 64 objSize: 0 1: 1 "in L: var MultArgL{in R: var MultArgR;out U: var MultRes;U.magnitude := L.magnitude * R.magnitude}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 64 "in L: var MultArgL{in R: var MultArgR;out U: var MultRes;U.magnitude := L.magnitude * R.magnitude}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "MultArgL:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "MultArgL:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "MultArgL:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "MultArgR:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "MultArgR:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "MultArgR:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "U" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "MultRes:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "MultRes:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "MultRes:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- Invocation:Qalloc: "U.magnitude" 
 -- ObjectInvocation:Qalloc: "U" 
 -- name: "U" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "L.magnitude * R.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "L.magnitude * R.magnitude"  marked:  false "U.magnitude := L.magnitude * R.magnitude" super:  L.magnitude * R.magnitude 
 -- Invocation:Qalloc: "L.magnitude * R.magnitude" 
 -- BinaryExp:Qalloc: "L.magnitude * R.magnitude" 
 -- Invocation:Qalloc: "L.magnitude" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* R.magnitude" 
 -- name: "*" 
 -- Arguments "R.magnitude" 
 -- OG:Qalloc: "R.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "R.magnitude"  marked:  false "R.magnitude" super:  R.magnitude 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.magnitude" 
 -- super:  "R.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "R.magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 112{in V: var float;out R: var float} 
 -- OG:Qalloc:SuperAlloc: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc: "%basic 112{   in V: var float;   out R: var float}" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  ""  marked:  false "*  : {   %basic 112;   in V: var float;   out R: var float}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 112{   in V: var float;   out R: var float}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "*" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 65 IS.newDescNo: 65 objSize: 0 1: 1 "%basic 112{in V: var float;out R: var float}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 65 "%basic 112{in V: var float;out R: var float}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 65 "%basic 112{in V: var float;out R: var float}" 
 -- IS.newDescNo: 65 IS.objSize: 7 "%basic 112{in V: var float;out R: var float}" 
 -- OG:Qalloc:end: IS.newDescNo:  65 "%basic 112{   in V: var float;   out R: var float}" 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.magnitude * R.magnitude" 
 -- super:  "L.magnitude * R.magnitude" 
 -- E:  "L.magnitude * R.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.magnitude * R.magnitude" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 64 "in L: var MultArgL{in R: var MultArgR;out U: var MultRes;U.magnitude := L.magnitude * R.magnitude}" 
 -- IS.newDescNo: 64 IS.objSize: 7 "in L: var MultArgL{in R: var MultArgR;out U: var MultRes;U.magnitude := L.magnitude * R.magnitude}" 
 -- OG:Qalloc:end: IS.newDescNo:  64 "in L: var MultArgL{   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" 
 -- ObjTmpStack:add: "gMult" : "in L: var MultArgL{   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude}" 
 -- items:markForCodeGen: "in L: var MultArgL{in R: var MultArgR;out U: var MultRes;U.magnitude := L.magnitude * R.magnitude}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MultArgL" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MultArgL" 
 -- "MultArgL" false 
 -- 
 -- OG:markSuper: "MultArgL" 
 -- Invocation:markForCodeGen: "MultArgL" 
 -- ObjectInvocation:markForCodeGen: "MultArgL"  ATd: "MultArgL:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MultArgL"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MultArgR" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MultArgR" 
 -- "MultArgR" false 
 -- 
 -- OG:markSuper: "MultArgR" 
 -- Invocation:markForCodeGen: "MultArgR" 
 -- ObjectInvocation:markForCodeGen: "MultArgR"  ATd: "MultArgR:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MultArgR"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "U" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MultRes" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MultRes" 
 -- "MultRes" false 
 -- 
 -- OG:markSuper: "MultRes" 
 -- Invocation:markForCodeGen: "MultRes" 
 -- ObjectInvocation:markForCodeGen: "MultRes"  ATd: "MultRes:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MultRes"  IS.isEmpty:  true 
 -- markItem: "U.magnitude := L.magnitude * R.magnitude" Assign 
 -- Invocation:markForCodeGen: "U.magnitude" 
 -- ObjectInvocation:markForCodeGen: "U"  ATd: "out U: var MultRes" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L.magnitude * R.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L.magnitude * R.magnitude" 
 -- "L.magnitude * R.magnitude" true 
 -- 
 -- OG:markSuper: "L.magnitude * R.magnitude" 
 -- Invocation:markForCodeGen: "L.magnitude * R.magnitude" 
 -- BinaryExp:markForCodeGen: "L.magnitude * R.magnitude" 
 -- Invocation:markForCodeGen: "L.magnitude" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "in L: var MultArgL" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* R.magnitude"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- Pattern:markForCodeGen: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "R.magnitude" 
 -- OG:markForCodeGen: "R.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "R.magnitude" 
 -- "R" false 
 -- "magnitude" true 
 -- 
 -- not ObjDesc:  "L.magnitude * R.magnitude"  IS.isEmpty:  true 
 -- markItem: "inner(Dimension)" ObjectGenerator 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Public;      thi ...}" 
 -- OG:Qalloc: "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Public;      thi ...}" q ... 0 
 -- OG:Qalloc:A:  "Area"  super:  "Dimension"  marked:  true "Area: obj Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   Squar ...}" s ... D ... 
 -- Invocation:Qalloc: "Dimension" 
 -- ObjectInvocation:Qalloc: "Dimension" 
 -- name: "Dimension" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 %dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   th ...} 
 -- OG:super:  "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:<  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Public;      thisUnit:: Squ ...}" 
 -- super:  "Dimension" 
 -- E:  "Dimension" 
 -- OG:Qalloc:B: "Area" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 66 IS.newDescNo: 66 objSize: 0 1: 1 "%dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1 ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 66 "%dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1;   %Public;   thisUnit: ...}" 
 -- Items:Qalloc:super: "Dimension" size: 1 "Area" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- Pattern:Qalloc: PrimaryUnit$67 
 -- Pattern:Qalloc:B: PrimaryUnit$67 
 -- Pattern:Qalloc: SquareMeter 
 -- Pattern:Qalloc:B: SquareMeter 
 -- Pattern:Qalloc: SquareCentimeter 
 -- Pattern:Qalloc:B: SquareCentimeter 
 -- Pattern:Qalloc: mult 
 -- Pattern:Qalloc:B: mult 
 -- Pattern:Qalloc: symbol 
 -- Pattern:Qalloc:B: symbol 
 -- Pattern:Qalloc: test 
 -- Pattern:Qalloc:B: test 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 66 "%dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1;   %Public;   thisU ...}" 
 -- IS.newDescNo: 66 IS.objSize: 1 "%dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1;   %Public;   thisUnit:: Square ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  66 "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;  ...}" 
 -- ObjTmpStack:add: "Area" : "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %P ...}" 
 -- items:markForCodeGen: "%dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;    ...}" 
 -- markItem: "%dimension "A", "L*L"" Property 
 -- markItem: "%requires Length" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:: SquareMeter" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "SquareMeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SquareMeter" 
 -- "SquareMeter" false 
 -- 
 -- OG:markSuper: "SquareMeter" 
 -- Invocation:markForCodeGen: "SquareMeter" 
 -- ObjectInvocation:markForCodeGen: "SquareMeter"  ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Pattern:markForCodeGen: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- OG:Qalloc: "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" qDescno:  0 
 -- OG:Qalloc:A:  "SquareMeter"  super:  "Unit"  marked:  true "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "SquareMeter" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 68 IS.newDescNo: 68 objSize: 0 1: 1 "%unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 68 "%unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print}" 
 -- Items:Qalloc:super: "Unit" size: 2 "SquareMeter" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$69 
 -- Pattern:Qalloc:B: thisUnit$69 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 68 "%unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print}" 
 -- IS.newDescNo: 68 IS.objSize: 2 "%unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print}" 
 -- OG:Qalloc:end: IS.newDescNo:  68 "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- ObjTmpStack:add: "SquareMeter" : "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- items:markForCodeGen: "%unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print}" 
 -- markItem: "%unit "m2", 1" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "thisUnit:: SquareMeter" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "SquareMeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "SquareMeter" 
 -- "SquareMeter" false 
 -- 
 -- OG:markSuper: "SquareMeter" 
 -- Invocation:markForCodeGen: "SquareMeter" 
 -- ObjectInvocation:markForCodeGen: "SquareMeter"  ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Pattern:markForCodeGen: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "SquareMeter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "print:: {   "SquareMeter".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""SquareMeter".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""SquareMeter".print" 
 -- OG:Qalloc: ""SquareMeter".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  true "print:: {   "SquareMeter".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""SquareMeter".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 70 IS.newDescNo: 70 objSize: 0 1: 1 ""SquareMeter".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 70 ""SquareMeter".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""SquareMeter".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""SquareMeter".print"  marked:  false ""SquareMeter".print" super:  "SquareMeter".print 
 -- Invocation:Qalloc: ""SquareMeter".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""SquareMeter".print" 
 -- super:  ""SquareMeter".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""SquareMeter".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 70 ""SquareMeter".print" 
 -- IS.newDescNo: 70 IS.objSize: 3 ""SquareMeter".print" 
 -- OG:Qalloc:end: IS.newDescNo:  70 ""SquareMeter".print" 
 -- ObjTmpStack:add: "print" : ""SquareMeter".print" 
 -- items:markForCodeGen: ""SquareMeter".print" 
 -- markItem: ""SquareMeter".print" ObjectGenerator 
 -- OG:markForCodeGen: ""SquareMeter".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""SquareMeter".print" 
 -- ""SquareMeter"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""SquareMeter".print" 
 -- Invocation:markForCodeGen: ""SquareMeter".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""SquareMeter".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "SquareMeter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "symbol:: {   T := "A"}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "T := "A"" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "T := "A"" 
 -- OG:Qalloc: "T := "A"" qDescno:  0 
 -- OG:Qalloc:A:  "symbol"  super:  ""  marked:  true "symbol:: {   T := "A"}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  63 2 %globals{out T: var StringLib.String;inner(Symbol)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T := "A"" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "symbol" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 71 IS.newDescNo: 71 objSize: 0 1: 1 "T := "A"" 
 -- Items:Qalloc:objSize: 0  newDescNo: 71 "T := "A"" 
 -- Items:Qalloc:super: "" size: 2 "symbol" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 1 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "T" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- OG:Qalloc: ""A"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""A""  marked:  false "T := "A"" super:  "A" 
 -- Invocation:Qalloc: ""A"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""A"" 
 -- super:  ""A"" 
 -- E:  ""A"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""A"" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 71 "T := "A"" 
 -- IS.newDescNo: 71 IS.objSize: 2 "T := "A"" 
 -- OG:Qalloc:end: IS.newDescNo:  71 "T := "A"" 
 -- ObjTmpStack:add: "symbol" : "T := "A"" 
 -- items:markForCodeGen: "T := "A"" 
 -- markItem: "T := "A"" Assign 
 -- Invocation:markForCodeGen: "T" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "out T: var StringLib.String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: ""A"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""A"" 
 -- ""A"" true 
 -- 
 -- OG:markSuper: ""A"" 
 -- Invocation:markForCodeGen: ""A"" 
 -- not ObjDesc:  ""A""  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit:: Meter; ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Dimension" 
 -- "Dimension" false 
 -- 
 -- OG:markSuper: "Dimension" 
 -- Invocation:markForCodeGen: "Dimension" 
 -- ObjectInvocation:markForCodeGen: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;     ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit:: Meter;      ar ...}" 
 -- OG:Qalloc: "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit:: Meter;      ar ...}" q ... 0 
 -- OG:Qalloc:A:  "Length"  super:  "Dimension"  marked:  true "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;     ...}" s ... D ... 
 -- Invocation:Qalloc: "Dimension" 
 -- ObjectInvocation:Qalloc: "Dimension" 
 -- name: "Dimension" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 %dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   th ...} 
 -- OG:super:  "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:<  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit:: Meter;      argUnit:: Met ...}" 
 -- super:  "Dimension" 
 -- E:  "Dimension" 
 -- OG:Qalloc:B: "Length" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 72 IS.newDescNo: 72 objSize: 0 1: 1 "%dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUni ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 72 "%dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: M ...}" 
 -- Items:Qalloc:super: "Dimension" size: 1 "Length" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- Pattern:Qalloc: PrimaryUnit$73 
 -- Pattern:Qalloc:B: PrimaryUnit$73 
 -- Pattern:Qalloc: Meter 
 -- Pattern:Qalloc:B: Meter 
 -- Pattern:Qalloc: Centimeter 
 -- Pattern:Qalloc:B: Centimeter 
 -- Pattern:Qalloc: LightYear 
 -- Pattern:Qalloc:B: LightYear 
 -- Pattern:Qalloc: Foot 
 -- Pattern:Qalloc:B: Foot 
 -- Pattern:Qalloc: Mile 
 -- Pattern:Qalloc:B: Mile 
 -- Pattern:Qalloc: symbol 
 -- Pattern:Qalloc:B: symbol 
 -- Pattern:Qalloc: F2M 
 -- Pattern:Qalloc:B: F2M 
 -- Pattern:Qalloc: Meter2Foot 
 -- Pattern:Qalloc:B: Meter2Foot 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 72 "%dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit ...}" 
 -- IS.newDescNo: 72 IS.objSize: 1 "%dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;    ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  72 "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thi ...}" 
 -- ObjTmpStack:add: "Length" : "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit ...}" 
 -- items:markForCodeGen: "%dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: ...}" 
 -- markItem: "%dimension "L"" Property 
 -- markItem: "%requires Area" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:: Meter" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Meter" 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Meter" 
 -- Invocation:markForCodeGen: "Meter" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- Pattern:markForCodeGen: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude : ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude; ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   fromP ...}" 
 -- OG:Qalloc: "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   fromP ...}" q ... 0 
 -- OG:Qalloc:A:  "Meter"  super:  "Unit"  marked:  true "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrim ...}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;  ...}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "Meter" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 74 IS.newDescNo: 74 objSize: 0 1: 1 "%unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magni ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 74 "%unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := magnitude;fromPr ...}" 
 -- Items:Qalloc:super: "Unit" size: 2 "Meter" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$75 
 -- Pattern:Qalloc:B: thisUnit$75 
 -- Pattern:Qalloc: argUnit 
 -- Pattern:Qalloc:B: argUnit 
 -- Pattern:Qalloc: argUnit$76 
 -- Pattern:Qalloc:B: argUnit$76 
 -- Pattern:Qalloc: resUnit 
 -- Pattern:Qalloc:B: resUnit 
 -- Pattern:Qalloc: resUnit$77 
 -- Pattern:Qalloc:B: resUnit$77 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Pattern:Qalloc: power 
 -- Pattern:Qalloc:B: power 
 -- Pattern:Qalloc: power2 
 -- Pattern:Qalloc:B: power2 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 74 "%unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := magnitude;fr ...}" 
 -- IS.newDescNo: 74 IS.objSize: 2 "%unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := magnitude;fromPrimary::  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  74 "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude ...}" 
 -- ObjTmpStack:add: "Meter" : "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := ma ...}" 
 -- items:markForCodeGen: "%unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magni ...}" 
 -- markItem: "%unit "m", 1" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "thisUnit:: Meter" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Meter" 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Meter" 
 -- Invocation:markForCodeGen: "Meter" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- Pattern:markForCodeGen: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude : ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Meter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "argUnit:: Meter" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Meter" 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Meter" 
 -- Invocation:markForCodeGen: "Meter" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Meter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "resUnit:: Area.SquareMeter" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Area.SquareMeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Area.SquareMeter" 
 -- "Area" false 
 -- "SquareMeter" false 
 -- 
 -- OG:markSuper: "Area.SquareMeter" 
 -- Invocation:markForCodeGen: "Area.SquareMeter" 
 -- ObjectInvocation:markForCodeGen: "Area"  ATd: "--Area{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "SquareMeter"  ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Area.SquareMeter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "toPrimary:: {   base.magnitude := magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "base.magnitude := magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "base.magnitude := magnitude" 
 -- OG:Qalloc: "base.magnitude := magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  ""  marked:  true "toPrimary:: {   base.magnitude := magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 out base: var PrimaryUnit{inner(toPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude := magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "toPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 78 IS.newDescNo: 78 objSize: 0 1: 1 "base.magnitude := magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 78 "base.magnitude := magnitude" 
 -- Items:Qalloc:super: "" size: 5 "toPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "magnitude"  marked:  false "base.magnitude := magnitude" super:  magnitude 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude" 
 -- super:  "magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 78 "base.magnitude := magnitude" 
 -- IS.newDescNo: 78 IS.objSize: 5 "base.magnitude := magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  78 "base.magnitude := magnitude" 
 -- ObjTmpStack:add: "toPrimary" : "base.magnitude := magnitude" 
 -- items:markForCodeGen: "base.magnitude := magnitude" 
 -- markItem: "base.magnitude := magnitude" Assign 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "out base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "magnitude" 
 -- "magnitude" true 
 -- 
 -- Pattern:markForCodeGen: "fromPrimary:: {   magnitude := base.magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "magnitude := base.magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "magnitude := base.magnitude" 
 -- OG:Qalloc: "magnitude := base.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  ""  marked:  true "fromPrimary:: {   magnitude := base.magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 5 in base: var PrimaryUnit{inner(fromPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude := base.magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fromPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 79 IS.newDescNo: 79 objSize: 0 1: 1 "magnitude := base.magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 79 "magnitude := base.magnitude" 
 -- Items:Qalloc:super: "" size: 5 "fromPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "base.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "base.magnitude"  marked:  false "magnitude := base.magnitude" super:  base.magnitude 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude" 
 -- super:  "base.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "base.magnitude" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 79 "magnitude := base.magnitude" 
 -- IS.newDescNo: 79 IS.objSize: 5 "magnitude := base.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  79 "magnitude := base.magnitude" 
 -- ObjTmpStack:add: "fromPrimary" : "magnitude := base.magnitude" 
 -- items:markForCodeGen: "magnitude := base.magnitude" 
 -- markItem: "magnitude := base.magnitude" Assign 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "base.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "base.magnitude" 
 -- "base" false 
 -- "magnitude" true 
 -- 
 -- Pattern:markForCodeGen: "print:: {   "Meter".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""Meter".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""Meter".print" 
 -- OG:Qalloc: ""Meter".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  true "print:: {   "Meter".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Meter".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 80 IS.newDescNo: 80 objSize: 0 1: 1 ""Meter".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 80 ""Meter".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Meter".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Meter".print"  marked:  false ""Meter".print" super:  "Meter".print 
 -- Invocation:Qalloc: ""Meter".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Meter".print" 
 -- super:  ""Meter".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Meter".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 80 ""Meter".print" 
 -- IS.newDescNo: 80 IS.objSize: 3 ""Meter".print" 
 -- OG:Qalloc:end: IS.newDescNo:  80 ""Meter".print" 
 -- ObjTmpStack:add: "print" : ""Meter".print" 
 -- items:markForCodeGen: ""Meter".print" 
 -- markItem: ""Meter".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Meter".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Meter".print" 
 -- ""Meter"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Meter".print" 
 -- Invocation:markForCodeGen: ""Meter".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Meter".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Meter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "symbol:: {   T := "L"}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "T := "L"" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "T := "L"" 
 -- OG:Qalloc: "T := "L"" qDescno:  0 
 -- OG:Qalloc:A:  "symbol"  super:  ""  marked:  true "symbol:: {   T := "L"}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  63 2 %globals{out T: var StringLib.String;inner(Symbol)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T := "L"" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "symbol" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 81 IS.newDescNo: 81 objSize: 0 1: 1 "T := "L"" 
 -- Items:Qalloc:objSize: 0  newDescNo: 81 "T := "L"" 
 -- Items:Qalloc:super: "" size: 2 "symbol" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 1 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "T" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- OG:Qalloc: ""L"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""L""  marked:  false "T := "L"" super:  "L" 
 -- Invocation:Qalloc: ""L"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""L"" 
 -- super:  ""L"" 
 -- E:  ""L"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""L"" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 81 "T := "L"" 
 -- IS.newDescNo: 81 IS.objSize: 2 "T := "L"" 
 -- OG:Qalloc:end: IS.newDescNo:  81 "T := "L"" 
 -- ObjTmpStack:add: "symbol" : "T := "L"" 
 -- items:markForCodeGen: "T := "L"" 
 -- markItem: "T := "L"" Assign 
 -- Invocation:markForCodeGen: "T" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "out T: var StringLib.String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: ""L"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""L"" 
 -- ""L"" true 
 -- 
 -- OG:markSuper: ""L"" 
 -- Invocation:markForCodeGen: ""L"" 
 -- not ObjDesc:  ""L""  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      fromPrimary: ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Dimension" 
 -- "Dimension" false 
 -- 
 -- OG:markSuper: "Dimension" 
 -- Invocation:markForCodeGen: "Dimension" 
 -- ObjectInvocation:markForCodeGen: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;     ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      fromPrimary:: ;      ...}" 
 -- OG:Qalloc: "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      fromPrimary:: ;      ...}" q ... 0 
 -- OG:Qalloc:A:  "Temperature"  super:  "Dimension"  marked:  true "Temperature: obj Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrim ...}" s ... D ... 
 -- Invocation:Qalloc: "Dimension" 
 -- ObjectInvocation:Qalloc: "Dimension" 
 -- name: "Dimension" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 %dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   th ...} 
 -- OG:super:  "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:<  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      fromPrimary:: ;         magnitu ...}" 
 -- super:  "Dimension" 
 -- E:  "Dimension" 
 -- OG:Qalloc:B: "Temperature" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 82 IS.newDescNo: 82 objSize: 0 1: 1 "%Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 82 "%Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      ma ...}" 
 -- Items:Qalloc:super: "Dimension" size: 1 "Temperature" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Celsius 
 -- Pattern:Qalloc:B: Celsius 
 -- Pattern:Qalloc: Fahrenheit 
 -- Pattern:Qalloc:B: Fahrenheit 
 -- Pattern:Qalloc: FasCelsius 
 -- Pattern:Qalloc:B: FasCelsius 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 82 "%Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;     ...}" 
 -- IS.newDescNo: 82 IS.objSize: 1 "%Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  82 "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;     ...}" 
 -- ObjTmpStack:add: "Temperature" : "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;     ...}" 
 -- items:markForCodeGen: "%Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.m ...}" 
 -- markItem: "%Public" Property 
 -- OG:markForCodeGen: "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      toPrimary ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Dimension" 
 -- "Dimension" false 
 -- 
 -- OG:markSuper: "Dimension" 
 -- Invocation:markForCodeGen: "Dimension" 
 -- ObjectInvocation:markForCodeGen: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;     ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      toPrimary:: ;     ...}" 
 -- OG:Qalloc: "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      toPrimary:: ;     ...}" q ... 0 
 -- OG:Qalloc:A:  "Time"  super:  "Dimension"  marked:  true "Time: obj Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      ...}" s ... D ... 
 -- Invocation:Qalloc: "Dimension" 
 -- ObjectInvocation:Qalloc: "Dimension" 
 -- name: "Dimension" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 %dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   th ...} 
 -- OG:super:  "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:<  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      toPrimary:: ;         base.m ...}" 
 -- super:  "Dimension" 
 -- E:  "Dimension" 
 -- OG:Qalloc:B: "Time" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 83 IS.newDescNo: 83 objSize: 0 1: 1 "%dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 83 "%dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base ...}" 
 -- Items:Qalloc:super: "Dimension" size: 1 "Time" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- Pattern:Qalloc: PrimaryUnit$84 
 -- Pattern:Qalloc:B: PrimaryUnit$84 
 -- Pattern:Qalloc: Second 
 -- Pattern:Qalloc:B: Second 
 -- Pattern:Qalloc: Minutes 
 -- Pattern:Qalloc:B: Minutes 
 -- Pattern:Qalloc: Hours 
 -- Pattern:Qalloc:B: Hours 
 -- Pattern:Qalloc: Year 
 -- Pattern:Qalloc:B: Year 
 -- Pattern:Qalloc: F2M 
 -- Pattern:Qalloc:B: F2M 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 83 "%dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;       ...}" 
 -- IS.newDescNo: 83 IS.objSize: 1 "%dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitu ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  83 "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;  ...}" 
 -- ObjTmpStack:add: "Time" : "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      to ...}" 
 -- items:markForCodeGen: "%dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- markItem: "%dimension "T"" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:: Second" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Second" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Second" 
 -- "Second" false 
 -- 
 -- OG:markSuper: "Second" 
 -- Invocation:markForCodeGen: "Second" 
 -- ObjectInvocation:markForCodeGen: "Second"  ATd: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrim ...}" 
 -- Pattern:markForCodeGen: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude : ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnit ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   p ...}" 
 -- OG:Qalloc: "Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   p ...}" q ... 0 
 -- OG:Qalloc:A:  "Second"  super:  "Unit"  marked:  true "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fr ...}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print:: ;    ...}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "Second" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 85 IS.newDescNo: 85 objSize: 0 1: 1 "%unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnit ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 85 "%unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;pr ...}" 
 -- Items:Qalloc:super: "Unit" size: 2 "Second" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$86 
 -- Pattern:Qalloc:B: thisUnit$86 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 85 "%unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitud ...}" 
 -- IS.newDescNo: 85 IS.objSize: 2 "%unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  85 "Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude  ...}" 
 -- ObjTmpStack:add: "Second" : "Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := ba ...}" 
 -- items:markForCodeGen: "%unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Second ..."}" 
 -- markItem: "%unit "s", 1" Property 
 -- markItem: "%public" Property 
 -- Pattern:markForCodeGen: "thisUnit:: Second" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Second" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Second" 
 -- "Second" false 
 -- 
 -- OG:markSuper: "Second" 
 -- Invocation:markForCodeGen: "Second" 
 -- ObjectInvocation:markForCodeGen: "Second"  ATd: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrim ...}" 
 -- Pattern:markForCodeGen: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude : ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Second"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "toPrimary:: {   base.magnitude := magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "base.magnitude := magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "base.magnitude := magnitude" 
 -- OG:Qalloc: "base.magnitude := magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  ""  marked:  true "toPrimary:: {   base.magnitude := magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 out base: var PrimaryUnit{inner(toPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude := magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "toPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 87 IS.newDescNo: 87 objSize: 0 1: 1 "base.magnitude := magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 87 "base.magnitude := magnitude" 
 -- Items:Qalloc:super: "" size: 5 "toPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "magnitude"  marked:  false "base.magnitude := magnitude" super:  magnitude 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude" 
 -- super:  "magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 87 "base.magnitude := magnitude" 
 -- IS.newDescNo: 87 IS.objSize: 5 "base.magnitude := magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  87 "base.magnitude := magnitude" 
 -- ObjTmpStack:add: "toPrimary" : "base.magnitude := magnitude" 
 -- items:markForCodeGen: "base.magnitude := magnitude" 
 -- markItem: "base.magnitude := magnitude" Assign 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "out base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "magnitude" 
 -- "magnitude" true 
 -- 
 -- Pattern:markForCodeGen: "fromPrimary:: {   magnitude := base.magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "magnitude := base.magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "magnitude := base.magnitude" 
 -- OG:Qalloc: "magnitude := base.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  ""  marked:  true "fromPrimary:: {   magnitude := base.magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 5 in base: var PrimaryUnit{inner(fromPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude := base.magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fromPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 88 IS.newDescNo: 88 objSize: 0 1: 1 "magnitude := base.magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 88 "magnitude := base.magnitude" 
 -- Items:Qalloc:super: "" size: 5 "fromPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "base.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "base.magnitude"  marked:  false "magnitude := base.magnitude" super:  base.magnitude 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude" 
 -- super:  "base.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "base.magnitude" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 88 "magnitude := base.magnitude" 
 -- IS.newDescNo: 88 IS.objSize: 5 "magnitude := base.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  88 "magnitude := base.magnitude" 
 -- ObjTmpStack:add: "fromPrimary" : "magnitude := base.magnitude" 
 -- items:markForCodeGen: "magnitude := base.magnitude" 
 -- markItem: "magnitude := base.magnitude" Assign 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "base.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "base.magnitude" 
 -- "base" false 
 -- "magnitude" true 
 -- 
 -- Pattern:markForCodeGen: "print:: {   "Second".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""Second".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""Second".print" 
 -- OG:Qalloc: ""Second".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  true "print:: {   "Second".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Second".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 89 IS.newDescNo: 89 objSize: 0 1: 1 ""Second".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 89 ""Second".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Second".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Second".print"  marked:  false ""Second".print" super:  "Second".print 
 -- Invocation:Qalloc: ""Second".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Second".print" 
 -- super:  ""Second".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Second".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 89 ""Second".print" 
 -- IS.newDescNo: 89 IS.objSize: 3 ""Second".print" 
 -- OG:Qalloc:end: IS.newDescNo:  89 ""Second".print" 
 -- ObjTmpStack:add: "print" : ""Second".print" 
 -- items:markForCodeGen: ""Second".print" 
 -- markItem: ""Second".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Second".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Second".print" 
 -- ""Second"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Second".print" 
 -- Invocation:markForCodeGen: ""Second".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Second".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Second"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit "MpS", " ..."}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Dimension" 
 -- "Dimension" false 
 -- 
 -- OG:markSuper: "Dimension" 
 -- Invocation:markForCodeGen: "Dimension" 
 -- ObjectInvocation:markForCodeGen: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;     ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit "MpS", "m*s^-1", ...}" 
 -- OG:Qalloc: "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit "MpS", "m*s^-1", ...}" q ... 0 
 -- OG:Qalloc:A:  "Velocity"  super:  "Dimension"  marked:  true "Velocity: obj Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: Met ...}" s ... D ... 
 -- Invocation:Qalloc: "Dimension" 
 -- ObjectInvocation:Qalloc: "Dimension" 
 -- name: "Dimension" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  39 1 %dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   th ...} 
 -- OG:super:  "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisUnit:<  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit "MpS", "m*s^-1", "m/s", 1;  ...}" 
 -- super:  "Dimension" 
 -- E:  "Dimension" 
 -- OG:Qalloc:B: "Velocity" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 90 IS.newDescNo: 90 objSize: 0 1: 1 "%dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 90 "%dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "MpS", "m*s^-1", ...}" 
 -- Items:Qalloc:super: "Dimension" size: 1 "Velocity" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: PrimaryUnit 
 -- Pattern:Qalloc:B: PrimaryUnit 
 -- Pattern:Qalloc: PrimaryUnit$91 
 -- Pattern:Qalloc:B: PrimaryUnit$91 
 -- Pattern:Qalloc: MeterPerSecond 
 -- Pattern:Qalloc:B: MeterPerSecond 
 -- Pattern:Qalloc: CentimeterPerMinute 
 -- Pattern:Qalloc:B: CentimeterPerMinute 
 -- Pattern:Qalloc: mult 
 -- Pattern:Qalloc:B: mult 
 -- Pattern:Qalloc: div 
 -- Pattern:Qalloc:B: div 
 -- Pattern:Qalloc: F2M 
 -- Pattern:Qalloc:B: F2M 
 -- Pattern:Qalloc: symbol 
 -- Pattern:Qalloc:B: symbol 
 -- Pattern:Qalloc: MultArgL 
 -- Pattern:Qalloc:B: MultArgL 
 -- Pattern:Qalloc: MultArgL$92 
 -- Pattern:Qalloc:B: MultArgL$92 
 -- Pattern:Qalloc: MultArgR 
 -- Pattern:Qalloc:B: MultArgR 
 -- Pattern:Qalloc: MultArgR$93 
 -- Pattern:Qalloc:B: MultArgR$93 
 -- Pattern:Qalloc: MultRes 
 -- Pattern:Qalloc:B: MultRes 
 -- Pattern:Qalloc: MultRes$94 
 -- Pattern:Qalloc:B: MultRes$94 
 -- Pattern:Qalloc: test 
 -- Pattern:Qalloc:B: test 
 -- OG:Qalloc: "test" qDescno:  0 
 -- OG:Qalloc:A:  "test"  super:  "test"  marked:  false "%dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "M ..."}" s ... t ... 
 -- Invocation:Qalloc: "test" 
 -- ObjectInvocation:Qalloc: "test" 
 -- name: "test" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newline; ...} 
 -- OG:Qalloc:SuperAlloc: "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline ...}" 
 -- OG:Qalloc: "V: var MeterPerSecond{   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V := L / T;   V.p ...}" q ... 0 
 -- OG:Qalloc:A:  "test"  super:  ""  marked:  false "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T :=  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V: var MeterPerSecond{   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V := L / T;   V.print}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "test" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 95 IS.newDescNo: 95 objSize: 0 1: 1 "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print; ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 95 "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newline;V := L / T;V.pri ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" qDescno:  0 
 -- OG:Qalloc:A:  "MeterPerSecond"  super:  "Unit"  marked:  false "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print::  ...}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "MeterPerSecond" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 96 IS.newDescNo: 96 objSize: 0 1: 1 "%unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 96 "%unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print}" 
 -- Items:Qalloc:super: "Unit" size: 2 "MeterPerSecond" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$97 
 -- Pattern:Qalloc:B: thisUnit$97 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 96 "%unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print}" 
 -- IS.newDescNo: 96 IS.objSize: 2 "%unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print}" 
 -- OG:Qalloc:end: IS.newDescNo:  96 "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- new_size:A: true   "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- newDescNo: 96 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "T" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := bas ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitu ...}" 
 -- newDescNo: 85 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "10"m"" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "10"m""  marked:  false "L := 10"m"" super:  10"m" 
 -- Invocation:Qalloc: "10"m"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10"m"" 
 -- super:  "10"m"" 
 -- E:  "10"m"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "10"m"" 
 -- OG:Qalloc: "L.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L.print"  marked:  false "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newlin ...}" s ... L ... 
 -- Invocation:Qalloc: "L.print" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.print" 
 -- super:  "L.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newl ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{put(10)} 
 -- OG:Qalloc:SuperAlloc: "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc: "%globals{   put(10)}" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  ""  marked:  false "newline: {   %globals;   put(10)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   put(10)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "newline" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 98 IS.newDescNo: 98 objSize: 0 1: 1 "%globals{put(10)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 98 "%globals{put(10)}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- OG:Qalloc: "put(10)" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put(10)"  marked:  false "%globals{put(10)}" super:  put(10) 
 -- Invocation:Qalloc: "put(10)" 
 -- ObjectInvocation:Qalloc: "put(10)" 
 -- name: "put" 
 -- Arguments "put(10)" 
 -- OG:Qalloc: "10" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "10"  marked:  false "put(10)" super:  10 
 -- Invocation:Qalloc: "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "10" 
 -- super:  "10" 
 -- E:  "10" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "10" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put(10)" 
 -- super:  "put(10)" 
 -- E:  "put(10)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put(10)" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 98 "%globals{put(10)}" 
 -- IS.newDescNo: 98 IS.objSize: 0 "%globals{put(10)}" 
 -- OG:Qalloc:end: IS.newDescNo:  98 "%globals{   put(10)}" 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Invocation:Qalloc: "T" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- OG:Qalloc: "20"s"" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "20"s""  marked:  false "T := 20"s"" super:  20"s" 
 -- Invocation:Qalloc: "20"s"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "20"s"" 
 -- super:  "20"s"" 
 -- E:  "20"s"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "20"s"" 
 -- OG:Qalloc: "T.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "T.print"  marked:  false "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newlin ...}" s ... T ... 
 -- Invocation:Qalloc: "T.print" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  89 3 "Second".print 
 -- OG:super:  "print:: {   "Second".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.print" 
 -- super:  "T.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newl ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "L / T" qDescno:  0 
 -- OG:Qalloc:A:  "/"  super:  "L / T"  marked:  false "V := L / T" super:  L / T 
 -- Invocation:Qalloc: "L / T" 
 -- BinaryExp:Qalloc: "L / T" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "/ T" 
 -- name: "/" 
 -- Arguments "T" 
 -- OG:Qalloc: "T" qDescno:  0 
 -- OG:Qalloc:A:  "Second"  super:  "T"  marked:  false "T" super:  T 
 -- Invocation:Qalloc: "T" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  85 2 %unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude :=  ...} 
 -- OG:super:  "T: var Time.second" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T" 
 -- super:  "T" 
 -- E:  "T" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 121{in V: var float;out R: var float} 
 -- OG:Qalloc:SuperAlloc: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OG:Qalloc: "%basic 121{   in V: var float;   out R: var float}" qDescno:  0 
 -- OG:Qalloc:A:  "/"  super:  ""  marked:  false "/  : {   %basic 121;   in V: var float;   out R: var float}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 121{   in V: var float;   out R: var float}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "/" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 99 IS.newDescNo: 99 objSize: 0 1: 1 "%basic 121{in V: var float;out R: var float}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 99 "%basic 121{in V: var float;out R: var float}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 99 "%basic 121{in V: var float;out R: var float}" 
 -- IS.newDescNo: 99 IS.objSize: 7 "%basic 121{in V: var float;out R: var float}" 
 -- OG:Qalloc:end: IS.newDescNo:  99 "%basic 121{   in V: var float;   out R: var float}" 
 -- OG:super:  "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L / T" 
 -- super:  "L / T" 
 -- E:  "L / T" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L / T" 
 -- OG:Qalloc: "V.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "V.print"  marked:  false "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newlin ...}" s ... V ... 
 -- Invocation:Qalloc: "V.print" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "MpS".print 
 -- OG:Qalloc:SuperAlloc: "print:: {   "MpS".print}" 
 -- OG:Qalloc: ""MpS".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print:: {   "MpS".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""MpS".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 100 IS.newDescNo: 100 objSize: 0 1: 1 ""MpS".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 100 ""MpS".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""MpS".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""MpS".print"  marked:  false ""MpS".print" super:  "MpS".print 
 -- Invocation:Qalloc: ""MpS".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""MpS".print" 
 -- super:  ""MpS".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""MpS".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 100 ""MpS".print" 
 -- IS.newDescNo: 100 IS.objSize: 3 ""MpS".print" 
 -- OG:Qalloc:end: IS.newDescNo:  100 ""MpS".print" 
 -- OG:super:  "print:: {   "MpS".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V.print" 
 -- super:  "V.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V.print" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 95 "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newline;V := L / T;V ...}" 
 -- IS.newDescNo: 95 IS.objSize: 7 "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newline;V := L / T;V.print}" 
 -- OG:Qalloc:end: IS.newDescNo:  95 "V: var MeterPerSecond{   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newlin ...}" 
 -- OG:super:  "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V := L  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "test" 
 -- super:  "test" 
 -- E:  "test" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "test" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 90 "%dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "MpS", "m*s^ ..."}" 
 -- IS.newDescNo: 90 IS.objSize: 1 "%dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "MpS", "m*s^-1", "m/s",  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  90 "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;       ...}" 
 -- ObjTmpStack:add: "Velocity" : "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %un ...}" 
 -- items:markForCodeGen: "%dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "MpS", "m*s^-1", "m/s", 1;   %Pub ...}" 
 -- markItem: "%dimension "MpSD", "L/T"" Property 
 -- markItem: "%requires Length, Time" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "PrimaryUnit:: MeterPerSecond" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "MeterPerSecond" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MeterPerSecond" 
 -- "MeterPerSecond" false 
 -- 
 -- OG:markSuper: "MeterPerSecond" 
 -- Invocation:markForCodeGen: "MeterPerSecond" 
 -- ObjectInvocation:markForCodeGen: "MeterPerSecond"  ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;       ...}" 
 -- Pattern:markForCodeGen: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- OG:Qalloc: "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" qDescno:  96 
 -- ObjTmpStack:add: "MeterPerSecond" : "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- items:markForCodeGen: "%unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print}" 
 -- markItem: "%unit "MpS", "m*s^-1", "m/s", 1" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "thisUnit:: MeterPerSecond" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "MeterPerSecond" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MeterPerSecond" 
 -- "MeterPerSecond" false 
 -- 
 -- OG:markSuper: "MeterPerSecond" 
 -- Invocation:markForCodeGen: "MeterPerSecond" 
 -- ObjectInvocation:markForCodeGen: "MeterPerSecond"  ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;       ...}" 
 -- Pattern:markForCodeGen: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MeterPerSecond"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "print:: {   "MpS".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""MpS".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""MpS".print" 
 -- OG:Qalloc: ""MpS".print" qDescno:  100 
 -- ObjTmpStack:add: "print" : ""MpS".print" 
 -- items:markForCodeGen: ""MpS".print" 
 -- markItem: ""MpS".print" ObjectGenerator 
 -- OG:markForCodeGen: ""MpS".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""MpS".print" 
 -- ""MpS"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""MpS".print" 
 -- Invocation:markForCodeGen: ""MpS".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""MpS".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MeterPerSecond"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "symbol:: {   T := "V"}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "T := "V"" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "T := "V"" 
 -- OG:Qalloc: "T := "V"" qDescno:  0 
 -- OG:Qalloc:A:  "symbol"  super:  ""  marked:  true "symbol:: {   T := "V"}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  63 2 %globals{out T: var StringLib.String;inner(Symbol)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T := "V"" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "symbol" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 101 IS.newDescNo: 101 objSize: 0 1: 1 "T := "V"" 
 -- Items:Qalloc:objSize: 0  newDescNo: 101 "T := "V"" 
 -- Items:Qalloc:super: "" size: 2 "symbol" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 1 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Invocation:Qalloc: "T" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- OG:Qalloc: ""V"" qDescno:  0 
 -- OG:Qalloc:A:  "String"  super:  ""V""  marked:  false "T := "V"" super:  "V" 
 -- Invocation:Qalloc: ""V"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  10 0 %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- ac ...} 
 -- OG:super:  "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually an  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""V"" 
 -- super:  ""V"" 
 -- E:  ""V"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""V"" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 101 "T := "V"" 
 -- IS.newDescNo: 101 IS.objSize: 2 "T := "V"" 
 -- OG:Qalloc:end: IS.newDescNo:  101 "T := "V"" 
 -- ObjTmpStack:add: "symbol" : "T := "V"" 
 -- items:markForCodeGen: "T := "V"" 
 -- markItem: "T := "V"" Assign 
 -- Invocation:markForCodeGen: "T" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "out T: var StringLib.String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: ""V"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- ""V"" 
 -- ""V"" true 
 -- 
 -- OG:markSuper: ""V"" 
 -- Invocation:markForCodeGen: ""V"" 
 -- not ObjDesc:  ""V""  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "MultArgL:: Length.Meter" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "MultArgR:: Time.Minutes" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Time.Minutes" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Time.Minutes" 
 -- "Time" false 
 -- "Minutes" false 
 -- 
 -- OG:markSuper: "Time.Minutes" 
 -- Invocation:markForCodeGen: "Time.Minutes" 
 -- ObjectInvocation:markForCodeGen: "Time"  ATd: "--Time{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Minutes"  ATd: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60; ...}" 
 -- Pattern:markForCodeGen: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      m ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnitude := ba ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnitude := base.magni ...}" 
 -- OG:Qalloc: "Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnitude := base.magni ...}" q ... 0 
 -- OG:Qalloc:A:  "Minutes"  super:  "Unit"  marked:  true "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude ...}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnitude := base.magnitude / 60;  ...}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "Minutes" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 102 IS.newDescNo: 102 objSize: 0 1: 1 "%unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 102 "%unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   magnitude := base.ma ...}" 
 -- Items:Qalloc:super: "Unit" size: 2 "Minutes" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$103 
 -- Pattern:Qalloc:B: thisUnit$103 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 102 "%unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   magnitude := bas ...}" 
 -- IS.newDescNo: 102 IS.objSize: 2 "%unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   magnitude := base.magnitude  ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  102 "Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;       ...}" 
 -- ObjTmpStack:add: "Minutes" : "Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magni ...}" 
 -- items:markForCodeGen: "%unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   magnitude := base.magnitude / 60;print ...}" 
 -- markItem: "%unit "min", 60" Property 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "thisUnit:: Minutes" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Minutes" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Minutes" 
 -- "Minutes" false 
 -- 
 -- OG:markSuper: "Minutes" 
 -- Invocation:markForCodeGen: "Minutes" 
 -- ObjectInvocation:markForCodeGen: "Minutes"  ATd: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60; ...}" 
 -- Pattern:markForCodeGen: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      m ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Minutes"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "toPrimary:: {   base.magnitude := magnitude * 60}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "base.magnitude := magnitude * 60" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "base.magnitude := magnitude * 60" 
 -- OG:Qalloc: "base.magnitude := magnitude * 60" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  ""  marked:  true "toPrimary:: {   base.magnitude := magnitude * 60}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 out base: var PrimaryUnit{inner(toPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude := magnitude * 60" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "toPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 104 IS.newDescNo: 104 objSize: 0 1: 1 "base.magnitude := magnitude * 60" 
 -- Items:Qalloc:objSize: 0  newDescNo: 104 "base.magnitude := magnitude * 60" 
 -- Items:Qalloc:super: "" size: 5 "toPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "magnitude * 60" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "magnitude * 60"  marked:  false "base.magnitude := magnitude * 60" super:  magnitude * 60 
 -- Invocation:Qalloc: "magnitude * 60" 
 -- BinaryExp:Qalloc: "magnitude * 60" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* 60" 
 -- name: "*" 
 -- Arguments "60" 
 -- OG:Qalloc: "60" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "60"  marked:  false "60" super:  60 
 -- Invocation:Qalloc: "60" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "60" 
 -- super:  "60" 
 -- E:  "60" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "60" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 7 %basic 112{in V: var float;out R: var float} 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude * 60" 
 -- super:  "magnitude * 60" 
 -- E:  "magnitude * 60" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude * 60" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 104 "base.magnitude := magnitude * 60" 
 -- IS.newDescNo: 104 IS.objSize: 5 "base.magnitude := magnitude * 60" 
 -- OG:Qalloc:end: IS.newDescNo:  104 "base.magnitude := magnitude * 60" 
 -- ObjTmpStack:add: "toPrimary" : "base.magnitude := magnitude * 60" 
 -- items:markForCodeGen: "base.magnitude := magnitude * 60" 
 -- markItem: "base.magnitude := magnitude * 60" Assign 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "out base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "magnitude * 60" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "magnitude * 60" 
 -- "magnitude * 60" true 
 -- 
 -- OG:markSuper: "magnitude * 60" 
 -- Invocation:markForCodeGen: "magnitude * 60" 
 -- BinaryExp:markForCodeGen: "magnitude * 60" 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* 60"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "60" 
 -- OG:markForCodeGen: "60" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "60" 
 -- "60" true 
 -- 
 -- OG:markSuper: "60" 
 -- Invocation:markForCodeGen: "60" 
 -- not ObjDesc:  "60"  IS.isEmpty:  true 
 -- not ObjDesc:  "magnitude * 60"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "fromPrimary:: {   magnitude := base.magnitude / 60}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "magnitude := base.magnitude / 60" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "magnitude := base.magnitude / 60" 
 -- OG:Qalloc: "magnitude := base.magnitude / 60" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  ""  marked:  true "fromPrimary:: {   magnitude := base.magnitude / 60}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 5 in base: var PrimaryUnit{inner(fromPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude := base.magnitude / 60" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fromPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 105 IS.newDescNo: 105 objSize: 0 1: 1 "magnitude := base.magnitude / 60" 
 -- Items:Qalloc:objSize: 0  newDescNo: 105 "magnitude := base.magnitude / 60" 
 -- Items:Qalloc:super: "" size: 5 "fromPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "base.magnitude / 60" qDescno:  0 
 -- OG:Qalloc:A:  "/"  super:  "base.magnitude / 60"  marked:  false "magnitude := base.magnitude / 60" super:  base.magnitude / 60 
 -- Invocation:Qalloc: "base.magnitude / 60" 
 -- BinaryExp:Qalloc: "base.magnitude / 60" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "/ 60" 
 -- name: "/" 
 -- Arguments "60" 
 -- OG:Qalloc: "60" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "60"  marked:  false "60" super:  60 
 -- Invocation:Qalloc: "60" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "60" 
 -- super:  "60" 
 -- E:  "60" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "60" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  99 7 %basic 121{in V: var float;out R: var float} 
 -- OG:super:  "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude / 60" 
 -- super:  "base.magnitude / 60" 
 -- E:  "base.magnitude / 60" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "base.magnitude / 60" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 105 "magnitude := base.magnitude / 60" 
 -- IS.newDescNo: 105 IS.objSize: 5 "magnitude := base.magnitude / 60" 
 -- OG:Qalloc:end: IS.newDescNo:  105 "magnitude := base.magnitude / 60" 
 -- ObjTmpStack:add: "fromPrimary" : "magnitude := base.magnitude / 60" 
 -- items:markForCodeGen: "magnitude := base.magnitude / 60" 
 -- markItem: "magnitude := base.magnitude / 60" Assign 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "base.magnitude / 60" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "base.magnitude / 60" 
 -- "base.magnitude / 60" true 
 -- 
 -- OG:markSuper: "base.magnitude / 60" 
 -- Invocation:markForCodeGen: "base.magnitude / 60" 
 -- BinaryExp:markForCodeGen: "base.magnitude / 60" 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "in base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "/ 60"  ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- Pattern:markForCodeGen: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "60" 
 -- OG:markForCodeGen: "60" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "60" 
 -- "60" true 
 -- 
 -- OG:markSuper: "60" 
 -- Invocation:markForCodeGen: "60" 
 -- not ObjDesc:  "60"  IS.isEmpty:  true 
 -- not ObjDesc:  "base.magnitude / 60"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "print:: {   "Minutes".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""Minutes".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""Minutes".print" 
 -- OG:Qalloc: ""Minutes".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  true "print:: {   "Minutes".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Minutes".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 106 IS.newDescNo: 106 objSize: 0 1: 1 ""Minutes".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 106 ""Minutes".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Minutes".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Minutes".print"  marked:  false ""Minutes".print" super:  "Minutes".print 
 -- Invocation:Qalloc: ""Minutes".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Minutes".print" 
 -- super:  ""Minutes".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Minutes".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 106 ""Minutes".print" 
 -- IS.newDescNo: 106 IS.objSize: 3 ""Minutes".print" 
 -- OG:Qalloc:end: IS.newDescNo:  106 ""Minutes".print" 
 -- ObjTmpStack:add: "print" : ""Minutes".print" 
 -- items:markForCodeGen: ""Minutes".print" 
 -- markItem: ""Minutes".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Minutes".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Minutes".print" 
 -- ""Minutes"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Minutes".print" 
 -- Invocation:markForCodeGen: ""Minutes".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Minutes".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Time.Minutes"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "MultRes:: MeterPerSecond" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "MeterPerSecond" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MeterPerSecond" 
 -- "MeterPerSecond" false 
 -- 
 -- OG:markSuper: "MeterPerSecond" 
 -- Invocation:markForCodeGen: "MeterPerSecond" 
 -- ObjectInvocation:markForCodeGen: "MeterPerSecond"  ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MeterPerSecond"  IS.isEmpty:  true 
 -- markItem: "test" ObjectGenerator 
 -- OG:markForCodeGen: "test" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "test" 
 -- "test" false 
 -- 
 -- OG:markSuper: "test" 
 -- Invocation:markForCodeGen: "test" 
 -- ObjectInvocation:markForCodeGen: "test"  ATd: "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20" ..."}" 
 -- Pattern:markForCodeGen: "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newli ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "V: var MeterPerSecond{   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V := L /  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "V: var MeterPerSecond{   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V := L / T;   V.p ...}" 
 -- OG:Qalloc: "V: var MeterPerSecond{   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V := L / T;   V.p ...}" q ... 95 
 -- ObjTmpStack:add: "test" : "V: var MeterPerSecond{   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V  ...}" 
 -- items:markForCodeGen: "V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newline;V := L / T;V.print}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MeterPerSecond" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MeterPerSecond" 
 -- "MeterPerSecond" false 
 -- 
 -- OG:markSuper: "MeterPerSecond" 
 -- Invocation:markForCodeGen: "MeterPerSecond" 
 -- ObjectInvocation:markForCodeGen: "MeterPerSecond"  ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MeterPerSecond"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Time.second" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Time.second" 
 -- "Time" false 
 -- "second" false 
 -- 
 -- OG:markSuper: "Time.second" 
 -- Invocation:markForCodeGen: "Time.second" 
 -- ObjectInvocation:markForCodeGen: "Time"  ATd: "--Time{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "second"  ATd: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrim ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Time.second"  IS.isEmpty:  true 
 -- markItem: "L := 10"m"" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "10"m"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10"m"" 
 -- "10"m"" true 
 -- 
 -- OG:markSuper: "10"m"" 
 -- Invocation:markForCodeGen: "10"m"" 
 -- not ObjDesc:  "10"m""  IS.isEmpty:  true 
 -- markItem: "L.print" ObjectGenerator 
 -- OG:markForCodeGen: "L.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.print" 
 -- "L" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L.print" 
 -- Invocation:markForCodeGen: "L.print" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- Pattern:markForCodeGen: "newline: {   %globals;   put(10)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   put(10)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   put(10)}" 
 -- OG:Qalloc: "%globals{   put(10)}" qDescno:  98 
 -- ObjTmpStack:add: "newline" : "%globals{   put(10)}" 
 -- items:markForCodeGen: "%globals{put(10)}" 
 -- markItem: "%globals" Property 
 -- markItem: "put(10)" ObjectGenerator 
 -- OG:markForCodeGen: "put(10)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put(10)" 
 -- "put(10)" true 
 -- 
 -- OG:markSuper: "put(10)" 
 -- Invocation:markForCodeGen: "put(10)" 
 -- ObjectInvocation:markForCodeGen: "put(10)"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put(10)" 
 -- OG:markForCodeGen: "10" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "10" 
 -- "10" true 
 -- 
 -- OG:markSuper: "10" 
 -- Invocation:markForCodeGen: "10" 
 -- not ObjDesc:  "10"  IS.isEmpty:  true 
 -- arg:   "10" 
 -- not ObjDesc:  "put(10)"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "T := 20"s"" Assign 
 -- Invocation:markForCodeGen: "T" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "T: var Time.second" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "20"s"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "20"s"" 
 -- "20"s"" true 
 -- 
 -- OG:markSuper: "20"s"" 
 -- Invocation:markForCodeGen: "20"s"" 
 -- not ObjDesc:  "20"s""  IS.isEmpty:  true 
 -- markItem: "T.print" ObjectGenerator 
 -- OG:markForCodeGen: "T.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "T.print" 
 -- "T" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "T.print" 
 -- Invocation:markForCodeGen: "T.print" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "T: var Time.second" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Second".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "T.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "V := L / T" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var MeterPerSecond" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L / T" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L / T" 
 -- "L / T" true 
 -- 
 -- OG:markSuper: "L / T" 
 -- Invocation:markForCodeGen: "L / T" 
 -- BinaryExp:markForCodeGen: "L / T" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "/ T"  ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "T" 
 -- OG:markForCodeGen: "T" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "T" 
 -- "T" false 
 -- 
 -- not ObjDesc:  "L / T"  IS.isEmpty:  true 
 -- markItem: "V.print" ObjectGenerator 
 -- OG:markForCodeGen: "V.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "V.print" 
 -- "V" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "V.print" 
 -- Invocation:markForCodeGen: "V.print" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var MeterPerSecond" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "MpS".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "V.print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "test"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      len ...}" 
 -- OG:Qalloc: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      len ...}" q ... 0 
 -- OG:Qalloc:A:  "StringLib"  super:  ""  marked:  true "StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %O ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      length: ;      ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "StringLib" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 107 IS.newDescNo: 107 objSize: 0 1: 1 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 107 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: String 
 -- Pattern:Qalloc: C 
 -- Pattern:Qalloc:B: C 
 -- Pattern:Qalloc: I2S 
 -- Pattern:Qalloc:B: I2S 
 -- Pattern:Qalloc: F2S 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 107 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %publ ...}" 
 -- IS.newDescNo: 107 IS.objSize: 1 "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  107 "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5; ...}" 
 -- ObjTmpStack:add: "StringLib" : "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;    ...}" 
 -- items:markForCodeGen: "%id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      o ...}" 
 -- markItem: "%id "String module"" Property 
 -- markItem: "%module LIB" Property 
 -- markItem: "%public" Property 
 -- Items:markString %id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V:  ...} 
 -- Pattern:markForCodeGen: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ...}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "StringLib"  ATd: "--StringLib{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "String"  ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var inte ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- markItem: "inner(X_asString)" ObjectGenerator 
 -- markItem: "inner(Object)" ObjectGenerator 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "this(Value)" 
 -- OG:markForCodeGen: "Value" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Value"  IS.isEmpty:  true 
 -- arg:   "Value" 
 -- not ObjDesc:  "this(Value)"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Veq.length"  IS.isEmpty:  true 
 -- not ObjDesc:  "(L <> Veq.length)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "leave(loop)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "leave(loop)" 
 -- OG:Qalloc: "leave(loop)" qDescno:  18 
 -- ObjTmpStack:add: "leave(loop)" 
 -- items:markForCodeGen: "leave(loop)" 
 -- markItem: "leave(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (L <> Veq.length) :then {   leave(loop)}"  IS.isEmpty:  true 
 -- markItem: "beq := true" Assign 
 -- Invocation:markForCodeGen: "beq" 
 -- ObjectInvocation:markForCodeGen: "beq"  ATd: "out Beq: var boolean" 
 -- DataItem:markForCodeGen: "Beq" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- Pattern:markForCodeGen: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean; ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "value" 
 -- "value" true 
 -- 
 -- OG:markSuper: "value" 
 -- Invocation:markForCodeGen: "value" 
 -- ObjectInvocation:markForCodeGen: "value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean;      ou ...}" 
 -- OG:Qalloc: "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean;      ou ...}" q ... 0 
 -- OG:Qalloc:A:  "Boolean"  super:  "value"  marked:  true "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   & ...}" s ... v ... 
 -- Invocation:Qalloc: "value" 
 -- ObjectInvocation:Qalloc: "value" 
 -- name: "value" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  4 0 %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inne ...} 
 -- OG:super:  "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out Beq: var boolean;      inner(= );    ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: var boolean;      out R: var bo ...}" 
 -- super:  "value" 
 -- E:  "value" 
 -- OG:Qalloc:B: "Boolean" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 108 IS.newDescNo: 108 objSize: 0 1: 1 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 108 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R: ...}" 
 -- Items:Qalloc:super: "value" size: 0 "Boolean" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "_thisBasicValue" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: && 
 -- Pattern:Qalloc: || 
 -- Pattern:Qalloc: =? 
 -- Pattern:Qalloc: not 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 108 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   ou ...}" 
 -- IS.newDescNo: 108 IS.objSize: 1 "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R: var boo ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  108 "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in  ...}" 
 -- ObjTmpStack:add: "Boolean" : "value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;      %basic 70;      in B: va ...}" 
 -- items:markForCodeGen: "%id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R: var boolean;||  : ...}" 
 -- markItem: "%id "Boolean"" Property 
 -- markItem: "%globals inSub" Property 
 -- markItem: "%basic 4, 8" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "_thisBasicValue" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Universal" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Universal" 
 -- "Universal" true 
 -- 
 -- OG:markSuper: "Universal" 
 -- Invocation:markForCodeGen: "Universal" 
 -- ObjectInvocation:markForCodeGen: "Universal"  ATd: "universal: Value{   %ID universal;   %basic 1, 32;   %globals;   +  : ;      %basic 61;      in V: var integer;      ou ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Universal"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "true" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "true" 
 -- "true" false 
 -- 
 -- OG:markSuper: "true" 
 -- Invocation:markForCodeGen: "true" 
 -- ObjectInvocation:markForCodeGen: "true"  ATd: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- Pattern:markForCodeGen: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   out B: var boolean;   B := 1}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   out B: var boolean;   B := 1}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 1}" qDescno:  23 
 -- ObjTmpStack:add: "True" : "%globals{   out B: var boolean;   B := 1}" 
 -- items:markForCodeGen: "%globals{out B: var boolean;B := 1}" 
 -- markItem: "%globals" Property 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- markItem: "B := 1" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "true"  IS.isEmpty:  true 
 -- markItem: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" false 
 -- 
 -- OG:markSuper: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- Invocation:markForCodeGen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"  ATd: "f ..." 
 -- OI:args:markForCodgen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length" 
 -- "length" false 
 -- 
 -- OG:markSuper: "length" 
 -- Invocation:markForCodeGen: "length" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- OG:Qalloc: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" qDescno:  24 
 -- ObjTmpStack:add: "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- items:markForCodeGen: "c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)}" 
 -- markItem: "c1 := get[inx]" Assign 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "c2 := Veq.get[inx]" Assign 
 -- Invocation:markForCodeGen: "c2" 
 -- ObjectInvocation:markForCodeGen: "c2"  ATd: "c2: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" true 
 -- 
 -- OG:markSuper: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- Invocation:markForCodeGen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:markForCodeGen: "(c1 <> c2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(c1 <> c2)" 
 -- "(c1 <> c2)" true 
 -- 
 -- OG:markSuper: "(c1 <> c2)" 
 -- Invocation:markForCodeGen: "(c1 <> c2)" 
 -- Invocation:markForCodeGen: "c1 <> c2" 
 -- BinaryExp:markForCodeGen: "c1 <> c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<> c2"  ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "(c1 <> c2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Beq := false{   leave(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := false{   leave(loop)}" 
 -- OG:Qalloc: "Beq := false{   leave(loop)}" qDescno:  26 
 -- ObjTmpStack:add: "Beq := false{   leave(loop)}" 
 -- items:markForCodeGen: "Beq := false{leave(loop)}" 
 -- markItem: "Beq := false" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "false" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "false" 
 -- "false" false 
 -- 
 -- OG:markSuper: "false" 
 -- Invocation:markForCodeGen: "false" 
 -- ObjectInvocation:markForCodeGen: "false"  ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- Pattern:markForCodeGen: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   out B: var boolean;   B := 0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   out B: var boolean;   B := 0}" 
 -- OG:Qalloc: "%globals{   out B: var boolean;   B := 0}" qDescno:  27 
 -- ObjTmpStack:add: "False" : "%globals{   out B: var boolean;   B := 0}" 
 -- items:markForCodeGen: "%globals{out B: var boolean;B := 0}" 
 -- markItem: "%globals" Property 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- markItem: "B := 0" Assign 
 -- Invocation:markForCodeGen: "B" 
 -- ObjectInvocation:markForCodeGen: "B"  ATd: "out B: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "false"  IS.isEmpty:  true 
 -- markItem: "leave(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}"  IS.isEmpty:  true 
 -- arg:   "1" 
 -- arg:   "length" 
 -- arg:   "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" 
 -- OG:markIS: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- OG:Qalloc: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" qDescno:  30 
 -- ObjTmpStack:add: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- items:markForCodeGen: "" 
 -- Pattern:markForCodeGen: "<=  :: {   loop: obj ;      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qw ..."}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qwerty";   ...}" 
 -- OG:Qalloc: "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qwerty";   ...}" q ... 0 
 -- OG:Qalloc:A:  "<="  super:  ""  marked:  true "<=  :: {   loop: obj ;      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc ..."}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  58 5 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    <= "Qwerty";      -- "Qwe ..."}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<=" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 109 IS.newDescNo: 109 objSize: 0 1: 1 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 109 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"  ...}" 
 -- Items:Qalloc:super: "" size: 5 "<=" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "loop" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 6 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Q ..."}" 
 -- OG:Qalloc: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" q ... 0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  false "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";    ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - false;   -- " ..."}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 110 IS.newDescNo: 110 objSize: 0 1: 1 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe ..."}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 110 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwer ..."}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: matchEq 
 -- Pattern:Qalloc:B: matchEq 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "L1" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L2" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- OG:Qalloc: "length{-- min length of this and V}" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "length{-- min length of this and V}"  marked:  false "L1 := length{-- min length of this and V}" super:  length{-- min length of this and  ...} 
 -- Invocation:Qalloc: "length{-- min length of this and V}" 
 -- ObjectInvocation:Qalloc: "length{-- min length of this and V}" 
 -- name: "length" 
 -- Arguments "-- min length of this and V" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "length{-- min length of this and V}" 
 -- super:  "length{-- min length of this and V}" 
 -- E:  "length{-- min length of this and V}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "length{-- min length of this and V}" 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- OG:Qalloc: "Veq.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "Veq.length"  marked:  false "L2 := Veq.length" super:  Veq.length 
 -- Invocation:Qalloc: "Veq.length" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.length" 
 -- super:  "Veq.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.length" 
 -- OG:Qalloc: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}"  marked:  false "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since  ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:Qalloc: "(L1 < L2)" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "(L1 < L2)"  marked:  false "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" super:  (L1 < L2) 
 -- Invocation:Qalloc: "(L1 < L2)" 
 -- Invocation:Qalloc: "L1 < L2" 
 -- BinaryExp:Qalloc: "L1 < L2" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< L2" 
 -- name: "<" 
 -- Arguments "L2" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 51{in V: var integer;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 51{   in V: var integer;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  ""  marked:  false "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 51{   in V: var integer;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 111 IS.newDescNo: 111 objSize: 0 1: 1 "%basic 51{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 111 "%basic 51{in V: var integer;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 111 "%basic 51{in V: var integer;out B: var boolean}" 
 -- IS.newDescNo: 111 IS.objSize: 5 "%basic 51{in V: var integer;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  111 "%basic 51{   in V: var integer;   out B: var boolean}" 
 -- OG:super:  "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L1 < L2)" 
 -- super:  "(L1 < L2)" 
 -- E:  "(L1 < L2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L1 < L2)" 
 -- OG:Qalloc: "L := L1" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L := L1" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 112 IS.newDescNo: 112 objSize: 0 1: 1 "L := L1" 
 -- Items:Qalloc:objSize: 0  newDescNo: 112 "L := L1" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "L1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L1"  marked:  false "L := L1" super:  L1 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L1: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1" 
 -- super:  "L1" 
 -- E:  "L1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 112 "L := L1" 
 -- IS.newDescNo: 112 IS.objSize: 1 "L := L1" 
 -- OG:Qalloc:end: IS.newDescNo:  112 "L := L1" 
 -- OG:Qalloc: "L := L2" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L := L2" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 113 IS.newDescNo: 113 objSize: 0 1: 1 "L := L2" 
 -- Items:Qalloc:objSize: 0  newDescNo: 113 "L := L2" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L := L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 113 "L := L2" 
 -- IS.newDescNo: 113 IS.objSize: 1 "L := L2" 
 -- OG:Qalloc:end: IS.newDescNo:  113 "L := L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- super:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- E:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    < ...}" s ... m ... 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(mat ...} 
 -- OG:Qalloc:SuperAlloc: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(match ...}" 
 -- OG:Qalloc: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :t ...}" q ... 0 
 -- OG:Qalloc:A:  "matchEq"  super:  ""  marked:  false "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :then ;       ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "matchEq" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 114 IS.newDescNo: 114 objSize: 0 1: 1 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 114 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "c1" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "c2" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 114 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if ...}" 
 -- IS.newDescNo: 114 IS.objSize: 4 "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :t ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  114 "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchE ...}" 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 110 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- " ..."}" 
 -- IS.newDescNo: 110 IS.objSize: 4 "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwerty" <= " ..."}" 
 -- OG:Qalloc:end: IS.newDescNo:  110 "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- ...}" 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 109 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Q ..."}" 
 -- IS.newDescNo: 109 IS.objSize: 6 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Q ..."}" 
 -- OG:Qalloc:end: IS.newDescNo:  109 "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      --  ...}" 
 -- ObjTmpStack:add: "<=  " : "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    ...}" 
 -- items:markForCodeGen: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";    ...}" 
 -- DataItem:markForCodeGen: "loop" :descNo: 110 :OG.primNo: 0 
 -- OG:markForCodeGen: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Q ..."}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" 
 -- OG:Qalloc: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" q ... 110 
 -- ObjTmpStack:add: "loop" : "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty ..."}" 
 -- items:markForCodeGen: "-- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwerty" <= "Qwe" - fal ...}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L1" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L2" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "L1 := length{-- min length of this and V}" Assign 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "length{-- min length of this and V}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "length{-- min length of this and V}" 
 -- "length{-- min length of this and V}" false 
 -- 
 -- OG:markSuper: "length{-- min length of this and V}" 
 -- Invocation:markForCodeGen: "length{-- min length of this and V}" 
 -- ObjectInvocation:markForCodeGen: "length{-- min length of this and V}"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "-- min length of this and V" 
 -- not ObjDesc:  "length{-- min length of this and V}"  IS.isEmpty:  true 
 -- markItem: "L2 := Veq.length" Assign 
 -- Invocation:markForCodeGen: "L2" 
 -- ObjectInvocation:markForCodeGen: "L2"  ATd: "L2: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Veq.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Veq.length" 
 -- "Veq" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "Veq.length" 
 -- Invocation:markForCodeGen: "Veq.length" 
 -- ObjectInvocation:markForCodeGen: "Veq"  ATd: "in Veq: var this(Value)" 
 -- DataItem:markForCodeGen: "Veq" :descNo: 0 :OG.primNo: 18 
 -- OG:markForCodeGen: "this(Value)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "this(Value)" 
 -- "this(Value)" true 
 -- 
 -- OG:markSuper: "this(Value)" 
 -- Invocation:markForCodeGen: "this(Value)" 
 -- ObjectInvocation:markForCodeGen: "this(Value)"  ATd: "this: {   %basic 18;   in this: ref Object}" 
 -- OI:args:markForCodgen: "this(Value)" 
 -- OG:markForCodeGen: "Value" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Value" 
 -- "Value" true 
 -- 
 -- OG:markSuper: "Value" 
 -- Invocation:markForCodeGen: "Value" 
 -- ObjectInvocation:markForCodeGen: "Value"  ATd: "Value: {   %ID Value;   %globals;   %basic 21;   %public;   =  :< ;      %basic 50;      in Veq: var this(Value);      out  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Value"  IS.isEmpty:  true 
 -- arg:   "Value" 
 -- not ObjDesc:  "this(Value)"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Veq.length"  IS.isEmpty:  true 
 -- markItem: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" true 
 -- 
 -- OG:markSuper: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- Invocation:markForCodeGen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:markForCodeGen: "(L1 < L2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L1 < L2)" 
 -- "(L1 < L2)" true 
 -- 
 -- OG:markSuper: "(L1 < L2)" 
 -- Invocation:markForCodeGen: "(L1 < L2)" 
 -- Invocation:markForCodeGen: "L1 < L2" 
 -- BinaryExp:markForCodeGen: "L1 < L2" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< L2"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "L2" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "(L1 < L2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L := L1" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L := L1" 
 -- OG:Qalloc: "L := L1" qDescno:  112 
 -- ObjTmpStack:add: "L := L1" 
 -- items:markForCodeGen: "L := L1" 
 -- markItem: "L := L1" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L1" 
 -- "L1" true 
 -- 
 -- OG:markForCodeGen: "L := L2" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L := L2" 
 -- OG:Qalloc: "L := L2" qDescno:  113 
 -- ObjTmpStack:add: "L := L2" 
 -- items:markForCodeGen: "L := L2" 
 -- markItem: "L := L2" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}"  IS.isEmpty:  true 
 -- markItem: "matchEq" ObjectGenerator 
 -- OG:markForCodeGen: "matchEq" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "matchEq" 
 -- "matchEq" false 
 -- 
 -- OG:markSuper: "matchEq" 
 -- Invocation:markForCodeGen: "matchEq" 
 -- ObjectInvocation:markForCodeGen: "matchEq"  ATd: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 ...}" 
 -- Pattern:markForCodeGen: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(mat ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :t ...}" 
 -- OG:Qalloc: "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      if (L2 = 0) :t ...}" q ... 114 
 -- ObjTmpStack:add: "matchEq" : "inx: var integer{   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);   ...}" 
 -- items:markForCodeGen: "inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      ...}" 
 -- DataItem:markForCodeGen: "inx" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c1" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "c2" :descNo: 0 :OG.primNo: 3 
 -- OG:markForCodeGen: "char" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "char" 
 -- "char" true 
 -- 
 -- OG:markSuper: "char" 
 -- Invocation:markForCodeGen: "char" 
 -- ObjectInvocation:markForCodeGen: "char"  ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "char"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- OG:Qalloc: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "isEmpty"  super:  ""  marked:  true "isEmpty: do {   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false; ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "isEmpty" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 115 IS.newDescNo: 115 objSize: 0 1: 1 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(match ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 115 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}"  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if ( ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:Qalloc: "(L1 = 0)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(L1 = 0)"  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" super:  (L1 = 0) 
 -- Invocation:Qalloc: "(L1 = 0)" 
 -- Invocation:Qalloc: "L1 = 0" 
 -- BinaryExp:Qalloc: "L1 = 0" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= 0" 
 -- name: "=" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L1 = 0)" 
 -- super:  "(L1 = 0)" 
 -- E:  "(L1 = 0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L1 = 0)" 
 -- OG:Qalloc: "Beq := L1 <= L2{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := L1 <= L2{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 116 IS.newDescNo: 116 objSize: 0 1: 1 "Beq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 116 "Beq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "L1 <= L2" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  "L1 <= L2"  marked:  false "Beq := L1 <= L2" super:  L1 <= L2 
 -- Invocation:Qalloc: "L1 <= L2" 
 -- BinaryExp:Qalloc: "L1 <= L2" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<= L2" 
 -- name: "<=" 
 -- Arguments "L2" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  58 5 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:super:  "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 <= L2" 
 -- super:  "L1 <= L2" 
 -- E:  "L1 <= L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 <= L2" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "Beq := L1 <= L2{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  114 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(m ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 116 "Beq := L1 <= L2{leave(matchEq)}" 
 -- IS.newDescNo: 116 IS.objSize: 1 "Beq := L1 <= L2{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  116 "Beq := L1 <= L2{   leave(matchEq)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- super:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- E:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:Qalloc: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}"  marked:  false "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2  ...}" s ... i ... 
 -- Invocation:Qalloc: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:Qalloc: "(L2 = 0)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(L2 = 0)"  marked:  false "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" super:  (L2 = 0) 
 -- Invocation:Qalloc: "(L2 = 0)" 
 -- Invocation:Qalloc: "L2 = 0" 
 -- BinaryExp:Qalloc: "L2 = 0" 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= 0" 
 -- name: "=" 
 -- Arguments "0" 
 -- OG:Qalloc: "0" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "0"  marked:  false "0" super:  0 
 -- Invocation:Qalloc: "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0" 
 -- super:  "0" 
 -- E:  "0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(L2 = 0)" 
 -- super:  "(L2 = 0)" 
 -- E:  "(L2 = 0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(L2 = 0)" 
 -- OG:Qalloc: "Beq := false{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := false{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 117 IS.newDescNo: 117 objSize: 0 1: 1 "Beq := false{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 117 "Beq := false{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "false" qDescno:  0 
 -- OG:Qalloc:A:  "False"  super:  "false"  marked:  false "Beq := false" super:  false 
 -- Invocation:Qalloc: "false" 
 -- ObjectInvocation:Qalloc: "false" 
 -- name: "false" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  27 1 %globals{out B: var boolean;B := 0} 
 -- OG:super:  "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "false" 
 -- super:  "false" 
 -- E:  "false" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "false" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "Beq := false{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  114 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(m ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 117 "Beq := false{leave(matchEq)}" 
 -- IS.newDescNo: 117 IS.objSize: 1 "Beq := false{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  117 "Beq := false{   leave(matchEq)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- super:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- E:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 115 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- IS.newDescNo: 115 IS.objSize: 1 "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  115 "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- ObjTmpStack:add: "isEmpty" : "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- items:markForCodeGen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)}" 
 -- markItem: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" true 
 -- 
 -- OG:markSuper: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- Invocation:markForCodeGen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:markForCodeGen: "(L1 = 0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L1 = 0)" 
 -- "(L1 = 0)" true 
 -- 
 -- OG:markSuper: "(L1 = 0)" 
 -- Invocation:markForCodeGen: "(L1 = 0)" 
 -- Invocation:markForCodeGen: "L1 = 0" 
 -- BinaryExp:markForCodeGen: "L1 = 0" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(L1 = 0)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Beq := L1 <= L2{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := L1 <= L2{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := L1 <= L2{   leave(matchEq)}" qDescno:  116 
 -- ObjTmpStack:add: "Beq := L1 <= L2{   leave(matchEq)}" 
 -- items:markForCodeGen: "Beq := L1 <= L2{leave(matchEq)}" 
 -- markItem: "Beq := L1 <= L2" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- DataItem:markForCodeGen: "Beq" :descNo: 0 :OG.primNo: 4 
 -- OG:markForCodeGen: "boolean" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "boolean" 
 -- "boolean" true 
 -- 
 -- OG:markSuper: "boolean" 
 -- Invocation:markForCodeGen: "boolean" 
 -- ObjectInvocation:markForCodeGen: "boolean"  ATd: "Boolean: value{   %id "Boolean";   %globals inSub;   %basic 4, 8;   %public;   _thisBasicValue: var Universal;   &&  : ;  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "boolean"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L1 <= L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L1 <= L2" 
 -- "L1 <= L2" true 
 -- 
 -- OG:markSuper: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1 <= L2" 
 -- BinaryExp:markForCodeGen: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:args:markForCodgen: "L2" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "L1 <= L2"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- not ObjDesc:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}"  IS.isEmpty:  true 
 -- markItem: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" true 
 -- 
 -- OG:markSuper: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- Invocation:markForCodeGen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:markForCodeGen: "(L2 = 0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(L2 = 0)" 
 -- "(L2 = 0)" true 
 -- 
 -- OG:markSuper: "(L2 = 0)" 
 -- Invocation:markForCodeGen: "(L2 = 0)" 
 -- Invocation:markForCodeGen: "L2 = 0" 
 -- BinaryExp:markForCodeGen: "L2 = 0" 
 -- Invocation:markForCodeGen: "L2" 
 -- ObjectInvocation:markForCodeGen: "L2"  ATd: "L2: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "0" 
 -- OG:markForCodeGen: "0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0" 
 -- "0" true 
 -- 
 -- OG:markSuper: "0" 
 -- Invocation:markForCodeGen: "0" 
 -- not ObjDesc:  "0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(L2 = 0)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Beq := false{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := false{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := false{   leave(matchEq)}" qDescno:  117 
 -- ObjTmpStack:add: "Beq := false{   leave(matchEq)}" 
 -- items:markForCodeGen: "Beq := false{leave(matchEq)}" 
 -- markItem: "Beq := false" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "false" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "false" 
 -- "false" false 
 -- 
 -- OG:markSuper: "false" 
 -- Invocation:markForCodeGen: "false" 
 -- ObjectInvocation:markForCodeGen: "false"  ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "false"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- not ObjDesc:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- OG:Qalloc: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  ""  marked:  true "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;      ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "loop" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 118 IS.newDescNo: 118 objSize: 0 1: 1 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 118 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- OG:Qalloc: "inx + 1" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "inx + 1"  marked:  false "inx := inx + 1" super:  inx + 1 
 -- Invocation:Qalloc: "inx + 1" 
 -- BinaryExp:Qalloc: "inx + 1" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ 1" 
 -- name: "+" 
 -- Arguments "1" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "1" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  60 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx + 1" 
 -- super:  "inx + 1" 
 -- E:  "inx + 1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx + 1" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "c1 := get[inx]" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- OG:Qalloc: "Veq.get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "Veq.get[inx]"  marked:  false "c2 := Veq.get[inx]" super:  Veq.get[inx] 
 -- Invocation:Qalloc: "Veq.get[inx]" 
 -- ObjectInvocation:Qalloc: "Veq" 
 -- name: "Veq" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Veq.get[inx]" 
 -- super:  "Veq.get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Veq.get[inx]" 
 -- OG:Qalloc: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}"  marked:  false "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if ( ...}" s ... i ... 
 -- Invocation:Qalloc: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:Qalloc: "(c1 = c2)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(c1 = c2)"  marked:  false "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" super:  (c1 = c2) 
 -- Invocation:Qalloc: "(c1 = c2)" 
 -- Invocation:Qalloc: "c1 = c2" 
 -- BinaryExp:Qalloc: "c1 = c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= c2" 
 -- name: "=" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 = c2)" 
 -- super:  "(c1 = c2)" 
 -- E:  "(c1 = c2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 = c2)" 
 -- OG:Qalloc: "if (inx < L) :then {      restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (inx < L) :then {      restart(loop)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 119 IS.newDescNo: 119 objSize: 0 1: 1 "if (inx < L) :then {   restart(loop)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 119 "if (inx < L) :then {   restart(loop)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (inx < L) :then {   restart(loop)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (inx < L) :then {   restart(loop)}"  marked:  false "if (inx < L) :then {   restart(loop)}" super:  if (inx < L) :then {   restart(l ...} 
 -- Invocation:Qalloc: "if (inx < L) :then {   restart(loop)}" 
 -- OG:Qalloc: "(inx < L)" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "(inx < L)"  marked:  false "if (inx < L) :then {   restart(loop)}" super:  (inx < L) 
 -- Invocation:Qalloc: "(inx < L)" 
 -- Invocation:Qalloc: "inx < L" 
 -- BinaryExp:Qalloc: "inx < L" 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< L" 
 -- name: "<" 
 -- Arguments "L" 
 -- OG:Qalloc: "L" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L"  marked:  false "L" super:  L 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L" 
 -- super:  "L" 
 -- E:  "L" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  111 5 %basic 51{in V: var integer;out B: var boolean} 
 -- OG:super:  "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(inx < L)" 
 -- super:  "(inx < L)" 
 -- E:  "(inx < L)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(inx < L)" 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (inx < L) :then {   restart(loop)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 120 IS.newDescNo: 120 objSize: 0 1: 1 "restart(loop)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 120 "restart(loop)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "restart(loop)" qDescno:  0 
 -- OG:Qalloc:A:  "restart"  super:  "restart(loop)"  marked:  false "restart(loop)" super:  restart(loop) 
 -- Invocation:Qalloc: "restart(loop)" 
 -- ObjectInvocation:Qalloc: "restart(loop)" 
 -- name: "restart" 
 -- Arguments "restart(loop)" 
 -- OG:Qalloc: "loop" qDescno:  0 
 -- OG:Qalloc:A:  "loop"  super:  "loop"  marked:  false "restart(loop)" super:  loop 
 -- Invocation:Qalloc: "loop" 
 -- ObjectInvocation:Qalloc: "loop" 
 -- name: "loop" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  118 1 inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)} 
 -- OG:super:  "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "loop" 
 -- super:  "loop" 
 -- E:  "loop" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "loop" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  61 2 %basic 102 
 -- OG:super:  "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "restart(loop)" 
 -- super:  "restart(loop)" 
 -- E:  "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "restart(loop)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 120 "restart(loop)" 
 -- IS.newDescNo: 120 IS.objSize: 1 "restart(loop)" 
 -- OG:Qalloc:end: IS.newDescNo:  120 "restart(loop)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (inx < L) :then {   restart(loop)}" 
 -- super:  "if (inx < L) :then {   restart(loop)}" 
 -- E:  "if (inx < L) :then {   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (inx < L) :then {   restart(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 119 "if (inx < L) :then {   restart(loop)}" 
 -- IS.newDescNo: 119 IS.objSize: 1 "if (inx < L) :then {   restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  119 "if (inx < L) :then {      restart(loop)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- super:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- E:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 118 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- IS.newDescNo: 118 IS.objSize: 1 "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- OG:Qalloc:end: IS.newDescNo:  118 "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- ObjTmpStack:add: "loop" : "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- items:markForCodeGen: "inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)}" 
 -- markItem: "inx := inx + 1" Assign 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "inx + 1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx + 1" 
 -- "inx + 1" true 
 -- 
 -- OG:markSuper: "inx + 1" 
 -- Invocation:markForCodeGen: "inx + 1" 
 -- BinaryExp:markForCodeGen: "inx + 1" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "1" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- not ObjDesc:  "inx + 1"  IS.isEmpty:  true 
 -- markItem: "c1 := get[inx]" Assign 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "c2 := Veq.get[inx]" Assign 
 -- Invocation:markForCodeGen: "c2" 
 -- ObjectInvocation:markForCodeGen: "c2"  ATd: "c2: var char" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- Invocation:markForCodeGen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:markForCodeGen: "(c1 = c2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(c1 = c2)" 
 -- "(c1 = c2)" true 
 -- 
 -- OG:markSuper: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "c1 = c2" 
 -- BinaryExp:markForCodeGen: "c1 = c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "(c1 = c2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "if (inx < L) :then {      restart(loop)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (inx < L) :then {      restart(loop)}" 
 -- OG:Qalloc: "if (inx < L) :then {      restart(loop)}" qDescno:  119 
 -- ObjTmpStack:add: "if (inx < L) :then {      restart(loop)}" 
 -- items:markForCodeGen: "if (inx < L) :then {   restart(loop)}" 
 -- markItem: "if (inx < L) :then {   restart(loop)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (inx < L) :then {   restart(loop)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (inx < L) :then {   restart(loop)}" 
 -- "if (inx < L) :then {   restart(loop)}" true 
 -- 
 -- OG:markSuper: "if (inx < L) :then {   restart(loop)}" 
 -- Invocation:markForCodeGen: "if (inx < L) :then {   restart(loop)}" 
 -- OG:markForCodeGen: "(inx < L)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(inx < L)" 
 -- "(inx < L)" true 
 -- 
 -- OG:markSuper: "(inx < L)" 
 -- Invocation:markForCodeGen: "(inx < L)" 
 -- Invocation:markForCodeGen: "inx < L" 
 -- BinaryExp:markForCodeGen: "inx < L" 
 -- Invocation:markForCodeGen: "inx" 
 -- ObjectInvocation:markForCodeGen: "inx"  ATd: "inx: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< L"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:args:markForCodgen: "L" 
 -- OG:markForCodeGen: "L" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L" 
 -- "L" true 
 -- 
 -- not ObjDesc:  "(inx < L)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "restart(loop)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "restart(loop)" 
 -- OG:Qalloc: "restart(loop)" qDescno:  120 
 -- ObjTmpStack:add: "restart(loop)" 
 -- items:markForCodeGen: "restart(loop)" 
 -- markItem: "restart(loop)" ObjectGenerator 
 -- not ObjDesc:  "if (inx < L) :then {   restart(loop)}"  IS.isEmpty:  true 
 -- not ObjDesc:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- OG:Qalloc: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "doit"  super:  ""  marked:  true "doit: do {   if (c1 = c2) :then ;      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 <  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "doit" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 121 IS.newDescNo: 121 objSize: 0 1: 1 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   le ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 121 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- OG:Qalloc: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}"  marked:  false "i ..." s ... i ... 
 -- Invocation:Qalloc: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:Qalloc: "(c1 = c2)" qDescno:  0 
 -- OG:Qalloc:A:  "="  super:  "(c1 = c2)"  marked:  false "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchE ...}" s ... ( ... 
 -- Invocation:Qalloc: "(c1 = c2)" 
 -- Invocation:Qalloc: "c1 = c2" 
 -- BinaryExp:Qalloc: "c1 = c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "= c2" 
 -- name: "=" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  11 5 %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- OG:super:  "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(c1 = c2)" 
 -- super:  "(c1 = c2)" 
 -- E:  "(c1 = c2)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(c1 = c2)" 
 -- OG:Qalloc: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" sup ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 122 IS.newDescNo: 122 objSize: 0 1: 1 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 122 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "L1 <= L2" qDescno:  0 
 -- OG:Qalloc:A:  "<="  super:  "L1 <= L2"  marked:  false "Beq := L1 <= L2" super:  L1 <= L2 
 -- Invocation:Qalloc: "L1 <= L2" 
 -- BinaryExp:Qalloc: "L1 <= L2" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "<= L2" 
 -- name: "<=" 
 -- Arguments "L2" 
 -- OG:Qalloc: "L2" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L2"  marked:  false "L2" super:  L2 
 -- Invocation:Qalloc: "L2" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L2: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2" 
 -- super:  "L2" 
 -- E:  "L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  58 5 %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- OG:super:  "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 <= L2" 
 -- super:  "L1 <= L2" 
 -- E:  "L1 <= L2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 <= L2" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  114 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(m ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 122 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- IS.newDescNo: 122 IS.objSize: 1 "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  122 "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := c1 < c2{   leave(matchEq)}" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" sup ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Beq := c1 < c2{   leave(matchEq)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 123 IS.newDescNo: 123 objSize: 0 1: 1 "Beq := c1 < c2{leave(matchEq)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 123 "Beq := c1 < c2{leave(matchEq)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "Beq" 
 -- ObjectInvocation:Qalloc: "Beq" 
 -- name: "Beq" 
 -- Arguments "" 
 -- OG:Qalloc: "c1 < c2" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "c1 < c2"  marked:  false "Beq := c1 < c2" super:  c1 < c2 
 -- Invocation:Qalloc: "c1 < c2" 
 -- BinaryExp:Qalloc: "c1 < c2" 
 -- Invocation:Qalloc: "c1" 
 -- ObjectInvocation:Qalloc: "c1" 
 -- name: "c1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< c2" 
 -- name: "<" 
 -- Arguments "c2" 
 -- OG:Qalloc: "c2" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "c2"  marked:  false "c2" super:  c2 
 -- Invocation:Qalloc: "c2" 
 -- ObjectInvocation:Qalloc: "c2" 
 -- name: "c2" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "c2: var char" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c2" 
 -- super:  "c2" 
 -- E:  "c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c2" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 51{in V: var char;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 51{   in V: var char;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  ""  marked:  false "<  : {   %basic 51;   in V: var char;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 51{   in V: var char;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 124 IS.newDescNo: 124 objSize: 0 1: 1 "%basic 51{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 124 "%basic 51{in V: var char;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 124 "%basic 51{in V: var char;out B: var boolean}" 
 -- IS.newDescNo: 124 IS.objSize: 5 "%basic 51{in V: var char;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  124 "%basic 51{   in V: var char;   out B: var boolean}" 
 -- OG:super:  "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "c1 < c2" 
 -- super:  "c1 < c2" 
 -- E:  "c1 < c2" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "c1 < c2" 
 -- OG:Qalloc: "leave(matchEq)" qDescno:  0 
 -- OG:Qalloc:A:  "leave"  super:  "leave(matchEq)"  marked:  false "Beq := c1 < c2{leave(matchEq)}" super:  leave(matchEq) 
 -- Invocation:Qalloc: "leave(matchEq)" 
 -- ObjectInvocation:Qalloc: "leave(matchEq)" 
 -- name: "leave" 
 -- Arguments "leave(matchEq)" 
 -- OG:Qalloc: "matchEq" qDescno:  0 
 -- OG:Qalloc:A:  "matchEq"  super:  "matchEq"  marked:  false "leave(matchEq)" super:  matchEq 
 -- Invocation:Qalloc: "matchEq" 
 -- ObjectInvocation:Qalloc: "matchEq" 
 -- name: "matchEq" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  114 4 inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(m ...} 
 -- OG:super:  "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);      i ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "matchEq" 
 -- super:  "matchEq" 
 -- E:  "matchEq" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "matchEq" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  19 2 %basic 103 
 -- OG:super:  "leave(V: var integer): {   %basic 103}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "leave(matchEq)" 
 -- super:  "leave(matchEq)" 
 -- E:  "leave(matchEq)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "leave(matchEq)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 123 "Beq := c1 < c2{leave(matchEq)}" 
 -- IS.newDescNo: 123 IS.objSize: 1 "Beq := c1 < c2{leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  123 "Beq := c1 < c2{   leave(matchEq)}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- super:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- E:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 121 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- IS.newDescNo: 121 IS.objSize: 1 "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:Qalloc:end: IS.newDescNo:  121 "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- ObjTmpStack:add: "doit" : "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- items:markForCodeGen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- markItem: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" ObjectGenerator 
 -- OG:markForCodeGen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" true 
 -- 
 -- OG:markSuper: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- Invocation:markForCodeGen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:markForCodeGen: "(c1 = c2)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(c1 = c2)" 
 -- "(c1 = c2)" true 
 -- 
 -- OG:markSuper: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "(c1 = c2)" 
 -- Invocation:markForCodeGen: "c1 = c2" 
 -- BinaryExp:markForCodeGen: "c1 = c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "= c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "(c1 = c2)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- OG:Qalloc: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" qDescno:  122 
 -- ObjTmpStack:add: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 -- items:markForCodeGen: "-- we have inx = LBeq := L1 <= L2{leave(matchEq)}" 
 -- markItem: "Beq := L1 <= L2" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L1 <= L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L1 <= L2" 
 -- "L1 <= L2" true 
 -- 
 -- OG:markSuper: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1 <= L2" 
 -- BinaryExp:markForCodeGen: "L1 <= L2" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "<= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:args:markForCodgen: "L2" 
 -- OG:markForCodeGen: "L2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L2" 
 -- "L2" true 
 -- 
 -- not ObjDesc:  "L1 <= L2"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- OG:markForCodeGen: "Beq := c1 < c2{   leave(matchEq)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "Beq := c1 < c2{   leave(matchEq)}" 
 -- OG:Qalloc: "Beq := c1 < c2{   leave(matchEq)}" qDescno:  123 
 -- ObjTmpStack:add: "Beq := c1 < c2{   leave(matchEq)}" 
 -- items:markForCodeGen: "Beq := c1 < c2{leave(matchEq)}" 
 -- markItem: "Beq := c1 < c2" Assign 
 -- Invocation:markForCodeGen: "Beq" 
 -- ObjectInvocation:markForCodeGen: "Beq"  ATd: "out Beq: var boolean" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "c1 < c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c1 < c2" 
 -- "c1 < c2" true 
 -- 
 -- OG:markSuper: "c1 < c2" 
 -- Invocation:markForCodeGen: "c1 < c2" 
 -- BinaryExp:markForCodeGen: "c1 < c2" 
 -- Invocation:markForCodeGen: "c1" 
 -- ObjectInvocation:markForCodeGen: "c1"  ATd: "c1: var char" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< c2"  ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "c2" 
 -- OG:markForCodeGen: "c2" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "c2" 
 -- "c2" true 
 -- 
 -- not ObjDesc:  "c1 < c2"  IS.isEmpty:  true 
 -- markItem: "leave(matchEq)" ObjectGenerator 
 -- not ObjDesc:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "matchEq"  IS.isEmpty:  true 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "inner(puttext)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(puttext)" 
 -- OG:Qalloc: "inner(puttext)" qDescno:  0 
 -- OG:Qalloc:A:  "puttext"  super:  ""  marked:  true "puttext(T: var LIB.StringLib.String):< {   inner(puttext)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(puttext)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "puttext" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 125 IS.newDescNo: 125 objSize: 0 1: 1 "inner(puttext)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 125 "inner(puttext)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{T: var LIB.StringLib.String;%$E ")"}" 
 -- dataitem:qalloc: "T" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "T: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{T: var LIB.StringLib.String;%$E ")"}" 
 -- OG:Qalloc: "inner(puttext)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(puttext)"  marked:  false "inner(puttext)" super:  inner(puttext) 
 -- Invocation:Qalloc: "inner(puttext)" 
 -- ObjectInvocation:Qalloc: "inner(puttext)" 
 -- name: "inner" 
 -- Arguments "inner(puttext)" 
 -- OG:Qalloc: "puttext" qDescno:  0 
 -- OG:Qalloc:A:  "puttext"  super:  "puttext"  marked:  false "inner(puttext)" super:  puttext 
 -- Invocation:Qalloc: "puttext" 
 -- ObjectInvocation:Qalloc: "puttext" 
 -- name: "puttext" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  125 2 inner(puttext) 
 -- OG:super:  "puttext(T: var LIB.StringLib.String):< {   inner(puttext)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "puttext" 
 -- super:  "puttext" 
 -- E:  "puttext" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "puttext" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(puttext)" 
 -- super:  "inner(puttext)" 
 -- E:  "inner(puttext)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(puttext)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 125 "inner(puttext)" 
 -- IS.newDescNo: 125 IS.objSize: 2 "inner(puttext)" 
 -- OG:Qalloc:end: IS.newDescNo:  125 "inner(puttext)" 
 -- ObjTmpStack:add: "puttext(T: var LIB.StringLib.String)" : "inner(puttext)" 
 -- items:markForCodeGen: "inner(puttext)" 
 -- markItem: "inner(puttext)" ObjectGenerator 
 -- Pattern:markForCodeGen: "putint(V: var Integer):< {   inner(putint)}" 
 -- items:markForCodeGen: "%$B "("{V: var Integer;%$E ")"}" 
 -- markItem: "%$B "("" Property 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Integer" 
 -- "Integer" true 
 -- 
 -- OG:markSuper: "Integer" 
 -- Invocation:markForCodeGen: "Integer" 
 -- ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Integer"  IS.isEmpty:  true 
 -- markItem: "%$E ")"" Property 
 -- OG:markForCodeGen: "inner(putint)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(putint)" 
 -- OG:Qalloc: "inner(putint)" qDescno:  0 
 -- OG:Qalloc:A:  "putint"  super:  ""  marked:  true "putint(V: var Integer):< {   inner(putint)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(putint)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "putint" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 126 IS.newDescNo: 126 objSize: 0 1: 1 "inner(putint)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 126 "inner(putint)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var Integer;%$E ")"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "%$B "("{V: var Integer;%$E ")"}" 
 -- OG:Qalloc: "inner(putint)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(putint)"  marked:  false "inner(putint)" super:  inner(putint) 
 -- Invocation:Qalloc: "inner(putint)" 
 -- ObjectInvocation:Qalloc: "inner(putint)" 
 -- name: "inner" 
 -- Arguments "inner(putint)" 
 -- OG:Qalloc: "putint" qDescno:  0 
 -- OG:Qalloc:A:  "putint"  super:  "putint"  marked:  false "inner(putint)" super:  putint 
 -- Invocation:Qalloc: "putint" 
 -- ObjectInvocation:Qalloc: "putint" 
 -- name: "putint" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  126 2 inner(putint) 
 -- OG:super:  "putint(V: var Integer):< {   inner(putint)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "putint" 
 -- super:  "putint" 
 -- E:  "putint" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "putint" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(putint)" 
 -- super:  "inner(putint)" 
 -- E:  "inner(putint)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(putint)" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 126 "inner(putint)" 
 -- IS.newDescNo: 126 IS.objSize: 2 "inner(putint)" 
 -- OG:Qalloc:end: IS.newDescNo:  126 "inner(putint)" 
 -- ObjTmpStack:add: "putint(V: var Integer)" : "inner(putint)" 
 -- items:markForCodeGen: "inner(putint)" 
 -- markItem: "inner(putint)" ObjectGenerator 
 -- not ObjDesc:  "ConsoleIF"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoE ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmB ...}" 
 -- OG:Qalloc: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmB ...}" q ... 0 
 -- OG:Qalloc:A:  "workspace"  super:  ""  marked:  true "workspace: obj {   %id "workspace";   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_bound ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicSys;--A ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "workspace" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 127 IS.newDescNo: 127 objSize: 0 1: 1 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--Abstrac ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 127 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPre ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- ModuleItem:Qalloc:  --AbstractEx{} 
 -- ModuleItem:Qalloc:  --AccessEx{} 
 -- ModuleItem:Qalloc:  --ApplyPred{} 
 -- ModuleItem:Qalloc:  --ArduinoEx{} 
 -- ModuleItem:Qalloc:  --ArmBasicSys{} 
 -- ModuleItem:Qalloc:  --ArmLed{} 
 -- ModuleItem:Qalloc:  --ArmMultiCore{} 
 -- ModuleItem:Qalloc:  --CAStest{} 
 -- ModuleItem:Qalloc:  --CAStestCore{} 
 -- ModuleItem:Qalloc:  --CoroutineEx{} 
 -- ModuleItem:Qalloc:  --CppEx{} 
 -- ModuleItem:Qalloc:  --DumpObjEx{} 
 -- ModuleItem:Qalloc:  --Errors{} 
 -- ModuleItem:Qalloc:  --FoolishUnitEx{} 
 -- ModuleItem:Qalloc:  --ForkGC{} 
 -- ModuleItem:Qalloc:  --FuncVirtExVclass{} 
 -- ModuleItem:Qalloc:  --FunctionalVirtEx{} 
 -- ModuleItem:Qalloc:  --Jurgen{} 
 -- ModuleItem:Qalloc:  --LLVMex{} 
 -- ModuleItem:Qalloc:  --ListLiteralEx{} 
 -- ModuleItem:Qalloc:  --LockTestCore{} 
 -- ModuleItem:Qalloc:  --MVRsystem{} 
 -- ModuleItem:Qalloc:  --MapEx{} 
 -- ModuleItem:Qalloc:  --MiniVal{} 
 -- ModuleItem:Qalloc:  --NewInner{} 
 -- ModuleItem:Qalloc:  --NewSyntax{} 
 -- ModuleItem:Qalloc:  --NoneEx{} 
 -- ModuleItem:Qalloc:  --ObjectAndValues{} 
 -- ModuleItem:Qalloc:  --ReadersSingleWriter{} 
 -- ModuleItem:Qalloc:  --RemoteSuperVC{} 
 -- ModuleItem:Qalloc:  --Restrictions{} 
 -- ModuleItem:Qalloc:  --SlideEx{} 
 -- ModuleItem:Qalloc:  --Sub1{} 
 -- ModuleItem:Qalloc:  --TST{} 
 -- ModuleItem:Qalloc:  --TstBreak{} 
 -- ModuleItem:Qalloc:  --UnitIssues{} 
 -- ModuleItem:Qalloc:  --UnitKindEx{} 
 -- ModuleItem:Qalloc:  --UnitTest{} 
 -- ModuleItem:Qalloc:  --ValueArray{} 
 -- ModuleItem:Qalloc:  --ValueConv{} 
 -- ModuleItem:Qalloc:  --ValueEx{} 
 -- ModuleItem:Qalloc:  --ValueItemEx{} 
 -- ModuleItem:Qalloc:  --ValueTypes{} 
 -- ModuleItem:Qalloc:  --VirtError{} 
 -- ModuleItem:Qalloc:  --VirtualEx{} 
 -- ModuleItem:Qalloc:  --Visibility{} 
 -- ModuleItem:Qalloc:  --demo{} 
 -- Qalloc:module: demo 
 -- Module:alloc:off: 2 demo: obj {   %id "demo";   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--Co ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --embodyex{} 
 -- ModuleItem:Qalloc:  --hello{} 
 -- ModuleItem:Qalloc:  --qbetaCmp{} 
 -- ModuleItem:Qalloc:  --test{} 
 -- ModuleItem:Qalloc:  --tiny{} 
 -- ModuleItem:Qalloc:  --tinyA{} 
 -- ModuleItem:Qalloc:  --tinyAA{} 
 -- ModuleItem:Qalloc:  --tinyAB{} 
 -- ModuleItem:Qalloc:  --tinyAC{} 
 -- ModuleItem:Qalloc:  --tinyB{} 
 -- ModuleItem:Qalloc:  --tinyC{} 
 -- ModuleItem:Qalloc:  --tinyD{} 
 -- ModuleItem:Qalloc:  --tinyE{} 
 -- ModuleItem:Qalloc:  --tinyF{} 
 -- ModuleItem:Qalloc:  --tinyG{} 
 -- ModuleItem:Qalloc:  --tinyH{} 
 -- ModuleItem:Qalloc:  --tinyI{} 
 -- ModuleItem:Qalloc:  --tinyJ{} 
 -- ModuleItem:Qalloc:  --tinyP{} 
 -- ModuleItem:Qalloc:  --tinyQ{} 
 -- ModuleItem:Qalloc:  --tinyR{} 
 -- ModuleItem:Qalloc:  --tinyS{} 
 -- ModuleItem:Qalloc:  --tinyV{} 
 -- ModuleItem:Qalloc:  --tinyW{} 
 -- ModuleItem:Qalloc:  --tinyX{} 
 -- ModuleItem:Qalloc:  --tinyY{} 
 -- ModuleItem:Qalloc:  --tinyZ{} 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 127 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--Appl ...}" 
 -- IS.newDescNo: 127 IS.objSize: 2 "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPred;--Ardu ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  127 "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--Apply ...}" 
 -- ObjTmpStack:add: "workspace" : "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPre ...}" 
 -- items:markForCodeGen: "%id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--Ar ...}" 
 -- markItem: "%id "workspace"" Property 
 -- markItem: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib" Property 
 -- markItem: "%domain_boundary" Property 
 -- OG:markForCodeGen: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--C ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx ...}" 
 -- OG:Qalloc: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx ...}" q ... 0 
 -- OG:Qalloc:A:  "demo"  super:  ""  marked:  true "demo: obj {   %id "demo";   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--Che ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx;--Factoria ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "demo" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 128 IS.newDescNo: 128 objSize: 0 1: 1 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--Che ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 128 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg; ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- ModuleItem:Qalloc:  --AnimalMonitorSystem{} 
 -- ModuleItem:Qalloc:  --ArrayDemos{} 
 -- ModuleItem:Qalloc:  --Bank{} 
 -- ModuleItem:Qalloc:  --BasicValueSub{} 
 -- ModuleItem:Qalloc:  --BinTreeMerge{} 
 -- ModuleItem:Qalloc:  --Break{} 
 -- ModuleItem:Qalloc:  --COSex{} 
 -- ModuleItem:Qalloc:  --ChemicalPlantSystem{} 
 -- ModuleItem:Qalloc:  --CoArg{} 
 -- ModuleItem:Qalloc:  --CollectionEx{} 
 -- ModuleItem:Qalloc:  --ComplexEx{} 
 -- ModuleItem:Qalloc:  --FactorialEx{} 
 -- ModuleItem:Qalloc:  --FileDemo{} 
 -- ModuleItem:Qalloc:  --ForkJoinEx{} 
 -- ModuleItem:Qalloc:  --Formater{} 
 -- ModuleItem:Qalloc:  --ISoLA2022{} 
 -- ModuleItem:Qalloc:  --KBprocess{} 
 -- ModuleItem:Qalloc:  --LibraEx{} 
 -- ModuleItem:Qalloc:  --MixedScheduling{} 
 -- ModuleItem:Qalloc:  --MonitorDemo{} 
 -- ModuleItem:Qalloc:  --NonBlockingIOex{} 
 -- ModuleItem:Qalloc:  --NullList{} 
 -- ModuleItem:Qalloc:  --PointEx{} 
 -- ModuleItem:Qalloc:  --Robots{} 
 -- ModuleItem:Qalloc:  --SCPex{} 
 -- ModuleItem:Qalloc:  --SimpleEx{} 
 -- ModuleItem:Qalloc:  --SimpleThreadEx{} 
 -- ModuleItem:Qalloc:  --SocketEx{} 
 -- ModuleItem:Qalloc:  --Static{} 
 -- ModuleItem:Qalloc:  --TempEx{} 
 -- ModuleItem:Qalloc:  --ToyCar{} 
 -- ModuleItem:Qalloc:  --UnitEx{} 
 -- Qalloc:module: UnitEx 
 -- Module:alloc:off: 2 UnitEx: obj {   %requires Dimensions, Area, Length, Temperature, Velocity, Time;   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var ...} 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- ModuleItem:Qalloc:  --Units{} 
 -- ModuleItem:Qalloc:  --ValueDemo{} 
 -- ModuleItem:Qalloc:  --localsEx{} 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 128 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--Co ...}" 
 -- IS.newDescNo: 128 IS.objSize: 2 "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--Collec ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  128 "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--C ...}" 
 -- ObjTmpStack:add: "demo" : "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--Collectio ...}" 
 -- items:markForCodeGen: "%id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--C ...}" 
 -- markItem: "%id "demo"" Property 
 -- OG:markForCodeGen: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.SquareMete ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.SquareMeter;       ...}" 
 -- OG:Qalloc: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.SquareMeter;       ...}" q ... 0 
 -- OG:Qalloc:A:  "UnitEx"  super:  ""  marked:  true "UnitEx: obj {   %requires Dimensions, Area, Length, Temperature, Velocity, Time;   %visible Dimensions;   Figure: ;      ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.SquareMeter;         inner(th ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "UnitEx" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 129 IS.newDescNo: 129 objSize: 0 1: 1 "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 129 "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.S ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Pattern:Qalloc: Figure 
 -- Pattern:Qalloc:B: Figure 
 -- Pattern:Qalloc: Rectangle 
 -- Pattern:Qalloc:B: Rectangle 
 -- Pattern:Qalloc: temperatureEx 
 -- Pattern:Qalloc:B: temperatureEx 
 -- Pattern:Qalloc: LengthEx 
 -- Pattern:Qalloc:B: LengthEx 
 -- dataitem:qalloc: "L1" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L2" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('!');      mag ...}" q ... 0 
 -- OG:Qalloc:A:  "Foot"  super:  "Unit"  marked:  false "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0. ...}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('!');      magnitude := b ...}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "Foot" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 130 IS.newDescNo: 130 objSize: 0 1: 1 "%unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrim ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 130 "%unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrimary:: ;   put('!');   mag ...}" 
 -- Items:Qalloc:super: "Unit" size: 2 "Foot" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$131 
 -- Pattern:Qalloc:B: thisUnit$131 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 130 "%unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrimary:: ;   put('!');   ...}" 
 -- IS.newDescNo: 130 IS.objSize: 2 "%unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrimary:: ;   put('!');   magnitude : ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  130 "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;  ...}" 
 -- new_size:A: true   "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('!');     ...}" 
 -- newDescNo: 130 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "L3" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 8 "R: obj Rectangle" 
 -- OG:Qalloc: "Rectangle" qDescno:  0 
 -- OG:Qalloc:A:  "Rectangle"  super:  "Rectangle"  marked:  false "R: obj Rectangle" super:  Rectangle 
 -- Invocation:Qalloc: "Rectangle" 
 -- ObjectInvocation:Qalloc: "Rectangle" 
 -- name: "Rectangle" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width ...} 
 -- OG:Qalloc:SuperAlloc: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      wi ...}" 
 -- OG:Qalloc: "Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width := w;      heigth  ...}" q ... 0 
 -- OG:Qalloc:A:  "Rectangle"  super:  "Figure"  marked:  false "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter ...}" s ... F ... 
 -- Invocation:Qalloc: "Figure" 
 -- ObjectInvocation:Qalloc: "Figure" 
 -- name: "Figure" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 theArea:< {   out A: var Area.SquareMeter;   inner(theArea);print:< ;   printMore:< ;      inner(printMore);   AR:  ...} 
 -- OG:Qalloc:SuperAlloc: "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var ...}" 
 -- OG:Qalloc: "theArea:< {      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area.SquareMeter;      ...}" q ... 0 
 -- OG:Qalloc:A:  "Figure"  super:  ""  marked:  false "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         i ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "theArea:< {      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area.SquareMeter;      "Figure:". ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Figure" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 132 IS.newDescNo: 132 objSize: 0 1: 1 "theArea:< {   out A: var Area.SquareMeter;   inner(theArea);print:< ;   printMore:< ;      inner(printMor ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 132 "theArea:< {   out A: var Area.SquareMeter;   inner(theArea);print:< ;   printMore:< ;      inner(printMore);   AR: var Area.Square ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: theArea 
 -- Pattern:Qalloc:B: theArea 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 132 "theArea:< {   out A: var Area.SquareMeter;   inner(theArea);print:< ;   printMore:< ;      inner(printMore);   AR: var Area.Sq ...}" 
 -- IS.newDescNo: 132 IS.objSize: 1 "theArea:< {   out A: var Area.SquareMeter;   inner(theArea);print:< ;   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  132 "theArea:< {      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var ...}" 
 -- OG:super:  "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area.Squar ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width := w;      heigth := h;   the ...}" 
 -- super:  "Figure" 
 -- E:  "Figure" 
 -- OG:Qalloc:B: "Rectangle" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 133 IS.newDescNo: 133 objSize: 0 1: 1 "width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Mete ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 133 "width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth ...}" 
 -- Items:Qalloc:super: "Figure" size: 1 "Rectangle" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "width" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "heigth" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Pattern:Qalloc: set 
 -- Pattern:Qalloc:B: set 
 -- Pattern:Qalloc: theArea 
 -- Pattern:Qalloc:B: theArea 
 -- Pattern:Qalloc: perimeter 
 -- Pattern:Qalloc:B: perimeter 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 133 "width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   he ...}" 
 -- IS.newDescNo: 133 IS.objSize: 5 "width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h;th ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  133 "Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      w ...}" 
 -- OG:super:  "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width := w;   ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Rectangle" 
 -- super:  "Rectangle" 
 -- E:  "Rectangle" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Rectangle" 
 -- Items:Qalloc:objSize: 8  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 8  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- newDescNo: 96 
 -- diSize: 2 IT.qSize: 10 
 -- Items:Qalloc:objSize: 10  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 10  newDescNo: 0 "" 
 -- dataitem:qalloc: "T" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnit ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnitude := ba ...}" 
 -- newDescNo: 102 
 -- diSize: 2 IT.qSize: 12 
 -- Items:Qalloc:objSize: 12  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 12  newDescNo: 0 "" 
 -- OG:Qalloc: ""Hello UnitEx\n".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Hello UnitEx\n".print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   th ...}" s ... " ..." 
 -- Invocation:Qalloc: ""Hello UnitEx\n".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Hello UnitEx\n".print" 
 -- super:  ""Hello UnitEx\n".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Hello UnitEx\n".print" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- OG:Qalloc: "Length.F2M(12.0)" qDescno:  0 
 -- OG:Qalloc:A:  "F2M"  super:  "Length.F2M(12.0)"  marked:  false "L1 := Length.F2M(12.0)" super:  Length.F2M(12.0) 
 -- Invocation:Qalloc: "Length.F2M(12.0)" 
 -- ObjectInvocation:Qalloc: "Length" 
 -- name: "Length" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "F2M(12.0)" 
 -- name: "F2M" 
 -- Arguments "F2M(12.0)" 
 -- OG:Qalloc: "12.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "12.0"  marked:  false "F2M(12.0)" super:  12.0 
 -- Invocation:Qalloc: "12.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "12.0" 
 -- super:  "12.0" 
 -- E:  "12.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "12.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')} 
 -- OG:Qalloc:SuperAlloc: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OG:Qalloc: "in V: var float{   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" qDescno:  0 
 -- OG:Qalloc:A:  "F2M"  super:  ""  marked:  false "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in V: var float{   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "F2M" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 134 IS.newDescNo: 134 objSize: 0 1: 1 "in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 134 "in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- OG:Qalloc: "put('A')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('A')"  marked:  false "in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')}" super:  put('A') 
 -- Invocation:Qalloc: "put('A')" 
 -- ObjectInvocation:Qalloc: "put('A')" 
 -- name: "put" 
 -- Arguments "put('A')" 
 -- OG:Qalloc: "'A'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "'A'"  marked:  false "put('A')" super:  'A' 
 -- Invocation:Qalloc: "'A'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'A'" 
 -- super:  "'A'" 
 -- E:  "'A'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'A'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('A')" 
 -- super:  "put('A')" 
 -- E:  "put('A')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('A')" 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "V" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "V"  marked:  false "R.magnitude := V" super:  V 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "in V: var float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V" 
 -- super:  "V" 
 -- E:  "V" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V" 
 -- OG:Qalloc: "put('B')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('B')"  marked:  false "in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')}" super:  put('B') 
 -- Invocation:Qalloc: "put('B')" 
 -- ObjectInvocation:Qalloc: "put('B')" 
 -- name: "put" 
 -- Arguments "put('B')" 
 -- OG:Qalloc: "'B'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "'B'"  marked:  false "put('B')" super:  'B' 
 -- Invocation:Qalloc: "'B'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'B'" 
 -- super:  "'B'" 
 -- E:  "'B'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'B'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('B')" 
 -- super:  "put('B')" 
 -- E:  "put('B')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('B')" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 134 "in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')}" 
 -- IS.newDescNo: 134 IS.objSize: 5 "in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')}" 
 -- OG:Qalloc:end: IS.newDescNo:  134 "in V: var float{   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OG:super:  "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Length.F2M(12.0)" 
 -- super:  "Length.F2M(12.0)" 
 -- E:  "F2M(12.0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Length.F2M(12.0)" 
 -- OG:Qalloc: "L1.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L1.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      ...}" s ... L ... 
 -- Invocation:Qalloc: "L1.print" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1.print" 
 -- super:  "L1.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- OG:Qalloc: "L2.fromPrimary(L1.toPrimary)" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  "L2.fromPrimary(L1.toPrimary)"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Fi ...}" s ... L ... 
 -- Invocation:Qalloc: "L2.fromPrimary(L1.toPrimary)" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "fromPrimary(L1.toPrimary)" 
 -- name: "fromPrimary" 
 -- Arguments "fromPrimary(L1.toPrimary)" 
 -- OG:Qalloc: "L1.toPrimary" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  "L1.toPrimary"  marked:  false "fromPrimary(L1.toPrimary)" super:  L1.toPrimary 
 -- Invocation:Qalloc: "L1.toPrimary" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "toPrimary" 
 -- name: "toPrimary" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  78 5 base.magnitude := magnitude 
 -- OG:super:  "toPrimary:: {   base.magnitude := magnitude}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1.toPrimary" 
 -- super:  "L1.toPrimary" 
 -- E:  "toPrimary" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1.toPrimary" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 put('!'){magnitude := base.magnitude / 0.3048} 
 -- OG:Qalloc:SuperAlloc: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- OG:Qalloc: "put('!'){   magnitude := base.magnitude / 0.3048}" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  ""  marked:  false "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 5 in base: var PrimaryUnit{inner(fromPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('!'){   magnitude := base.magnitude / 0.3048}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fromPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 135 IS.newDescNo: 135 objSize: 0 1: 1 "put('!'){magnitude := base.magnitude / 0.3048}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 135 "put('!'){magnitude := base.magnitude / 0.3048}" 
 -- Items:Qalloc:super: "" size: 5 "fromPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- OG:Qalloc: "put('!')" qDescno:  0 
 -- OG:Qalloc:A:  "put"  super:  "put('!')"  marked:  false "put('!'){magnitude := base.magnitude / 0.3048}" super:  put('!') 
 -- Invocation:Qalloc: "put('!')" 
 -- ObjectInvocation:Qalloc: "put('!')" 
 -- name: "put" 
 -- Arguments "put('!')" 
 -- OG:Qalloc: "'!'" qDescno:  0 
 -- OG:Qalloc:A:  "char"  super:  "'!'"  marked:  false "put('!')" super:  '!' 
 -- Invocation:Qalloc: "'!'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  7 1 %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out ...} 
 -- OG:super:  "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;      out R: v ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "'!'" 
 -- super:  "'!'" 
 -- E:  "'!'" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "'!'" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  54 1 %globals{%basic 2;in ch: val char} 
 -- OG:super:  "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "put('!')" 
 -- super:  "put('!')" 
 -- E:  "put('!')" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "put('!')" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "base.magnitude / 0.3048" qDescno:  0 
 -- OG:Qalloc:A:  "/"  super:  "base.magnitude / 0.3048"  marked:  false "magnitude := base.magnitude / 0.3048" super:  base.magnitude / 0.3048 
 -- Invocation:Qalloc: "base.magnitude / 0.3048" 
 -- BinaryExp:Qalloc: "base.magnitude / 0.3048" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "/ 0.3048" 
 -- name: "/" 
 -- Arguments "0.3048" 
 -- OG:Qalloc: "0.3048" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "0.3048"  marked:  false "0.3048" super:  0.3048 
 -- Invocation:Qalloc: "0.3048" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0.3048" 
 -- super:  "0.3048" 
 -- E:  "0.3048" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0.3048" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  99 7 %basic 121{in V: var float;out R: var float} 
 -- OG:super:  "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude / 0.3048" 
 -- super:  "base.magnitude / 0.3048" 
 -- E:  "base.magnitude / 0.3048" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "base.magnitude / 0.3048" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 135 "put('!'){magnitude := base.magnitude / 0.3048}" 
 -- IS.newDescNo: 135 IS.objSize: 5 "put('!'){magnitude := base.magnitude / 0.3048}" 
 -- OG:Qalloc:end: IS.newDescNo:  135 "put('!'){   magnitude := base.magnitude / 0.3048}" 
 -- OG:super:  "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2.fromPrimary(L1.toPrimary)" 
 -- super:  "L2.fromPrimary(L1.toPrimary)" 
 -- E:  "fromPrimary(L1.toPrimary)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2.fromPrimary(L1.toPrimary)" 
 -- OG:Qalloc: "L2.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L2.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      ...}" s ... L ... 
 -- Invocation:Qalloc: "L2.print" 
 -- ObjectInvocation:Qalloc: "L2" 
 -- name: "L2" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "Foot".print 
 -- OG:Qalloc:SuperAlloc: "print:: {   "Foot".print}" 
 -- OG:Qalloc: ""Foot".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print:: {   "Foot".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Foot".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 136 IS.newDescNo: 136 objSize: 0 1: 1 ""Foot".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 136 ""Foot".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Foot".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Foot".print"  marked:  false ""Foot".print" super:  "Foot".print 
 -- Invocation:Qalloc: ""Foot".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Foot".print" 
 -- super:  ""Foot".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Foot".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 136 ""Foot".print" 
 -- IS.newDescNo: 136 IS.objSize: 3 ""Foot".print" 
 -- OG:Qalloc:end: IS.newDescNo:  136 ""Foot".print" 
 -- OG:super:  "print:: {   "Foot".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L2.print" 
 -- super:  "L2.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L2.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Invocation:Qalloc: "L3" 
 -- ObjectInvocation:Qalloc: "L3" 
 -- name: "L3" 
 -- Arguments "" 
 -- OG:Qalloc: "Length.F2M(3.0)" qDescno:  0 
 -- OG:Qalloc:A:  "F2M"  super:  "Length.F2M(3.0)"  marked:  false "L3 := Length.F2M(3.0)" super:  Length.F2M(3.0) 
 -- Invocation:Qalloc: "Length.F2M(3.0)" 
 -- ObjectInvocation:Qalloc: "Length" 
 -- name: "Length" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "F2M(3.0)" 
 -- name: "F2M" 
 -- Arguments "F2M(3.0)" 
 -- OG:Qalloc: "3.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "3.0"  marked:  false "F2M(3.0)" super:  3.0 
 -- Invocation:Qalloc: "3.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "3.0" 
 -- super:  "3.0" 
 -- E:  "3.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "3.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  134 5 in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')} 
 -- OG:super:  "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Length.F2M(3.0)" 
 -- super:  "Length.F2M(3.0)" 
 -- E:  "F2M(3.0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Length.F2M(3.0)" 
 -- OG:Qalloc: "R.set(L1,L3)" qDescno:  0 
 -- OG:Qalloc:A:  "set"  super:  "R.set(L1,L3)"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;    ...}" s ... R ... 
 -- Invocation:Qalloc: "R.set(L1,L3)" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "set(L1,L3)" 
 -- name: "set" 
 -- Arguments "(L1,L3)" 
 -- OG:Qalloc: "L1" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "L1"  marked:  false "(L1,L3)" super:  L1 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "L1: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1" 
 -- super:  "L1" 
 -- E:  "L1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1" 
 -- OG:Qalloc: "L3" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "L3"  marked:  false "(L1,L3)" super:  L3 
 -- Invocation:Qalloc: "L3" 
 -- ObjectInvocation:Qalloc: "L3" 
 -- name: "L3" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "L3: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L3" 
 -- super:  "L3" 
 -- E:  "L3" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L3" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in w: var Length.Meter{in h: var Length.Meter;width := w;heigth := h} 
 -- OG:Qalloc:SuperAlloc: "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- OG:Qalloc: "in w: var Length.Meter{   in h: var Length.Meter;   width := w;   heigth := h}" qDescno:  0 
 -- OG:Qalloc:A:  "set"  super:  ""  marked:  false "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in w: var Length.Meter{   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "set" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 137 IS.newDescNo: 137 objSize: 0 1: 1 "in w: var Length.Meter{in h: var Length.Meter;width := w;heigth := h}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 137 "in w: var Length.Meter{in h: var Length.Meter;width := w;heigth := h}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "w" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "h" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "width" 
 -- ObjectInvocation:Qalloc: "width" 
 -- name: "width" 
 -- Arguments "" 
 -- OG:Qalloc: "w" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "w"  marked:  false "width := w" super:  w 
 -- Invocation:Qalloc: "w" 
 -- ObjectInvocation:Qalloc: "w" 
 -- name: "w" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "in w: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "w" 
 -- super:  "w" 
 -- E:  "w" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "w" 
 -- Invocation:Qalloc: "heigth" 
 -- ObjectInvocation:Qalloc: "heigth" 
 -- name: "heigth" 
 -- Arguments "" 
 -- OG:Qalloc: "h" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "h"  marked:  false "heigth := h" super:  h 
 -- Invocation:Qalloc: "h" 
 -- ObjectInvocation:Qalloc: "h" 
 -- name: "h" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "in h: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "h" 
 -- super:  "h" 
 -- E:  "h" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "h" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 137 "in w: var Length.Meter{in h: var Length.Meter;width := w;heigth := h}" 
 -- IS.newDescNo: 137 IS.objSize: 5 "in w: var Length.Meter{in h: var Length.Meter;width := w;heigth := h}" 
 -- OG:Qalloc:end: IS.newDescNo:  137 "in w: var Length.Meter{   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- OG:super:  "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.set(L1,L3)" 
 -- super:  "R.set(L1,L3)" 
 -- E:  "set(L1,L3)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "R.set(L1,L3)" 
 -- OG:Qalloc: "R.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "R.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;       ...}" s ... R ... 
 -- Invocation:Qalloc: "R.print" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;wi ...} 
 -- OG:Qalloc:SuperAlloc: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width ...}" 
 -- OG:Qalloc: "printMore:: {      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print;   ":heigth:".pr ...}" q ... 0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rect ..."}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := theAre ...} 
 -- OG:Qalloc:SuperAlloc: "print:< {   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;  ...}" 
 -- OG:Qalloc: "printMore:< {      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.print;   printMore ...}" q ... 0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print:< {   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nAre ..."}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "printMore:< {      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.print;   printMore}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 138 IS.newDescNo: 138 objSize: 0 1: 1 "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 138 "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := theArea;AR.print;prin ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: printMore 
 -- Pattern:Qalloc:B: printMore 
 -- dataitem:qalloc: "AR" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- newDescNo: 68 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Figure:".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Figure:".print"  marked:  false "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR ...}" s ... " ..." 
 -- Invocation:Qalloc: ""Figure:".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Figure:".print" 
 -- super:  ""Figure:".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Figure:".print" 
 -- OG:Qalloc: "inner(print)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(print)"  marked:  false "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := ...}" s ... i ... 
 -- Invocation:Qalloc: "inner(print)" 
 -- ObjectInvocation:Qalloc: "inner(print)" 
 -- name: "inner" 
 -- Arguments "inner(print)" 
 -- OG:Qalloc: "print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "print"  marked:  false "inner(print)" super:  print 
 -- Invocation:Qalloc: "print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  138 3 printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := theA ...} 
 -- OG:super:  "print:< {   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.print; ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "print" 
 -- super:  "print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "print" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(print)" 
 -- super:  "inner(print)" 
 -- E:  "inner(print)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(print)" 
 -- OG:Qalloc: ""\nArea:".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""\nArea:".print"  marked:  false "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR ...}" s ... " ..." 
 -- Invocation:Qalloc: ""\nArea:".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""\nArea:".print" 
 -- super:  ""\nArea:".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""\nArea:".print" 
 -- Invocation:Qalloc: "AR" 
 -- ObjectInvocation:Qalloc: "AR" 
 -- name: "AR" 
 -- Arguments "" 
 -- OG:Qalloc: "theArea" qDescno:  0 
 -- OG:Qalloc:A:  "theArea"  super:  "theArea"  marked:  false "AR := theArea" super:  theArea 
 -- Invocation:Qalloc: "theArea" 
 -- ObjectInvocation:Qalloc: "theArea" 
 -- name: "theArea" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out A: var Area.SquareMeter{inner(theArea)} 
 -- OG:Qalloc:SuperAlloc: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- OG:Qalloc: "out A: var Area.SquareMeter{   inner(theArea)}" qDescno:  0 
 -- OG:Qalloc:A:  "theArea"  super:  ""  marked:  false "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out A: var Area.SquareMeter{   inner(theArea)}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "theArea" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 139 IS.newDescNo: 139 objSize: 0 1: 1 "out A: var Area.SquareMeter{inner(theArea)}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 139 "out A: var Area.SquareMeter{inner(theArea)}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "A" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- newDescNo: 68 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(theArea)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(theArea)"  marked:  false "out A: var Area.SquareMeter{inner(theArea)}" super:  inner(theArea) 
 -- Invocation:Qalloc: "inner(theArea)" 
 -- ObjectInvocation:Qalloc: "inner(theArea)" 
 -- name: "inner" 
 -- Arguments "inner(theArea)" 
 -- OG:Qalloc: "theArea" qDescno:  0 
 -- OG:Qalloc:A:  "theArea"  super:  "theArea"  marked:  false "inner(theArea)" super:  theArea 
 -- Invocation:Qalloc: "theArea" 
 -- ObjectInvocation:Qalloc: "theArea" 
 -- name: "theArea" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  139 3 out A: var Area.SquareMeter{inner(theArea)} 
 -- OG:super:  "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "theArea" 
 -- super:  "theArea" 
 -- E:  "theArea" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "theArea" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(theArea)" 
 -- super:  "inner(theArea)" 
 -- E:  "inner(theArea)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(theArea)" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 139 "out A: var Area.SquareMeter{inner(theArea)}" 
 -- IS.newDescNo: 139 IS.objSize: 3 "out A: var Area.SquareMeter{inner(theArea)}" 
 -- OG:Qalloc:end: IS.newDescNo:  139 "out A: var Area.SquareMeter{   inner(theArea)}" 
 -- OG:super:  "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "theArea" 
 -- super:  "theArea" 
 -- E:  "theArea" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "theArea" 
 -- OG:Qalloc: "AR.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "AR.print"  marked:  false "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := the ...}" s ... A ... 
 -- Invocation:Qalloc: "AR.print" 
 -- ObjectInvocation:Qalloc: "AR" 
 -- name: "AR" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  70 3 "SquareMeter".print 
 -- OG:super:  "print:: {   "SquareMeter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "AR.print" 
 -- super:  "AR.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "AR.print" 
 -- OG:Qalloc: "printMore" qDescno:  0 
 -- OG:Qalloc:A:  "printMore"  super:  "printMore"  marked:  false "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR : ...}" s ... p ... 
 -- Invocation:Qalloc: "printMore" 
 -- ObjectInvocation:Qalloc: "printMore" 
 -- name: "printMore" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 inner(printMore) 
 -- OG:Qalloc:SuperAlloc: "printMore:< {   inner(printMore)}" 
 -- OG:Qalloc: "inner(printMore)" qDescno:  0 
 -- OG:Qalloc:A:  "printMore"  super:  ""  marked:  false "printMore:< {   inner(printMore)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(printMore)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "printMore" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 140 IS.newDescNo: 140 objSize: 0 1: 1 "inner(printMore)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 140 "inner(printMore)" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- OG:Qalloc: "inner(printMore)" qDescno:  0 
 -- OG:Qalloc:A:  "inner"  super:  "inner(printMore)"  marked:  false "inner(printMore)" super:  inner(printMore) 
 -- Invocation:Qalloc: "inner(printMore)" 
 -- ObjectInvocation:Qalloc: "inner(printMore)" 
 -- name: "inner" 
 -- Arguments "inner(printMore)" 
 -- OG:Qalloc: "printMore" qDescno:  0 
 -- OG:Qalloc:A:  "printMore"  super:  "printMore"  marked:  false "inner(printMore)" super:  printMore 
 -- Invocation:Qalloc: "printMore" 
 -- ObjectInvocation:Qalloc: "printMore" 
 -- name: "printMore" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  140 1 inner(printMore) 
 -- OG:super:  "printMore:< {   inner(printMore)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "printMore" 
 -- super:  "printMore" 
 -- E:  "printMore" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "printMore" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  12 2 %basic 101{in inner: ref Object} 
 -- OG:super:  "inner: {   %basic 101;   in inner: ref Object}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inner(printMore)" 
 -- super:  "inner(printMore)" 
 -- E:  "inner(printMore)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inner(printMore)" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 140 "inner(printMore)" 
 -- IS.newDescNo: 140 IS.objSize: 1 "inner(printMore)" 
 -- OG:Qalloc:end: IS.newDescNo:  140 "inner(printMore)" 
 -- OG:super:  "printMore:< {   inner(printMore)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "printMore" 
 -- super:  "printMore" 
 -- E:  "printMore" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "printMore" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 138 "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := theArea;AR.print; ...}" 
 -- IS.newDescNo: 138 IS.objSize: 3 "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := theArea;AR.print;printMore}" 
 -- OG:Qalloc:end: IS.newDescNo:  138 "printMore:< {      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;  ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "printMore:: {      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print;   ":heigth:".print;   heig ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 141 IS.newDescNo: 141 objSize: 0 1: 1 "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width: ..."}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 141 "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;width.print;":hei ..."}" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Pattern:Qalloc: printMore 
 -- Pattern:Qalloc:B: printMore 
 -- OG:Qalloc: ""Rectangle:width:".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Rectangle:width:".print"  marked:  false "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectang ..."}" s ... " ..." 
 -- Invocation:Qalloc: ""Rectangle:width:".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Rectangle:width:".print" 
 -- super:  ""Rectangle:width:".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Rectangle:width:".print" 
 -- OG:Qalloc: "width.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "width.print"  marked:  false "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".pr ...}" s ... w ... 
 -- Invocation:Qalloc: "width.print" 
 -- ObjectInvocation:Qalloc: "width" 
 -- name: "width" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "width.print" 
 -- super:  "width.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "width.print" 
 -- OG:Qalloc: "":heigth:".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "":heigth:".print"  marked:  false "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width ..."}" s ... " ..." 
 -- Invocation:Qalloc: "":heigth:".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "":heigth:".print" 
 -- super:  "":heigth:".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "":heigth:".print" 
 -- OG:Qalloc: "heigth.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "heigth.print"  marked:  false "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".p ...}" s ... h ... 
 -- Invocation:Qalloc: "heigth.print" 
 -- ObjectInvocation:Qalloc: "heigth" 
 -- name: "heigth" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "heigth.print" 
 -- super:  "heigth.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "heigth.print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 141 "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;width.print;" ..."}" 
 -- IS.newDescNo: 141 IS.objSize: 3 "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;width.print;":heigth:".pr ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  141 "printMore:: {      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width ...}" 
 -- OG:super:  "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print;   " ..."}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.print" 
 -- super:  "R.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "R.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Invocation:Qalloc: "T" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- OG:Qalloc: "3"min"" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "3"min""  marked:  false "T := 3"min"" super:  3"min" 
 -- Invocation:Qalloc: "3"min"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "3"min"" 
 -- super:  "3"min"" 
 -- E:  "3"min"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "3"min"" 
 -- OG:Qalloc: "T.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "T.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;       ...}" s ... T ... 
 -- Invocation:Qalloc: "T.print" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  106 3 "Minutes".print 
 -- OG:super:  "print:: {   "Minutes".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.print" 
 -- super:  "T.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "Velocity.mult(L1,T)" qDescno:  0 
 -- OG:Qalloc:A:  "mult"  super:  "Velocity.mult(L1,T)"  marked:  false "V := Velocity.mult(L1,T)" super:  Velocity.mult(L1,T) 
 -- Invocation:Qalloc: "Velocity.mult(L1,T)" 
 -- ObjectInvocation:Qalloc: "Velocity" 
 -- name: "Velocity" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "mult(L1,T)" 
 -- name: "mult" 
 -- Arguments "(L1,T)" 
 -- OG:Qalloc: "L1" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "L1"  marked:  false "(L1,T)" super:  L1 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "L1: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1" 
 -- super:  "L1" 
 -- E:  "L1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1" 
 -- OG:Qalloc: "T" qDescno:  0 
 -- OG:Qalloc:A:  "Minutes"  super:  "T"  marked:  false "(L1,T)" super:  T 
 -- Invocation:Qalloc: "T" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  102 2 %unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   mag ...} 
 -- OG:super:  "T: var Time.Minutes" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T" 
 -- super:  "T" 
 -- E:  "T" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in L: var Length.Meter{in T: var Time.Minutes;out R: var MeterPerSecond;R.magnitude := L.magnitude * T.magnitude} 
 -- OG:Qalloc:SuperAlloc: "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- OG:Qalloc: "in L: var Length.Meter{   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" qDescno:  0 
 -- OG:Qalloc:A:  "mult"  super:  ""  marked:  false "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in L: var Length.Meter{   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "mult" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 142 IS.newDescNo: 142 objSize: 0 1: 1 "in L: var Length.Meter{in T: var Time.Minutes;out R: var MeterPerSecond;R.magnitude := L.magnitude * T.ma ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 142 "in L: var Length.Meter{in T: var Time.Minutes;out R: var MeterPerSecond;R.magnitude := L.magnitude * T.magnitude}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "T" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnit ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnitude := ba ...}" 
 -- newDescNo: 102 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- newDescNo: 96 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "L.magnitude * T.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "L.magnitude * T.magnitude"  marked:  false "R.magnitude := L.magnitude * T.magnitude" super:  L.magnitude * T.magnitude 
 -- Invocation:Qalloc: "L.magnitude * T.magnitude" 
 -- BinaryExp:Qalloc: "L.magnitude * T.magnitude" 
 -- Invocation:Qalloc: "L.magnitude" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* T.magnitude" 
 -- name: "*" 
 -- Arguments "T.magnitude" 
 -- OG:Qalloc: "T.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "T.magnitude"  marked:  false "T.magnitude" super:  T.magnitude 
 -- Invocation:Qalloc: "T.magnitude" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.magnitude" 
 -- super:  "T.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 7 %basic 112{in V: var float;out R: var float} 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.magnitude * T.magnitude" 
 -- super:  "L.magnitude * T.magnitude" 
 -- E:  "L.magnitude * T.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.magnitude * T.magnitude" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 142 "in L: var Length.Meter{in T: var Time.Minutes;out R: var MeterPerSecond;R.magnitude := L.magnitude * T.magnitude}" 
 -- IS.newDescNo: 142 IS.objSize: 7 "in L: var Length.Meter{in T: var Time.Minutes;out R: var MeterPerSecond;R.magnitude := L.magnitude * T.magnitude}" 
 -- OG:Qalloc:end: IS.newDescNo:  142 "in L: var Length.Meter{   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- OG:super:  "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Velocity.mult(L1,T)" 
 -- super:  "Velocity.mult(L1,T)" 
 -- E:  "mult(L1,T)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Velocity.mult(L1,T)" 
 -- OG:Qalloc: "V.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "V.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;       ...}" s ... V ... 
 -- Invocation:Qalloc: "V.print" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  100 3 "MpS".print 
 -- OG:super:  "print:: {   "MpS".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V.print" 
 -- super:  "V.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- OG:Qalloc: ""The minimum of ".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""The minimum of ".print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   t ...}" s ... " ..." 
 -- Invocation:Qalloc: ""The minimum of ".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""The minimum of ".print" 
 -- super:  ""The minimum of ".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""The minimum of ".print" 
 -- OG:Qalloc: "L1.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L1.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      ...}" s ... L ... 
 -- Invocation:Qalloc: "L1.print" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1.print" 
 -- super:  "L1.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1.print" 
 -- OG:Qalloc: "" and ".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "" and ".print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ; ...}" s ... " ..." 
 -- Invocation:Qalloc: "" and ".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" and ".print" 
 -- super:  "" and ".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" and ".print" 
 -- OG:Qalloc: "L3.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L3.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      ...}" s ... L ... 
 -- Invocation:Qalloc: "L3.print" 
 -- ObjectInvocation:Qalloc: "L3" 
 -- name: "L3" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L3.print" 
 -- super:  "L3.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L3.print" 
 -- OG:Qalloc: "" is ".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "" is ".print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;  ...}" s ... " ..." 
 -- Invocation:Qalloc: "" is ".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" is ".print" 
 -- super:  "" is ".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" is ".print" 
 -- OG:Qalloc: "L1.min(L3).print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L1.min(L3).print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea: ...}" s ... L ... 
 -- Invocation:Qalloc: "L1.min(L3).print" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "min(L3)" 
 -- name: "min" 
 -- Arguments "min(L3)" 
 -- OG:Qalloc: "L3" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "L3"  marked:  false "min(L3)" super:  L3 
 -- Invocation:Qalloc: "L3" 
 -- ObjectInvocation:Qalloc: "L3" 
 -- name: "L3" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "L3: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L3" 
 -- super:  "L3" 
 -- E:  "L3" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L3" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1.min(L3).print" 
 -- super:  "L1.min(L3).print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1.min(L3).print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- OG:Qalloc: ""The maximum of ".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""The maximum of ".print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   t ...}" s ... " ..." 
 -- Invocation:Qalloc: ""The maximum of ".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""The maximum of ".print" 
 -- super:  ""The maximum of ".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""The maximum of ".print" 
 -- OG:Qalloc: "L1.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L1.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      ...}" s ... L ... 
 -- Invocation:Qalloc: "L1.print" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1.print" 
 -- super:  "L1.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1.print" 
 -- OG:Qalloc: "" and ".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "" and ".print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ; ...}" s ... " ..." 
 -- Invocation:Qalloc: "" and ".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" and ".print" 
 -- super:  "" and ".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" and ".print" 
 -- OG:Qalloc: "L3.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L3.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      ...}" s ... L ... 
 -- Invocation:Qalloc: "L3.print" 
 -- ObjectInvocation:Qalloc: "L3" 
 -- name: "L3" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L3.print" 
 -- super:  "L3.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L3.print" 
 -- OG:Qalloc: "" is ".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "" is ".print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;  ...}" s ... " ..." 
 -- Invocation:Qalloc: "" is ".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" is ".print" 
 -- super:  "" is ".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" is ".print" 
 -- OG:Qalloc: "L1.max(L3).print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L1.max(L3).print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea: ...}" s ... L ... 
 -- Invocation:Qalloc: "L1.max(L3).print" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "max(L3)" 
 -- name: "max" 
 -- Arguments "max(L3)" 
 -- OG:Qalloc: "L3" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "L3"  marked:  false "max(L3)" super:  L3 
 -- Invocation:Qalloc: "L3" 
 -- ObjectInvocation:Qalloc: "L3" 
 -- name: "L3" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "L3: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L3" 
 -- super:  "L3" 
 -- E:  "L3" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L3" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1.max(L3).print" 
 -- super:  "L1.max(L3).print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1.max(L3).print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- dataitem:qalloc: "A" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- newDescNo: 68 
 -- diSize: 2 IT.qSize: 14 
 -- Items:Qalloc:objSize: 14  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 14  newDescNo: 0 "" 
 -- Invocation:Qalloc: "A" 
 -- ObjectInvocation:Qalloc: "A" 
 -- name: "A" 
 -- Arguments "" 
 -- OG:Qalloc: "L1 * L3" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "L1 * L3"  marked:  false "A := L1 * L3" super:  L1 * L3 
 -- Invocation:Qalloc: "L1 * L3" 
 -- BinaryExp:Qalloc: "L1 * L3" 
 -- Invocation:Qalloc: "L1" 
 -- ObjectInvocation:Qalloc: "L1" 
 -- name: "L1" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* L3" 
 -- name: "*" 
 -- Arguments "L3" 
 -- OG:Qalloc: "L3" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "L3"  marked:  false "L3" super:  L3 
 -- Invocation:Qalloc: "L3" 
 -- ObjectInvocation:Qalloc: "L3" 
 -- name: "L3" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "L3: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L3" 
 -- super:  "L3" 
 -- E:  "L3" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L3" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 7 %basic 112{in V: var float;out R: var float} 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L1 * L3" 
 -- super:  "L1 * L3" 
 -- E:  "L1 * L3" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L1 * L3" 
 -- OG:Qalloc: "A.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "A.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;       ...}" s ... A ... 
 -- Invocation:Qalloc: "A.print" 
 -- ObjectInvocation:Qalloc: "A" 
 -- name: "A" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  70 3 "SquareMeter".print 
 -- OG:super:  "print:: {   "SquareMeter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "A.print" 
 -- super:  "A.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "A.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- OG:Qalloc: "temperatureEx" qDescno:  0 
 -- OG:Qalloc:A:  "temperatureEx"  super:  "temperatureEx"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   the ...}" s ... t ... 
 -- Invocation:Qalloc: "temperatureEx" 
 -- ObjectInvocation:Qalloc: "temperatureEx" 
 -- name: "temperatureEx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fromP ...} 
 -- OG:Qalloc:SuperAlloc: "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.from ...}" 
 -- OG:Qalloc: "C: var Temperature.Celsius{   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimary(C.toPrimary);   F.prin ...}" q ... 0 
 -- OG:Qalloc:A:  "temperatureEx"  super:  ""  marked:  false "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(10 ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C: var Temperature.Celsius{   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimary(C.toPrimary);   F.print;   newlin ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "temperatureEx" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 143 IS.newDescNo: 143 objSize: 0 1: 1 "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newli ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 143 "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fromPrimary(C.toPrim ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "C" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print:: ;      " ..."}" q ... 0 
 -- OG:Qalloc:A:  "Celsius"  super:  "Unit"  marked:  false "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary::  ...}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print:: ;      "Celsius".pr ...}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "Celsius" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 144 IS.newDescNo: 144 objSize: 0 1: 1 "%Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := bas ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 144 "%Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   " ..."}" 
 -- Items:Qalloc:super: "Unit" size: 2 "Celsius" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$145 
 -- Pattern:Qalloc:B: thisUnit$145 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 144 "%Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ; ...}" 
 -- IS.newDescNo: 144 IS.objSize: 2 "%Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Celsius" ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  144 "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnit ...}" 
 -- new_size:A: true   "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print::  ...}" 
 -- newDescNo: 144 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "F" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      magnitude := (base.ma ...}" q ... 0 
 -- OG:Qalloc:A:  "Fahrenheit"  super:  "Unit"  marked:  false "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) ...}" s ... U ... 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      magnitude := (base.magnitude * ( ...}" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:B: "Fahrenheit" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 146 IS.newDescNo: 146 objSize: 0 1: 1 "%Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrim ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 146 "%Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrimary:: ;   magnitude := (b ...}" 
 -- Items:Qalloc:super: "Unit" size: 2 "Fahrenheit" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 2 originOff: 0 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Pattern:Qalloc: thisUnit 
 -- Pattern:Qalloc:B: thisUnit 
 -- Pattern:Qalloc: thisUnit$147 
 -- Pattern:Qalloc:B: thisUnit$147 
 -- Pattern:Qalloc: toPrimary 
 -- Pattern:Qalloc:B: toPrimary 
 -- Pattern:Qalloc: fromPrimary 
 -- Pattern:Qalloc:B: fromPrimary 
 -- Pattern:Qalloc: print 
 -- Pattern:Qalloc:B: print 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 146 "%Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrimary:: ;   magnitude : ...}" 
 -- IS.newDescNo: 146 IS.objSize: 2 "%Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrimary:: ;   magnitude := (base.magn ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  146 "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;     ...}" 
 -- new_size:A: true   "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      m ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      magnitude  ...}" 
 -- newDescNo: 146 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "C" 
 -- ObjectInvocation:Qalloc: "C" 
 -- name: "C" 
 -- Arguments "" 
 -- OG:Qalloc: "Temperature.FasCelsius(100.0)" qDescno:  0 
 -- OG:Qalloc:A:  "FasCelsius"  super:  "Temperature.FasCelsius(100.0)"  marked:  false "C := Temperature.FasCelsius(100.0)" super:  Temperature.FasCelsius(100.0) 
 -- Invocation:Qalloc: "Temperature.FasCelsius(100.0)" 
 -- ObjectInvocation:Qalloc: "Temperature" 
 -- name: "Temperature" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "FasCelsius(100.0)" 
 -- name: "FasCelsius" 
 -- Arguments "FasCelsius(100.0)" 
 -- OG:Qalloc: "100.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "100.0"  marked:  false "FasCelsius(100.0)" super:  100.0 
 -- Invocation:Qalloc: "100.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "100.0" 
 -- super:  "100.0" 
 -- E:  "100.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "100.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in V: var float{out R: var Celsius;R.magnitude := V} 
 -- OG:Qalloc:SuperAlloc: "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V}" 
 -- OG:Qalloc: "in V: var float{   out R: var Celsius;   R.magnitude := V}" qDescno:  0 
 -- OG:Qalloc:A:  "FasCelsius"  super:  ""  marked:  false "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in V: var float{   out R: var Celsius;   R.magnitude := V}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "FasCelsius" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 148 IS.newDescNo: 148 objSize: 0 1: 1 "in V: var float{out R: var Celsius;R.magnitude := V}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 148 "in V: var float{out R: var Celsius;R.magnitude := V}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print::  ...}" 
 -- newDescNo: 144 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "V" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "V"  marked:  false "R.magnitude := V" super:  V 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "in V: var float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V" 
 -- super:  "V" 
 -- E:  "V" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 148 "in V: var float{out R: var Celsius;R.magnitude := V}" 
 -- IS.newDescNo: 148 IS.objSize: 5 "in V: var float{out R: var Celsius;R.magnitude := V}" 
 -- OG:Qalloc:end: IS.newDescNo:  148 "in V: var float{   out R: var Celsius;   R.magnitude := V}" 
 -- OG:super:  "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Temperature.FasCelsius(100.0)" 
 -- super:  "Temperature.FasCelsius(100.0)" 
 -- E:  "FasCelsius(100.0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Temperature.FasCelsius(100.0)" 
 -- OG:Qalloc: "C.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "C.print"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fro ...}" s ... C ... 
 -- Invocation:Qalloc: "C.print" 
 -- ObjectInvocation:Qalloc: "C" 
 -- name: "C" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "Celsius".print 
 -- OG:Qalloc:SuperAlloc: "print:: {   "Celsius".print}" 
 -- OG:Qalloc: ""Celsius".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print:: {   "Celsius".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Celsius".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 149 IS.newDescNo: 149 objSize: 0 1: 1 ""Celsius".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 149 ""Celsius".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Celsius".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Celsius".print"  marked:  false ""Celsius".print" super:  "Celsius".print 
 -- Invocation:Qalloc: ""Celsius".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Celsius".print" 
 -- super:  ""Celsius".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Celsius".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 149 ""Celsius".print" 
 -- IS.newDescNo: 149 IS.objSize: 3 ""Celsius".print" 
 -- OG:Qalloc:end: IS.newDescNo:  149 ""Celsius".print" 
 -- OG:super:  "print:: {   "Celsius".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C.print" 
 -- super:  "C.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.f ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- OG:Qalloc: "F.fromPrimary(C.toPrimary)" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  "F.fromPrimary(C.toPrimary)"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100 ...}" s ... F ... 
 -- Invocation:Qalloc: "F.fromPrimary(C.toPrimary)" 
 -- ObjectInvocation:Qalloc: "F" 
 -- name: "F" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "fromPrimary(C.toPrimary)" 
 -- name: "fromPrimary" 
 -- Arguments "fromPrimary(C.toPrimary)" 
 -- OG:Qalloc: "C.toPrimary" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  "C.toPrimary"  marked:  false "fromPrimary(C.toPrimary)" super:  C.toPrimary 
 -- Invocation:Qalloc: "C.toPrimary" 
 -- ObjectInvocation:Qalloc: "C" 
 -- name: "C" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "toPrimary" 
 -- name: "toPrimary" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 base.magnitude := magnitude 
 -- OG:Qalloc:SuperAlloc: "toPrimary:: {   base.magnitude := magnitude}" 
 -- OG:Qalloc: "base.magnitude := magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  ""  marked:  false "toPrimary:: {   base.magnitude := magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 out base: var PrimaryUnit{inner(toPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude := magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "toPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 150 IS.newDescNo: 150 objSize: 0 1: 1 "base.magnitude := magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 150 "base.magnitude := magnitude" 
 -- Items:Qalloc:super: "" size: 5 "toPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "magnitude"  marked:  false "base.magnitude := magnitude" super:  magnitude 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude" 
 -- super:  "magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 150 "base.magnitude := magnitude" 
 -- IS.newDescNo: 150 IS.objSize: 5 "base.magnitude := magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  150 "base.magnitude := magnitude" 
 -- OG:super:  "toPrimary:: {   base.magnitude := magnitude}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C.toPrimary" 
 -- super:  "C.toPrimary" 
 -- E:  "toPrimary" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C.toPrimary" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0 
 -- OG:Qalloc:SuperAlloc: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0}" 
 -- OG:Qalloc: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  ""  marked:  false "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 5 in base: var PrimaryUnit{inner(fromPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fromPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 151 IS.newDescNo: 151 objSize: 0 1: 1 "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- Items:Qalloc:objSize: 0  newDescNo: 151 "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- Items:Qalloc:super: "" size: 5 "fromPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "(base.magnitude * (9.0 / 5.0)) + 32.0" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "(base.magnitude * (9.0 / 5.0)) + 32.0"  marked:  false "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" super:  (base.magnitude * (9.0 / 5. ... 
 -- Invocation:Qalloc: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- BinaryExp:Qalloc: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- Invocation:Qalloc: "(base.magnitude * (9.0 / 5.0))" 
 -- Invocation:Qalloc: "base.magnitude * (9.0 / 5.0)" 
 -- BinaryExp:Qalloc: "base.magnitude * (9.0 / 5.0)" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* (9.0 / 5.0)" 
 -- name: "*" 
 -- Arguments "(9.0 / 5.0)" 
 -- OG:Qalloc: "(9.0 / 5.0)" qDescno:  0 
 -- OG:Qalloc:A:  "/"  super:  "(9.0 / 5.0)"  marked:  false "(9.0 / 5.0)" super:  (9.0 / 5.0) 
 -- Invocation:Qalloc: "(9.0 / 5.0)" 
 -- Invocation:Qalloc: "9.0 / 5.0" 
 -- BinaryExp:Qalloc: "9.0 / 5.0" 
 -- Invocation:Qalloc: "9.0" 
 -- ObjectInvocation:Qalloc: "/ 5.0" 
 -- name: "/" 
 -- Arguments "5.0" 
 -- OG:Qalloc: "5.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "5.0"  marked:  false "5.0" super:  5.0 
 -- Invocation:Qalloc: "5.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "5.0" 
 -- super:  "5.0" 
 -- E:  "5.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "5.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  99 7 %basic 121{in V: var float;out R: var float} 
 -- OG:super:  "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(9.0 / 5.0)" 
 -- super:  "(9.0 / 5.0)" 
 -- E:  "(9.0 / 5.0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(9.0 / 5.0)" 
 -- ObjectInvocation:Qalloc: "+ 32.0" 
 -- name: "+" 
 -- Arguments "32.0" 
 -- OG:Qalloc: "32.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "32.0"  marked:  false "32.0" super:  32.0 
 -- Invocation:Qalloc: "32.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "32.0" 
 -- super:  "32.0" 
 -- E:  "32.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "32.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 109{in V: var float;out R: var float} 
 -- OG:Qalloc:SuperAlloc: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- OG:Qalloc: "%basic 109{   in V: var float;   out R: var float}" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  ""  marked:  false "+  : {   %basic 109;   in V: var float;   out R: var float}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 109{   in V: var float;   out R: var float}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "+" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 152 IS.newDescNo: 152 objSize: 0 1: 1 "%basic 109{in V: var float;out R: var float}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 152 "%basic 109{in V: var float;out R: var float}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 152 "%basic 109{in V: var float;out R: var float}" 
 -- IS.newDescNo: 152 IS.objSize: 7 "%basic 109{in V: var float;out R: var float}" 
 -- OG:Qalloc:end: IS.newDescNo:  152 "%basic 109{   in V: var float;   out R: var float}" 
 -- OG:super:  "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- super:  "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- E:  "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 151 "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- IS.newDescNo: 151 IS.objSize: 5 "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- OG:Qalloc:end: IS.newDescNo:  151 "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- OG:super:  "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F.fromPrimary(C.toPrimary)" 
 -- super:  "F.fromPrimary(C.toPrimary)" 
 -- E:  "fromPrimary(C.toPrimary)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "F.fromPrimary(C.toPrimary)" 
 -- OG:Qalloc: "F.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "F.print"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fro ...}" s ... F ... 
 -- Invocation:Qalloc: "F.print" 
 -- ObjectInvocation:Qalloc: "F" 
 -- name: "F" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 "Fahrenheit".print 
 -- OG:Qalloc:SuperAlloc: "print:: {   "Fahrenheit".print}" 
 -- OG:Qalloc: ""Fahrenheit".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""  marked:  false "print:: {   "Fahrenheit".print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  51 3 "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Fahrenheit".print" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "print" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 153 IS.newDescNo: 153 objSize: 0 1: 1 ""Fahrenheit".print" 
 -- Items:Qalloc:objSize: 0  newDescNo: 153 ""Fahrenheit".print" 
 -- Items:Qalloc:super: "" size: 3 "print" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: ""Fahrenheit".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""Fahrenheit".print"  marked:  false ""Fahrenheit".print" super:  "Fahrenheit".print 
 -- Invocation:Qalloc: ""Fahrenheit".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""Fahrenheit".print" 
 -- super:  ""Fahrenheit".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""Fahrenheit".print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 153 ""Fahrenheit".print" 
 -- IS.newDescNo: 153 IS.objSize: 3 ""Fahrenheit".print" 
 -- OG:Qalloc:end: IS.newDescNo:  153 ""Fahrenheit".print" 
 -- OG:super:  "print:: {   "Fahrenheit".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F.print" 
 -- super:  "F.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "F.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.f ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- OG:Qalloc: "C.fromPrimary(F.toPrimary)" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  "C.fromPrimary(F.toPrimary)"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100 ...}" s ... C ... 
 -- Invocation:Qalloc: "C.fromPrimary(F.toPrimary)" 
 -- ObjectInvocation:Qalloc: "C" 
 -- name: "C" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "fromPrimary(F.toPrimary)" 
 -- name: "fromPrimary" 
 -- Arguments "fromPrimary(F.toPrimary)" 
 -- OG:Qalloc: "F.toPrimary" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  "F.toPrimary"  marked:  false "fromPrimary(F.toPrimary)" super:  F.toPrimary 
 -- Invocation:Qalloc: "F.toPrimary" 
 -- ObjectInvocation:Qalloc: "F" 
 -- name: "F" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "toPrimary" 
 -- name: "toPrimary" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 base.magnitude := (magnitude - 32.0) * (5.0 / 9.0) 
 -- OG:Qalloc:SuperAlloc: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)}" 
 -- OG:Qalloc: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  ""  marked:  false "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 out base: var PrimaryUnit{inner(toPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "toPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 154 IS.newDescNo: 154 objSize: 0 1: 1 "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 154 "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- Items:Qalloc:super: "" size: 5 "toPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "(magnitude - 32.0) * (5.0 / 9.0)" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "(magnitude - 32.0) * (5.0 / 9.0)"  marked:  false "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" super:  (magnitude - 32.0) * (5.0 / 9.0) ... 
 -- Invocation:Qalloc: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- BinaryExp:Qalloc: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- Invocation:Qalloc: "(magnitude - 32.0)" 
 -- Invocation:Qalloc: "magnitude - 32.0" 
 -- BinaryExp:Qalloc: "magnitude - 32.0" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "- 32.0" 
 -- name: "-" 
 -- Arguments "32.0" 
 -- OG:Qalloc: "32.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "32.0"  marked:  false "32.0" super:  32.0 
 -- Invocation:Qalloc: "32.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "32.0" 
 -- super:  "32.0" 
 -- E:  "32.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "32.0" 
 -- ObjectInvocation:Qalloc: "* (5.0 / 9.0)" 
 -- name: "*" 
 -- Arguments "(5.0 / 9.0)" 
 -- OG:Qalloc: "(5.0 / 9.0)" qDescno:  0 
 -- OG:Qalloc:A:  "/"  super:  "(5.0 / 9.0)"  marked:  false "(5.0 / 9.0)" super:  (5.0 / 9.0) 
 -- Invocation:Qalloc: "(5.0 / 9.0)" 
 -- Invocation:Qalloc: "5.0 / 9.0" 
 -- BinaryExp:Qalloc: "5.0 / 9.0" 
 -- Invocation:Qalloc: "5.0" 
 -- ObjectInvocation:Qalloc: "/ 9.0" 
 -- name: "/" 
 -- Arguments "9.0" 
 -- OG:Qalloc: "9.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "9.0"  marked:  false "9.0" super:  9.0 
 -- Invocation:Qalloc: "9.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "9.0" 
 -- super:  "9.0" 
 -- E:  "9.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "9.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  99 7 %basic 121{in V: var float;out R: var float} 
 -- OG:super:  "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(5.0 / 9.0)" 
 -- super:  "(5.0 / 9.0)" 
 -- E:  "(5.0 / 9.0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(5.0 / 9.0)" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 7 %basic 112{in V: var float;out R: var float} 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- super:  "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- E:  "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 154 "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- IS.newDescNo: 154 IS.objSize: 5 "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- OG:Qalloc:end: IS.newDescNo:  154 "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- OG:super:  "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F.toPrimary" 
 -- super:  "F.toPrimary" 
 -- E:  "toPrimary" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "F.toPrimary" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 magnitude := base.magnitude 
 -- OG:Qalloc:SuperAlloc: "fromPrimary:: {   magnitude := base.magnitude}" 
 -- OG:Qalloc: "magnitude := base.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  ""  marked:  false "fromPrimary:: {   magnitude := base.magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  50 5 in base: var PrimaryUnit{inner(fromPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude := base.magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "fromPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 155 IS.newDescNo: 155 objSize: 0 1: 1 "magnitude := base.magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 155 "magnitude := base.magnitude" 
 -- Items:Qalloc:super: "" size: 5 "fromPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "base.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "base.magnitude"  marked:  false "magnitude := base.magnitude" super:  base.magnitude 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude" 
 -- super:  "base.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "base.magnitude" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 155 "magnitude := base.magnitude" 
 -- IS.newDescNo: 155 IS.objSize: 5 "magnitude := base.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  155 "magnitude := base.magnitude" 
 -- OG:super:  "fromPrimary:: {   magnitude := base.magnitude}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C.fromPrimary(F.toPrimary)" 
 -- super:  "C.fromPrimary(F.toPrimary)" 
 -- E:  "fromPrimary(F.toPrimary)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C.fromPrimary(F.toPrimary)" 
 -- OG:Qalloc: "C.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "C.print"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fro ...}" s ... C ... 
 -- Invocation:Qalloc: "C.print" 
 -- ObjectInvocation:Qalloc: "C" 
 -- name: "C" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  149 3 "Celsius".print 
 -- OG:super:  "print:: {   "Celsius".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "C.print" 
 -- super:  "C.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "C.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.f ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 143 "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fromPrimary(C.to ...}" 
 -- IS.newDescNo: 143 IS.objSize: 5 "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fromPrimary(C.toPrimary);F.p ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  143 "C: var Temperature.Celsius{   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimary ...}" 
 -- OG:super:  "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimary(C.t ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "temperatureEx" 
 -- super:  "temperatureEx" 
 -- E:  "temperatureEx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "temperatureEx" 
 -- OG:Qalloc: "lengthEx" qDescno:  0 
 -- OG:Qalloc:A:  "LengthEx"  super:  "lengthEx"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;   ...}" s ... l ... 
 -- Invocation:Qalloc: "lengthEx" 
 -- ObjectInvocation:Qalloc: "lengthEx" 
 -- name: "lengthEx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPrima ...} 
 -- OG:Qalloc:SuperAlloc: "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimar ...}" 
 -- OG:Qalloc: "L: var Length.Meter{   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   F.print;   "kok:\n" ...}" q ... 0 
 -- OG:Qalloc:A:  "LengthEx"  super:  ""  marked:  false "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newl ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L: var Length.Meter{   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   F.print;   "kok:\n".print;   n ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "LengthEx" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 156 IS.newDescNo: 156 objSize: 0 1: 1 "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 156 "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPrimary);F.print;"ko ..."}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "F" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('!');     ...}" 
 -- newDescNo: 130 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "Length.F2M(3.05)" qDescno:  0 
 -- OG:Qalloc:A:  "F2M"  super:  "Length.F2M(3.05)"  marked:  false "L := Length.F2M(3.05)" super:  Length.F2M(3.05) 
 -- Invocation:Qalloc: "Length.F2M(3.05)" 
 -- ObjectInvocation:Qalloc: "Length" 
 -- name: "Length" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "F2M(3.05)" 
 -- name: "F2M" 
 -- Arguments "F2M(3.05)" 
 -- OG:Qalloc: "3.05" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "3.05"  marked:  false "F2M(3.05)" super:  3.05 
 -- Invocation:Qalloc: "3.05" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "3.05" 
 -- super:  "3.05" 
 -- E:  "3.05" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "3.05" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  134 5 in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')} 
 -- OG:super:  "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Length.F2M(3.05)" 
 -- super:  "Length.F2M(3.05)" 
 -- E:  "F2M(3.05)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Length.F2M(3.05)" 
 -- OG:Qalloc: ""kuk:\n".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""kuk:\n".print"  marked:  false "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary( ...}" s ... " ..." 
 -- Invocation:Qalloc: ""kuk:\n".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""kuk:\n".print" 
 -- super:  ""kuk:\n".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""kuk:\n".print" 
 -- OG:Qalloc: "L.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "L.print"  marked:  false "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPri ...}" s ... L ... 
 -- Invocation:Qalloc: "L.print" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.print" 
 -- super:  "L.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toP ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- OG:Qalloc: "F.fromPrimary(L.toPrimary)" qDescno:  0 
 -- OG:Qalloc:A:  "fromPrimary"  super:  "F.fromPrimary(L.toPrimary)"  marked:  false "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newl ...}" s ... F ... 
 -- Invocation:Qalloc: "F.fromPrimary(L.toPrimary)" 
 -- ObjectInvocation:Qalloc: "F" 
 -- name: "F" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "fromPrimary(L.toPrimary)" 
 -- name: "fromPrimary" 
 -- Arguments "fromPrimary(L.toPrimary)" 
 -- OG:Qalloc: "L.toPrimary" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  "L.toPrimary"  marked:  false "fromPrimary(L.toPrimary)" super:  L.toPrimary 
 -- Invocation:Qalloc: "L.toPrimary" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "toPrimary" 
 -- name: "toPrimary" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  78 5 base.magnitude := magnitude 
 -- OG:super:  "toPrimary:: {   base.magnitude := magnitude}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L.toPrimary" 
 -- super:  "L.toPrimary" 
 -- E:  "toPrimary" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L.toPrimary" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  135 5 put('!'){magnitude := base.magnitude / 0.3048} 
 -- OG:super:  "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F.fromPrimary(L.toPrimary)" 
 -- super:  "F.fromPrimary(L.toPrimary)" 
 -- E:  "fromPrimary(L.toPrimary)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "F.fromPrimary(L.toPrimary)" 
 -- OG:Qalloc: "F.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "F.print"  marked:  false "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPri ...}" s ... F ... 
 -- Invocation:Qalloc: "F.print" 
 -- ObjectInvocation:Qalloc: "F" 
 -- name: "F" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  136 3 "Foot".print 
 -- OG:super:  "print:: {   "Foot".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "F.print" 
 -- super:  "F.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "F.print" 
 -- OG:Qalloc: ""kok:\n".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  ""kok:\n".print"  marked:  false "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary( ...}" s ... " ..." 
 -- Invocation:Qalloc: ""kok:\n".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- ""kok:\n".print" 
 -- super:  ""kok:\n".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 ""kok:\n".print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toP ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 156 "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPrimary);F.print ...}" 
 -- IS.newDescNo: 156 IS.objSize: 5 "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPrimary);F.print;"kok:\n".pr ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  156 "L: var Length.Meter{   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary) ...}" 
 -- OG:super:  "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   F.pri ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "lengthEx" 
 -- super:  "lengthEx" 
 -- E:  "lengthEx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "lengthEx" 
 -- Invocation:Qalloc: "A" 
 -- ObjectInvocation:Qalloc: "A" 
 -- name: "A" 
 -- Arguments "" 
 -- OG:Qalloc: "15.6"m2"" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "15.6"m2""  marked:  false "A := 15.6"m2"" super:  15.6"m2" 
 -- Invocation:Qalloc: "15.6"m2"" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "15.6"m2"" 
 -- super:  "15.6"m2"" 
 -- E:  "15.6"m2"" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "15.6"m2"" 
 -- OG:Qalloc: "A.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "A.print"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;       ...}" s ... A ... 
 -- Invocation:Qalloc: "A.print" 
 -- ObjectInvocation:Qalloc: "A" 
 -- name: "A" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  70 3 "SquareMeter".print 
 -- OG:super:  "print:: {   "SquareMeter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "A.print" 
 -- super:  "A.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "A.print" 
 -- OG:Qalloc: "newline" qDescno:  0 
 -- OG:Qalloc:A:  "newline"  super:  "newline"  marked:  false "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;     ...}" s ... n ... 
 -- Invocation:Qalloc: "newline" 
 -- ObjectInvocation:Qalloc: "newline" 
 -- name: "newline" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  98 0 %globals{put(10)} 
 -- OG:super:  "newline: {   %globals;   put(10)}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "newline" 
 -- super:  "newline" 
 -- E:  "newline" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "newline" 
 -- Items:Qalloc:END:objSize: 14  newDescNo: 129 "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var A ...}" 
 -- IS.newDescNo: 129 IS.objSize: 14 "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMe ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  129 "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var  ...}" 
 -- ObjTmpStack:add: "UnitEx" : "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.S ...}" 
 -- items:markForCodeGen: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter;      i ...}" 
 -- markItem: "%requires Dimensions, Area, Length, Temperature, Velocity, Time" Property 
 -- markItem: "%visible Dimensions" Property 
 -- DataItem:markForCodeGen: "L1" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L2" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Foot" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Foot" 
 -- "Length" false 
 -- "Foot" false 
 -- 
 -- OG:markSuper: "Length.Foot" 
 -- Invocation:markForCodeGen: "Length.Foot" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Foot"  ATd: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);  ...}" 
 -- Pattern:markForCodeGen: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('!');  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('!');      mag ...}" 
 -- OG:Qalloc: "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('!');      mag ...}" q ... 130 
 -- ObjTmpStack:add: "Foot" : "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put ...}" 
 -- items:markForCodeGen: "%unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrimary:: ;   put('!');   magnitude := base.mag ...}" 
 -- markItem: "%unit "F", 0.3048" Property 
 -- Pattern:markForCodeGen: "thisUnit:: Foot" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Foot" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Foot" 
 -- "Foot" false 
 -- 
 -- OG:markSuper: "Foot" 
 -- Invocation:markForCodeGen: "Foot" 
 -- ObjectInvocation:markForCodeGen: "Foot"  ATd: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);  ...}" 
 -- Pattern:markForCodeGen: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Foot"  IS.isEmpty:  true 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "toPrimary:: {   base.magnitude := (magnitude * 0.3048)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "base.magnitude := (magnitude * 0.3048)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "base.magnitude := (magnitude * 0.3048)" 
 -- OG:Qalloc: "base.magnitude := (magnitude * 0.3048)" qDescno:  0 
 -- OG:Qalloc:A:  "toPrimary"  super:  ""  marked:  true "toPrimary:: {   base.magnitude := (magnitude * 0.3048)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  49 5 out base: var PrimaryUnit{inner(toPrimary)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "base.magnitude := (magnitude * 0.3048)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "toPrimary" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 157 IS.newDescNo: 157 objSize: 0 1: 1 "base.magnitude := (magnitude * 0.3048)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 157 "base.magnitude := (magnitude * 0.3048)" 
 -- Items:Qalloc:super: "" size: 5 "toPrimary" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 5 originOff: 1 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- Invocation:Qalloc: "base.magnitude" 
 -- ObjectInvocation:Qalloc: "base" 
 -- name: "base" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "(magnitude * 0.3048)" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "(magnitude * 0.3048)"  marked:  false "base.magnitude := (magnitude * 0.3048)" super:  (magnitude * 0.3048) 
 -- Invocation:Qalloc: "(magnitude * 0.3048)" 
 -- Invocation:Qalloc: "magnitude * 0.3048" 
 -- BinaryExp:Qalloc: "magnitude * 0.3048" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* 0.3048" 
 -- name: "*" 
 -- Arguments "0.3048" 
 -- OG:Qalloc: "0.3048" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "0.3048"  marked:  false "0.3048" super:  0.3048 
 -- Invocation:Qalloc: "0.3048" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "0.3048" 
 -- super:  "0.3048" 
 -- E:  "0.3048" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "0.3048" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 7 %basic 112{in V: var float;out R: var float} 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(magnitude * 0.3048)" 
 -- super:  "(magnitude * 0.3048)" 
 -- E:  "(magnitude * 0.3048)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(magnitude * 0.3048)" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 157 "base.magnitude := (magnitude * 0.3048)" 
 -- IS.newDescNo: 157 IS.objSize: 5 "base.magnitude := (magnitude * 0.3048)" 
 -- OG:Qalloc:end: IS.newDescNo:  157 "base.magnitude := (magnitude * 0.3048)" 
 -- ObjTmpStack:add: "toPrimary" : "base.magnitude := (magnitude * 0.3048)" 
 -- items:markForCodeGen: "base.magnitude := (magnitude * 0.3048)" 
 -- markItem: "base.magnitude := (magnitude * 0.3048)" Assign 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "out base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "(magnitude * 0.3048)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(magnitude * 0.3048)" 
 -- "(magnitude * 0.3048)" true 
 -- 
 -- OG:markSuper: "(magnitude * 0.3048)" 
 -- Invocation:markForCodeGen: "(magnitude * 0.3048)" 
 -- Invocation:markForCodeGen: "magnitude * 0.3048" 
 -- BinaryExp:markForCodeGen: "magnitude * 0.3048" 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* 0.3048"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "0.3048" 
 -- OG:markForCodeGen: "0.3048" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0.3048" 
 -- "0.3048" true 
 -- 
 -- OG:markSuper: "0.3048" 
 -- Invocation:markForCodeGen: "0.3048" 
 -- not ObjDesc:  "0.3048"  IS.isEmpty:  true 
 -- not ObjDesc:  "(magnitude * 0.3048)"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "put('!'){   magnitude := base.magnitude / 0.3048}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "put('!'){   magnitude := base.magnitude / 0.3048}" 
 -- OG:Qalloc: "put('!'){   magnitude := base.magnitude / 0.3048}" qDescno:  135 
 -- ObjTmpStack:add: "fromPrimary" : "put('!'){   magnitude := base.magnitude / 0.3048}" 
 -- items:markForCodeGen: "put('!'){magnitude := base.magnitude / 0.3048}" 
 -- markItem: "put('!')" ObjectGenerator 
 -- OG:markForCodeGen: "put('!')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('!')" 
 -- "put('!')" true 
 -- 
 -- OG:markSuper: "put('!')" 
 -- Invocation:markForCodeGen: "put('!')" 
 -- ObjectInvocation:markForCodeGen: "put('!')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('!')" 
 -- OG:markForCodeGen: "'!'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'!'" 
 -- "'!'" true 
 -- 
 -- OG:markSuper: "'!'" 
 -- Invocation:markForCodeGen: "'!'" 
 -- not ObjDesc:  "'!'"  IS.isEmpty:  true 
 -- arg:   "'!'" 
 -- not ObjDesc:  "put('!')"  IS.isEmpty:  true 
 -- markItem: "magnitude := base.magnitude / 0.3048" Assign 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "base.magnitude / 0.3048" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "base.magnitude / 0.3048" 
 -- "base.magnitude / 0.3048" true 
 -- 
 -- OG:markSuper: "base.magnitude / 0.3048" 
 -- Invocation:markForCodeGen: "base.magnitude / 0.3048" 
 -- BinaryExp:markForCodeGen: "base.magnitude / 0.3048" 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "in base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "/ 0.3048"  ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "0.3048" 
 -- OG:markForCodeGen: "0.3048" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "0.3048" 
 -- "0.3048" true 
 -- 
 -- OG:markSuper: "0.3048" 
 -- Invocation:markForCodeGen: "0.3048" 
 -- not ObjDesc:  "0.3048"  IS.isEmpty:  true 
 -- not ObjDesc:  "base.magnitude / 0.3048"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "print:: {   "Foot".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""Foot".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""Foot".print" 
 -- OG:Qalloc: ""Foot".print" qDescno:  136 
 -- ObjTmpStack:add: "print" : ""Foot".print" 
 -- items:markForCodeGen: ""Foot".print" 
 -- markItem: ""Foot".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Foot".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Foot".print" 
 -- ""Foot"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Foot".print" 
 -- Invocation:markForCodeGen: ""Foot".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Foot".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Foot"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L3" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Rectangle" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Rectangle" 
 -- "Rectangle" false 
 -- 
 -- OG:markSuper: "Rectangle" 
 -- Invocation:markForCodeGen: "Rectangle" 
 -- ObjectInvocation:markForCodeGen: "Rectangle"  ATd: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in ...}" 
 -- Pattern:markForCodeGen: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;       ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width := w;      ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Figure" 
 -- "Figure" false 
 -- 
 -- OG:markSuper: "Figure" 
 -- Invocation:markForCodeGen: "Figure" 
 -- ObjectInvocation:markForCodeGen: "Figure"  ATd: "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inne ...}" 
 -- Pattern:markForCodeGen: "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: v ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "theArea:< {      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area.SquareMet ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "theArea:< {      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area.SquareMeter;      ...}" 
 -- OG:Qalloc: "theArea:< {      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area.SquareMeter;      ...}" q ... 132 
 -- ObjTmpStack:add: "Figure" : "theArea:< {      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area. ...}" 
 -- items:markForCodeGen: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea);print:< ;   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:" ...}" 
 -- Pattern:markForCodeGen: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out A: var Area.SquareMeter{   inner(theArea)}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out A: var Area.SquareMeter{   inner(theArea)}" 
 -- OG:Qalloc: "out A: var Area.SquareMeter{   inner(theArea)}" qDescno:  139 
 -- ObjTmpStack:add: "theArea" : "out A: var Area.SquareMeter{   inner(theArea)}" 
 -- items:markForCodeGen: "out A: var Area.SquareMeter{inner(theArea)}" 
 -- DataItem:markForCodeGen: "A" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Area.SquareMeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Area.SquareMeter" 
 -- "Area" false 
 -- "SquareMeter" false 
 -- 
 -- OG:markSuper: "Area.SquareMeter" 
 -- Invocation:markForCodeGen: "Area.SquareMeter" 
 -- ObjectInvocation:markForCodeGen: "Area"  ATd: "--Area{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "SquareMeter"  ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Area.SquareMeter"  IS.isEmpty:  true 
 -- markItem: "inner(theArea)" ObjectGenerator 
 -- Pattern:markForCodeGen: "print:< {   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "printMore:< {      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.print;   p ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "printMore:< {      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.print;   printMore ...}" 
 -- OG:Qalloc: "printMore:< {      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.print;   printMore ...}" q ... 138 
 -- ObjTmpStack:add: "print" : "printMore:< {      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.pr ...}" 
 -- items:markForCodeGen: "printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := theArea;AR.print;printMore}" 
 -- Pattern:markForCodeGen: "printMore:< {   inner(printMore)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "inner(printMore)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "inner(printMore)" 
 -- OG:Qalloc: "inner(printMore)" qDescno:  140 
 -- ObjTmpStack:add: "printMore" : "inner(printMore)" 
 -- items:markForCodeGen: "inner(printMore)" 
 -- markItem: "inner(printMore)" ObjectGenerator 
 -- DataItem:markForCodeGen: "AR" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Area.SquareMeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Area.SquareMeter" 
 -- "Area" false 
 -- "SquareMeter" false 
 -- 
 -- OG:markSuper: "Area.SquareMeter" 
 -- Invocation:markForCodeGen: "Area.SquareMeter" 
 -- ObjectInvocation:markForCodeGen: "Area"  ATd: "--Area{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "SquareMeter"  ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Area.SquareMeter"  IS.isEmpty:  true 
 -- markItem: ""Figure:".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Figure:".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Figure:".print" 
 -- ""Figure:"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Figure:".print" 
 -- Invocation:markForCodeGen: ""Figure:".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Figure:".print"  IS.isEmpty:  true 
 -- markItem: "inner(print)" ObjectGenerator 
 -- markItem: ""\nArea:".print" ObjectGenerator 
 -- OG:markForCodeGen: ""\nArea:".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""\nArea:".print" 
 -- ""\nArea:"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""\nArea:".print" 
 -- Invocation:markForCodeGen: ""\nArea:".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""\nArea:".print"  IS.isEmpty:  true 
 -- markItem: "AR := theArea" Assign 
 -- Invocation:markForCodeGen: "AR" 
 -- ObjectInvocation:markForCodeGen: "AR"  ATd: "AR: var Area.SquareMeter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "theArea" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "theArea" 
 -- "theArea" false 
 -- 
 -- OG:markSuper: "theArea" 
 -- Invocation:markForCodeGen: "theArea" 
 -- ObjectInvocation:markForCodeGen: "theArea"  ATd: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "theArea"  IS.isEmpty:  true 
 -- markItem: "AR.print" ObjectGenerator 
 -- OG:markForCodeGen: "AR.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "AR.print" 
 -- "AR" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "AR.print" 
 -- Invocation:markForCodeGen: "AR.print" 
 -- ObjectInvocation:markForCodeGen: "AR"  ATd: "AR: var Area.SquareMeter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "AR.print"  IS.isEmpty:  true 
 -- markItem: "printMore" ObjectGenerator 
 -- OG:markForCodeGen: "printMore" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "printMore" 
 -- "printMore" false 
 -- 
 -- OG:markSuper: "printMore" 
 -- Invocation:markForCodeGen: "printMore" 
 -- ObjectInvocation:markForCodeGen: "printMore"  ATd: "printMore:< {   inner(printMore)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "printMore"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width := w;      heigth  ...}" 
 -- OG:Qalloc: "Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width := w;      heigth  ...}" q ... 133 
 -- ObjTmpStack:add: "Rectangle" : "Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      widt ...}" 
 -- items:markForCodeGen: "width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h;theArea:: ;  ...}" 
 -- DataItem:markForCodeGen: "width" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "heigth" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "theArea:: {   A := Area.mult(width,heigth)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "A := Area.mult(width,heigth)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "A := Area.mult(width,heigth)" 
 -- OG:Qalloc: "A := Area.mult(width,heigth)" qDescno:  0 
 -- OG:Qalloc:A:  "theArea"  super:  ""  marked:  true "theArea:: {   A := Area.mult(width,heigth)}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  139 3 out A: var Area.SquareMeter{inner(theArea)} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "A := Area.mult(width,heigth)" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "theArea" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 158 IS.newDescNo: 158 objSize: 0 1: 1 "A := Area.mult(width,heigth)" 
 -- Items:Qalloc:objSize: 0  newDescNo: 158 "A := Area.mult(width,heigth)" 
 -- Items:Qalloc:super: "" size: 3 "theArea" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Invocation:Qalloc: "A" 
 -- ObjectInvocation:Qalloc: "A" 
 -- name: "A" 
 -- Arguments "" 
 -- OG:Qalloc: "Area.mult(width,heigth)" qDescno:  0 
 -- OG:Qalloc:A:  "mult"  super:  "Area.mult(width,heigth)"  marked:  false "A := Area.mult(width,heigth)" super:  Area.mult(width,heigth) 
 -- Invocation:Qalloc: "Area.mult(width,heigth)" 
 -- ObjectInvocation:Qalloc: "Area" 
 -- name: "Area" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "mult(width,heigth)" 
 -- name: "mult" 
 -- Arguments "(width,heigth)" 
 -- OG:Qalloc: "width" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "width"  marked:  false "(width,heigth)" super:  width 
 -- Invocation:Qalloc: "width" 
 -- ObjectInvocation:Qalloc: "width" 
 -- name: "width" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "width: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "width" 
 -- super:  "width" 
 -- E:  "width" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "width" 
 -- OG:Qalloc: "heigth" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "heigth"  marked:  false "(width,heigth)" super:  heigth 
 -- Invocation:Qalloc: "heigth" 
 -- ObjectInvocation:Qalloc: "heigth" 
 -- name: "heigth" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "heigth: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "heigth" 
 -- super:  "heigth" 
 -- E:  "heigth" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "heigth" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 in A: var Length.Meter{in B: var Length.Meter;out R: var squareMeter;R.magnitude := A.magnitude * B.magnitude} 
 -- OG:Qalloc:SuperAlloc: "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- OG:Qalloc: "in A: var Length.Meter{   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" qDescno:  0 
 -- OG:Qalloc:A:  "mult"  super:  ""  marked:  false "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.ma ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in A: var Length.Meter{   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "mult" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 159 IS.newDescNo: 159 objSize: 0 1: 1 "in A: var Length.Meter{in B: var Length.Meter;out R: var squareMeter;R.magnitude := A.magnitude * B.magni ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 159 "in A: var Length.Meter{in B: var Length.Meter;out R: var squareMeter;R.magnitude := A.magnitude * B.magnitude}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "A" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- newDescNo: 68 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "A.magnitude * B.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "A.magnitude * B.magnitude"  marked:  false "R.magnitude := A.magnitude * B.magnitude" super:  A.magnitude * B.magnitude 
 -- Invocation:Qalloc: "A.magnitude * B.magnitude" 
 -- BinaryExp:Qalloc: "A.magnitude * B.magnitude" 
 -- Invocation:Qalloc: "A.magnitude" 
 -- ObjectInvocation:Qalloc: "A" 
 -- name: "A" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "* B.magnitude" 
 -- name: "*" 
 -- Arguments "B.magnitude" 
 -- OG:Qalloc: "B.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "B.magnitude"  marked:  false "B.magnitude" super:  B.magnitude 
 -- Invocation:Qalloc: "B.magnitude" 
 -- ObjectInvocation:Qalloc: "B" 
 -- name: "B" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "B.magnitude" 
 -- super:  "B.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "B.magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 7 %basic 112{in V: var float;out R: var float} 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "A.magnitude * B.magnitude" 
 -- super:  "A.magnitude * B.magnitude" 
 -- E:  "A.magnitude * B.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "A.magnitude * B.magnitude" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 159 "in A: var Length.Meter{in B: var Length.Meter;out R: var squareMeter;R.magnitude := A.magnitude * B.magnitude}" 
 -- IS.newDescNo: 159 IS.objSize: 7 "in A: var Length.Meter{in B: var Length.Meter;out R: var squareMeter;R.magnitude := A.magnitude * B.magnitude}" 
 -- OG:Qalloc:end: IS.newDescNo:  159 "in A: var Length.Meter{   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- OG:super:  "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Area.mult(width,heigth)" 
 -- super:  "Area.mult(width,heigth)" 
 -- E:  "mult(width,heigth)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Area.mult(width,heigth)" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 158 "A := Area.mult(width,heigth)" 
 -- IS.newDescNo: 158 IS.objSize: 3 "A := Area.mult(width,heigth)" 
 -- OG:Qalloc:end: IS.newDescNo:  158 "A := Area.mult(width,heigth)" 
 -- ObjTmpStack:add: "theArea" : "A := Area.mult(width,heigth)" 
 -- items:markForCodeGen: "A := Area.mult(width,heigth)" 
 -- markItem: "A := Area.mult(width,heigth)" Assign 
 -- Invocation:markForCodeGen: "A" 
 -- ObjectInvocation:markForCodeGen: "A"  ATd: "out A: var Area.SquareMeter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Area.mult(width,heigth)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Area.mult(width,heigth)" 
 -- "Area" false 
 -- "mult(width,heigth)" false 
 -- 
 -- OG:markSuper: "Area.mult(width,heigth)" 
 -- Invocation:markForCodeGen: "Area.mult(width,heigth)" 
 -- ObjectInvocation:markForCodeGen: "Area"  ATd: "--Area{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "mult(width,heigth)"  ATd: "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magni ...}" 
 -- Pattern:markForCodeGen: "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in A: var Length.Meter{   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in A: var Length.Meter{   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- OG:Qalloc: "in A: var Length.Meter{   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" qDescno:  159 
 -- ObjTmpStack:add: "mult" : "in A: var Length.Meter{   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude}" 
 -- items:markForCodeGen: "in A: var Length.Meter{in B: var Length.Meter;out R: var squareMeter;R.magnitude := A.magnitude * B.magnitude}" 
 -- DataItem:markForCodeGen: "A" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "B" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "squareMeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "squareMeter" 
 -- "squareMeter" false 
 -- 
 -- OG:markSuper: "squareMeter" 
 -- Invocation:markForCodeGen: "squareMeter" 
 -- ObjectInvocation:markForCodeGen: "squareMeter"  ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "squareMeter"  IS.isEmpty:  true 
 -- markItem: "R.magnitude := A.magnitude * B.magnitude" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var squareMeter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "A.magnitude * B.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "A.magnitude * B.magnitude" 
 -- "A.magnitude * B.magnitude" true 
 -- 
 -- OG:markSuper: "A.magnitude * B.magnitude" 
 -- Invocation:markForCodeGen: "A.magnitude * B.magnitude" 
 -- BinaryExp:markForCodeGen: "A.magnitude * B.magnitude" 
 -- Invocation:markForCodeGen: "A.magnitude" 
 -- ObjectInvocation:markForCodeGen: "A"  ATd: "in A: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* B.magnitude"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "B.magnitude" 
 -- OG:markForCodeGen: "B.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "B.magnitude" 
 -- "B" false 
 -- "magnitude" true 
 -- 
 -- not ObjDesc:  "A.magnitude * B.magnitude"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "(width,heigth)" 
 -- OG:markForCodeGen: "width" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "width" 
 -- "width" false 
 -- 
 -- OG:markForCodeGen: "heigth" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "heigth" 
 -- "heigth" false 
 -- 
 -- arg:   "width" 
 -- arg:   "heigth" 
 -- not ObjDesc:  "Area.mult(width,heigth)"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   wid ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "printMore:: {      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print;   ":hei ..."}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "printMore:: {      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print;   ":heigth:".pr ...}" 
 -- OG:Qalloc: "printMore:: {      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print;   ":heigth:".pr ...}" q ... 141 
 -- ObjTmpStack:add: "print" : "printMore:: {      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print; ...}" 
 -- items:markForCodeGen: "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;width.print;":heigth:".print;heigth ...}" 
 -- Pattern:markForCodeGen: "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "P: var Length.meter{   " Perimeter:".print;   P := Perimeter;   P.print}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "P: var Length.meter{   " Perimeter:".print;   P := Perimeter;   P.print}" 
 -- OG:Qalloc: "P: var Length.meter{   " Perimeter:".print;   P := Perimeter;   P.print}" qDescno:  0 
 -- OG:Qalloc:A:  "printMore"  super:  ""  marked:  true "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  140 1 inner(printMore) 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P: var Length.meter{   " Perimeter:".print;   P := Perimeter;   P.print}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "printMore" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 160 IS.newDescNo: 160 objSize: 0 1: 1 "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 160 "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" 
 -- Items:Qalloc:super: "" size: 1 "printMore" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "P" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- OG:Qalloc: "" Perimeter:".print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "" Perimeter:".print"  marked:  false "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" super:  " Perimeter:".print 
 -- Invocation:Qalloc: "" Perimeter:".print" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  52 1 gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- OG:super:  "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "" Perimeter:".print" 
 -- super:  "" Perimeter:".print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "" Perimeter:".print" 
 -- Invocation:Qalloc: "P" 
 -- ObjectInvocation:Qalloc: "P" 
 -- name: "P" 
 -- Arguments "" 
 -- OG:Qalloc: "Perimeter" qDescno:  0 
 -- OG:Qalloc:A:  "perimeter"  super:  "Perimeter"  marked:  false "P := Perimeter" super:  Perimeter 
 -- Invocation:Qalloc: "Perimeter" 
 -- ObjectInvocation:Qalloc: "Perimeter" 
 -- name: "Perimeter" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 out V: var Length.Meter{V := (width + heigth) * 2.0} 
 -- OG:Qalloc:SuperAlloc: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" 
 -- OG:Qalloc: "out V: var Length.Meter{   V := (width + heigth) * 2.0}" qDescno:  0 
 -- OG:Qalloc:A:  "perimeter"  super:  ""  marked:  false "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "out V: var Length.Meter{   V := (width + heigth) * 2.0}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "perimeter" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 161 IS.newDescNo: 161 objSize: 0 1: 1 "out V: var Length.Meter{V := (width + heigth) * 2.0}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 161 "out V: var Length.Meter{V := (width + heigth) * 2.0}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- new_size:A: true   "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ...}" 
 -- new_size:C: 2  qSize: 2 
 -- B: 2 ptn: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magnitude;   ...}" 
 -- newDescNo: 74 
 -- diSize: 2 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "(width + heigth) * 2.0" qDescno:  0 
 -- OG:Qalloc:A:  "*"  super:  "(width + heigth) * 2.0"  marked:  false "V := (width + heigth) * 2.0" super:  (width + heigth) * 2.0 
 -- Invocation:Qalloc: "(width + heigth) * 2.0" 
 -- BinaryExp:Qalloc: "(width + heigth) * 2.0" 
 -- Invocation:Qalloc: "(width + heigth)" 
 -- Invocation:Qalloc: "width + heigth" 
 -- BinaryExp:Qalloc: "width + heigth" 
 -- Invocation:Qalloc: "width" 
 -- ObjectInvocation:Qalloc: "width" 
 -- name: "width" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ heigth" 
 -- name: "+" 
 -- Arguments "heigth" 
 -- OG:Qalloc: "heigth" qDescno:  0 
 -- OG:Qalloc:A:  "Meter"  super:  "heigth"  marked:  false "heigth" super:  heigth 
 -- Invocation:Qalloc: "heigth" 
 -- ObjectInvocation:Qalloc: "heigth" 
 -- name: "heigth" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  74 2 %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := ...} 
 -- OG:super:  "heigth: var Length.Meter" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "heigth" 
 -- super:  "heigth" 
 -- E:  "heigth" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "heigth" 
 -- ObjectInvocation:Qalloc: "* 2.0" 
 -- name: "*" 
 -- Arguments "2.0" 
 -- OG:Qalloc: "2.0" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "2.0"  marked:  false "2.0" super:  2.0 
 -- Invocation:Qalloc: "2.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   -  : ;  ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "2.0" 
 -- super:  "2.0" 
 -- E:  "2.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "2.0" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  65 7 %basic 112{in V: var float;out R: var float} 
 -- OG:super:  "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(width + heigth) * 2.0" 
 -- super:  "(width + heigth) * 2.0" 
 -- E:  "(width + heigth) * 2.0" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(width + heigth) * 2.0" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 161 "out V: var Length.Meter{V := (width + heigth) * 2.0}" 
 -- IS.newDescNo: 161 IS.objSize: 3 "out V: var Length.Meter{V := (width + heigth) * 2.0}" 
 -- OG:Qalloc:end: IS.newDescNo:  161 "out V: var Length.Meter{   V := (width + heigth) * 2.0}" 
 -- OG:super:  "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Perimeter" 
 -- super:  "Perimeter" 
 -- E:  "Perimeter" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Perimeter" 
 -- OG:Qalloc: "P.print" qDescno:  0 
 -- OG:Qalloc:A:  "print"  super:  "P.print"  marked:  false "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" super:  P.print 
 -- Invocation:Qalloc: "P.print" 
 -- ObjectInvocation:Qalloc: "P" 
 -- name: "P" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "print" 
 -- name: "print" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  80 3 "Meter".print 
 -- OG:super:  "print:: {   "Meter".print}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "P.print" 
 -- super:  "P.print" 
 -- E:  "print" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "P.print" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 160 "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" 
 -- IS.newDescNo: 160 IS.objSize: 3 "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" 
 -- OG:Qalloc:end: IS.newDescNo:  160 "P: var Length.meter{   " Perimeter:".print;   P := Perimeter;   P.print}" 
 -- ObjTmpStack:add: "printMore" : "P: var Length.meter{   " Perimeter:".print;   P := Perimeter;   P.print}" 
 -- items:markForCodeGen: "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" 
 -- DataItem:markForCodeGen: "P" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.meter" 
 -- "Length" false 
 -- "meter" false 
 -- 
 -- OG:markSuper: "Length.meter" 
 -- Invocation:markForCodeGen: "Length.meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.meter"  IS.isEmpty:  true 
 -- markItem: "" Perimeter:".print" ObjectGenerator 
 -- OG:markForCodeGen: "" Perimeter:".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" Perimeter:".print" 
 -- "" Perimeter:"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "" Perimeter:".print" 
 -- Invocation:markForCodeGen: "" Perimeter:".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "" Perimeter:".print"  IS.isEmpty:  true 
 -- markItem: "P := Perimeter" Assign 
 -- Invocation:markForCodeGen: "P" 
 -- ObjectInvocation:markForCodeGen: "P"  ATd: "P: var Length.meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Perimeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Perimeter" 
 -- "Perimeter" false 
 -- 
 -- OG:markSuper: "Perimeter" 
 -- Invocation:markForCodeGen: "Perimeter" 
 -- ObjectInvocation:markForCodeGen: "Perimeter"  ATd: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" 
 -- Pattern:markForCodeGen: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "out V: var Length.Meter{   V := (width + heigth) * 2.0}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "out V: var Length.Meter{   V := (width + heigth) * 2.0}" 
 -- OG:Qalloc: "out V: var Length.Meter{   V := (width + heigth) * 2.0}" qDescno:  161 
 -- ObjTmpStack:add: "perimeter" : "out V: var Length.Meter{   V := (width + heigth) * 2.0}" 
 -- items:markForCodeGen: "out V: var Length.Meter{V := (width + heigth) * 2.0}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- markItem: "V := (width + heigth) * 2.0" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "out V: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "(width + heigth) * 2.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(width + heigth) * 2.0" 
 -- "(width + heigth) * 2.0" true 
 -- 
 -- OG:markSuper: "(width + heigth) * 2.0" 
 -- Invocation:markForCodeGen: "(width + heigth) * 2.0" 
 -- BinaryExp:markForCodeGen: "(width + heigth) * 2.0" 
 -- Invocation:markForCodeGen: "(width + heigth)" 
 -- Invocation:markForCodeGen: "width + heigth" 
 -- BinaryExp:markForCodeGen: "width + heigth" 
 -- Invocation:markForCodeGen: "width" 
 -- ObjectInvocation:markForCodeGen: "width"  ATd: "width: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ heigth"  ATd: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- Pattern:markForCodeGen: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "heigth" 
 -- OG:markForCodeGen: "heigth" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "heigth" 
 -- "heigth" false 
 -- 
 -- ObjectInvocation:markForCodeGen: "* 2.0"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "2.0" 
 -- OG:markForCodeGen: "2.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "2.0" 
 -- "2.0" true 
 -- 
 -- OG:markSuper: "2.0" 
 -- Invocation:markForCodeGen: "2.0" 
 -- not ObjDesc:  "2.0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(width + heigth) * 2.0"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Perimeter"  IS.isEmpty:  true 
 -- markItem: "P.print" ObjectGenerator 
 -- OG:markForCodeGen: "P.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "P.print" 
 -- "P" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "P.print" 
 -- Invocation:markForCodeGen: "P.print" 
 -- ObjectInvocation:markForCodeGen: "P"  ATd: "P: var Length.meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "P.print"  IS.isEmpty:  true 
 -- markItem: ""Rectangle:width:".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Rectangle:width:".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Rectangle:width:".print" 
 -- ""Rectangle:width:"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Rectangle:width:".print" 
 -- Invocation:markForCodeGen: ""Rectangle:width:".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Rectangle:width:".print"  IS.isEmpty:  true 
 -- markItem: "width.print" ObjectGenerator 
 -- OG:markForCodeGen: "width.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "width.print" 
 -- "width" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "width.print" 
 -- Invocation:markForCodeGen: "width.print" 
 -- ObjectInvocation:markForCodeGen: "width"  ATd: "width: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "width.print"  IS.isEmpty:  true 
 -- markItem: "":heigth:".print" ObjectGenerator 
 -- OG:markForCodeGen: "":heigth:".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "":heigth:".print" 
 -- "":heigth:"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "":heigth:".print" 
 -- Invocation:markForCodeGen: "":heigth:".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "":heigth:".print"  IS.isEmpty:  true 
 -- markItem: "heigth.print" ObjectGenerator 
 -- OG:markForCodeGen: "heigth.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "heigth.print" 
 -- "heigth" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "heigth.print" 
 -- Invocation:markForCodeGen: "heigth.print" 
 -- ObjectInvocation:markForCodeGen: "heigth"  ATd: "heigth: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "heigth.print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Rectangle"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Velocity.MeterPerSecond" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Velocity.MeterPerSecond" 
 -- "Velocity" false 
 -- "MeterPerSecond" false 
 -- 
 -- OG:markSuper: "Velocity.MeterPerSecond" 
 -- Invocation:markForCodeGen: "Velocity.MeterPerSecond" 
 -- ObjectInvocation:markForCodeGen: "Velocity"  ATd: "--Velocity{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "MeterPerSecond"  ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Velocity.MeterPerSecond"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Time.Minutes" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Time.Minutes" 
 -- "Time" false 
 -- "Minutes" false 
 -- 
 -- OG:markSuper: "Time.Minutes" 
 -- Invocation:markForCodeGen: "Time.Minutes" 
 -- ObjectInvocation:markForCodeGen: "Time"  ATd: "--Time{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Minutes"  ATd: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Time.Minutes"  IS.isEmpty:  true 
 -- markItem: ""Hello UnitEx\n".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Hello UnitEx\n".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Hello UnitEx\n".print" 
 -- ""Hello UnitEx\n"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Hello UnitEx\n".print" 
 -- Invocation:markForCodeGen: ""Hello UnitEx\n".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Hello UnitEx\n".print"  IS.isEmpty:  true 
 -- markItem: "L1 := Length.F2M(12.0)" Assign 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Length.F2M(12.0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.F2M(12.0)" 
 -- "Length" false 
 -- "F2M(12.0)" false 
 -- 
 -- OG:markSuper: "Length.F2M(12.0)" 
 -- Invocation:markForCodeGen: "Length.F2M(12.0)" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "F2M(12.0)"  ATd: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- Pattern:markForCodeGen: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in V: var float{   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in V: var float{   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OG:Qalloc: "in V: var float{   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" qDescno:  134 
 -- ObjTmpStack:add: "F2M" : "in V: var float{   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- items:markForCodeGen: "in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "float" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "float" 
 -- "float" true 
 -- 
 -- OG:markSuper: "float" 
 -- Invocation:markForCodeGen: "float" 
 -- ObjectInvocation:markForCodeGen: "float"  ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var flo ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "float"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Meter" 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Meter" 
 -- Invocation:markForCodeGen: "Meter" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Meter"  IS.isEmpty:  true 
 -- markItem: "put('A')" ObjectGenerator 
 -- OG:markForCodeGen: "put('A')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('A')" 
 -- "put('A')" true 
 -- 
 -- OG:markSuper: "put('A')" 
 -- Invocation:markForCodeGen: "put('A')" 
 -- ObjectInvocation:markForCodeGen: "put('A')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('A')" 
 -- OG:markForCodeGen: "'A'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'A'" 
 -- "'A'" true 
 -- 
 -- OG:markSuper: "'A'" 
 -- Invocation:markForCodeGen: "'A'" 
 -- not ObjDesc:  "'A'"  IS.isEmpty:  true 
 -- arg:   "'A'" 
 -- not ObjDesc:  "put('A')"  IS.isEmpty:  true 
 -- markItem: "R.magnitude := V" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V" 
 -- "V" true 
 -- 
 -- markItem: "put('B')" ObjectGenerator 
 -- OG:markForCodeGen: "put('B')" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "put('B')" 
 -- "put('B')" true 
 -- 
 -- OG:markSuper: "put('B')" 
 -- Invocation:markForCodeGen: "put('B')" 
 -- ObjectInvocation:markForCodeGen: "put('B')"  ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:args:markForCodgen: "put('B')" 
 -- OG:markForCodeGen: "'B'" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "'B'" 
 -- "'B'" true 
 -- 
 -- OG:markSuper: "'B'" 
 -- Invocation:markForCodeGen: "'B'" 
 -- not ObjDesc:  "'B'"  IS.isEmpty:  true 
 -- arg:   "'B'" 
 -- not ObjDesc:  "put('B')"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "F2M(12.0)" 
 -- OG:markForCodeGen: "12.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "12.0" 
 -- "12.0" true 
 -- 
 -- OG:markSuper: "12.0" 
 -- Invocation:markForCodeGen: "12.0" 
 -- not ObjDesc:  "12.0"  IS.isEmpty:  true 
 -- arg:   "12.0" 
 -- not ObjDesc:  "Length.F2M(12.0)"  IS.isEmpty:  true 
 -- markItem: "L1.print" ObjectGenerator 
 -- OG:markForCodeGen: "L1.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1.print" 
 -- "L1" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L1.print" 
 -- Invocation:markForCodeGen: "L1.print" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L1.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "L2.fromPrimary(L1.toPrimary)" ObjectGenerator 
 -- OG:markForCodeGen: "L2.fromPrimary(L1.toPrimary)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L2.fromPrimary(L1.toPrimary)" 
 -- "L2" false 
 -- "fromPrimary(L1.toPrimary)" false 
 -- 
 -- OG:markSuper: "L2.fromPrimary(L1.toPrimary)" 
 -- Invocation:markForCodeGen: "L2.fromPrimary(L1.toPrimary)" 
 -- ObjectInvocation:markForCodeGen: "L2"  ATd: "L2: var Length.Foot" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "fromPrimary(L1.toPrimary)"  ATd: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- OI:args:markForCodgen: "fromPrimary(L1.toPrimary)" 
 -- OG:markForCodeGen: "L1.toPrimary" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1.toPrimary" 
 -- "L1" false 
 -- "toPrimary" false 
 -- 
 -- OG:markSuper: "L1.toPrimary" 
 -- Invocation:markForCodeGen: "L1.toPrimary" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "toPrimary"  ATd: "toPrimary:: {   base.magnitude := magnitude}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L1.toPrimary"  IS.isEmpty:  true 
 -- arg:   "L1.toPrimary" 
 -- not ObjDesc:  "L2.fromPrimary(L1.toPrimary)"  IS.isEmpty:  true 
 -- markItem: "L2.print" ObjectGenerator 
 -- OG:markForCodeGen: "L2.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L2.print" 
 -- "L2" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L2.print" 
 -- Invocation:markForCodeGen: "L2.print" 
 -- ObjectInvocation:markForCodeGen: "L2"  ATd: "L2: var Length.Foot" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Foot".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L2.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "L3 := Length.F2M(3.0)" Assign 
 -- Invocation:markForCodeGen: "L3" 
 -- ObjectInvocation:markForCodeGen: "L3"  ATd: "L3: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Length.F2M(3.0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.F2M(3.0)" 
 -- "Length" false 
 -- "F2M(3.0)" false 
 -- 
 -- OG:markSuper: "Length.F2M(3.0)" 
 -- Invocation:markForCodeGen: "Length.F2M(3.0)" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "F2M(3.0)"  ATd: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OI:args:markForCodgen: "F2M(3.0)" 
 -- OG:markForCodeGen: "3.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "3.0" 
 -- "3.0" true 
 -- 
 -- OG:markSuper: "3.0" 
 -- Invocation:markForCodeGen: "3.0" 
 -- not ObjDesc:  "3.0"  IS.isEmpty:  true 
 -- arg:   "3.0" 
 -- not ObjDesc:  "Length.F2M(3.0)"  IS.isEmpty:  true 
 -- markItem: "R.set(L1,L3)" ObjectGenerator 
 -- OG:markForCodeGen: "R.set(L1,L3)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "R.set(L1,L3)" 
 -- "R" false 
 -- "set(L1,L3)" false 
 -- 
 -- OG:markSuper: "R.set(L1,L3)" 
 -- Invocation:markForCodeGen: "R.set(L1,L3)" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "R: obj Rectangle" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "set(L1,L3)"  ATd: "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- Pattern:markForCodeGen: "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in w: var Length.Meter{   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in w: var Length.Meter{   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- OG:Qalloc: "in w: var Length.Meter{   in h: var Length.Meter;   width := w;   heigth := h}" qDescno:  137 
 -- ObjTmpStack:add: "set" : "in w: var Length.Meter{   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- items:markForCodeGen: "in w: var Length.Meter{in h: var Length.Meter;width := w;heigth := h}" 
 -- DataItem:markForCodeGen: "w" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "h" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- markItem: "width := w" Assign 
 -- Invocation:markForCodeGen: "width" 
 -- ObjectInvocation:markForCodeGen: "width"  ATd: "width: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "w" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "w" 
 -- "w" false 
 -- 
 -- markItem: "heigth := h" Assign 
 -- Invocation:markForCodeGen: "heigth" 
 -- ObjectInvocation:markForCodeGen: "heigth"  ATd: "heigth: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "h" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "h" 
 -- "h" false 
 -- 
 -- OI:args:markForCodgen: "(L1,L3)" 
 -- OG:markForCodeGen: "L1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1" 
 -- "L1" false 
 -- 
 -- OG:markForCodeGen: "L3" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L3" 
 -- "L3" false 
 -- 
 -- arg:   "L1" 
 -- arg:   "L3" 
 -- not ObjDesc:  "R.set(L1,L3)"  IS.isEmpty:  true 
 -- markItem: "R.print" ObjectGenerator 
 -- OG:markForCodeGen: "R.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "R.print" 
 -- "R" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "R.print" 
 -- Invocation:markForCodeGen: "R.print" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "R: obj Rectangle" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectang ..."}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "R.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "T := 3"min"" Assign 
 -- Invocation:markForCodeGen: "T" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "T: var Time.Minutes" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "3"min"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "3"min"" 
 -- "3"min"" true 
 -- 
 -- OG:markSuper: "3"min"" 
 -- Invocation:markForCodeGen: "3"min"" 
 -- not ObjDesc:  "3"min""  IS.isEmpty:  true 
 -- markItem: "T.print" ObjectGenerator 
 -- OG:markForCodeGen: "T.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "T.print" 
 -- "T" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "T.print" 
 -- Invocation:markForCodeGen: "T.print" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "T: var Time.Minutes" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Minutes".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "T.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "V := Velocity.mult(L1,T)" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var Velocity.MeterPerSecond" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Velocity.mult(L1,T)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Velocity.mult(L1,T)" 
 -- "Velocity" false 
 -- "mult(L1,T)" false 
 -- 
 -- OG:markSuper: "Velocity.mult(L1,T)" 
 -- Invocation:markForCodeGen: "Velocity.mult(L1,T)" 
 -- ObjectInvocation:markForCodeGen: "Velocity"  ATd: "--Velocity{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "mult(L1,T)"  ATd: "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude  ...}" 
 -- Pattern:markForCodeGen: "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in L: var Length.Meter{   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in L: var Length.Meter{   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- OG:Qalloc: "in L: var Length.Meter{   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" qDescno:  142 
 -- ObjTmpStack:add: "mult" : "in L: var Length.Meter{   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- items:markForCodeGen: "in L: var Length.Meter{in T: var Time.Minutes;out R: var MeterPerSecond;R.magnitude := L.magnitude * T.magnitude}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Time.Minutes" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Time.Minutes" 
 -- "Time" false 
 -- "Minutes" false 
 -- 
 -- OG:markSuper: "Time.Minutes" 
 -- Invocation:markForCodeGen: "Time.Minutes" 
 -- ObjectInvocation:markForCodeGen: "Time"  ATd: "--Time{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Minutes"  ATd: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60; ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Time.Minutes"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "MeterPerSecond" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "MeterPerSecond" 
 -- "MeterPerSecond" false 
 -- 
 -- OG:markSuper: "MeterPerSecond" 
 -- Invocation:markForCodeGen: "MeterPerSecond" 
 -- ObjectInvocation:markForCodeGen: "MeterPerSecond"  ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "MeterPerSecond"  IS.isEmpty:  true 
 -- markItem: "R.magnitude := L.magnitude * T.magnitude" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var MeterPerSecond" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L.magnitude * T.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L.magnitude * T.magnitude" 
 -- "L.magnitude * T.magnitude" true 
 -- 
 -- OG:markSuper: "L.magnitude * T.magnitude" 
 -- Invocation:markForCodeGen: "L.magnitude * T.magnitude" 
 -- BinaryExp:markForCodeGen: "L.magnitude * T.magnitude" 
 -- Invocation:markForCodeGen: "L.magnitude" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "in L: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* T.magnitude"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "T.magnitude" 
 -- OG:markForCodeGen: "T.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "T.magnitude" 
 -- "T" false 
 -- "magnitude" true 
 -- 
 -- not ObjDesc:  "L.magnitude * T.magnitude"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "(L1,T)" 
 -- OG:markForCodeGen: "L1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1" 
 -- "L1" false 
 -- 
 -- OG:markForCodeGen: "T" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "T" 
 -- "T" false 
 -- 
 -- arg:   "L1" 
 -- arg:   "T" 
 -- not ObjDesc:  "Velocity.mult(L1,T)"  IS.isEmpty:  true 
 -- markItem: "V.print" ObjectGenerator 
 -- OG:markForCodeGen: "V.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "V.print" 
 -- "V" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "V.print" 
 -- Invocation:markForCodeGen: "V.print" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "V: var Velocity.MeterPerSecond" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "MpS".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "V.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: ""The minimum of ".print" ObjectGenerator 
 -- OG:markForCodeGen: ""The minimum of ".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""The minimum of ".print" 
 -- ""The minimum of "" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""The minimum of ".print" 
 -- Invocation:markForCodeGen: ""The minimum of ".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""The minimum of ".print"  IS.isEmpty:  true 
 -- markItem: "L1.print" ObjectGenerator 
 -- OG:markForCodeGen: "L1.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1.print" 
 -- "L1" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L1.print" 
 -- Invocation:markForCodeGen: "L1.print" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L1.print"  IS.isEmpty:  true 
 -- markItem: "" and ".print" ObjectGenerator 
 -- OG:markForCodeGen: "" and ".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" and ".print" 
 -- "" and "" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "" and ".print" 
 -- Invocation:markForCodeGen: "" and ".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "" and ".print"  IS.isEmpty:  true 
 -- markItem: "L3.print" ObjectGenerator 
 -- OG:markForCodeGen: "L3.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L3.print" 
 -- "L3" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L3.print" 
 -- Invocation:markForCodeGen: "L3.print" 
 -- ObjectInvocation:markForCodeGen: "L3"  ATd: "L3: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L3.print"  IS.isEmpty:  true 
 -- markItem: "" is ".print" ObjectGenerator 
 -- OG:markForCodeGen: "" is ".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" is ".print" 
 -- "" is "" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "" is ".print" 
 -- Invocation:markForCodeGen: "" is ".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "" is ".print"  IS.isEmpty:  true 
 -- markItem: "L1.min(L3).print" ObjectGenerator 
 -- OG:markForCodeGen: "L1.min(L3).print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1.min(L3).print" 
 -- "L1" false 
 -- "min(L3)" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L1.min(L3).print" 
 -- Invocation:markForCodeGen: "L1.min(L3).print" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "min(L3)"  ATd: "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude; ...}" 
 -- Pattern:markForCodeGen: "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitu ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in V: var thisUnit{   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnit ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in V: var thisUnit{   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnitude}" 
 -- OG:Qalloc: "in V: var thisUnit{   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnitude}" qD ... 0 
 -- OG:Qalloc:A:  "min"  super:  ""  marked:  true "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in V: var thisUnit{   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnitude}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "min" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 162 IS.newDescNo: 162 objSize: 0 1: 1 "in V: var thisUnit{out R: var thisUnit;if (magnitude < V.magnitude) :then ;   R.magnitude := magnitude;:e ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 162 "in V: var thisUnit{out R: var thisUnit;if (magnitude < V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V. ...}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "thisUnit:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "thisUnit:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "thisUnit:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "thisUnit:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "thisUnit:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "thisUnit:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- OG:Qalloc: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}"  marked:  false "in V: var thisU ..." s ... i ... 
 -- Invocation:Qalloc: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:Qalloc: "(magnitude < V.magnitude)" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  "(magnitude < V.magnitude)"  marked:  false "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitud ...}" s ... ( ... 
 -- Invocation:Qalloc: "(magnitude < V.magnitude)" 
 -- Invocation:Qalloc: "magnitude < V.magnitude" 
 -- BinaryExp:Qalloc: "magnitude < V.magnitude" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "< V.magnitude" 
 -- name: "<" 
 -- Arguments "V.magnitude" 
 -- OG:Qalloc: "V.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "V.magnitude"  marked:  false "V.magnitude" super:  V.magnitude 
 -- Invocation:Qalloc: "V.magnitude" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V.magnitude" 
 -- super:  "V.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V.magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 123{in V: var float;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 123{   in V: var float;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  "<"  super:  ""  marked:  false "<  : {   %basic 123;   in V: var float;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 123{   in V: var float;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "<" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 163 IS.newDescNo: 163 objSize: 0 1: 1 "%basic 123{in V: var float;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 163 "%basic 123{in V: var float;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 6 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 163 "%basic 123{in V: var float;out B: var boolean}" 
 -- IS.newDescNo: 163 IS.objSize: 6 "%basic 123{in V: var float;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  163 "%basic 123{   in V: var float;   out B: var boolean}" 
 -- OG:super:  "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(magnitude < V.magnitude)" 
 -- super:  "(magnitude < V.magnitude)" 
 -- E:  "(magnitude < V.magnitude)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(magnitude < V.magnitude)" 
 -- OG:Qalloc: "R.magnitude := magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.magnitude := magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 164 IS.newDescNo: 164 objSize: 0 1: 1 "R.magnitude := magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 164 "R.magnitude := magnitude" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "magnitude"  marked:  false "R.magnitude := magnitude" super:  magnitude 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude" 
 -- super:  "magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 164 "R.magnitude := magnitude" 
 -- IS.newDescNo: 164 IS.objSize: 1 "R.magnitude := magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  164 "R.magnitude := magnitude" 
 -- OG:Qalloc: "R.magnitude := V.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.magnitude := V.magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 165 IS.newDescNo: 165 objSize: 0 1: 1 "R.magnitude := V.magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 165 "R.magnitude := V.magnitude" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "V.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "V.magnitude"  marked:  false "R.magnitude := V.magnitude" super:  V.magnitude 
 -- Invocation:Qalloc: "V.magnitude" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V.magnitude" 
 -- super:  "V.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V.magnitude" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 165 "R.magnitude := V.magnitude" 
 -- IS.newDescNo: 165 IS.objSize: 1 "R.magnitude := V.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  165 "R.magnitude := V.magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- super:  "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- E:  "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 162 "in V: var thisUnit{out R: var thisUnit;if (magnitude < V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude : ...}" 
 -- IS.newDescNo: 162 IS.objSize: 7 "in V: var thisUnit{out R: var thisUnit;if (magnitude < V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitud ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  162 "in V: var thisUnit{   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnit ...}" 
 -- ObjTmpStack:add: "min" : "in V: var thisUnit{   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V. ...}" 
 -- items:markForCodeGen: "in V: var thisUnit{out R: var thisUnit;if (magnitude < V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "thisUnit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "thisUnit" 
 -- "thisUnit" false 
 -- 
 -- OG:markSuper: "thisUnit" 
 -- Invocation:markForCodeGen: "thisUnit" 
 -- ObjectInvocation:markForCodeGen: "thisUnit"  ATd: "thisUnit:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "thisUnit"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "thisUnit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "thisUnit" 
 -- "thisUnit" false 
 -- 
 -- OG:markSuper: "thisUnit" 
 -- Invocation:markForCodeGen: "thisUnit" 
 -- ObjectInvocation:markForCodeGen: "thisUnit"  ATd: "thisUnit:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "thisUnit"  IS.isEmpty:  true 
 -- markItem: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" ObjectGenerator 
 -- OG:markForCodeGen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" true 
 -- 
 -- OG:markSuper: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- Invocation:markForCodeGen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:markForCodeGen: "(magnitude < V.magnitude)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(magnitude < V.magnitude)" 
 -- "(magnitude < V.magnitude)" true 
 -- 
 -- OG:markSuper: "(magnitude < V.magnitude)" 
 -- Invocation:markForCodeGen: "(magnitude < V.magnitude)" 
 -- Invocation:markForCodeGen: "magnitude < V.magnitude" 
 -- BinaryExp:markForCodeGen: "magnitude < V.magnitude" 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "< V.magnitude"  ATd: "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- Pattern:markForCodeGen: "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "V.magnitude" 
 -- OG:markForCodeGen: "V.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V.magnitude" 
 -- "V" false 
 -- "magnitude" true 
 -- 
 -- not ObjDesc:  "(magnitude < V.magnitude)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "R.magnitude := magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "R.magnitude := magnitude" 
 -- OG:Qalloc: "R.magnitude := magnitude" qDescno:  164 
 -- ObjTmpStack:add: "R.magnitude := magnitude" 
 -- items:markForCodeGen: "R.magnitude := magnitude" 
 -- markItem: "R.magnitude := magnitude" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var thisUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "magnitude" 
 -- "magnitude" true 
 -- 
 -- OG:markForCodeGen: "R.magnitude := V.magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "R.magnitude := V.magnitude" 
 -- OG:Qalloc: "R.magnitude := V.magnitude" qDescno:  165 
 -- ObjTmpStack:add: "R.magnitude := V.magnitude" 
 -- items:markForCodeGen: "R.magnitude := V.magnitude" 
 -- markItem: "R.magnitude := V.magnitude" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var thisUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V.magnitude" 
 -- "V" false 
 -- "magnitude" true 
 -- 
 -- not ObjDesc:  "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "min(L3)" 
 -- OG:markForCodeGen: "L3" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L3" 
 -- "L3" false 
 -- 
 -- arg:   "L3" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L1.min(L3).print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: ""The maximum of ".print" ObjectGenerator 
 -- OG:markForCodeGen: ""The maximum of ".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""The maximum of ".print" 
 -- ""The maximum of "" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""The maximum of ".print" 
 -- Invocation:markForCodeGen: ""The maximum of ".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""The maximum of ".print"  IS.isEmpty:  true 
 -- markItem: "L1.print" ObjectGenerator 
 -- OG:markForCodeGen: "L1.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1.print" 
 -- "L1" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L1.print" 
 -- Invocation:markForCodeGen: "L1.print" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L1.print"  IS.isEmpty:  true 
 -- markItem: "" and ".print" ObjectGenerator 
 -- OG:markForCodeGen: "" and ".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" and ".print" 
 -- "" and "" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "" and ".print" 
 -- Invocation:markForCodeGen: "" and ".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "" and ".print"  IS.isEmpty:  true 
 -- markItem: "L3.print" ObjectGenerator 
 -- OG:markForCodeGen: "L3.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L3.print" 
 -- "L3" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L3.print" 
 -- Invocation:markForCodeGen: "L3.print" 
 -- ObjectInvocation:markForCodeGen: "L3"  ATd: "L3: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L3.print"  IS.isEmpty:  true 
 -- markItem: "" is ".print" ObjectGenerator 
 -- OG:markForCodeGen: "" is ".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" is ".print" 
 -- "" is "" true 
 -- "print" false 
 -- 
 -- OG:markSuper: "" is ".print" 
 -- Invocation:markForCodeGen: "" is ".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "" is ".print"  IS.isEmpty:  true 
 -- markItem: "L1.max(L3).print" ObjectGenerator 
 -- OG:markForCodeGen: "L1.max(L3).print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L1.max(L3).print" 
 -- "L1" false 
 -- "max(L3)" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L1.max(L3).print" 
 -- Invocation:markForCodeGen: "L1.max(L3).print" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "max(L3)"  ATd: "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude; ...}" 
 -- Pattern:markForCodeGen: "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitu ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in V: var thisUnit{   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnit ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in V: var thisUnit{   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnitude}" 
 -- OG:Qalloc: "in V: var thisUnit{   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnitude}" qD ... 0 
 -- OG:Qalloc:A:  "max"  super:  ""  marked:  true "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in V: var thisUnit{   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V.magnitude}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "max" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 166 IS.newDescNo: 166 objSize: 0 1: 1 "in V: var thisUnit{out R: var thisUnit;if (magnitude > V.magnitude) :then ;   R.magnitude := magnitude;:e ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 166 "in V: var thisUnit{out R: var thisUnit;if (magnitude > V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V. ...}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "thisUnit:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "thisUnit:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "thisUnit:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "R" isValue: true  isPrimitive: false  isValObj:  true  isBasicValue: false 
 -- OG:Qalloc: "Unit" qDescno:  0 
 -- OG:Qalloc:A:  "Unit"  super:  "Unit"  marked:  true "thisUnit:< Unit" super:  Unit 
 -- Invocation:Qalloc: "Unit" 
 -- ObjectInvocation:Qalloc: "Unit" 
 -- name: "Unit" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  40 2 %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUn ...} 
 -- OG:super:  "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUnit;       ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Unit" 
 -- super:  "Unit" 
 -- E:  "Unit" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Unit" 
 -- new_size:A: true   "thisUnit:< Unit" 
 -- new_size:A: true   "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ...}" 
 -- new_size:C: 2  qSize: 2 
 -- new_size:B: 2  objSize:  2  newDescNo:  40 
 -- B: 2 ptn: "thisUnit:< Unit" 
 -- newDescNo: 0 
 -- diSize: 2 IT.qSize: 7 
 -- Items:Qalloc:objSize: 7  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 0 "" 
 -- OG:Qalloc: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" qDescno:  0 
 -- OG:Qalloc:A:  "if:then$0"  super:  "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}"  marked:  false "in V: var thisU ..." s ... i ... 
 -- Invocation:Qalloc: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:Qalloc: "(magnitude > V.magnitude)" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  "(magnitude > V.magnitude)"  marked:  false "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitud ...}" s ... ( ... 
 -- Invocation:Qalloc: "(magnitude > V.magnitude)" 
 -- Invocation:Qalloc: "magnitude > V.magnitude" 
 -- BinaryExp:Qalloc: "magnitude > V.magnitude" 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "> V.magnitude" 
 -- name: ">" 
 -- Arguments "V.magnitude" 
 -- OG:Qalloc: "V.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "V.magnitude"  marked:  false "V.magnitude" super:  V.magnitude 
 -- Invocation:Qalloc: "V.magnitude" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V.magnitude" 
 -- super:  "V.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V.magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 125{in V: var float;out B: var boolean} 
 -- OG:Qalloc:SuperAlloc: ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- OG:Qalloc: "%basic 125{   in V: var float;   out B: var boolean}" qDescno:  0 
 -- OG:Qalloc:A:  ">"  super:  ""  marked:  false ">  : {   %basic 125;   in V: var float;   out B: var boolean}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 125{   in V: var float;   out B: var boolean}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: ">" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 167 IS.newDescNo: 167 objSize: 0 1: 1 "%basic 125{in V: var float;out B: var boolean}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 167 "%basic 125{in V: var float;out B: var boolean}" 
 -- Items:Qalloc:Super:C:objSize: 3 originOff: 1 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 2 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 
 -- dataitem:qalloc: "B" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 6 
 -- Items:Qalloc:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 6  newDescNo: 167 "%basic 125{in V: var float;out B: var boolean}" 
 -- IS.newDescNo: 167 IS.objSize: 6 "%basic 125{in V: var float;out B: var boolean}" 
 -- OG:Qalloc:end: IS.newDescNo:  167 "%basic 125{   in V: var float;   out B: var boolean}" 
 -- OG:super:  ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "(magnitude > V.magnitude)" 
 -- super:  "(magnitude > V.magnitude)" 
 -- E:  "(magnitude > V.magnitude)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "(magnitude > V.magnitude)" 
 -- OG:Qalloc: "R.magnitude := magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.magnitude := magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 168 IS.newDescNo: 168 objSize: 0 1: 1 "R.magnitude := magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 168 "R.magnitude := magnitude" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "magnitude"  marked:  false "R.magnitude := magnitude" super:  magnitude 
 -- Invocation:Qalloc: "magnitude" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "magnitude" 
 -- super:  "magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "magnitude" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 168 "R.magnitude := magnitude" 
 -- IS.newDescNo: 168 IS.objSize: 1 "R.magnitude := magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  168 "R.magnitude := magnitude" 
 -- OG:Qalloc: "R.magnitude := V.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "$0"  super:  ""  marked:  false "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "R.magnitude := V.magnitude" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 169 IS.newDescNo: 169 objSize: 0 1: 1 "R.magnitude := V.magnitude" 
 -- Items:Qalloc:objSize: 0  newDescNo: 169 "R.magnitude := V.magnitude" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "R.magnitude" 
 -- ObjectInvocation:Qalloc: "R" 
 -- name: "R" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- OG:Qalloc: "V.magnitude" qDescno:  0 
 -- OG:Qalloc:A:  "float"  super:  "V.magnitude"  marked:  false "R.magnitude := V.magnitude" super:  V.magnitude 
 -- Invocation:Qalloc: "V.magnitude" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "magnitude" 
 -- name: "magnitude" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  48 2 %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  ...} 
 -- OG:super:  "magnitude: var Float" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "V.magnitude" 
 -- super:  "V.magnitude" 
 -- E:  "magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "V.magnitude" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 169 "R.magnitude := V.magnitude" 
 -- IS.newDescNo: 169 IS.objSize: 1 "R.magnitude := V.magnitude" 
 -- OG:Qalloc:end: IS.newDescNo:  169 "R.magnitude := V.magnitude" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  20 1 %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- OG:super:  "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inSub}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- super:  "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- E:  "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- Items:Qalloc:END:objSize: 7  newDescNo: 166 "in V: var thisUnit{out R: var thisUnit;if (magnitude > V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude : ...}" 
 -- IS.newDescNo: 166 IS.objSize: 7 "in V: var thisUnit{out R: var thisUnit;if (magnitude > V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitud ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  166 "in V: var thisUnit{   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnit ...}" 
 -- ObjTmpStack:add: "max" : "in V: var thisUnit{   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V. ...}" 
 -- items:markForCodeGen: "in V: var thisUnit{out R: var thisUnit;if (magnitude > V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "thisUnit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "thisUnit" 
 -- "thisUnit" false 
 -- 
 -- OG:markSuper: "thisUnit" 
 -- Invocation:markForCodeGen: "thisUnit" 
 -- ObjectInvocation:markForCodeGen: "thisUnit"  ATd: "thisUnit:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "thisUnit"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "thisUnit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "thisUnit" 
 -- "thisUnit" false 
 -- 
 -- OG:markSuper: "thisUnit" 
 -- Invocation:markForCodeGen: "thisUnit" 
 -- ObjectInvocation:markForCodeGen: "thisUnit"  ATd: "thisUnit:< Unit" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "thisUnit"  IS.isEmpty:  true 
 -- markItem: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" ObjectGenerator 
 -- OG:markForCodeGen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" true 
 -- 
 -- OG:markSuper: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- Invocation:markForCodeGen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:markForCodeGen: "(magnitude > V.magnitude)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(magnitude > V.magnitude)" 
 -- "(magnitude > V.magnitude)" true 
 -- 
 -- OG:markSuper: "(magnitude > V.magnitude)" 
 -- Invocation:markForCodeGen: "(magnitude > V.magnitude)" 
 -- Invocation:markForCodeGen: "magnitude > V.magnitude" 
 -- BinaryExp:markForCodeGen: "magnitude > V.magnitude" 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "> V.magnitude"  ATd: ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- Pattern:markForCodeGen: ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "V.magnitude" 
 -- OG:markForCodeGen: "V.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V.magnitude" 
 -- "V" false 
 -- "magnitude" true 
 -- 
 -- not ObjDesc:  "(magnitude > V.magnitude)"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "R.magnitude := magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "R.magnitude := magnitude" 
 -- OG:Qalloc: "R.magnitude := magnitude" qDescno:  168 
 -- ObjTmpStack:add: "R.magnitude := magnitude" 
 -- items:markForCodeGen: "R.magnitude := magnitude" 
 -- markItem: "R.magnitude := magnitude" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var thisUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "magnitude" 
 -- "magnitude" true 
 -- 
 -- OG:markForCodeGen: "R.magnitude := V.magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "R.magnitude := V.magnitude" 
 -- OG:Qalloc: "R.magnitude := V.magnitude" qDescno:  169 
 -- ObjTmpStack:add: "R.magnitude := V.magnitude" 
 -- items:markForCodeGen: "R.magnitude := V.magnitude" 
 -- markItem: "R.magnitude := V.magnitude" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var thisUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V.magnitude" 
 -- "V" false 
 -- "magnitude" true 
 -- 
 -- not ObjDesc:  "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "max(L3)" 
 -- OG:markForCodeGen: "L3" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L3" 
 -- "L3" false 
 -- 
 -- arg:   "L3" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L1.max(L3).print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "A" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Area.SquareMeter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Area.SquareMeter" 
 -- "Area" false 
 -- "SquareMeter" false 
 -- 
 -- OG:markSuper: "Area.SquareMeter" 
 -- Invocation:markForCodeGen: "Area.SquareMeter" 
 -- ObjectInvocation:markForCodeGen: "Area"  ATd: "--Area{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "SquareMeter"  ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Area.SquareMeter"  IS.isEmpty:  true 
 -- markItem: "A := L1 * L3" Assign 
 -- Invocation:markForCodeGen: "A" 
 -- ObjectInvocation:markForCodeGen: "A"  ATd: "A: var Area.SquareMeter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L1 * L3" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L1 * L3" 
 -- "L1 * L3" true 
 -- 
 -- OG:markSuper: "L1 * L3" 
 -- Invocation:markForCodeGen: "L1 * L3" 
 -- BinaryExp:markForCodeGen: "L1 * L3" 
 -- Invocation:markForCodeGen: "L1" 
 -- ObjectInvocation:markForCodeGen: "L1"  ATd: "L1: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* L3"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "L3" 
 -- OG:markForCodeGen: "L3" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L3" 
 -- "L3" false 
 -- 
 -- not ObjDesc:  "L1 * L3"  IS.isEmpty:  true 
 -- markItem: "A.print" ObjectGenerator 
 -- OG:markForCodeGen: "A.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "A.print" 
 -- "A" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "A.print" 
 -- Invocation:markForCodeGen: "A.print" 
 -- ObjectInvocation:markForCodeGen: "A"  ATd: "A: var Area.SquareMeter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "A.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "temperatureEx" ObjectGenerator 
 -- OG:markForCodeGen: "temperatureEx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "temperatureEx" 
 -- "temperatureEx" false 
 -- 
 -- OG:markSuper: "temperatureEx" 
 -- Invocation:markForCodeGen: "temperatureEx" 
 -- ObjectInvocation:markForCodeGen: "temperatureEx"  ATd: "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0 ...}" 
 -- Pattern:markForCodeGen: "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fr ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "C: var Temperature.Celsius{   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimary(C.toPrimary);  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "C: var Temperature.Celsius{   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimary(C.toPrimary);   F.prin ...}" 
 -- OG:Qalloc: "C: var Temperature.Celsius{   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimary(C.toPrimary);   F.prin ...}" q ... 143 
 -- ObjTmpStack:add: "temperatureEx" : "C: var Temperature.Celsius{   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrimar ...}" 
 -- items:markForCodeGen: "C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fromPrimary(C.toPrimary);F.print;newli ...}" 
 -- DataItem:markForCodeGen: "C" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Temperature.Celsius" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Temperature.Celsius" 
 -- "Temperature" false 
 -- "Celsius" false 
 -- 
 -- OG:markSuper: "Temperature.Celsius" 
 -- Invocation:markForCodeGen: "Temperature.Celsius" 
 -- ObjectInvocation:markForCodeGen: "Temperature"  ATd: "--Temperature{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Celsius"  ATd: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;       ...}" 
 -- Pattern:markForCodeGen: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitu ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print::  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print:: ;      " ..."}" 
 -- OG:Qalloc: "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   print:: ;      " ..."}" q ... 144 
 -- ObjTmpStack:add: "Celsius" : "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;  ...}" 
 -- items:markForCodeGen: "%Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Celsius".print}" 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "thisUnit:: Celsius" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Celsius" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Celsius" 
 -- "Celsius" false 
 -- 
 -- OG:markSuper: "Celsius" 
 -- Invocation:markForCodeGen: "Celsius" 
 -- ObjectInvocation:markForCodeGen: "Celsius"  ATd: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;       ...}" 
 -- Pattern:markForCodeGen: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitu ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Celsius"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "toPrimary:: {   base.magnitude := magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "base.magnitude := magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "base.magnitude := magnitude" 
 -- OG:Qalloc: "base.magnitude := magnitude" qDescno:  150 
 -- ObjTmpStack:add: "toPrimary" : "base.magnitude := magnitude" 
 -- items:markForCodeGen: "base.magnitude := magnitude" 
 -- markItem: "base.magnitude := magnitude" Assign 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "out base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "magnitude" 
 -- "magnitude" true 
 -- 
 -- Pattern:markForCodeGen: "fromPrimary:: {   magnitude := base.magnitude}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "magnitude := base.magnitude" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "magnitude := base.magnitude" 
 -- OG:Qalloc: "magnitude := base.magnitude" qDescno:  155 
 -- ObjTmpStack:add: "fromPrimary" : "magnitude := base.magnitude" 
 -- items:markForCodeGen: "magnitude := base.magnitude" 
 -- markItem: "magnitude := base.magnitude" Assign 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "base.magnitude" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "base.magnitude" 
 -- "base" false 
 -- "magnitude" true 
 -- 
 -- Pattern:markForCodeGen: "print:: {   "Celsius".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""Celsius".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""Celsius".print" 
 -- OG:Qalloc: ""Celsius".print" qDescno:  149 
 -- ObjTmpStack:add: "print" : ""Celsius".print" 
 -- items:markForCodeGen: ""Celsius".print" 
 -- markItem: ""Celsius".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Celsius".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Celsius".print" 
 -- ""Celsius"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Celsius".print" 
 -- Invocation:markForCodeGen: ""Celsius".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Celsius".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Temperature.Celsius"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "F" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Temperature.Fahrenheit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Temperature.Fahrenheit" 
 -- "Temperature" false 
 -- "Fahrenheit" false 
 -- 
 -- OG:markSuper: "Temperature.Fahrenheit" 
 -- Invocation:markForCodeGen: "Temperature.Fahrenheit" 
 -- ObjectInvocation:markForCodeGen: "Temperature"  ATd: "--Temperature{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Fahrenheit"  ATd: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 ...}" 
 -- Pattern:markForCodeGen: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;   ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      magnitude :=  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Unit" 
 -- "Unit" false 
 -- 
 -- OG:markSuper: "Unit" 
 -- Invocation:markForCodeGen: "Unit" 
 -- ObjectInvocation:markForCodeGen: "Unit"  ATd: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  ...}" 
 -- OI:args:markForCodgen: "" 
 -- OG:markIS: "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      magnitude := (base.ma ...}" 
 -- OG:Qalloc: "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      magnitude := (base.ma ...}" q ... 146 
 -- ObjTmpStack:add: "Fahrenheit" : "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;       ...}" 
 -- items:markForCodeGen: "%Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrimary:: ;   magnitude := (base.magnitude * (9 ...}" 
 -- markItem: "%Public" Property 
 -- Pattern:markForCodeGen: "thisUnit:: Fahrenheit" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Fahrenheit" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Fahrenheit" 
 -- "Fahrenheit" false 
 -- 
 -- OG:markSuper: "Fahrenheit" 
 -- Invocation:markForCodeGen: "Fahrenheit" 
 -- ObjectInvocation:markForCodeGen: "Fahrenheit"  ATd: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 ...}" 
 -- Pattern:markForCodeGen: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;   ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Fahrenheit"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- OG:Qalloc: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" qDescno:  154 
 -- ObjTmpStack:add: "toPrimary" : "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- items:markForCodeGen: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- markItem: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" Assign 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "out base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- "(magnitude - 32.0) * (5.0 / 9.0)" true 
 -- 
 -- OG:markSuper: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- Invocation:markForCodeGen: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- BinaryExp:markForCodeGen: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- Invocation:markForCodeGen: "(magnitude - 32.0)" 
 -- Invocation:markForCodeGen: "magnitude - 32.0" 
 -- BinaryExp:markForCodeGen: "magnitude - 32.0" 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "- 32.0"  ATd: "-  : {   %basic 110;   in V: var float;   out R: var float}" 
 -- Pattern:markForCodeGen: "-  : {   %basic 110;   in V: var float;   out R: var float}" 
 -- items:markForCodeGen: "" 
 -- OI:args:markForCodgen: "32.0" 
 -- OG:markForCodeGen: "32.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "32.0" 
 -- "32.0" true 
 -- 
 -- OG:markSuper: "32.0" 
 -- Invocation:markForCodeGen: "32.0" 
 -- not ObjDesc:  "32.0"  IS.isEmpty:  true 
 -- ObjectInvocation:markForCodeGen: "* (5.0 / 9.0)"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "(5.0 / 9.0)" 
 -- OG:markForCodeGen: "(5.0 / 9.0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(5.0 / 9.0)" 
 -- "(5.0 / 9.0)" true 
 -- 
 -- OG:markSuper: "(5.0 / 9.0)" 
 -- Invocation:markForCodeGen: "(5.0 / 9.0)" 
 -- Invocation:markForCodeGen: "5.0 / 9.0" 
 -- BinaryExp:markForCodeGen: "5.0 / 9.0" 
 -- Invocation:markForCodeGen: "5.0" 
 -- ObjectInvocation:markForCodeGen: "/ 9.0"  ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "9.0" 
 -- OG:markForCodeGen: "9.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "9.0" 
 -- "9.0" true 
 -- 
 -- OG:markSuper: "9.0" 
 -- Invocation:markForCodeGen: "9.0" 
 -- not ObjDesc:  "9.0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(5.0 / 9.0)"  IS.isEmpty:  true 
 -- not ObjDesc:  "(magnitude - 32.0) * (5.0 / 9.0)"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- OG:Qalloc: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" qDescno:  151 
 -- ObjTmpStack:add: "fromPrimary" : "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- items:markForCodeGen: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- markItem: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" Assign 
 -- Invocation:markForCodeGen: "magnitude" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- "(base.magnitude * (9.0 / 5.0)) + 32.0" true 
 -- 
 -- OG:markSuper: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- Invocation:markForCodeGen: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- BinaryExp:markForCodeGen: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- Invocation:markForCodeGen: "(base.magnitude * (9.0 / 5.0))" 
 -- Invocation:markForCodeGen: "base.magnitude * (9.0 / 5.0)" 
 -- BinaryExp:markForCodeGen: "base.magnitude * (9.0 / 5.0)" 
 -- Invocation:markForCodeGen: "base.magnitude" 
 -- ObjectInvocation:markForCodeGen: "base"  ATd: "in base: var PrimaryUnit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "* (9.0 / 5.0)"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "(9.0 / 5.0)" 
 -- OG:markForCodeGen: "(9.0 / 5.0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "(9.0 / 5.0)" 
 -- "(9.0 / 5.0)" true 
 -- 
 -- OG:markSuper: "(9.0 / 5.0)" 
 -- Invocation:markForCodeGen: "(9.0 / 5.0)" 
 -- Invocation:markForCodeGen: "9.0 / 5.0" 
 -- BinaryExp:markForCodeGen: "9.0 / 5.0" 
 -- Invocation:markForCodeGen: "9.0" 
 -- ObjectInvocation:markForCodeGen: "/ 5.0"  ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "5.0" 
 -- OG:markForCodeGen: "5.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "5.0" 
 -- "5.0" true 
 -- 
 -- OG:markSuper: "5.0" 
 -- Invocation:markForCodeGen: "5.0" 
 -- not ObjDesc:  "5.0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(9.0 / 5.0)"  IS.isEmpty:  true 
 -- ObjectInvocation:markForCodeGen: "+ 32.0"  ATd: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- OI:args:markForCodgen: "32.0" 
 -- OG:markForCodeGen: "32.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "32.0" 
 -- "32.0" true 
 -- 
 -- OG:markSuper: "32.0" 
 -- Invocation:markForCodeGen: "32.0" 
 -- not ObjDesc:  "32.0"  IS.isEmpty:  true 
 -- not ObjDesc:  "(base.magnitude * (9.0 / 5.0)) + 32.0"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "print:: {   "Fahrenheit".print}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: ""Fahrenheit".print" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: ""Fahrenheit".print" 
 -- OG:Qalloc: ""Fahrenheit".print" qDescno:  153 
 -- ObjTmpStack:add: "print" : ""Fahrenheit".print" 
 -- items:markForCodeGen: ""Fahrenheit".print" 
 -- markItem: ""Fahrenheit".print" ObjectGenerator 
 -- OG:markForCodeGen: ""Fahrenheit".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""Fahrenheit".print" 
 -- ""Fahrenheit"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""Fahrenheit".print" 
 -- Invocation:markForCodeGen: ""Fahrenheit".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""Fahrenheit".print"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Temperature.Fahrenheit"  IS.isEmpty:  true 
 -- markItem: "C := Temperature.FasCelsius(100.0)" Assign 
 -- Invocation:markForCodeGen: "C" 
 -- ObjectInvocation:markForCodeGen: "C"  ATd: "C: var Temperature.Celsius" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Temperature.FasCelsius(100.0)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Temperature.FasCelsius(100.0)" 
 -- "Temperature" false 
 -- "FasCelsius(100.0)" false 
 -- 
 -- OG:markSuper: "Temperature.FasCelsius(100.0)" 
 -- Invocation:markForCodeGen: "Temperature.FasCelsius(100.0)" 
 -- ObjectInvocation:markForCodeGen: "Temperature"  ATd: "--Temperature{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "FasCelsius(100.0)"  ATd: "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V}" 
 -- Pattern:markForCodeGen: "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in V: var float{   out R: var Celsius;   R.magnitude := V}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in V: var float{   out R: var Celsius;   R.magnitude := V}" 
 -- OG:Qalloc: "in V: var float{   out R: var Celsius;   R.magnitude := V}" qDescno:  148 
 -- ObjTmpStack:add: "FasCelsius" : "in V: var float{   out R: var Celsius;   R.magnitude := V}" 
 -- items:markForCodeGen: "in V: var float{out R: var Celsius;R.magnitude := V}" 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 9 
 -- OG:markForCodeGen: "float" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "float" 
 -- "float" true 
 -- 
 -- OG:markSuper: "float" 
 -- Invocation:markForCodeGen: "float" 
 -- ObjectInvocation:markForCodeGen: "float"  ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var flo ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "float"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "R" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Celsius" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Celsius" 
 -- "Celsius" false 
 -- 
 -- OG:markSuper: "Celsius" 
 -- Invocation:markForCodeGen: "Celsius" 
 -- ObjectInvocation:markForCodeGen: "Celsius"  ATd: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;       ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Celsius"  IS.isEmpty:  true 
 -- markItem: "R.magnitude := V" Assign 
 -- Invocation:markForCodeGen: "R.magnitude" 
 -- ObjectInvocation:markForCodeGen: "R"  ATd: "out R: var Celsius" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "magnitude"  ATd: "magnitude: var Float" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "V" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "V" 
 -- "V" true 
 -- 
 -- OI:args:markForCodgen: "FasCelsius(100.0)" 
 -- OG:markForCodeGen: "100.0" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "100.0" 
 -- "100.0" true 
 -- 
 -- OG:markSuper: "100.0" 
 -- Invocation:markForCodeGen: "100.0" 
 -- not ObjDesc:  "100.0"  IS.isEmpty:  true 
 -- arg:   "100.0" 
 -- not ObjDesc:  "Temperature.FasCelsius(100.0)"  IS.isEmpty:  true 
 -- markItem: "C.print" ObjectGenerator 
 -- OG:markForCodeGen: "C.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C.print" 
 -- "C" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "C.print" 
 -- Invocation:markForCodeGen: "C.print" 
 -- ObjectInvocation:markForCodeGen: "C"  ATd: "C: var Temperature.Celsius" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Celsius".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "C.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "F.fromPrimary(C.toPrimary)" ObjectGenerator 
 -- OG:markForCodeGen: "F.fromPrimary(C.toPrimary)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "F.fromPrimary(C.toPrimary)" 
 -- "F" false 
 -- "fromPrimary(C.toPrimary)" false 
 -- 
 -- OG:markSuper: "F.fromPrimary(C.toPrimary)" 
 -- Invocation:markForCodeGen: "F.fromPrimary(C.toPrimary)" 
 -- ObjectInvocation:markForCodeGen: "F"  ATd: "F: var Temperature.Fahrenheit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "fromPrimary(C.toPrimary)"  ATd: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0}" 
 -- OI:args:markForCodgen: "fromPrimary(C.toPrimary)" 
 -- OG:markForCodeGen: "C.toPrimary" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C.toPrimary" 
 -- "C" false 
 -- "toPrimary" false 
 -- 
 -- OG:markSuper: "C.toPrimary" 
 -- Invocation:markForCodeGen: "C.toPrimary" 
 -- ObjectInvocation:markForCodeGen: "C"  ATd: "C: var Temperature.Celsius" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "toPrimary"  ATd: "toPrimary:: {   base.magnitude := magnitude}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "C.toPrimary"  IS.isEmpty:  true 
 -- arg:   "C.toPrimary" 
 -- not ObjDesc:  "F.fromPrimary(C.toPrimary)"  IS.isEmpty:  true 
 -- markItem: "F.print" ObjectGenerator 
 -- OG:markForCodeGen: "F.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "F.print" 
 -- "F" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "F.print" 
 -- Invocation:markForCodeGen: "F.print" 
 -- ObjectInvocation:markForCodeGen: "F"  ATd: "F: var Temperature.Fahrenheit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Fahrenheit".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "F.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "C.fromPrimary(F.toPrimary)" ObjectGenerator 
 -- OG:markForCodeGen: "C.fromPrimary(F.toPrimary)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C.fromPrimary(F.toPrimary)" 
 -- "C" false 
 -- "fromPrimary(F.toPrimary)" false 
 -- 
 -- OG:markSuper: "C.fromPrimary(F.toPrimary)" 
 -- Invocation:markForCodeGen: "C.fromPrimary(F.toPrimary)" 
 -- ObjectInvocation:markForCodeGen: "C"  ATd: "C: var Temperature.Celsius" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "fromPrimary(F.toPrimary)"  ATd: "fromPrimary:: {   magnitude := base.magnitude}" 
 -- OI:args:markForCodgen: "fromPrimary(F.toPrimary)" 
 -- OG:markForCodeGen: "F.toPrimary" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "F.toPrimary" 
 -- "F" false 
 -- "toPrimary" false 
 -- 
 -- OG:markSuper: "F.toPrimary" 
 -- Invocation:markForCodeGen: "F.toPrimary" 
 -- ObjectInvocation:markForCodeGen: "F"  ATd: "F: var Temperature.Fahrenheit" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "toPrimary"  ATd: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "F.toPrimary"  IS.isEmpty:  true 
 -- arg:   "F.toPrimary" 
 -- not ObjDesc:  "C.fromPrimary(F.toPrimary)"  IS.isEmpty:  true 
 -- markItem: "C.print" ObjectGenerator 
 -- OG:markForCodeGen: "C.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "C.print" 
 -- "C" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "C.print" 
 -- Invocation:markForCodeGen: "C.print" 
 -- ObjectInvocation:markForCodeGen: "C"  ATd: "C: var Temperature.Celsius" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Celsius".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "C.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "temperatureEx"  IS.isEmpty:  true 
 -- markItem: "lengthEx" ObjectGenerator 
 -- OG:markForCodeGen: "lengthEx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "lengthEx" 
 -- "lengthEx" false 
 -- 
 -- OG:markSuper: "lengthEx" 
 -- Invocation:markForCodeGen: "lengthEx" 
 -- ObjectInvocation:markForCodeGen: "lengthEx"  ATd: "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline ...}" 
 -- Pattern:markForCodeGen: "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrim ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "L: var Length.Meter{   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   F.print;    ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "L: var Length.Meter{   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   F.print;   "kok:\n" ...}" 
 -- OG:Qalloc: "L: var Length.Meter{   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   F.print;   "kok:\n" ...}" q ... 156 
 -- ObjTmpStack:add: "LengthEx" : "L: var Length.Meter{   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);    ...}" 
 -- items:markForCodeGen: "L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPrimary);F.print;"kok:\n".print;newlin ...}" 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Meter" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Meter" 
 -- "Length" false 
 -- "Meter" false 
 -- 
 -- OG:markSuper: "Length.Meter" 
 -- Invocation:markForCodeGen: "Length.Meter" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Meter"  ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary::  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Meter"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "F" :descNo: 0 :OG.primNo: 0 
 -- OG:markForCodeGen: "Length.Foot" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.Foot" 
 -- "Length" false 
 -- "Foot" false 
 -- 
 -- OG:markSuper: "Length.Foot" 
 -- Invocation:markForCodeGen: "Length.Foot" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "Foot"  ATd: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);  ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length.Foot"  IS.isEmpty:  true 
 -- markItem: "L := Length.F2M(3.05)" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Length.F2M(3.05)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length.F2M(3.05)" 
 -- "Length" false 
 -- "F2M(3.05)" false 
 -- 
 -- OG:markSuper: "Length.F2M(3.05)" 
 -- Invocation:markForCodeGen: "Length.F2M(3.05)" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "--Length{}" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "F2M(3.05)"  ATd: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OI:args:markForCodgen: "F2M(3.05)" 
 -- OG:markForCodeGen: "3.05" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "3.05" 
 -- "3.05" true 
 -- 
 -- OG:markSuper: "3.05" 
 -- Invocation:markForCodeGen: "3.05" 
 -- not ObjDesc:  "3.05"  IS.isEmpty:  true 
 -- arg:   "3.05" 
 -- not ObjDesc:  "Length.F2M(3.05)"  IS.isEmpty:  true 
 -- markItem: ""kuk:\n".print" ObjectGenerator 
 -- OG:markForCodeGen: ""kuk:\n".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""kuk:\n".print" 
 -- ""kuk:\n"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""kuk:\n".print" 
 -- Invocation:markForCodeGen: ""kuk:\n".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""kuk:\n".print"  IS.isEmpty:  true 
 -- markItem: "L.print" ObjectGenerator 
 -- OG:markForCodeGen: "L.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.print" 
 -- "L" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "L.print" 
 -- Invocation:markForCodeGen: "L.print" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Meter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- markItem: "F.fromPrimary(L.toPrimary)" ObjectGenerator 
 -- OG:markForCodeGen: "F.fromPrimary(L.toPrimary)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "F.fromPrimary(L.toPrimary)" 
 -- "F" false 
 -- "fromPrimary(L.toPrimary)" false 
 -- 
 -- OG:markSuper: "F.fromPrimary(L.toPrimary)" 
 -- Invocation:markForCodeGen: "F.fromPrimary(L.toPrimary)" 
 -- ObjectInvocation:markForCodeGen: "F"  ATd: "F: var Length.Foot" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "fromPrimary(L.toPrimary)"  ATd: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- OI:args:markForCodgen: "fromPrimary(L.toPrimary)" 
 -- OG:markForCodeGen: "L.toPrimary" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "L.toPrimary" 
 -- "L" false 
 -- "toPrimary" false 
 -- 
 -- OG:markSuper: "L.toPrimary" 
 -- Invocation:markForCodeGen: "L.toPrimary" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var Length.Meter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "toPrimary"  ATd: "toPrimary:: {   base.magnitude := magnitude}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "L.toPrimary"  IS.isEmpty:  true 
 -- arg:   "L.toPrimary" 
 -- not ObjDesc:  "F.fromPrimary(L.toPrimary)"  IS.isEmpty:  true 
 -- markItem: "F.print" ObjectGenerator 
 -- OG:markForCodeGen: "F.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "F.print" 
 -- "F" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "F.print" 
 -- Invocation:markForCodeGen: "F.print" 
 -- ObjectInvocation:markForCodeGen: "F"  ATd: "F: var Length.Foot" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "Foot".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "F.print"  IS.isEmpty:  true 
 -- markItem: ""kok:\n".print" ObjectGenerator 
 -- OG:markForCodeGen: ""kok:\n".print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- ""kok:\n".print" 
 -- ""kok:\n"" true 
 -- "print" false 
 -- 
 -- OG:markSuper: ""kok:\n".print" 
 -- Invocation:markForCodeGen: ""kok:\n".print" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  ""kok:\n".print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "lengthEx"  IS.isEmpty:  true 
 -- markItem: "A := 15.6"m2"" Assign 
 -- Invocation:markForCodeGen: "A" 
 -- ObjectInvocation:markForCodeGen: "A"  ATd: "A: var Area.SquareMeter" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "15.6"m2"" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "15.6"m2"" 
 -- "15.6"m2"" true 
 -- 
 -- OG:markSuper: "15.6"m2"" 
 -- Invocation:markForCodeGen: "15.6"m2"" 
 -- not ObjDesc:  "15.6"m2""  IS.isEmpty:  true 
 -- markItem: "A.print" ObjectGenerator 
 -- OG:markForCodeGen: "A.print" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "A.print" 
 -- "A" false 
 -- "print" false 
 -- 
 -- OG:markSuper: "A.print" 
 -- Invocation:markForCodeGen: "A.print" 
 -- ObjectInvocation:markForCodeGen: "A"  ATd: "A: var Area.SquareMeter" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "print"  ATd: "print:: {   "SquareMeter".print}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "A.print"  IS.isEmpty:  true 
 -- markItem: "newline" ObjectGenerator 
 -- OG:markForCodeGen: "newline" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "newline" 
 -- "newline" false 
 -- 
 -- OG:markSuper: "newline" 
 -- Invocation:markForCodeGen: "newline" 
 -- ObjectInvocation:markForCodeGen: "newline"  ATd: "newline: {   %globals;   put(10)}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "newline"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "Object: {   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basi ...}" 
 -- items:markForCodeGen: "" 
 -- Pattern:markForCodeGen: "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T:  ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.leng ...}" 
 -- OG:Qalloc: "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.leng ...}" q ... 0 
 -- OG:Qalloc:A:  "+"  super:  ""  marked:  true "+  : {   in S: var String;   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i:  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.length,Integer) ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "+" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 170 IS.newDescNo: 170 objSize: 0 1: 1 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var int ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 170 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L  ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "in S: var String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "V" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 3 "out V: var String" 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "L" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- OG:Qalloc: "Length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "Length"  marked:  false "L := Length" super:  Length 
 -- Invocation:Qalloc: "Length" 
 -- ObjectInvocation:Qalloc: "Length" 
 -- name: "Length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Length" 
 -- super:  "Length" 
 -- E:  "Length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Length" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 170 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexe ...}" 
 -- IS.newDescNo: 170 IS.objSize: 4 "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.leng ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  170 "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: ...}" 
 -- ObjTmpStack:add: "+  " : "in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Inde ...}" 
 -- items:markForCodeGen: "in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer ...}" 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "String" 
 -- "String" true 
 -- 
 -- not ObjDesc:  "String"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "V" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "String" 
 -- "String" true 
 -- 
 -- not ObjDesc:  "String"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "L" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- markItem: "L := Length" Assign 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "Length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "Length" 
 -- "Length" false 
 -- 
 -- OG:markSuper: "Length" 
 -- Invocation:markForCodeGen: "Length" 
 -- ObjectInvocation:markForCodeGen: "Length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1 ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.l ...}" 
 -- OG:Qalloc: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.l ...}" q ... 0 
 -- OG:Qalloc:A:  "doplus"  super:  ""  marked:  true "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e : ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.length):repe ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "doplus" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 171 IS.newDescNo: 171 objSize: 0 1: 1 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];  ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 171 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1 ...}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- dataitem:qalloc: "e" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "i" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- dataitem:qalloc: "T" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "T: obj Indexed(L + S.length,Integer)" 
 -- OG:Qalloc: "Indexed(L + S.length,Integer)" qDescno:  0 
 -- OG:Qalloc:A:  "T"  super:  "Indexed(L + S.length,Integer)"  marked:  false "T: obj Indexed(L + S.length,Integer)" super:  Indexed(L + S.length,Integer) 
 -- Invocation:Qalloc: "Indexed(L + S.length,Integer)" 
 -- ObjectInvocation:Qalloc: "Indexed(L + S.length,Integer)" 
 -- name: "Indexed" 
 -- Arguments "(L + S.length,Integer)" 
 -- OG:Qalloc: "L + S.length" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "L + S.length"  marked:  false "(L + S.length,Integer)" super:  L + S.length 
 -- Invocation:Qalloc: "L + S.length" 
 -- BinaryExp:Qalloc: "L + S.length" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ S.length" 
 -- name: "+" 
 -- Arguments "S.length" 
 -- OG:Qalloc: "S.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "S.length"  marked:  false "S.length" super:  S.length 
 -- Invocation:Qalloc: "S.length" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.length" 
 -- super:  "S.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.length" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  60 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + S.length" 
 -- super:  "L + S.length" 
 -- E:  "L + S.length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + S.length" 
 -- OG:Qalloc: "Integer" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "Integer"  marked:  false "(L + S.length,Integer)" super:  Integer 
 -- Invocation:Qalloc: "Integer" 
 -- ObjectInvocation:Qalloc: "Integer" 
 -- name: "Integer" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "Integer" 
 -- super:  "Integer" 
 -- E:  "Integer" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Integer" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0] ...} 
 -- OG:Qalloc:SuperAlloc: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0 ...}" 
 -- OG:Qalloc: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer) ...}" q ... 0 
 -- OG:Qalloc:A:  "Indexed"  super:  ""  marked:  false "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res:  ...}" s ...  
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer):at[inx: va ...}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "Indexed" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 172 IS.newDescNo: 172 objSize: 0 1: 1 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res ...}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 172 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var int ...}" 
 -- Items:Qalloc:Super:C:objSize: 0 originOff: 0 
 -- Items:Qalloc:objSize: 0  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 0  newDescNo: 0 "" 
 -- dataitem:qalloc: "range" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- Pattern:Qalloc: elm 
 -- Pattern:Qalloc:B: elm 
 -- Pattern:Qalloc: elm$173 
 -- Pattern:Qalloc:B: elm$173 
 -- Pattern:Qalloc: length 
 -- Pattern:Qalloc:B: length 
 -- Pattern:Qalloc: put:at 
 -- Pattern:Qalloc: get 
 -- Pattern:Qalloc: has 
 -- Pattern:Qalloc:B: has 
 -- Pattern:Qalloc: scan 
 -- Pattern:Qalloc:B: scan 
 -- Pattern:Qalloc: asString 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 172 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var ...}" 
 -- IS.newDescNo: 172 IS.objSize: 1 "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var integer):at ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  172 "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0] ...}" 
 -- OG:super:  "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "Indexed(L + S.length,Integer)" 
 -- super:  "Indexed(L + S.length,Integer)" 
 -- E:  "Indexed(L + S.length,Integer)" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "Indexed(L + S.length,Integer)" 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- OG:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  marked:  false "e: var integer{i: var integer;T: obj Indexed(L + S.l ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- ObjectInvocation:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "L" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "L"  marked:  false "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" super:  L 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "L: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L" 
 -- super:  "L" 
 -- E:  "L" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L" 
 -- OG:Qalloc: "e := get[inx]{   T.put(e):at[inx]}" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e := get[inx]{   T.put(e):at[inx]}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 174 IS.newDescNo: 174 objSize: 0 1: 1 "e := get[inx]{T.put(e):at[inx]}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 174 "e := get[inx]{T.put(e):at[inx]}" 
 -- Items:Qalloc:super: "" size: 1 "repeat$174" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- OG:Qalloc: "get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "get[inx]"  marked:  false "e := get[inx]" super:  get[inx] 
 -- Invocation:Qalloc: "get[inx]" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "get[inx]" 
 -- super:  "get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "get[inx]" 
 -- OG:Qalloc: "T.put(e):at[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  "T.put(e):at[inx]"  marked:  false "e := get[inx]{T.put(e):at[inx]}" super:  T.put(e):at[inx] 
 -- Invocation:Qalloc: "T.put(e):at[inx]" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "put(e):at[inx]" 
 -- name: "put:at" 
 -- Arguments "put(e):at[inx]" 
 -- OG:Qalloc: "e" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "e"  marked:  false "put(e):at[inx]" super:  e 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "e: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e" 
 -- super:  "e" 
 -- E:  "e" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "e" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "put(e):at[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 115 
 -- OG:Qalloc:SuperAlloc: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc: "%basic 115" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  ""  marked:  false "put(V: var integer):at[inx: var integer]: {   %basic 115}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 115" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "put:at" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 175 IS.newDescNo: 175 objSize: 0 1: 1 "%basic 115" 
 -- Items:Qalloc:objSize: 0  newDescNo: 175 "%basic 115" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "%$B "("{V: var integer;%$S "):at[";inx: var integer;%$E "]"}" 
 -- dataitem:qalloc: "V" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 2 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- dataitem:qalloc: "inx" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- Items:Qalloc:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 0 "%$B "("{V: var integer;%$S "):at[";inx: var integer;%$E "]"}" 
 -- Items:Qalloc:END:objSize: 3  newDescNo: 175 "%basic 115" 
 -- IS.newDescNo: 175 IS.objSize: 3 "%basic 115" 
 -- OG:Qalloc:end: IS.newDescNo:  175 "%basic 115" 
 -- OG:super:  "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.put(e):at[inx]" 
 -- super:  "T.put(e):at[inx]" 
 -- E:  "put(e):at[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.put(e):at[inx]" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 174 "e := get[inx]{T.put(e):at[inx]}" 
 -- IS.newDescNo: 174 IS.objSize: 1 "e := get[inx]{T.put(e):at[inx]}" 
 -- OG:Qalloc:end: IS.newDescNo:  174 "e := get[inx]{   T.put(e):at[inx]}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- super:  "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- E:  "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 176 IS.newDescNo: 176 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 176 "" 
 -- Items:Qalloc:super: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" size: 3 "for:to:repeat$176" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 176 "" 
 -- IS.newDescNo: 176 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  176 "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" qDescno:  0 
 -- OG:Qalloc:A:  "for:to:repeat$0"  super:  "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  marked:  false "e: var integer{i: var integer ...}" s ... f ... 
 -- Invocation:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- ObjectInvocation:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- name: "for:to:repeat" 
 -- Arguments "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:Qalloc: "1" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "1"  marked:  false "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" super:  1 
 -- Invocation:Qalloc: "1" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer;      o ...}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "1" 
 -- super:  "1" 
 -- E:  "1" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "1" 
 -- OG:Qalloc: "S.length" qDescno:  0 
 -- OG:Qalloc:A:  "length"  super:  "S.length"  marked:  false "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" super:  S.length 
 -- Invocation:Qalloc: "S.length" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "length" 
 -- name: "length" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  15 2 out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- OG:super:  "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.length" 
 -- super:  "S.length" 
 -- E:  "length" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.length" 
 -- OG:Qalloc: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" qDescno:  0 
 -- OG:Qalloc:A:  "repeat$0"  super:  ""  marked:  false "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "repeat$0" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 177 IS.newDescNo: 177 objSize: 0 1: 1 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 177 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- Items:Qalloc:super: "" size: 1 "repeat$177" 
 -- super.isThisBlockLevel: true superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 1 originOff: 1 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- OG:Qalloc: "S.get[inx]" qDescno:  0 
 -- OG:Qalloc:A:  "get"  super:  "S.get[inx]"  marked:  false "e := S.get[inx]" super:  S.get[inx] 
 -- Invocation:Qalloc: "S.get[inx]" 
 -- ObjectInvocation:Qalloc: "S" 
 -- name: "S" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "get[inx]" 
 -- name: "get" 
 -- Arguments "get[inx]" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "get[inx]" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  16 3 %basic 117{out ch: var char} 
 -- OG:super:  "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "S.get[inx]" 
 -- super:  "S.get[inx]" 
 -- E:  "get[inx]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "S.get[inx]" 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- OG:Qalloc: "L + inx" qDescno:  0 
 -- OG:Qalloc:A:  "+"  super:  "L + inx"  marked:  false "i := L + inx" super:  L + inx 
 -- Invocation:Qalloc: "L + inx" 
 -- BinaryExp:Qalloc: "L + inx" 
 -- Invocation:Qalloc: "L" 
 -- ObjectInvocation:Qalloc: "L" 
 -- name: "L" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "+ inx" 
 -- name: "+" 
 -- Arguments "inx" 
 -- OG:Qalloc: "inx" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "inx"  marked:  false "inx" super:  inx 
 -- Invocation:Qalloc: "inx" 
 -- ObjectInvocation:Qalloc: "inx" 
 -- name: "inx" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "inx: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "inx" 
 -- super:  "inx" 
 -- E:  "inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "inx" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  60 5 %basic 61{in V: var integer;out R: var integer} 
 -- OG:super:  "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "L + inx" 
 -- super:  "L + inx" 
 -- E:  "L + inx" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "L + inx" 
 -- OG:Qalloc: "T.put(e):at[i]" qDescno:  0 
 -- OG:Qalloc:A:  "put:at"  super:  "T.put(e):at[i]"  marked:  false "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" super:  T.put(e):at[i] 
 -- Invocation:Qalloc: "T.put(e):at[i]" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "put(e):at[i]" 
 -- name: "put:at" 
 -- Arguments "put(e):at[i]" 
 -- OG:Qalloc: "e" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "e"  marked:  false "put(e):at[i]" super:  e 
 -- Invocation:Qalloc: "e" 
 -- ObjectInvocation:Qalloc: "e" 
 -- name: "e" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "e: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "e" 
 -- super:  "e" 
 -- E:  "e" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "e" 
 -- OG:Qalloc: "i" qDescno:  0 
 -- OG:Qalloc:A:  "integer"  super:  "i"  marked:  false "put(e):at[i]" super:  i 
 -- Invocation:Qalloc: "i" 
 -- ObjectInvocation:Qalloc: "i" 
 -- name: "i" 
 -- Arguments "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  5 1 %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   ...} 
 -- OG:super:  "i: var integer" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "i" 
 -- super:  "i" 
 -- E:  "i" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "i" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  175 3 %basic 115 
 -- OG:super:  "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.put(e):at[i]" 
 -- super:  "T.put(e):at[i]" 
 -- E:  "put(e):at[i]" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.put(e):at[i]" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 177 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- IS.newDescNo: 177 IS.objSize: 1 "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- OG:Qalloc:end: IS.newDescNo:  177 "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  28 3 %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;    ...} 
 -- OG:super:  "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx := first;   ...}" 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  false 
 --  super.hasVirtualArgs:  true  not super.isPrimitive:  false 
 -- "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- super:  "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- E:  "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:Qalloc:B: "for:to:repeat$0" newDescNo: 0 objSize: 3 
 -- OG:isObjectDesc:NewDescNo: 178 IS.newDescNo: 178 objSize: 3 1: 1 "" 
 -- Items:Qalloc:objSize: 0  newDescNo: 178 "" 
 -- Items:Qalloc:super: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" size: 3 "for:to:repeat$178" 
 -- super.isThisBlockLevel: false superNotImplOrSingularImpl: true 
 -- Items:Qalloc:super:B:objSize: 4 originOff: 4 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 178 "" 
 -- IS.newDescNo: 178 IS.objSize: 3 "" 
 -- OG:Qalloc:end: IS.newDescNo:  178 "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- Invocation:Qalloc: "V" 
 -- ObjectInvocation:Qalloc: "V" 
 -- name: "V" 
 -- Arguments "" 
 -- OG:Qalloc: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" qDescno:  0 
 -- OG:Qalloc:A:  "asString"  super:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  marked:  false "V := T.asString{-- V: obj Index ...}" s ... T ... 
 -- Invocation:Qalloc: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- ObjectInvocation:Qalloc: "T" 
 -- name: "T" 
 -- Arguments "" 
 -- ObjectInvocation:Qalloc: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- name: "asString" 
 -- Arguments "-- V: obj Indexed(Length + S.length){-- V := T[1:length] + S.T[1:S.length]}" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  0 0 %basic 118{out S: var LIB.StringLib.String} 
 -- OG:Qalloc:SuperAlloc: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- OG:Qalloc: "%basic 118{   out S: var LIB.StringLib.String}" qDescno:  0 
 -- OG:Qalloc:A:  "asString"  super:  ""  marked:  false "asString: {   %basic 118;   out S: var LIB.StringLib.String}" super:   
 -- Invocation:Qalloc: "" 
 -- IS.superDesc<>none:  true  IS.superDesc.newDescNo:  21 1 %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57 ...} 
 -- OG:Qalloc:isObjectDesc:  true  isObjectDesc:  true  hasItems:  true 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "%basic 118{   out S: var LIB.StringLib.String}" 
 -- super:  "" 
 -- E:  "" 
 -- OG:Qalloc:B: "asString" newDescNo: 0 objSize: 0 
 -- OG:isObjectDesc:NewDescNo: 179 IS.newDescNo: 179 objSize: 0 1: 1 "%basic 118{out S: var LIB.StringLib.String}" 
 -- Items:Qalloc:objSize: 0  newDescNo: 179 "%basic 118{out S: var LIB.StringLib.String}" 
 -- Items:Qalloc:Super:C:objSize: 1 originOff: 1 
 -- Items:Qalloc:objSize: 1  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 1  newDescNo: 0 "" 
 -- dataitem:qalloc: "S" isValue: false  isPrimitive: true  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 2 "out S: var LIB.StringLib.String" 
 -- Items:Qalloc:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 2  newDescNo: 179 "%basic 118{out S: var LIB.StringLib.String}" 
 -- IS.newDescNo: 179 IS.objSize: 2 "%basic 118{out S: var LIB.StringLib.String}" 
 -- OG:Qalloc:end: IS.newDescNo:  179 "%basic 118{   out S: var LIB.StringLib.String}" 
 -- OG:super:  "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- OG:Qalloc:isObjectDesc:  false  isObjectDesc:  false  hasItems:  false 
 --  super.hasVirtualArgs:  false  not super.isPrimitive:  true 
 -- "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- super:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OG:Qalloc:end: IS.newDescNo:  0 "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 171 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;f ...}" 
 -- IS.newDescNo: 171 IS.objSize: 4 "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1):to(S.l ...}" 
 -- OG:Qalloc:end: IS.newDescNo:  171 "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[in ...}" 
 -- ObjTmpStack:add: "doplus" : "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];    ...}" 
 -- items:markForCodeGen: "e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1):to(S.length):rep ...}" 
 -- DataItem:markForCodeGen: "e" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "i" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "integer" 
 -- "integer" true 
 -- 
 -- OG:markSuper: "integer" 
 -- Invocation:markForCodeGen: "integer" 
 -- ObjectInvocation:markForCodeGen: "integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "integer"  IS.isEmpty:  true 
 -- DataItem:markForCodeGen: "T" :descNo: 0 :OG.primNo: 114 
 -- OG:markForCodeGen: "Indexed(L + S.length,Integer)" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Indexed(L + S.length,Integer)" 
 -- "Indexed(L + S.length,Integer)" true 
 -- 
 -- OG:markSuper: "Indexed(L + S.length,Integer)" 
 -- Invocation:markForCodeGen: "Indexed(L + S.length,Integer)" 
 -- ObjectInvocation:markForCodeGen: "Indexed(L + S.length,Integer)"  ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   lengt ...}" 
 -- Pattern:markForCodeGen: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get ...}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var  ...}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer) ...}" 
 -- OG:Qalloc: "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   put(V: var integer) ...}" q ... 172 
 -- ObjTmpStack:add: "Indexed" : "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 -- items:markForCodeGen: "%globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var integer):at[inx: var  ...}" 
 -- markItem: "%globals" Property 
 -- markItem: "%basic 114" Property 
 -- markItem: "%public" Property 
 -- DataItem:markForCodeGen: "range" :descNo: 0 :OG.primNo: 1 
 -- OG:markForCodeGen: "Integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Integer" 
 -- "Integer" true 
 -- 
 -- OG:markSuper: "Integer" 
 -- Invocation:markForCodeGen: "Integer" 
 -- ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Integer"  IS.isEmpty:  true 
 -- Pattern:markForCodeGen: "in elm:< Object" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "Object" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Object" 
 -- "Object" true 
 -- 
 -- not ObjDesc:  "Object"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "(L + S.length,Integer)" 
 -- OG:markForCodeGen: "L + S.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L + S.length" 
 -- "L + S.length" true 
 -- 
 -- OG:markSuper: "L + S.length" 
 -- Invocation:markForCodeGen: "L + S.length" 
 -- BinaryExp:markForCodeGen: "L + S.length" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ S.length"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "S.length" 
 -- OG:markForCodeGen: "S.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S.length" 
 -- "S" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "S.length" 
 -- Invocation:markForCodeGen: "S.length" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "in S: var String" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "S.length"  IS.isEmpty:  true 
 -- not ObjDesc:  "L + S.length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "Integer" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "Integer" 
 -- "Integer" true 
 -- 
 -- OG:markSuper: "Integer" 
 -- Invocation:markForCodeGen: "Integer" 
 -- ObjectInvocation:markForCodeGen: "Integer"  ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %ba ...}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "Integer"  IS.isEmpty:  true 
 -- arg:   "L + S.length" 
 -- arg:   "Integer" 
 -- not ObjDesc:  "Indexed(L + S.length,Integer)"  IS.isEmpty:  true 
 -- markItem: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" false 
 -- 
 -- OG:markSuper: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- Invocation:markForCodeGen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  ATd: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: ..." 
 -- OI:args:markForCodgen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "L" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L" 
 -- "L" true 
 -- 
 -- OG:markForCodeGen: "e := get[inx]{   T.put(e):at[inx]}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "e := get[inx]{   T.put(e):at[inx]}" 
 -- OG:Qalloc: "e := get[inx]{   T.put(e):at[inx]}" qDescno:  174 
 -- ObjTmpStack:add: "e := get[inx]{   T.put(e):at[inx]}" 
 -- items:markForCodeGen: "e := get[inx]{T.put(e):at[inx]}" 
 -- markItem: "e := get[inx]" Assign 
 -- Invocation:markForCodeGen: "e" 
 -- ObjectInvocation:markForCodeGen: "e"  ATd: "e: var integer" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "T.put(e):at[inx]" ObjectGenerator 
 -- arg:   "1" 
 -- arg:   "L" 
 -- arg:   "e := get[inx]{   T.put(e):at[inx]}" 
 -- OG:markIS: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- OG:Qalloc: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" qDescno:  176 
 -- ObjTmpStack:add: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- items:markForCodeGen: "" 
 -- markItem: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" ObjectGenerator 
 -- OG:markForCodeGen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- isObjectDesc: true  hasItems: false 
 --  super.hasVirtualArgs: true 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" false 
 -- 
 -- OG:markSuper: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- Invocation:markForCodeGen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- ObjectInvocation:markForCodeGen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  ATd: "for(first: var integer):to(last: var integer):r ..." 
 -- OI:args:markForCodgen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:markForCodeGen: "1" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "1" 
 -- "1" true 
 -- 
 -- OG:markSuper: "1" 
 -- Invocation:markForCodeGen: "1" 
 -- not ObjDesc:  "1"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "S.length" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "S.length" 
 -- "S" true 
 -- "length" false 
 -- 
 -- OG:markSuper: "S.length" 
 -- Invocation:markForCodeGen: "S.length" 
 -- ObjectInvocation:markForCodeGen: "S"  ATd: "in S: var String" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:args:markForCodgen: "" 
 -- not ObjDesc:  "S.length"  IS.isEmpty:  true 
 -- OG:markForCodeGen: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- OG:Qalloc: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" qDescno:  177 
 -- ObjTmpStack:add: "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- items:markForCodeGen: "e := S.get[inx]{i := L + inx;T.put(e):at[i]}" 
 -- markItem: "e := S.get[inx]" Assign 
 -- Invocation:markForCodeGen: "e" 
 -- ObjectInvocation:markForCodeGen: "e"  ATd: "e: var integer" 
 -- OI:args:markForCodgen: "" 
 -- markItem: "i := L + inx" Assign 
 -- Invocation:markForCodeGen: "i" 
 -- ObjectInvocation:markForCodeGen: "i"  ATd: "i: var integer" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "L + inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "L + inx" 
 -- "L + inx" true 
 -- 
 -- OG:markSuper: "L + inx" 
 -- Invocation:markForCodeGen: "L + inx" 
 -- BinaryExp:markForCodeGen: "L + inx" 
 -- Invocation:markForCodeGen: "L" 
 -- ObjectInvocation:markForCodeGen: "L"  ATd: "L: var integer" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "+ inx"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:args:markForCodgen: "inx" 
 -- OG:markForCodeGen: "inx" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "inx" 
 -- "inx" true 
 -- 
 -- not ObjDesc:  "L + inx"  IS.isEmpty:  true 
 -- markItem: "T.put(e):at[i]" ObjectGenerator 
 -- arg:   "1" 
 -- arg:   "S.length" 
 -- arg:   "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" 
 -- OG:markIS: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- OG:Qalloc: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" qDescno:  178 
 -- ObjTmpStack:add: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- items:markForCodeGen: "" 
 -- markItem: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" Assign 
 -- Invocation:markForCodeGen: "V" 
 -- ObjectInvocation:markForCodeGen: "V"  ATd: "out V: var String" 
 -- OI:args:markForCodgen: "" 
 -- OG:markForCodeGen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- "T" true 
 -- "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" true 
 -- 
 -- OG:markSuper: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- Invocation:markForCodeGen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- ObjectInvocation:markForCodeGen: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
 -- OI:args:markForCodgen: "" 
 -- ObjectInvocation:markForCodeGen: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  ATd: "asString: {   %basic 118;   out S: var LIB.S ...}" 
 -- Pattern:markForCodeGen: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- items:markForCodeGen: "" 
 -- OG:markForCodeGen: "%basic 118{   out S: var LIB.StringLib.String}" 
 -- isObjectDesc: true  hasItems: true 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: false 
 --  (super.last).isPrimitive: false 
 -- "" 
 -- "" false 
 -- 
 -- OG:markIS: "%basic 118{   out S: var LIB.StringLib.String}" 
 -- OG:Qalloc: "%basic 118{   out S: var LIB.StringLib.String}" qDescno:  179 
 -- ObjTmpStack:add: "asString" : "%basic 118{   out S: var LIB.StringLib.String}" 
 -- items:markForCodeGen: "%basic 118{out S: var LIB.StringLib.String}" 
 -- markItem: "%basic 118" Property 
 -- DataItem:markForCodeGen: "S" :descNo: 0 :OG.primNo: 5 
 -- OG:markForCodeGen: "LIB.StringLib.String" 
 -- isObjectDesc: false  hasItems: false 
 --  super.hasVirtualArgs: false 
 --  super.isPrimitive: true 
 --  (super.last).isPrimitive: true 
 -- "LIB.StringLib.String" 
 -- "LIB" false 
 -- "StringLib" false 
 -- "String" true 
 -- 
 -- not ObjDesc:  "LIB.StringLib.String"  IS.isEmpty:  true 
 -- OI:args:markForCodgen: "-- V: obj Indexed(Length + S.length){-- V := T[1:length] + S.T[1:S.length]}" 
 -- not ObjDesc:  "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  IS.isEmpty:  true 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 1 
 -- Items:GenClass: BETAworld descNo: 1 isValue: false 
 -- Items:GenClass: BETAworld descNo: 21 isValue: false 

 CLASS BETAworld 21 1 BETA 2
 -- Store itemArgs: %ID Object{%basic 64;%public;==  : ;   %basic 56;   in objx: ref Object;   out V: var boolean;=/=  : ;   %basic 57;   in objx: ref Object;   out V: var boo ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 mvStack 
 -- $Property:gen: "%ID Object"  
 -- $Property:gen: "%basic 64"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "X_asString:<  -- does not wokr, problem with virtual in Object{   out S: var LIB.StringLib.String;   inner(X_asString)" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%ID Object" 
 -- $Property:gen: "%ID Object"  
 -- genclass:stmt: "%basic 64" 
 -- $Property:gen: "%basic 64"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "inner(Object)" 
 -- $ObjectGenerator:gen: "inner(Object)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(Object)" 
 -- OG:before:super.gen: "inner(Object)" 
 -- $Invocation:gen: "inner(Object)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(Object)" 
 -- isConstant: "Invocation" "inner(Object)" 
 -- needorigin: "inner(Object)" 
 -- needOrigin:E: "inner(Object)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(Object)" 
 -- computeAdr:superAdj: 0 "inner(Object)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(Object)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(Object)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(Object)" >on:1 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(Object)" >ATd.off:0 (isPtn):on:1:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F  ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inner(Object)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- computeAdr:isLast:E:  "inner(Object)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:- 
 -- rec:  "inner(Object)" E:  "inner(Object)" 
 -- INV:gen:E.loadArgs "inner(Object)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(Object)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"Object"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(Object)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(Object)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Object)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(O ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(Object)" >rec:"inner(Object)" ATd:"pattern" E:"inner(Object)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(Object)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- OI:invoke:B: "inner(Object)" E: "inner(Object)"  rec: "inner(Object)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(Object)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(Object)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 -- 
 -- OI:invoke:C: inner(Object) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Object)":rec:inner(Object) 
 L2:
 -- pushReturn:  "BETAworld" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=21 vDescInx=0 vdtTop: 2 
 -- vdtAdd: inx=1 descInx=21 vDescInx=32 vdtTop: 2 

 CLASS BETAworld 1 1 Object 21
 -- Store itemArgs: %id "BETAworld"{%modules BETA, LIB, LIB.StringLib, LIB.BasicIo;error: ;   %basic 999;--BETA;--DK;--LIB;--OOPM;--Sequential;--no;--workspace;} 
 -- Store:Origin: 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=1 vDescInx=1 vdtTop: 1 
 pushThis 
 saveBETAworld
 mvStack 
 -- $Property:gen: "%id "BETAworld""  
 -- $Property:gen: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo"  
 -- $obj:gen: "BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  ..."} 
 -- $ObjectGenerator:gen: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ..."} 
 -- OG:gen: "%ID BETA{   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  : ;         %ba ...}" 
 pushThis 
 -- before objTmpStack:add:  2   "BETA" 
 invoke BETA 2 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Coll ..."} 
 -- $ObjectGenerator:gen: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Colle ..."} 
 -- OG:gen: "%id "LIB"{   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Compi ...}" 
 pushThis 
 -- before objTmpStack:add:  33   "LIB" 
 invoke LIB 33 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "workspace" 
 -- $ModuleItem:gen: "--BETA{" } 
 -- ModuleItem:gen BETA 
 -- $obj:gen: "BETA: obj {   %ID BETA;   %OSDvisibility disguised;   %module LIB, LIB.StringLib;   %public;   Object: ;      %ID Object;      %basic 64;      %public;      ==  ..."} 
 -- $ModuleItem:gen: "--DK{" } 
 -- $ModuleItem:gen: "--LIB{" } 
 -- ModuleItem:gen LIB 
 -- $obj:gen: "LIB: obj {   %id "LIB";   %module BETA;   %Include BETA;   x_dummy_LIB: var integer;   --AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Coll ..."} 
 -- $ModuleItem:gen: "--OOPM{" } 
 -- $ModuleItem:gen: "--Sequential{" } 
 -- $ModuleItem:gen: "--no{" } 
 -- $ModuleItem:gen: "--workspace{" } 
 -- ModuleItem:gen workspace 
 -- $obj:gen: "workspace: obj {   %id "workspace";   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred; ..."} 
 -- $ObjectGenerator:gen: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--Ardui ..."} 
 -- OG:gen: "%id "workspace"{   %visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;   %domain_boundary;   --AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasi ...}" 
 pushThis 
 -- before objTmpStack:add:  127   "workspace" 
 invoke workspace 127 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "BETAworld"" 
 -- $Property:gen: "%id "BETAworld""  
 -- genclass:stmt: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo" 
 -- $Property:gen: "%modules BETA, LIB, LIB.StringLib, LIB.BasicIo"  
 L2:
 -- pushReturn:  "BETAworld" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 2 
 -- Items:GenClass: BETA descNo: 2 isValue: false 
 -- Items:GenClass: BETA descNo: 21 isValue: false 

 CLASS BETA 2 1 BETAworld 1
 -- Store itemArgs: %ID BETA{%OSDvisibility disguised;%module LIB, LIB.StringLib;%public;Object: ;   %ID Object;   %basic 64;   %public;   ==  : ;      %basic 56;      in objx ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=2 vDescInx=2 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%ID BETA"  
 -- $Property:gen: "%OSDvisibility disguised"  
 -- $Property:gen: "%module LIB, LIB.StringLib"  
 -- $Property:gen: "%public"  
 -- $obj:gen: "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr ..."} 
 -- DI:gen: "ascii: obj {   asciiFoo: ;      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr:  ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  ascii 
 -- $ObjectGenerator:gen: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: v ..."} 
 -- OG:gen: "asciiFoo: {      msg1:  -- obj;         _put('F');         asciiBar.msg2;   asciiBar:  -- obj;      msg2: ;         _put('B');   nl: val 10;   cr: val 13;   null: ...}" 
 pushThis 
 -- before objTmpStack:add:  3   "ascii" 
 invoke ascii 3 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ref:gen: "console: ref ConsoleIF"  
 -- DI:gen: "console: ref ConsoleIF" DI:isConst: false :isBasicValue: false :primNo: 0 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%ID BETA" 
 -- $Property:gen: "%ID BETA"  
 -- genclass:stmt: "%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"  
 -- genclass:stmt: "%module LIB, LIB.StringLib" 
 -- $Property:gen: "%module LIB, LIB.StringLib"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "BETA" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 3 
 -- Items:GenClass: ascii descNo: 3 isValue: false 
 -- Items:GenClass: ascii descNo: 21 isValue: false 

 CLASS ascii 3 1 BETA 2
 -- Store itemArgs: asciiFoo: {   msg1:  -- obj;      _put('F');      asciiBar.msg2;asciiBar:  -- obj;   msg2: ;      _put('B');nl: val 10;cr: val 13;null: val 0;newline: var  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=3 vDescInx=3 vdtTop: 1 
 mvStack 
 -- $val:gen: "nl: val 10"  
 -- DI:gen: "nl: val 10" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  nl 
 -- $ObjectGenerator:gen: "10" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- $Invocation:gen: "10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10" 
 -- isConstant: "Invocation" "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- $ConstLiteral:loadArgs: "10"  
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 -- $ConstLiteral:invoke: "10"  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 1  NewOff: 2 
 pushThis 
 storeg nl 2
 -- $val:gen: "cr: val 13"  
 -- DI:gen: "cr: val 13" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  cr 
 -- $ObjectGenerator:gen: "13" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "13" 
 -- OG:before:super.gen: "13" 
 -- $Invocation:gen: "13" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "13" 
 -- isConstant: "Invocation" "13" 
 -- needorigin: "13" 
 -- needOrigin:E: "13"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "13" E:  "13" 
 -- INV:gen:E.loadArgs "13" 
 -- $ConstLiteral:loadArgs: "13"  
 -- INV:gen:after:E.loadArgs "13" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "13" 
 -- $ConstLiteral:invoke: "13"  
 pushc 13
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 2  NewOff: 3 
 pushThis 
 storeg cr 3
 -- $val:gen: "null: val 0"  
 -- DI:gen: "null: val 0" DI:isConst: true :isBasicValue: true :primNo: 1 
 -- DI:add:BP2:  null 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- dataItem:store:basicValue: off: 3  NewOff: 4 
 pushThis 
 storeg null 4
 -- $var:gen: "newline: var char"  
 -- DI:gen: "newline: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  newline 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- $Assign:gen: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1" } 
 -- assign: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- computeAdr:superAdj: 0 "newline" 
 -- computeAdr: 1 :rec: "none"  E: "newline" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "newline"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "newline" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "newline" >ATd.off:5:on:0:superAdj:0"newline: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu ... 
 -- $var:getAdr: "newline: var char" >newOff:5,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: char 
 -- before:floatTest:  "newline: var char" ObjectGenerator 
 -- :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- After:U*U: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- computeAdr:isLast:E:  "newline" 
 -- AssignmentStatement:gen: "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" right.label: "ObjectGenerator" "nl -- Win:<cr><lf>, Uni ..." 
 -- $ObjectGenerator:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- OG:before:super.gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- $Invocation:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1" >useRtnV:"True"superAdj: 0} 
 -- INV:gen: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- isConstant: "Invocation" "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- const literal:  10   ConstLiteral 
 pushc 10
 -- OG:gen:end: 
 -- rec: "newline" dstE: "newline" dstE.ATd: "newline: var char" useRtn: false :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newli ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" 
 -- isArgOfAssignI2IwithUniValArg "newline := nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" arg: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cyg ..." O ... 
 -- arg.super.arg: "nl -- Win:<cr><lf>, Unix:<lf>, Mac:<lf>, Cygwin default:<lf>{--asciiFoo.msg1}" ObjectInvocation_Unary 
 -- dstDI: "newline: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:5 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"newline":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg ascii$3 5
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "ascii" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 4 
 -- Items:GenClass: Value descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Value 4 0 BETA 2 isValueObj
 -- Store itemArgs: %ID Value{%globals;%basic 21;%public;=  :< ;   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= );<=  :< ;   %basic 52;   in Veq: va ...} 
 -- vdtAdd: inx=1 descInx=4 vDescInx=4 vdtTop: 1 
 -- $Property:gen: "%ID Value"  
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 21"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" } 
 -- $pattern:gen: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" } 
DO:
 L1:
 -- genclass:stmt: "%ID Value" 
 -- $Property:gen: "%ID Value"  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 21" 
 -- $Property:gen: "%basic 21"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Value" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- vdtAdd: inx=2 descInx=4 vDescInx=11 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=4 vDescInx=58 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 5 
 -- Items:GenClass: integer descNo: 5 isValue: true 
 -- Items:GenClass: integer descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS integer 5 0 BETA 2 isValueObj
 -- Store itemArgs: %ID integer{%basic 1, 32;%globals;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;  ...} 
 -- vdtAdd: inx=1 descInx=5 vDescInx=5 vdtTop: 1 
 -- $Property:gen: "%ID integer"  
 -- $Property:gen: "%basic 1, 32"  
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%public"  
 -- $var:gen: "_thisBasicValue: var Universal"  
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
DO:
 L1:
 -- genclass:stmt: "%ID integer" 
 -- $Property:gen: "%ID integer"  
 -- genclass:stmt: "%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "integer" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 6 
 -- Items:GenClass: universal descNo: 6 isValue: true 
 -- Items:GenClass: universal descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS universal 6 0 BETA 2 isValueObj
 -- Store itemArgs: %ID universal{%basic 1, 32;%globals;+  : ;   %basic 61;   in V: var integer;   out R: var integer;-  : ;   %basic 62;   in V: var integer;   out R: var int ...} 
 -- vdtAdd: inx=1 descInx=6 vDescInx=6 vdtTop: 1 
 -- $Property:gen: "%ID universal"  
 -- $Property:gen: "%basic 1, 32"  
 -- $Property:gen: "%globals"  
DO:
 L1:
 -- genclass:stmt: "%ID universal" 
 -- $Property:gen: "%ID universal"  
 -- genclass:stmt: "%basic 1, 32" 
 -- $Property:gen: "%basic 1, 32"  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 L2:
 -- pushReturn:  "universal" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 7 
 -- Items:GenClass: char descNo: 7 isValue: true 
 -- Items:GenClass: char descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS char 7 0 BETA 2 isValueObj
 -- Store itemArgs: %id "char"{%globals;%basic 3, 16;%public;_thisBasicValue: var Universal;+  : ;   %basic 61;   in V: var char;   out R: var char;-  : ;   %basic 62;   in V: ...} 
 -- vdtAdd: inx=1 descInx=7 vDescInx=7 vdtTop: 1 
 -- $Property:gen: "%id "char""  
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 3, 16"  
 -- $Property:gen: "%public"  
 -- $var:gen: "_thisBasicValue: var Universal"  
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
DO:
 L1:
 -- genclass:stmt: "%id "char"" 
 -- $Property:gen: "%id "char""  
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 3, 16" 
 -- $Property:gen: "%basic 3, 16"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "char" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 8 
 -- Items:GenClass: ConsoleIF descNo: 8 isValue: false 
 -- Items:GenClass: ConsoleIF descNo: 21 isValue: false 

 CLASS ConsoleIF 8 1 BETA 2
 -- Store itemArgs: put:< {   ...;puttext(T: var LIB.StringLib.String):< ;   inner(puttext);putint(V: var Integer):< ;   inner(putint)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=8 vDescInx=8 vdtTop: 1 
 mvStack 
 -- $pattern:gen: "put:< {   ..." } 
 -- $pattern:gen: "puttext(T: var LIB.StringLib.String):< {   inner(puttext)" } 
 -- $pattern:gen: "putint(V: var Integer):< {   inner(putint)" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "ConsoleIF" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=8 vDescInx=9 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=8 vDescInx=125 vdtTop: 3 
 -- vdtAdd: inx=4 descInx=8 vDescInx=126 vdtTop: 4 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 9 
 -- Items:GenClass: put descNo: 9 isValue: false 
 -- Items:GenClass: put descNo: 21 isValue: false 

 CLASS put 9 1 ConsoleIF 8
 -- Store itemArgs: ... 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=9 vDescInx=9 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "..." 
 -- $Dots:gen: "..."  
 L2:
 -- pushReturn:  "put" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 10 
 -- Items:GenClass: String descNo: 10 isValue: false 
 -- Items:GenClass: String descNo: 4 isValue: false 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS String 10 0 StringLib 107
 -- Store itemArgs: %id "String pattern"{%OSDvisibility disguised;%basic 5;%public;length: ;   out V: var integer;   V := get[0] -- actually an index error, accessing length;g ...} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=10 vDescInx=10 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "String pattern""  
 -- $Property:gen: "%OSDvisibility disguised"  
 -- $Property:gen: "%basic 5"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "=  :: {   loop: do ;      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);     ..."} 
 -- $pattern:gen: "<=  :: {   loop: obj ;      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"     ..."} 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "String pattern"" 
 -- $Property:gen: "%id "String pattern""  
 -- genclass:stmt: "%OSDvisibility disguised" 
 -- $Property:gen: "%OSDvisibility disguised"  
 -- genclass:stmt: "%basic 5" 
 -- $Property:gen: "%basic 5"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "String" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:2 objSize:0 isIndexed:1
 -- vdtAdd: inx=2 descInx=10 vDescInx=13 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=10 vDescInx=109 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 13 
 -- Items:GenClass: = descNo: 13 isValue: false 
 -- Items:GenClass: = descNo: 11 isValue: false 
 -- Items:GenClass: = descNo: 21 isValue: false 
 -- got:sub:vEq:  50  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 21 "%basic 50{   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OG:reAlloc: descNo: 0 0 "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      i ...}" 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 

 CLASS = 11 1 Value 4
 -- Store itemArgs: %basic 50{in Veq: var this(Value);out Beq: var boolean;inner(= )} 
 -- in Veq: var this(Value) true 18 
 -- DI:store: "Veq" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 L4:
 -- Store:Origin: 21 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=11 vDescInx=11 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 50"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 50" 
 -- $Property:gen: "%basic 50"  
 -- genclass:stmt: "inner(= )" 
 -- $ObjectGenerator:gen: "inner(= )" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(= )" 
 -- OG:before:super.gen: "inner(= )" 
 -- $Invocation:gen: "inner(= )" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(= )" 
 -- isConstant: "Invocation" "inner(= )" 
 -- needorigin: "inner(= )" 
 -- needOrigin:E: "inner(= )"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(= )" 
 -- computeAdr:superAdj: 0 "inner(= )" 
 -- computeAdr: 1 :rec: "none"  E: "inner(= )" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(= )"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(= )" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(= )" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F supe ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(= )"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- computeAdr:isLast:E:  "inner(= )" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:- 
 -- rec:  "inner(= )" E:  "inner(= )" 
 -- INV:gen:E.loadArgs "inner(= )" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(= )" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"= "} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(= )":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(= )" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(= )" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )": ... 
 -- $ObjectInvocation_KeyWord:invoke: "inner(= )" >rec:"inner(= )" ATd:"pattern" E:"inner(= )" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(= )" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- OI:invoke:B: "inner(= )" E: "inner(= )"  rec: "inner(= )"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(= )" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(= )" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 -- 
 -- OI:invoke:C: inner(= ) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(= )":rec:inner(= ) 
 L2:
 -- pushReturn:  "=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- vdtAdd: inx=2 descInx=11 vDescInx=0 vdtTop: 2 
 -- got:sub:vEq:  50  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 5 "loop: do {      c1: var char;      c2: var char;      L: var integer;      L := length;      if (L <> Veq.length) :then ;         leave(loop);     ...}" 
 -- OG:reAlloc:String: 
 -- currentDcl:this: 
 -- reAllocatedOff: "Veq" 2 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- reAllocatedOff: "Beq" 3 
 -- reAllocatedOff: "loop" 0 

 CLASS = 13 1 String 10
 -- vdtTableCopy: I:1:11 I:2:0
 -- vdtAdd: inx=2 descInx=13 vDescInx=13 vdtTop: 2 
 -- Store itemArgs: loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(len ...} 
 -- Store:Origin: 5 
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super =
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 rShiftDown  1
 -- hArgOrg:super: = 
 -- Store itemArgs: loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(len ...} 
 -- in Veq: var this(Value) true 18 
 pushThis 
 rstoreg  Veq 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=13 vDescInx=11 vdtTop: 2 
 mvStack 
 -- $Property:gen: "%basic 50"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(len ...}" 
 -- $do:gen: "loop: do {   c1: var char;   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):r ..."} 
 -- $ObjectGenerator:gen: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):r ..."} 
 -- OG:gen: "c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;      c1 ...}" 
 pushThis 
 -- before objTmpStack:add:  14   "loop" 
 invoke loop 14 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 14 
 -- Items:GenClass: loop descNo: 14 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 14 1 = 13
 -- Store itemArgs: c1: var char{c2: var char;L: var integer;L := length;if (L <> Veq.length) :then ;   leave(loop);beq := true;for(1):to(length):repeat;   c1 := get[inx];   c ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=14 vDescInx=14 vdtTop: 1 
 mvStack 
 -- $var:gen: "c1: var char"  
 -- DI:gen: "c1: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c1 
 -- $var:gen: "c2: var char"  
 -- DI:gen: "c2: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c2 
 -- $var:gen: "L: var integer"  
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := length" 
 -- $Assign:gen: "L := length"  
 -- assign: "L := length" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := length" right.label: "ObjectGenerator" "length" 
 -- $ObjectGenerator:gen: "length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- $Invocation:gen: "length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "length" 
 -- isConstant: "Invocation" "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "length" 
 -- computeAdr: 1 :rec: "none"  E: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:2:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"length" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length" E: "length"  rec: "length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "length" 
 -- isArgOfAssignI2IwithUniValArg "L := length" arg: "length" ObjectGenerator 
 -- arg.super.arg: "length" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $ObjectGenerator:gen: "if (L <> Veq.length) :then {   leave(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OG:before:super.gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $Invocation:gen: "if (L <> Veq.length) :then {   leave(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- isConstant: "Invocation" "if (L <> Veq.length) :then {   leave(loop)}" 
 -- needorigin: "if (L <> Veq.length) :then {   leave(loop)}" 
 -- needOrigin:E: "if (L <> Veq.length) :then {   leave(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globa ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L <> Veq.length) :then {   leave(loop)}" E:  "if (L <> Veq.length) :then {   leave(loop)}" 
 -- INV:gen:E.loadArgs "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $IfThen:loadArgs: "if (L <> Veq.length) :then {   leave(loop)" } 
 -- INV:gen:after:E.loadArgs "if (L <> Veq.length) :then {   leave(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L <> Veq.length) :then {   leave(loop)}" 
 -- $IfThen:invoke: "if (L <> Veq.length) :then {   leave(loop)" } 
 -- $IfThen:gen: "if (L <> Veq.length) :then {   leave(loop)" } 
 -- $ObjectGenerator:gen: "(L <> Veq.length)" >OGid:"<>" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L <> Veq.length)" 
 -- OG:before:super.gen: "(L <> Veq.length)" 
 -- $Invocation:gen: "(L <> Veq.length)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L <> Veq.length)" 
 -- isConstant: "Invocation" "(L <> Veq.length)" 
 -- needorigin: "(L <> Veq.length)" 
 -- needOrigin:E: "(L <> Veq.length)"  E.ATd: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(L <> Veq.length)" 
 -- computeAdr:superAdj: 0 "(L <> Veq.length)" 
 -- computeAdr: 1 :rec: "none"  E: "(L <> Veq.length)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L <> Veq.length)"  
 -- $BracketedExp:loadOrigin: "(L <> Veq.length)"  
 -- computeAdr:superAdj: 0 "L <> Veq.length" 
 -- computeAdr: 1 :rec: "none"  E: "L <> Veq.length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L <> Veq.length"  
 -- $BinOp:loadOrigin: "L <> Veq.length"  
 -- BinaryExp:loadOrigin:empty: "L <> Veq.length" superAdj: 0 
 -- $BinOp:getAdr: "L <> Veq.length"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L <> Veq.length" 
 -- BE:loadOrigin:E: L <> Veq.length 
 -- $BinOp:getAdr: "L <> Veq.length"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L <> Veq.length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L <> Veq.length" E:  "L <> Veq.length" 
 -- INV:gen:E.loadArgs "L <> Veq.length" 
 -- $BinOp:loadArgs: "L <> Veq.length"  
 -- BinaryExp:loadArgs: "L <> Veq.length" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 loop$14
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L <> Veq.length" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean" >E:"<> Veq.length":descNo:17} 
 -- ptn:loadArgs:E "<> Veq.length" 
 -- {(ObjectInvocation_Binary; (name: "<>"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "Veq");     (Arguments));    (ObjectInvocatio ...} 
 -- args: "Veq.length" 
 -- E: "ObjectGenerator" Veq.length 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "<> Veq.length" "ObjectInvocation_Binary" ActArg:  "Veq.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> Veq.length"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "Veq.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.length" 
 -- OG:before:super.gen: "Veq.length" 
 -- $Invocation:gen: "Veq.length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "Veq.length" 
 -- isConstant: "Invocation" "Veq.length" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "Veq.length" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:1:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 c1: var char{   c2: var char;   L: var integer;   L := length;   if (L <> Veq.length) :then ;      leave(loop);   beq := true;   for(1):to(length):repeat;    ...} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "Veq" E: "length"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "length" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$14 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec:  "Veq" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"Veq" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "length" E: "length"  rec: "Veq"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "Veq.length" :isBasicVal: true 
 -- case:B: Veq.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "<> Veq.length" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L <> Veq.length" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L <> Veq.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L <> Veq.length"  
 -- BinaryExp:invoke: "L" rec: "L <> Veq.length" 
 -- M: "<> Veq.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "<> Veq.length" >rec:"L" ATd:"pattern" E:"<> Veq.length" E.ATd:"<>  " unique:"False" 
 -- OI:invoke: "<> Veq.length" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "<> Veq.length" E: "<> Veq.length"  rec: "L"  useRtnV: true "<>  : {   %basic 55;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- $pattern:invoke: "<>  : {   %basic 55;   in V: var integer;   out B: var boolean" E: "<> Veq.length" useRTNv: "True"} 
 -- ptn:invoke: "<>  " E: "<> Veq.length" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "<> Veq.length" 
 -- arg:other 
 ne
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> Veq.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <> Veq.length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "leave(loop)" >OGid:"$18" singular! staticOff=0 descNo=18 superAdj=0 
 -- OG:gen: "leave(loop)" 
 pushThis 
 -- before objTmpStack:add:  18   "$18" 
 invoke $18 18 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "beq := true" 
 -- $Assign:gen: "beq := true"  
 -- assign: "beq := true" 
 -- computeAdr:superAdj: 0 "beq" 
 -- computeAdr: 1 :rec: "none"  E: "beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "beq" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "beq" >ATd.off:3:on:1:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- computeAdr:isLast:E:  "beq" 
 -- AssignmentStatement:gen: "beq := true" right.label: "ObjectGenerator" "true" 
 -- $ObjectGenerator:gen: "true" >OGid:"True" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "true" 
 -- OG:before:super.gen: "true" 
 -- $Invocation:gen: "true" >useRtnV:"True"superAdj: 0 descNo: 23 
 -- INV:gen: "true" 
 -- isConstant: "Invocation" "true" 
 -- needorigin: "true" 
 -- needOrigin:E: "true"  E.ATd: "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   out B: var boolean;   B := 1}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "true" E:  "true" 
 -- INV:gen:E.loadArgs "true" 
 -- $ObjectInvocation_Unary:loadArgs: "true" >staticOff:0 "True: {   %globals;   out B: var boolean;   B := 1" superAdj:0} 
 -- $pattern:loadArgs: "True: {   %globals;   out B: var boolean;   B := 1" >E:"true":descNo:23} 
 -- ptn:loadArgs:E "true" 
 -- {(ObjectInvocation_Unary; (name: "true"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "true" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "true" 
 -- $ObjectInvocation_Unary:invoke: "true" >rec:"true" ATd:"pattern" E:"true" E.ATd:"True" unique:"False" 
 -- OI:invoke: "true" 
 -- 
 -- OI:invoke:B: "true" E: "true"  rec: "true"  useRtnV: true "True: {   %globals;   out B: var boolean;   B := 1}" 
 -- OI:invoke:before:ATdx.invoke: pattern True 
 -- $pattern:invoke: "True: {   %globals;   out B: var boolean;   B := 1" E: "true" useRTNv: "True"} 
 -- ptn:invoke: "True" E: "true" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke True 23 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: true :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "beq" dstE: "beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "true" 
 -- isArgOfAssignI2IwithUniValArg "beq := true" arg: "true" ObjectGenerator 
 -- arg.super.arg: "true" ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- $ObjectGenerator:gen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);" >OGid:"for:to:repeat ..."} 
 -- OG:gen: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 pushThis 
 -- before objTmpStack:add:  30   "for:to:repeat$30" 
 invoke for:to:repeat$30 30 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 15 
 -- Items:GenClass: length descNo: 15 isValue: false 
 -- Items:GenClass: length descNo: 21 isValue: false 

 CLASS length 15 1 String 10
 -- Store itemArgs: out V: var integer{V := get[0] -- actually an index error, accessing length} 
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=15 vDescInx=15 vdtTop: 1 
 mvStack 
 -- $var:gen: "out V: var integer"  
 -- DI:gen: "out V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "V := get[0] -- actually an index error, accessing length" 
 -- $Assign:gen: "V := get[0] -- actually an index error, accessing length"  
 -- assign: "V := get[0] -- actually an index error, accessing length" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"out V: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- PING:String 0 out V: var integer{   V := get[0] -- actually an index error, accessing length} 
 -- $var:getAdr: "out V: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: integer 
 -- before:floatTest:  "out V: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := get[0] -- actually an index error, accessing length" right.label: "ObjectGenerator" "get[0] -- actually an index error, accessing length" 
 -- $ObjectGenerator:gen: "get[0] -- actually an index error, accessing length" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[0] -- actually an index error, accessing length" 
 -- OG:before:super.gen: "get[0] -- actually an index error, accessing length" 
 -- $Invocation:gen: "get[0] -- actually an index error, accessing length" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[0] -- actually an index error, accessing length" 
 -- isConstant: "Invocation" "get[0] -- actually an index error, accessing length" 
 -- needorigin: "get[0] -- actually an index error, accessing length" 
 -- needOrigin:E: "get[0] -- actually an index error, accessing length"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[0] -- actually an index error, accessing length" 
 -- computeAdr:superAdj: 0 "get[0] -- actually an index error, accessing length" 
 -- computeAdr: 1 :rec: "none"  E: "get[0] -- actually an index error, accessing length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[0] -- actually an index error, accessing length"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[0] -- actually an index error, accessing length" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "length" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg length$15 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[0] -- actually an index error, accessing length" >ATd.off:0 (isPtn):on:1:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: ..."} 
 -- PING:String 0 out V: var integer{   V := get[0] -- actually an index error, accessing length} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "get[0] -- actually an index error, accessing length"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:- 
 -- computeAdr:isLast:E:  "get[0] -- actually an index error, accessing length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing len ..." 
 -- rec:  "get[0] -- actually an index error, accessing length" E:  "get[0] -- actually an index error, accessing length" 
 -- INV:gen:E.loadArgs "get[0] -- actually an index error, accessing length" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[0] -- actually an index error, accessing length" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj ...} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[0] -- actually an index error, accessing length":descNo:16} 
 -- ptn:loadArgs:E "get[0] -- actually an index error, accessing length" 
 -- {(ObjectInvocation_KeyWord --24> actually an index error, accessing length; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    ( ...} 
 -- args: "get[0]" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[0] -- actually an index error, accessing length" "ObjectInvocation_KeyWord" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[0] -- actually an index error, accessing length"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "0" :isBasicVal: true 
 -- case:B: 0 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "get[0] -- actually an index error, accessing length" 
 -- INV:gen:after:E.loadArgs "get[0] -- actually an index error, accessing length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[0] -- actually an index error, accessing length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[0] -- actually an index error, accessing length" >rec:"get[0] -- actually an index error, accessing length" ATd:"pattern" E:"get[0]  ..." 
 -- OI:invoke: "get[0] -- actually an index error, accessing length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an i ... 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- actually an i ... 
 -- OI:invoke:B: "get[0] -- actually an index error, accessing length" E: "get[0] -- actually an index error, accessing length"  rec: "get[0] -- actually an index error, acces ..."   ... true "g ..." 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[0] -- actually an index error, accessing length" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[0] -- actually an index error, accessing length" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0 ... 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0 ... 
 -- 
 -- OI:invoke:C: get[0] -- actually an index error, accessing length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[0] -- actually an index error, accessing length":rec:get[0] -- a ... 
 -- rec: "V" dstE: "V" dstE.ATd: "out V: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[0] -- actually an index error, accessing length" 
 -- isArgOfAssignI2IwithUniValArg "V := get[0] -- actually an index error, accessing length" arg: "get[0] -- actually an index error, accessing length" ObjectGenerator 
 -- arg.super.arg: "get[0] -- actually an index error, accessing length" ObjectInvocation_KeyWord 
 -- dstDI: "out V: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg length$15 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "length" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 31 
 -- Items:GenClass: this descNo: 31 isValue: false 
 -- Items:GenClass: this descNo: 21 isValue: false 

 CLASS this 31 1 BETA 2
 -- Store itemArgs: %basic 18{in this: ref Object} 
 -- in this: ref Object true 64 
 -- DI:store: "this" 
 pushThis 
 rstoreg  this 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=31 vDescInx=31 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 18"  
 -- $ref:gen: "in this: ref Object"  
 -- DI:gen: "in this: ref Object" DI:isConst: false :isBasicValue: false :primNo: 64 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 18" 
 -- $Property:gen: "%basic 18"  
 L2:
 -- pushReturn:  "this" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 32 
 -- Items:GenClass: X_asString descNo: 32 isValue: false 
 -- Items:GenClass: X_asString descNo: 21 isValue: false 

 CLASS X_asString 32 1 Object 21
 -- Store itemArgs: out S: var LIB.StringLib.String{inner(X_asString)} 
 -- Store:Origin: 64 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=32 vDescInx=32 vdtTop: 1 
 mvStack 
 -- $var:gen: "out S: var LIB.StringLib.String"  
 -- DI:gen: "out S: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out S: var LIB.StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(X_asString)" 
 -- $ObjectGenerator:gen: "inner(X_asString)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(X_asString)" 
 -- OG:before:super.gen: "inner(X_asString)" 
 -- $Invocation:gen: "inner(X_asString)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(X_asString)" 
 -- isConstant: "Invocation" "inner(X_asString)" 
 -- needorigin: "inner(X_asString)" 
 -- needOrigin:E: "inner(X_asString)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(X_asString)" 
 -- computeAdr:superAdj: 0 "inner(X_asString)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(X_asString)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(X_asString)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(X_asString)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(X_asString)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVa ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(X_asString)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- computeAdr:isLast:E:  "inner(X_asString)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:- 
 -- rec:  "inner(X_asString)" E:  "inner(X_asString)" 
 -- INV:gen:E.loadArgs "inner(X_asString)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(X_asString)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"X_asString"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(X_asString)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(X_asString)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(X_asString)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inn ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(X_asString)" >rec:"inner(X_asString)" ATd:"pattern" E:"inner(X_asString)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(X_asString)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- OI:invoke:B: "inner(X_asString)" E: "inner(X_asString)"  rec: "inner(X_asString)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(X_asString)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(X_asString)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 -- 
 -- OI:invoke:C: inner(X_asString) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(X_asString)":rec:inner(X_asString) 
 L2:
 -- pushReturn:  "X_asString" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=32 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 33 
 -- Items:GenClass: LIB descNo: 33 isValue: false 
 -- Items:GenClass: LIB descNo: 21 isValue: false 

 CLASS LIB 33 1 BETAworld 1
 -- Store itemArgs: %id "LIB"{%module BETA;%Include BETA;x_dummy_LIB: var integer;--AgentSystem;--Associations;--BasicIO;--BasicSystemLib;--COsystem;--Collections;--Compiler;- ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=33 vDescInx=33 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "LIB""  
 -- $Property:gen: "%module BETA"  
 -- Module:genMI:  "BasicIO" 
 -- $obj:gen: "BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get:  ..."} 
 -- $ObjectGenerator:gen: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;     ..."} 
 -- OG:gen: "%module LIB.StringLib{   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get: ;         res: var  ...}" 
 pushThis 
 -- before objTmpStack:add:  34   "BasicIO" 
 invoke BasicIO 34 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "Dimensions" 
 -- $obj:gen: "Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit  ..."} 
 -- $ObjectGenerator:gen: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;  ..."} 
 -- OG:gen: "%domain_boundary{   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit "U", 1;         %publi ...}" 
 pushThis 
 -- before objTmpStack:add:  38   "Dimensions" 
 invoke Dimensions 38 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- Module:genMI:  "StringLib" 
 -- $obj:gen: "StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      ..."} 
 -- $ObjectGenerator:gen: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %publi ..."} 
 -- OG:gen: "%id "String module"{   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      %public;      length ...}" 
 pushThis 
 -- before objTmpStack:add:  107   "StringLib" 
 invoke StringLib 107 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $Property:gen: "%Include BETA"  
 -- $var:gen: "x_dummy_LIB: var integer"  
 -- DI:gen: "x_dummy_LIB: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  x_dummy_LIB 
 -- $ModuleItem:gen: "--AgentSystem{" } 
 -- $ModuleItem:gen: "--Associations{" } 
 -- $ModuleItem:gen: "--BasicIO{" } 
 -- ModuleItem:gen BasicIO 
 -- $obj:gen: "BasicIO: obj {   %module LIB.StringLib;   %Public;   Lock: ;      dummy: var integer;      %Public;      M: var integer;      init: ;         M := 0;      get:  ..."} 
 -- $ModuleItem:gen: "--BasicSystemLib{" } 
 -- $ModuleItem:gen: "--COsystem{" } 
 -- $ModuleItem:gen: "--Collections{" } 
 -- $ModuleItem:gen: "--Compiler{" } 
 -- $ModuleItem:gen: "--Complex{" } 
 -- $ModuleItem:gen: "--DateTimeLib{" } 
 -- $ModuleItem:gen: "--Dimensions{" } 
 -- ModuleItem:gen Dimensions 
 -- $obj:gen: "Dimensions: obj {   %domain_boundary;   %public;   Dimension: ;      %dimension "-top-";      %public;      PrimaryUnit:< Unit;      Unit: Value;         %unit  ..."} 
 -- $ModuleItem:gen: "--EMC2array{" } 
 -- $ModuleItem:gen: "--Embedded{" } 
 -- $ModuleItem:gen: "--FileSys{" } 
 -- $ModuleItem:gen: "--ForkJoinSystem{" } 
 -- $ModuleItem:gen: "--MetaSystem{" } 
 -- $ModuleItem:gen: "--MonitorSystemLib{" } 
 -- $ModuleItem:gen: "--NonBlockingIO{" } 
 -- $ModuleItem:gen: "--RandomNumberGeneratorLib{" } 
 -- $ModuleItem:gen: "--SimpleConcurrentProcesses{" } 
 -- $ModuleItem:gen: "--Socket{" } 
 -- $ModuleItem:gen: "--SocketSystem{" } 
 -- $ModuleItem:gen: "--StringLib{" } 
 -- ModuleItem:gen StringLib 
 -- $obj:gen: "StringLib: obj {   %id "String module";   %module LIB;   %public;   String: Value;      %id "String pattern";      %OSDvisibility disguised;      %basic 5;      ..."} 
 -- $ModuleItem:gen: "--Xarray{" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "LIB"" 
 -- $Property:gen: "%id "LIB""  
 -- genclass:stmt: "%module BETA" 
 -- $Property:gen: "%module BETA"  
 -- genclass:stmt: "%Include BETA" 
 -- $Property:gen: "%Include BETA"  
 L2:
 -- pushReturn:  "LIB" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 34 
 -- Items:GenClass: BasicIO descNo: 34 isValue: false 
 -- Items:GenClass: BasicIO descNo: 21 isValue: false 

 CLASS BasicIO 34 1 LIB 33
 -- Store itemArgs: %module LIB.StringLib{%Public;Lock: ;   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop:  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=34 vDescInx=34 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%module LIB.StringLib"  
 -- $Property:gen: "%Public"  
 -- $obj:gen: "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;        ..."} 
 -- DI:gen: "keyboard: obj {   %Public;   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;          ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  keyboard 
 -- $ObjectGenerator:gen: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch:  ..."} 
 -- OG:gen: "%Public{   readLine: ;      out M: var LIB.StringLib.String;      inx: var integer;      msg: obj Indexed(30,integer);      read: obj ;         ch: var Char;      ...}" 
 pushThis 
 -- before objTmpStack:add:  35   "keyboard" 
 invoke keyboard 35 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $obj:gen: "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free" } 
 -- DI:gen: "screen: obj {   L: obj Lock;   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" DI:isConst: true :isBas ... false : ... 0 
 -- DI:add:BP4:  screen 
 -- $ObjectGenerator:gen: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free" >OGid:"screen" singular! s ...} 
 -- OG:gen: "L: obj Lock{   %Public;   init: ;      L.get;      L.init;      L.free;   display: ;      L.get;      inner;      L.free}" 
 pushThis 
 -- before objTmpStack:add:  36   "screen" 
 invoke screen 36 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%module LIB.StringLib" 
 -- $Property:gen: "%module LIB.StringLib"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "BasicIO" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 35 
 -- Items:GenClass: keyboard descNo: 35 isValue: false 
 -- Items:GenClass: keyboard descNo: 21 isValue: false 

 CLASS keyboard 35 1 BasicIO 34
 -- Store itemArgs: %Public{readLine: ;   out M: var LIB.StringLib.String;   inx: var integer;   msg: obj Indexed(30,integer);   read: obj ;      ch: var Char;      ch := _iGe ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=35 vDescInx=35 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "keyboard" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 36 
 -- Items:GenClass: screen descNo: 36 isValue: false 
 -- Items:GenClass: screen descNo: 21 isValue: false 

 CLASS screen 36 1 BasicIO 34
 -- Store itemArgs: L: obj Lock{%Public;init: ;   L.get;   L.init;   L.free;display: ;   L.get;   inner;   L.free} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=36 vDescInx=36 vdtTop: 1 
 mvStack 
 -- $obj:gen: "L: obj Lock"  
 -- DI:gen: "L: obj Lock" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- $ObjectGenerator:gen: "Lock" >OGid:"Lock" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Lock" 
 -- OG:before:super.gen: "Lock" 
 -- $Invocation:gen: "Lock" >useRtnV:"False"superAdj: 0 descNo: 37 
 -- INV:gen: "Lock" 
 -- isConstant: "Invocation" "Lock" 
 -- needorigin: "Lock" 
 -- needOrigin:E: "Lock"  E.ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         di ...}" 
 -- doNeedOrigin:Ex: "Lock" 
 -- computeAdr:superAdj: 0 "Lock" 
 -- computeAdr: 1 :rec: "none"  E: "Lock" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Lock"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Lock" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "screen" on: 1 isValueObj: false 
 -- origin: BasicIO origin:isValueObj: false 
 rpushg screen$36 1
 -- $ObjectInvocation_Unary:getAdr: "Lock" >ATd.off:0 (isPtn):on:1:superAdj:0"Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      r ..."} 
 -- $pattern:getAdr: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;       ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Lock"  ATd: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;        ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- computeAdr:isLast:E:  "Lock" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- rec:  "Lock" E:  "Lock" 
 -- INV:gen:E.loadArgs "Lock" 
 -- $ObjectInvocation_Unary:loadArgs: "Lock" >staticOff:0 "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;    ..."} 
 -- $pattern:loadArgs: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;     ..."} 
 -- ptn:loadArgs:E "Lock" 
 -- {(ObjectInvocation_Unary; (name: "Lock"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Lock" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Lock" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Lock" >rec:"Lock" ATd:"pattern" E:"Lock" E.ATd:"Lock" unique:"False" 
 -- OI:invoke: "Lock" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- OI:invoke:B: "Lock" E: "Lock"  rec: "Lock"  useRtnV: false "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var intege ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Lock 
 -- $pattern:invoke: "Lock: {   dummy: var integer;   %Public;   M: var integer;   init: ;      M := 0;   get: ;      res: var integer;      loop: obj ;         disable;       ..."} 
 -- ptn:invoke: "Lock" E: "Lock" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 invoke Lock 37 2 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Lock :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Lock":rec:Lock 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "screen" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 37 
 -- Items:GenClass: Lock descNo: 37 isValue: false 
 -- Items:GenClass: Lock descNo: 21 isValue: false 

 CLASS Lock 37 1 BasicIO 34
 -- Store itemArgs: dummy: var integer{%Public;M: var integer;init: ;   M := 0;get: ;   res: var integer;   loop: obj ;      disable;      res := 17;      res := M.cmpAndSwap( ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=37 vDescInx=37 vdtTop: 1 
 mvStack 
 -- $var:gen: "dummy: var integer"  
 -- DI:gen: "dummy: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  dummy 
 -- $Property:gen: "%Public"  
 -- $var:gen: "M: var integer"  
 -- DI:gen: "M: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  M 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 -- pushReturn:  "Lock" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 38 
 -- Items:GenClass: Dimensions descNo: 38 isValue: false 
 -- Items:GenClass: Dimensions descNo: 21 isValue: false 

 CLASS Dimensions 38 1 LIB 33
 -- Store itemArgs: %domain_boundary{%public;Dimension: ;   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=38 vDescInx=38 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%domain_boundary"  
 -- $Property:gen: "%public"  
 -- $ModuleItem:gen: "--Acceleration{" } 
 -- $ModuleItem:gen: "--AmountOfSubstance{" } 
 -- $ModuleItem:gen: "--AngularAcceleration{" } 
 -- $ModuleItem:gen: "--Area{" } 
 -- ModuleItem:gen Area 
 -- $obj:gen: "Area: obj Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Public; ..."} 
 -- $ObjectGenerator:gen: "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Publi ..."} 
 -- OG:gen: "Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Public;      thisUn ...}" 
 pushThis 
 -- before objTmpStack:add:  66   "Area" 
 invoke Area 66 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ModuleItem:gen: "--Currency{" } 
 -- $ModuleItem:gen: "--Density{" } 
 -- $ModuleItem:gen: "--ElectricCurrent{" } 
 -- $ModuleItem:gen: "--ElectricFrequency{" } 
 -- $ModuleItem:gen: "--ElectricPower{" } 
 -- $ModuleItem:gen: "--ElectricVoltage{" } 
 -- $ModuleItem:gen: "--Energy{" } 
 -- $ModuleItem:gen: "--Force{" } 
 -- $ModuleItem:gen: "--Length{" } 
 -- ModuleItem:gen Length 
 -- $obj:gen: "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit:: Met ..."} 
 -- $ObjectGenerator:gen: "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit:: Met ..."} 
 -- OG:gen: "Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit:: Meter;      argUn ...}" 
 pushThis 
 -- before objTmpStack:add:  72   "Length" 
 invoke Length 72 3 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ModuleItem:gen: "--LuminousIntensity{" } 
 -- $ModuleItem:gen: "--MagneticFluxDensity{" } 
 -- $ModuleItem:gen: "--Mass{" } 
 -- $ModuleItem:gen: "--MassFlowRate{" } 
 -- $ModuleItem:gen: "--MeterPowerN{" } 
 -- $ModuleItem:gen: "--RadioNuclide{" } 
 -- $ModuleItem:gen: "--Temperature{" } 
 -- ModuleItem:gen Temperature 
 -- $obj:gen: "Temperature: obj Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      from ..."} 
 -- $ObjectGenerator:gen: "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      fromPrima ..."} 
 -- OG:gen: "Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      fromPrimary:: ;         ...}" 
 pushThis 
 -- before objTmpStack:add:  82   "Temperature" 
 invoke Temperature 82 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ModuleItem:gen: "--ThermodynamicTemperature{" } 
 -- $ModuleItem:gen: "--Time{" } 
 -- ModuleItem:gen Time 
 -- $obj:gen: "Time: obj Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      toPrimar ..."} 
 -- $ObjectGenerator:gen: "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      toPrim ..."} 
 -- OG:gen: "Dimension{   %dimension "T";   %Public;   PrimaryUnit:: Second;   Second: Unit;      %unit "s", 1;      %public;      thisUnit:: Second;      toPrimary:: ;        ...}" 
 pushThis 
 -- before objTmpStack:add:  83   "Time" 
 invoke Time 83 5 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ModuleItem:gen: "--Velocity{" } 
 -- ModuleItem:gen Velocity 
 -- $obj:gen: "Velocity: obj Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit "Mp ...} 
 -- $ObjectGenerator:gen: "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit "MpS" ..."} 
 -- OG:gen: "Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit "MpS", "m*s^-1", "m ..."}" 
 pushThis 
 -- before objTmpStack:add:  90   "Velocity" 
 invoke Velocity 90 6 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ModuleItem:gen: "--Volume{" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%domain_boundary" 
 -- $Property:gen: "%domain_boundary"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Dimensions" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:6 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 39 
 -- Items:GenClass: Dimension descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Dimension 39 1 Dimensions 38
 -- Store itemArgs: %dimension "-top-"{%public;PrimaryUnit:< Unit;Unit: Value;   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUni ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=39 vDescInx=39 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%dimension "-top-""  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "PrimaryUnit:< Unit"  
 -- $pattern:gen: "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)" } 
 -- $pattern:gen: "MultArgL:< Unit"  
 -- $pattern:gen: "MultArgR:< Unit"  
 -- $pattern:gen: "MultRes:< Unit"  
 -- $pattern:gen: "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude" } 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "-top-"" 
 -- $Property:gen: "%dimension "-top-""  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 -- genclass:stmt: "inner(Dimension)" 
 -- $ObjectGenerator:gen: "inner(Dimension)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(Dimension)" 
 -- OG:before:super.gen: "inner(Dimension)" 
 -- $Invocation:gen: "inner(Dimension)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(Dimension)" 
 -- isConstant: "Invocation" "inner(Dimension)" 
 -- needorigin: "inner(Dimension)" 
 -- needOrigin:E: "inner(Dimension)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(Dimension)" 
 -- computeAdr:superAdj: 0 "inner(Dimension)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(Dimension)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(Dimension)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(Dimension)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(Dimension)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(Dimension)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 -- computeAdr:isLast:E:  "inner(Dimension)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:- 
 -- rec:  "inner(Dimension)" E:  "inner(Dimension)" 
 -- INV:gen:E.loadArgs "inner(Dimension)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(Dimension)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"Dimension"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(Dimension)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(Dimension)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Dimension)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inne ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(Dimension)" >rec:"inner(Dimension)" ATd:"pattern" E:"inner(Dimension)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(Dimension)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- OI:invoke:B: "inner(Dimension)" E: "inner(Dimension)"  rec: "inner(Dimension)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(Dimension)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(Dimension)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  8
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 -- 
 -- OI:invoke:C: inner(Dimension) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Dimension)":rec:inner(Dimension) 
 L2:
 -- pushReturn:  "Dimension" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=8 descInx=39 vDescInx=0 vdtTop: 8 
 -- vdtAdd: inx=2 descInx=39 vDescInx=44 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=39 vDescInx=63 vdtTop: 8 
 -- vdtAdd: inx=4 descInx=39 vDescInx=45 vdtTop: 8 
 -- vdtAdd: inx=5 descInx=39 vDescInx=46 vdtTop: 8 
 -- vdtAdd: inx=6 descInx=39 vDescInx=47 vdtTop: 8 
 -- vdtAdd: inx=7 descInx=39 vDescInx=64 vdtTop: 8 

 CLASS PrimaryUnit#44 44 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 44  newDescNo:  39 

 CLASS MultArgL#45 45 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 45  newDescNo:  39 

 CLASS MultArgR#46 46 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 46  newDescNo:  39 

 CLASS MultRes#47 47 1 Dimension$39 39 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 40 
 invoke Unit 40 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 47  newDescNo:  39 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 40 
 -- Items:GenClass: Unit descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Unit 40 0 Dimension 39 isValueObj
 -- Store itemArgs: %unit "U", 1{%public;magnitude: var Float;thisUnit:< Unit;argUnit:< Unit;resUnit:< Unit;+?  : ;   in V: var thisUnit;   out R: var thisUnit;   R.magnitude  ...} 
 -- vdtAdd: inx=1 descInx=40 vDescInx=40 vdtTop: 1 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
DO:
 L1:
 -- genclass:stmt: "%unit "U", 1" 
 -- $Property:gen: "%unit "U", 1"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Unit" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=40 vDescInx=49 vdtTop: 7 
 -- vdtAdd: inx=8 descInx=40 vDescInx=50 vdtTop: 8 
 -- vdtAdd: inx=9 descInx=40 vDescInx=51 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 48 
 -- Items:GenClass: float descNo: 48 isValue: true 
 -- Items:GenClass: float descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS float 48 0 BETA 2 isValueObj
 -- Store itemArgs: %globals{%basic 9;_thisBasicValue: var Float;%public;+  : ;   %basic 109;   in V: var float;   out R: var float;-  : ;   %basic 110;   in V: var float;   o ...} 
 -- vdtAdd: inx=1 descInx=48 vDescInx=48 vdtTop: 1 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 9"  
 -- $var:gen: "_thisBasicValue: var Float"  
 -- DI:gen: "_thisBasicValue: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  _thisBasicValue 
 -- $Property:gen: "%public"  
DO:
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 9" 
 -- $Property:gen: "%basic 9"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "float" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 49 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 49 1 Unit 40
 -- Store itemArgs: out base: var PrimaryUnit{inner(toPrimary)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=49 vDescInx=49 vdtTop: 1 
 mvStack 
 -- $var:gen: "out base: var PrimaryUnit"  
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- $ObjectGenerator:gen: "PrimaryUnit" >OGid:"Unit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "PrimaryUnit" 
 -- OG:before:super.gen: "PrimaryUnit" 
 -- $Invocation:gen: "PrimaryUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "PrimaryUnit" 
 -- isConstant: "Invocation" "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "PrimaryUnit" E:  "PrimaryUnit" 
 -- INV:gen:E.loadArgs "PrimaryUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "PrimaryUnit" >staticOff:0 "PrimaryUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "PrimaryUnit:< Unit" >E:"PrimaryUnit":descNo:0 
 -- ptn:loadArgs:E "PrimaryUnit" 
 -- {(ObjectInvocation_Unary; (name: "PrimaryUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "PrimaryUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit" 
 -- $ObjectInvocation_Unary:invoke: "PrimaryUnit" >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:"PrimaryUnit" unique:"False" 
 -- OI:invoke: "PrimaryUnit" 
 -- 
 -- OI:invoke:B: "PrimaryUnit" E: "PrimaryUnit"  rec: "PrimaryUnit"  useRtnV: false "PrimaryUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: "PrimaryUnit:< Unit" E: "PrimaryUnit" useRTNv: "False" 
 -- ptn:invoke: "PrimaryUnit" E: "PrimaryUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 4 adr:none 
 -- isStatic: true rec: "PrimaryUnit" 
 invokeVal  PrimaryUnit 40 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(toPrimary)" 
 -- $ObjectGenerator:gen: "inner(toPrimary)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(toPrimary)" 
 -- OG:before:super.gen: "inner(toPrimary)" 
 -- $Invocation:gen: "inner(toPrimary)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(toPrimary)" 
 -- isConstant: "Invocation" "inner(toPrimary)" 
 -- needorigin: "inner(toPrimary)" 
 -- needOrigin:E: "inner(toPrimary)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(toPrimary)" 
 -- computeAdr:superAdj: 0 "inner(toPrimary)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(toPrimary)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(toPrimary)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(toPrimary)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(toPrimary)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(toPrimary)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- computeAdr:isLast:E:  "inner(toPrimary)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:- 
 -- rec:  "inner(toPrimary)" E:  "inner(toPrimary)" 
 -- INV:gen:E.loadArgs "inner(toPrimary)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(toPrimary)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"toPrimary"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(toPrimary)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(toPrimary)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(toPrimary)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inne ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(toPrimary)" >rec:"inner(toPrimary)" ATd:"pattern" E:"inner(toPrimary)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(toPrimary)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- OI:invoke:B: "inner(toPrimary)" E: "inner(toPrimary)"  rec: "inner(toPrimary)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(toPrimary)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(toPrimary)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 -- 
 -- OI:invoke:C: inner(toPrimary) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(toPrimary)":rec:inner(toPrimary) 
 L2:
 -- pushReturn:  "toPrimary" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- vdtAdd: inx=2 descInx=49 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 50 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 50 1 Unit 40
 -- Store itemArgs: in base: var PrimaryUnit{inner(fromPrimary)} 
 -- in base: var PrimaryUnit true 0 
 -- DI:store: "base" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  base 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=50 vDescInx=50 vdtTop: 1 
 mvStack 
 -- $var:gen: "in base: var PrimaryUnit"  
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(fromPrimary)" 
 -- $ObjectGenerator:gen: "inner(fromPrimary)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(fromPrimary)" 
 -- OG:before:super.gen: "inner(fromPrimary)" 
 -- $Invocation:gen: "inner(fromPrimary)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(fromPrimary)" 
 -- isConstant: "Invocation" "inner(fromPrimary)" 
 -- needorigin: "inner(fromPrimary)" 
 -- needOrigin:E: "inner(fromPrimary)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(fromPrimary)" 
 -- computeAdr:superAdj: 0 "inner(fromPrimary)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(fromPrimary)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(fromPrimary)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(fromPrimary)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(fromPrimary)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitV ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(fromPrimary)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- computeAdr:isLast:E:  "inner(fromPrimary)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:- 
 -- rec:  "inner(fromPrimary)" E:  "inner(fromPrimary)" 
 -- INV:gen:E.loadArgs "inner(fromPrimary)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(fromPrimary)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"fromPrimary"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(fromPrimary)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(fromPrimary)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(fromPrimary)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"in ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(fromPrimary)" >rec:"inner(fromPrimary)" ATd:"pattern" E:"inner(fromPrimary)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(fromPrimary)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- OI:invoke:B: "inner(fromPrimary)" E: "inner(fromPrimary)"  rec: "inner(fromPrimary)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(fromPrimary)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(fromPrimary)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 -- 
 -- OI:invoke:C: inner(fromPrimary) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(fromPrimary)":rec:inner(fromPrimary) 
 L2:
 -- pushReturn:  "fromPrimary" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- vdtAdd: inx=2 descInx=50 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 51 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 51 1 Unit 40
 -- Store itemArgs: "Unit:".print{inner(print);put(':');putFloat(magnitude)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=51 vDescInx=51 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: ""Unit:".print" 
 -- $ObjectGenerator:gen: ""Unit:".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Unit:".print" 
 -- OG:before:super.gen: ""Unit:".print" 
 -- $Invocation:gen: ""Unit:".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Unit:".print" 
 -- isConstant: "Invocation" ""Unit:".print" 
 -- needorigin: ""Unit:".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Unit:"" E:  ""Unit:"" 
 -- INV:gen:E.loadArgs ""Unit:"" 
 -- $String::loadArgs: ""Unit:""  
 -- INV:gen:after:E.loadArgs ""Unit:"" 
 -- OIadr: 
 -- $String::invoke: ""Unit:""  
 pushText "Unit:"
 -- IV:gen:checkTail: ""Unit:".print" E: ""Unit:"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Unit:"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Unit:""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "inner(print)" 
 -- $ObjectGenerator:gen: "inner(print)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(print)" 
 -- OG:before:super.gen: "inner(print)" 
 -- $Invocation:gen: "inner(print)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(print)" 
 -- isConstant: "Invocation" "inner(print)" 
 -- needorigin: "inner(print)" 
 -- needOrigin:E: "inner(print)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(print)" 
 -- computeAdr:superAdj: 0 "inner(print)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(print)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(print)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(print)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(print)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(print)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- computeAdr:isLast:E:  "inner(print)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- rec:  "inner(print)" E:  "inner(print)" 
 -- INV:gen:E.loadArgs "inner(print)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(print)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"print"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(print)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(print)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(print)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(pr ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(print)" >rec:"inner(print)" ATd:"pattern" E:"inner(print)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(print)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:B: "inner(print)" E: "inner(print)"  rec: "inner(print)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(print)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(print)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- 
 -- OI:invoke:C: inner(print) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- genclass:stmt: "put(':')" 
 -- $ObjectGenerator:gen: "put(':')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put(':')" 
 -- OG:before:super.gen: "put(':')" 
 -- $Invocation:gen: "put(':')" >useRtnV:"False"superAdj: 0 descNo: 54 
 -- INV:gen: "put(':')" 
 -- isConstant: "Invocation" "put(':')" 
 -- needorigin: "put(':')" 
 -- needOrigin:E: "put(':')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(':')" E:  "put(':')" 
 -- INV:gen:E.loadArgs "put(':')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(':')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"':'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put(':')":descNo:54} 
 -- ptn:loadArgs:E "put(':')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: ':'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put(':')" 
 -- E: "ObjectGenerator" ':' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put(':')" "ObjectInvocation_KeyWord" ActArg:  "':'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(':')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "':'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "':'" 
 -- OG:before:super.gen: "':'" 
 -- $Invocation:gen: "':'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "':'" 
 -- isConstant: "Invocation" "':'" 
 -- needorigin: "':'" 
 -- needOrigin:E: "':'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "':'" E:  "':'" 
 -- INV:gen:E.loadArgs "':'" 
 -- $Char::loadArgs: "':'"  
 -- INV:gen:after:E.loadArgs "':'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "':'" 
 -- $Char::invoke: "':'"  
 pushc 58
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "':'" :isBasicVal: true 
 -- case:B: ':' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put(':')" 
 -- INV:gen:after:E.loadArgs "put(':')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(':')" 
 -- $ObjectInvocation_KeyWord:invoke: "put(':')" >rec:"put(':')" ATd:"pattern" E:"put(':')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put(':')" 
 -- 
 -- OI:invoke:B: "put(':')" E: "put(':')"  rec: "put(':')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put(':')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put(':')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(':') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "putFloat(magnitude)" 
 -- $ObjectGenerator:gen: "putFloat(magnitude)" >OGid:"putFloat" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "putFloat(magnitude)" 
 -- OG:before:super.gen: "putFloat(magnitude)" 
 -- $Invocation:gen: "putFloat(magnitude)" >useRtnV:"False"superAdj: 0 descNo: 56 
 -- INV:gen: "putFloat(magnitude)" 
 -- isConstant: "Invocation" "putFloat(magnitude)" 
 -- needorigin: "putFloat(magnitude)" 
 -- needOrigin:E: "putFloat(magnitude)"  E.ATd: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" 
 -- doNeedOrigin:Ex: "putFloat(magnitude)" 
 -- computeAdr:superAdj: 0 "putFloat(magnitude)" 
 -- computeAdr: 1 :rec: "none"  E: "putFloat(magnitude)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "putFloat(magnitude)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "putFloat(magnitude)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "putFloat(magnitude)" >ATd.off:0 (isPtn):on:4:superAdj:0"putFloat: {   %basic 142;   in X: var Float;   out V: var integer":Adr:off:0 siz ...} 
 -- $pattern:getAdr: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "putFloat(magnitude)"  ATd: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- computeAdr:isLast:E:  "putFloat(magnitude)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:- 
 -- rec:  "putFloat(magnitude)" E:  "putFloat(magnitude)" 
 -- INV:gen:E.loadArgs "putFloat(magnitude)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "putFloat(magnitude)" >staticOff:0 "putFloat: {   %basic 142;   in X: var Float;   out V: var integer" superAdj:0arg:"magnitude"} 
 -- $pattern:loadArgs: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer" >E:"putFloat(magnitude)":descNo:56} 
 -- ptn:loadArgs:E "putFloat(magnitude)" 
 -- {(ObjectInvocation_KeyWord; (name: "putFloat"); (Arguments;  (name: "putFloat");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "ma ..."} 
 -- args: "putFloat(magnitude)" 
 -- E: "ObjectGenerator" magnitude 
 -- E.arg: "var" in X: var Float 
 -- NonVirt: "putFloat(magnitude)" "ObjectInvocation_KeyWord" ActArg:  "magnitude" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "putFloat(magnitude)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "magnitude" 
 -- OG:before:super.gen: "magnitude" 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: Unit origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg print$51 1
 rswap 0
 rdouble 0
 pushg 2 print$51
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 pushg 3 print$51
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- formalArg:isPtn: "in X: var Float" :isBasicVal: true :valueObj: true 
 -- :actArg: "magnitude" :isBasicVal: true 
 -- case:B: magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "putFloat(magnitude)" 
 -- INV:gen:after:E.loadArgs "putFloat(magnitude)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "putFloat(magnitude)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"p ..." 
 -- $ObjectInvocation_KeyWord:invoke: "putFloat(magnitude)" >rec:"putFloat(magnitude)" ATd:"pattern" E:"putFloat(magnitude)" E.ATd:"putFloat" unique:"False" 
 -- OI:invoke: "putFloat(magnitude)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- OI:invoke:B: "putFloat(magnitude)" E: "putFloat(magnitude)"  rec: "putFloat(magnitude)"  useRtnV: false "putFloat: {   %basic 142;   in X: var Float;   out V: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern putFloat 
 -- $pattern:invoke: "putFloat: {   %basic 142;   in X: var Float;   out V: var integer" E: "putFloat(magnitude)" useRTNv: "False"} 
 -- ptn:invoke: "putFloat" E: "putFloat(magnitude)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magn ... 
 %printf_prim 142
 vpop
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: putFloat(magnitude) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"putFloat(magnitude)":rec:putFloat(magnitude) 
 L2:
 -- pushReturn:  "print" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=51 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 52 
 -- Items:GenClass: print descNo: 52 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 52 1 String 10
 -- Store itemArgs: gogo: {   "gogo\n".print;for(1):to(length):repeat;   put(get[inx]);} 
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=52 vDescInx=52 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- $ObjectGenerator:gen: "for(1):to(length):repeat{   put(get[inx]);" >OGid:"for:to:repeat$55" IS.isempty! staticOff=0 descNo=55 superAdj=0} 
 -- OG:gen: "for(1):to(length):repeat{   put(get[inx]);}" 
 pushThis 
 -- before objTmpStack:add:  55   "for:to:repeat$55" 
 invoke for:to:repeat$55 55 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "print" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 28 
 -- Items:GenClass: for:to:repeat descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat 28 0 BETA 2
 -- Store itemArgs: %OSDvisibility skipInternal{%globals inSub;inx: var integer;inx := first;_doIt: do ;   if (inx <= last) :then ;      repeat;      inx := inx + 1;      rest ...} 
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=28 vDescInx=28 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%OSDvisibility skipInternal" 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- genclass:stmt: "%globals inSub" 
 -- $Property:gen: "%globals inSub"  
 -- genclass:stmt: "inx := first" 
 -- $Assign:gen: "inx := first"  
 -- assign: "inx := first" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:0:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := first" right.label: "ObjectGenerator" "first" 
 -- $ObjectGenerator:gen: "first" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "first" 
 -- OG:before:super.gen: "first" 
 -- $Invocation:gen: "first" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "first" 
 -- isConstant: "Invocation" "first" 
 -- notConst: first first: var integer 
 -- needorigin: "first" 
 -- needOrigin:E: "first"  E.ATd: "first: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "first" 
 -- computeAdr: 1 :rec: "none"  E: "first" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "first"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "first" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "first" >ATd.off:1:on:0:superAdj:0"first: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "first: var integer" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: integer 
 -- before:floatTest:  "first: var integer" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- computeAdr:isLast:E:  "first" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- rec:  "first" E:  "first" 
 -- INV:gen:E.loadArgs "first" 
 -- $ObjectInvocation_Unary:loadArgs: "first" >staticOff:0 "first: var integer" superAdj:0 
 -- $var:loadArgs: "first: var integer" >E:"first" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "first" 
 -- {(ObjectInvocation_Unary; (name: "first"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "first" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "first" :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:- 
 -- $ObjectInvocation_Unary:invoke: "first" >rec:"first" ATd:"var" isValueObj E:"first" E.ATd:"first" unique:"False" 
 -- OI:invoke: "first" 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- OI:invoke:B: "first" E: "first"  rec: "first"  useRtnV: true "first: var integer" 
 -- OI:invoke:before:ATdx.invoke: var first 
 -- $var:invoke: "first: var integer" E: "first">newOff:1 useRTNv: "True" 
 -- DI:invoke: "first: var integer" 
 -- load: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- isCompositeValueObj: false E: "first" "first: var integer" true 
 -- E.ATd.isValueObj: false rec: "first" 
 pushg 1 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- 
 -- OI:invoke:C: first :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"first":rec:first 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "first" 
 -- isArgOfAssignI2IwithUniValArg "inx := first" arg: "first" ObjectGenerator 
 -- arg.super.arg: "first" ObjectInvocation_Unary 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 -- $do:gen: "_doIt: do {   if (inx <= last) :then ;      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx" } 
 -- $ObjectGenerator:gen: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx" >OGid:"_doIt" singular! staticOff=0 descN ...} 
 -- OG:gen: "if (inx <= last) :then {      repeat;      inx := inx + 1;      restart(_doIt);   :else ;      inx := inx}" 
 pushThis 
 -- before objTmpStack:add:  57   "_doIt" 
 invoke _doIt 57 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "for:to:repeat" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=28 vDescInx=29 vdtTop: 2 

 CLASS repeat#29 29 0 for:to:repeat$28 28 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 1 21 
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdt:a:dNo: 29  newDescNo:  28 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 57 
 -- Items:GenClass: _doIt descNo: 57 isValue: false 
 -- Items:GenClass: _doIt descNo: 21 isValue: false 

 CLASS _doIt 57 1 for:to:repeat 28
 -- Store itemArgs: if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=57 vDescInx=57 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $ObjectGenerator:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 super ...} 
 -- OG:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OG:before:super.gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $Invocation:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- isConstant: "Invocation" "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- needorigin: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- needOrigin:E: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OS ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" E:  "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_do ...}" 
 -- INV:gen:E.loadArgs "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $IfThenElse:loadArgs: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" } 
 -- INV:gen:after:E.loadArgs "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx}" 
 -- $IfThenElse:invoke: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" } 
 -- $IfThenElse:gen: "if (inx <= last) :then {   repeat;   inx := inx + 1;   restart(_doIt);:else ;   inx := inx" } 
 -- $ObjectGenerator:gen: "(inx <= last)" >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(inx <= last)" 
 -- OG:before:super.gen: "(inx <= last)" 
 -- $Invocation:gen: "(inx <= last)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(inx <= last)" 
 -- isConstant: "Invocation" "(inx <= last)" 
 -- needorigin: "(inx <= last)" 
 -- needOrigin:E: "(inx <= last)"  E.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- doNeedOrigin:Ex: "(inx <= last)" 
 -- computeAdr:superAdj: 0 "(inx <= last)" 
 -- computeAdr: 1 :rec: "none"  E: "(inx <= last)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(inx <= last)"  
 -- $BracketedExp:loadOrigin: "(inx <= last)"  
 -- computeAdr:superAdj: 0 "inx <= last" 
 -- computeAdr: 1 :rec: "none"  E: "inx <= last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx <= last"  
 -- $BinOp:loadOrigin: "inx <= last"  
 -- BinaryExp:loadOrigin:empty: "inx <= last" superAdj: 0 
 -- $BinOp:getAdr: "inx <= last"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx <= last"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx <= last" 
 -- BE:loadOrigin:E: inx <= last 
 -- $BinOp:getAdr: "inx <= last"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx <= last"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx <= last" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx <= last" E:  "inx <= last" 
 -- INV:gen:E.loadArgs "inx <= last" 
 -- $BinOp:loadArgs: "inx <= last"  
 -- BinaryExp:loadArgs: "inx <= last" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "inx <= last" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" >E:"<= last":descNo:58} 
 -- ptn:loadArgs:E "<= last" 
 -- {(ObjectInvocation_Binary; (name: "<="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "last");     (Arguments)));   (Items descNo:  ...} 
 -- args: "last" 
 -- E: "ObjectGenerator" last 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "<= last" "ObjectInvocation_Binary" ActArg:  "last" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= last"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "last" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "last" 
 -- OG:before:super.gen: "last" 
 -- $Invocation:gen: "last" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "last" 
 -- isConstant: "Invocation" "last" 
 -- notConst: last last: var integer 
 -- needorigin: "last" 
 -- needOrigin:E: "last"  E.ATd: "last: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "last" 
 -- computeAdr: 1 :rec: "none"  E: "last" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "last"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "last" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: "last" >ATd.off:2:on:1:superAdj:0"last: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $var:getAdr: "last: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: integer 
 -- before:floatTest:  "last: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "last"  ATd: "last: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- computeAdr:isLast:E:  "last" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- rec:  "last" E:  "last" 
 -- INV:gen:E.loadArgs "last" 
 -- $ObjectInvocation_Unary:loadArgs: "last" >staticOff:0 "last: var integer" superAdj:0 
 -- $var:loadArgs: "last: var integer" >E:"last" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "last" 
 -- {(ObjectInvocation_Unary; (name: "last"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "last" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "last" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:- 
 -- $ObjectInvocation_Unary:invoke: "last" >rec:"last" ATd:"var" isValueObj E:"last" E.ATd:"last" unique:"False" 
 -- OI:invoke: "last" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- OI:invoke:B: "last" E: "last"  rec: "last"  useRtnV: true "last: var integer" 
 -- OI:invoke:before:ATdx.invoke: var last 
 -- $var:invoke: "last: var integer" E: "last">newOff:2 useRTNv: "True" 
 -- DI:invoke: "last: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- isCompositeValueObj: false E: "last" "last: var integer" true 
 -- E.ATd.isValueObj: false rec: "last" 
 pushg 2 for:to:repeat$28
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- 
 -- OI:invoke:C: last :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"last":rec:last 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= last" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx <= last" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx <= last" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx <= last"  
 -- BinaryExp:invoke: "inx" rec: "inx <= last" 
 -- M: "<= last" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "<= last" >rec:"inx" ATd:"pattern" E:"<= last" E.ATd:"<=  " unique:"False" 
 -- OI:invoke: "<= last" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "<= last" E: "<= last"  rec: "inx"  useRtnV: true "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- $pattern:invoke: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" E: "<= last" useRTNv: "True"} 
 -- ptn:invoke: "<=  " E: "<= last" ptnKind: 1 useRtnV: true 
 -- rec: "inx" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "inx: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= last":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <= last :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "repeat{   inx := inx + 1;   restart(_doIt)" >OGid:"$59" singular! staticOff=0 descNo=59 superAdj=0} 
 -- OG:gen: "repeat{   inx := inx + 1;   restart(_doIt)}" 
 pushThis 
 -- before objTmpStack:add:  59   "$59" 
 invoke $59 59 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "inx := inx" >OGid:"$62" singular! staticOff=0 descNo=62 superAdj=0 
 -- OG:gen: "inx := inx" 
 pushThis 
 -- before objTmpStack:add:  62   "$62" 
 invoke $62 62 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "_doIt" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 59 
 -- Items:GenClass: $59 descNo: 59 isValue: false 
 -- Items:GenClass: $59 descNo: 21 isValue: false 

 CLASS $59 59 1 _doIt 57
 -- Store itemArgs: repeat{inx := inx + 1;restart(_doIt)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=59 vDescInx=59 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "repeat" 
 -- $ObjectGenerator:gen: "repeat" >OGid:"Object" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "repeat" 
 -- OG:before:super.gen: "repeat" 
 -- $Invocation:gen: "repeat" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "repeat" 
 -- isConstant: "Invocation" "repeat" 
 -- needorigin: "repeat" 
 -- needOrigin:E: "repeat"  E.ATd: "repeat:< object" 
 -- doNeedOrigin:Ex: "repeat" 
 -- computeAdr:superAdj: 0 "repeat" 
 -- computeAdr: 1 :rec: "none"  E: "repeat" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "repeat"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "repeat" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: "repeat" >ATd.off:0 (isPtn):on:2:superAdj:0"repeat:< object":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $pattern:getAdr: "repeat:< object"  
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "repeat"  ATd: "repeat:< object" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- computeAdr:isLast:E:  "repeat" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- rec:  "repeat" E:  "repeat" 
 -- INV:gen:E.loadArgs "repeat" 
 -- $ObjectInvocation_Unary:loadArgs: "repeat" >staticOff:0 "repeat:< object" superAdj:0 
 -- $pattern:loadArgs: "repeat:< object" >E:"repeat":descNo:0 
 -- ptn:loadArgs:E "repeat" 
 -- {(ObjectInvocation_Unary; (name: "repeat"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "repeat" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "repeat" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:- 
 -- $ObjectInvocation_Unary:invoke: "repeat" >rec:"repeat" ATd:"pattern" E:"repeat" E.ATd:"repeat" unique:"False" 
 -- OI:invoke: "repeat" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- OI:invoke:B: "repeat" E: "repeat"  rec: "repeat"  useRtnV: false "repeat:< object" 
 -- OI:invoke:before:ATdx.invoke: pattern repeat 
 -- $pattern:invoke: "repeat:< object" E: "repeat" useRTNv: "False" 
 -- ptn:invoke: "repeat" E: "repeat" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- isPtn 
 -- isStatic: false rec: "repeat" 
 invokev 2 0 repeat$29$29 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: repeat :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"repeat":rec:repeat 
 -- genclass:stmt: "inx := inx + 1" 
 -- $Assign:gen: "inx := inx + 1"  
 -- assign: "inx := inx + 1" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := inx + 1" right.label: "ObjectGenerator" "inx + 1" 
 -- $ObjectGenerator:gen: "inx + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx + 1" 
 -- OG:before:super.gen: "inx + 1" 
 -- $Invocation:gen: "inx + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx + 1" 
 -- isConstant: "Invocation" "inx + 1" 
 -- needorigin: "inx + 1" 
 -- needOrigin:E: "inx + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "inx + 1" 
 -- computeAdr:superAdj: 0 "inx + 1" 
 -- computeAdr: 1 :rec: "none"  E: "inx + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx + 1"  
 -- $BinOp:loadOrigin: "inx + 1"  
 -- BinaryExp:loadOrigin:empty: "inx + 1" superAdj: 0 
 -- $BinOp:getAdr: "inx + 1"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx + 1" E:  "inx + 1" 
 -- INV:gen:E.loadArgs "inx + 1" 
 -- $BinOp:loadArgs: "inx + 1"  
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$59" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $59$59 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "inx + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:60} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx + 1"  
 -- BinaryExp:invoke: "inx" rec: "inx + 1" 
 -- M: "+ 1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"inx" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "inx"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "inx + 1" 
 -- isArgOfAssignI2IwithUniValArg "inx := inx + 1" arg: "inx + 1" ObjectGenerator 
 -- arg.super.arg: "inx + 1" BinOp 
 -- recx:BinaryExp:recx: "inx + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "restart(_doIt)" 
 -- $ObjectGenerator:gen: "restart(_doIt)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(_doIt)" 
 -- OG:before:super.gen: "restart(_doIt)" 
 -- $Invocation:gen: "restart(_doIt)" >useRtnV:"False"superAdj: 0 descNo: 61 
 -- INV:gen: "restart(_doIt)" 
 -- isConstant: "Invocation" "restart(_doIt)" 
 -- needorigin: "restart(_doIt)" 
 -- needOrigin:E: "restart(_doIt)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(_doIt)" 
 -- computeAdr:superAdj: 0 "restart(_doIt)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(_doIt)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(_doIt)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(_doIt)" >on:3 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(_doIt)" >ATd.off:0 (isPtn):on:3:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFl ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "restart(_doIt)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- computeAdr:isLast:E:  "restart(_doIt)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:- 
 -- rec:  "restart(_doIt)" E:  "restart(_doIt)" 
 -- INV:gen:E.loadArgs "restart(_doIt)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(_doIt)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"_doIt"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(_doIt)":descNo:61} 
 -- INV:gen:after:E.loadArgs "restart(_doIt)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(_doIt)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restar ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(_doIt)" >rec:"restart(_doIt)" ATd:"pattern" E:"restart(_doIt)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(_doIt)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- OI:invoke:B: "restart(_doIt)" E: "restart(_doIt)"  rec: "restart(_doIt)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(_doIt)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(_doIt)" ptnKind: 0 useRtnV: false 
 break  1 1 57 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 -- 
 -- OI:invoke:C: restart(_doIt) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(_doIt)":rec:restart(_doIt) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 62 
 -- Items:GenClass: $62 descNo: 62 isValue: false 
 -- Items:GenClass: $62 descNo: 21 isValue: false 

 CLASS $62 62 1 _doIt 57
 -- Store itemArgs: inx := inx 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=62 vDescInx=62 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inx := inx" 
 -- $Assign:gen: "inx := inx"  
 -- assign: "inx := inx" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$62" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := inx" right.label: "ObjectGenerator" "inx" 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$62" on: 2 isValueObj: false 
 -- origin: _doIt origin:isValueObj: false 
 rpushg $62$62 1
 -- items:goOrigin:encOG: "_doIt" on: 1 isValueObj: false 
 -- origin: for:to:repeat origin:isValueObj: false 
 rpushg _doIt$57 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$28
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "inx" 
 -- isArgOfAssignI2IwithUniValArg "inx := inx" arg: "inx" ObjectGenerator 
 -- arg.super.arg: "inx" ObjectInvocation_Unary 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg for:to:repeat$28 3
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 20 
 -- Items:GenClass: if:then descNo: 20 isValue: false 
 -- Items:GenClass: if:then descNo: 21 isValue: false 

 CLASS if:then 20 0 BETA 2
 -- Store itemArgs: %OSDvisibility skipInternal{%basic 100;%globals inSub} 
 -- cond: var boolean true 4 
 -- DI:store: "cond" 
 pushThis 
 storeg Boolean$108 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=20 vDescInx=20 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%basic 100"  
 -- $Property:gen: "%globals inSub"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%OSDvisibility skipInternal" 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- genclass:stmt: "%basic 100" 
 -- $Property:gen: "%basic 100"  
 -- genclass:stmt: "%globals inSub" 
 -- $Property:gen: "%globals inSub"  
 L2:
 -- pushReturn:  "if:then" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:1 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=20 vDescInx=22 vdtTop: 2 

 CLASS thenPart#22 22 0 if:then$20 20 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 1 21 
 invoke Object 21 0 0
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:1 objSize:3 isIndexed:0
 -- vdt:a:dNo: 22  newDescNo:  20 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 53 
 -- Items:GenClass: repeat$53 descNo: 53 isValue: false 
 -- Items:GenClass: repeat$53 descNo: 21 isValue: false 

 CLASS repeat$53 53 1 for:to:repeat$55 55
 -- Store itemArgs: put(get[inx]) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=53 vDescInx=53 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "put(get[inx])" 
 -- $ObjectGenerator:gen: "put(get[inx])" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put(get[inx])" 
 -- OG:before:super.gen: "put(get[inx])" 
 -- $Invocation:gen: "put(get[inx])" >useRtnV:"False"superAdj: 0 descNo: 54 
 -- INV:gen: "put(get[inx])" 
 -- isConstant: "Invocation" "put(get[inx])" 
 -- needorigin: "put(get[inx])" 
 -- needOrigin:E: "put(get[inx])"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(get[inx])" E:  "put(get[inx])" 
 -- INV:gen:E.loadArgs "put(get[inx])" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(get[inx])" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"get[inx]"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put(get[inx])":descNo:54} 
 -- ptn:loadArgs:E "put(get[inx])" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_KeyWord;     (name: "get");     ...} 
 -- args: "put(get[inx])" 
 -- E: "ObjectGenerator" get[inx] 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put(get[inx])" "ObjectInvocation_KeyWord" ActArg:  "get[inx]" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(get[inx])"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$53" on: 3 isValueObj: false 
 -- origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- items:goOrigin:encOG: "for:to:repeat$55" on: 2 isValueObj: false 
 -- origin: print origin:isValueObj: false 
 rpushg for:to:repeat$55$55 4
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:3:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$53" on: 1 isValueObj: false 
 -- origin: for:to:repeat$55 origin:isValueObj: false 
 rpushg repeat$53$53 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$55$55
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "get[inx]" :isBasicVal: true 
 -- case:B: get[inx] ObjectGenerator 3 117 117 false false 
 -- end:loadArgs:NonVirt: "put(get[inx])" 
 -- INV:gen:after:E.loadArgs "put(get[inx])" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(get[inx])" 
 -- $ObjectInvocation_KeyWord:invoke: "put(get[inx])" >rec:"put(get[inx])" ATd:"pattern" E:"put(get[inx])" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put(get[inx])" 
 -- 
 -- OI:invoke:B: "put(get[inx])" E: "put(get[inx])"  rec: "put(get[inx])"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put(get[inx])" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put(get[inx])" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(get[inx]) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 54 
 -- Items:GenClass: put descNo: 54 isValue: false 
 -- Items:GenClass: put descNo: 21 isValue: false 

 CLASS put 54 0 BETA 2
 -- Store itemArgs: %globals{%basic 2;in ch: val char} 
 -- in ch: val char true 3 
 -- DI:store: "ch" 
 pushThis 
 storeg char$7 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=54 vDescInx=54 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 2"  
 -- $val:gen: "in ch: val char"  
 -- DI:gen: "in ch: val char" DI:isConst: true :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  ch 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 2" 
 -- $Property:gen: "%basic 2"  
 L2:
 -- pushReturn:  "put" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 55 
 -- Items:GenClass: for:to:repeat$55 descNo: 55 isValue: false 
 -- Items:GenClass: for:to:repeat$55 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$55 55 4 print 52
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(length):repeat{   put(get[inx]);}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(length):repeat{   put(get[inx]);" >staticOff:0 "for(first: var integer):to(last: var integer):repeat{repeat:< object}: ;   % ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(length):repeat{   put(get[inx]);}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" length 
 -- E: "ObjectGenerator" put(get[inx]) 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   put(get[inx]);}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" "ObjectInvocation_KeyWord" ActArg:  "length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   put(get[inx]);}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- $Invocation:gen: "length" >useRtnV:"True"superAdj: 4 descNo: 15 
 -- INV:gen: "length" 
 -- isConstant: "Invocation" "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 4 "length" 
 -- computeAdr: 1 :rec: "none"  E: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length" >on:1 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg print$52 4
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg print$52 1
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:1:superAdj:4"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- PING:String 0 gogo: {      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   } 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:4} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"length" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length" E: "length"  rec: "length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "length" :isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- args:  "repeat:< object" "put(get[inx])" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=55 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(length):repeat{   put(get[inx]);}" 
 -- vdtAdd: inx=2 descInx=55 vDescInx=53 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 56 
 -- Items:GenClass: putFloat descNo: 56 isValue: false 
 -- Items:GenClass: putFloat descNo: 21 isValue: false 

 CLASS putFloat 56 1 BETA 2
 -- Store itemArgs: %basic 142{in X: var Float;out V: var integer} 
 -- in X: var Float true 9 
 -- DI:store: "X" 
 pushThis 
 fstoreg 2 X
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=56 vDescInx=56 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 142"  
 -- $var:gen: "in X: var Float"  
 -- DI:gen: "in X: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  X 
 -- $var:gen: "out V: var integer"  
 -- DI:gen: "out V: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  V 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 142" 
 -- $Property:gen: "%basic 142"  
 L2:
 -- pushReturn:  "putFloat" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 63 
 -- Items:GenClass: symbol descNo: 63 isValue: false 
 -- Items:GenClass: symbol descNo: 21 isValue: false 

 CLASS symbol 63 1 Dimension 39
 -- Store itemArgs: %globals{out T: var StringLib.String;inner(Symbol)} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=63 vDescInx=63 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out T: var StringLib.String"  
 -- DI:gen: "out T: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out T: var StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "inner(Symbol)" 
 -- $ObjectGenerator:gen: "inner(Symbol)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(Symbol)" 
 -- OG:before:super.gen: "inner(Symbol)" 
 -- $Invocation:gen: "inner(Symbol)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(Symbol)" 
 -- isConstant: "Invocation" "inner(Symbol)" 
 -- needorigin: "inner(Symbol)" 
 -- needOrigin:E: "inner(Symbol)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(Symbol)" 
 -- computeAdr:superAdj: 0 "inner(Symbol)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(Symbol)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(Symbol)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(Symbol)" >on:3 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(Symbol)" >ATd.off:0 (isPtn):on:3:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F  ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "inner(Symbol)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- computeAdr:isLast:E:  "inner(Symbol)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:- 
 -- rec:  "inner(Symbol)" E:  "inner(Symbol)" 
 -- INV:gen:E.loadArgs "inner(Symbol)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(Symbol)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"Symbol"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(Symbol)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(Symbol)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(Symbol)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(S ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(Symbol)" >rec:"inner(Symbol)" ATd:"pattern" E:"inner(Symbol)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(Symbol)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- OI:invoke:B: "inner(Symbol)" E: "inner(Symbol)"  rec: "inner(Symbol)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(Symbol)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(Symbol)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 -- 
 -- OI:invoke:C: inner(Symbol) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(Symbol)":rec:inner(Symbol) 
 L2:
 -- pushReturn:  "symbol" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=63 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 64 
 -- Items:GenClass: gMult descNo: 64 isValue: false 
 -- Items:GenClass: gMult descNo: 21 isValue: false 

 CLASS gMult 64 1 Dimension 39
 -- Store itemArgs: in L: var MultArgL{in R: var MultArgR;out U: var MultRes;U.magnitude := L.magnitude * R.magnitude} 
 -- in R: var MultArgR true 0 
 -- DI:store: "R" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: R off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  R 40 3
 L4:
 -- in L: var MultArgL true 0 
 -- DI:store: "L" 
 jmpFalse  L5
 pushThis 
 -- vassign:B: L off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  L 40 1
 L6:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=64 vDescInx=64 vdtTop: 1 
 mvStack 
 -- $var:gen: "in L: var MultArgL"  
 -- DI:gen: "in L: var MultArgL" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- inArg: in L: var MultArgL 
 -- $var:gen: "in R: var MultArgR"  
 -- DI:gen: "in R: var MultArgR" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- inArg: in R: var MultArgR 
 -- $var:gen: "out U: var MultRes"  
 -- DI:gen: "out U: var MultRes" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  U 
 -- $ObjectGenerator:gen: "MultRes" >OGid:"Unit" IS.isempty! staticOff=6 descNo=0 superAdj=0 
 -- OG:gen: "MultRes" 
 -- OG:before:super.gen: "MultRes" 
 -- $Invocation:gen: "MultRes" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "MultRes" 
 -- isConstant: "Invocation" "MultRes" 
 -- needorigin: "MultRes" 
 -- needOrigin:E: "MultRes"  E.ATd: "MultRes:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "MultRes" E:  "MultRes" 
 -- INV:gen:E.loadArgs "MultRes" 
 -- $ObjectInvocation_Unary:loadArgs: "MultRes" >staticOff:0 "MultRes:< Unit" superAdj:0 
 -- $pattern:loadArgs: "MultRes:< Unit" >E:"MultRes":descNo:0 
 -- ptn:loadArgs:E "MultRes" 
 -- {(ObjectInvocation_Unary; (name: "MultRes"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "MultRes" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "MultRes" 
 -- $ObjectInvocation_Unary:invoke: "MultRes" >rec:"MultRes" ATd:"pattern" isValueObj E:"MultRes" E.ATd:"MultRes" unique:"False" 
 -- OI:invoke: "MultRes" 
 -- 
 -- OI:invoke:B: "MultRes" E: "MultRes"  rec: "MultRes"  useRtnV: false "MultRes:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern MultRes 
 -- $pattern:invoke: "MultRes:< Unit" E: "MultRes" useRTNv: "False" 
 -- ptn:invoke: "MultRes" E: "MultRes" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 6 adr:none 
 -- isStatic: true rec: "MultRes" 
 invokeVal  MultRes 40 5
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: MultRes :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "U.magnitude := L.magnitude * R.magnitude" 
 -- $Assign:gen: "U.magnitude := L.magnitude * R.magnitude"  
 -- assign: "U.magnitude := L.magnitude * R.magnitude" 
 -- computeAdr:superAdj: 0 "U.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "U" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "U"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "U" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "U" >ATd.off:6:on:0:superAdj:0"out U: var MultRes":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out U: var MultRes" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: MultRes 
 -- before:floatTest:  "out U: var MultRes" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- computeAdr: 2 :rec: "U"  E: "magnitude"  A.E: "U" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "U.magnitude := L.magnitude * R.magnitude" right.label: "ObjectGenerator" "L.magnitude * R.magnitude" 
 -- $ObjectGenerator:gen: "L.magnitude * R.magnitude" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.magnitude * R.magnitude" 
 -- OG:before:super.gen: "L.magnitude * R.magnitude" 
 -- $Invocation:gen: "L.magnitude * R.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L.magnitude * R.magnitude" 
 -- isConstant: "Invocation" "L.magnitude * R.magnitude" 
 -- needorigin: "L.magnitude * R.magnitude" 
 -- needOrigin:E: "L.magnitude * R.magnitude"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "L.magnitude * R.magnitude" 
 -- computeAdr:superAdj: 0 "L.magnitude * R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "L.magnitude * R.magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L.magnitude * R.magnitude"  
 -- $BinOp:loadOrigin: "L.magnitude * R.magnitude"  
 -- BinaryExp:loadOrigin:empty: "L.magnitude * R.magnitude" superAdj: 0 
 -- $BinOp:getAdr: "L.magnitude * R.magnitude"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L.magnitude * R.magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L.magnitude * R.magnitude" E:  "L.magnitude * R.magnitude" 
 -- INV:gen:E.loadArgs "L.magnitude * R.magnitude" 
 -- $BinOp:loadArgs: "L.magnitude * R.magnitude"  
 -- BinaryExp:loadArgs: "L.magnitude * R.magnitude" superAdj: 0 
 -- $Invocation:gen: "L.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L.magnitude" 
 -- isConstant: "Invocation" "L.magnitude" 
 -- notConst: L in L: var MultArgL 
 -- needorigin: "L.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:0:superAdj:0"in L: var MultArgL":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "in L: var MultArgL" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: MultArgL 
 -- before:floatTest:  "in L: var MultArgL" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "magnitude"  A.E: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"L" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "L"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "L" 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* R.magnitude":descNo:65} 
 -- ptn:loadArgs:E "* R.magnitude" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "R");     (Arguments));    (ObjectInvocation_U ...} 
 -- args: "R.magnitude" 
 -- E: "ObjectGenerator" R.magnitude 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* R.magnitude" "ObjectInvocation_Binary" ActArg:  "R.magnitude" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* R.magnitude" 
 -- $ObjectGenerator:gen: "R.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "R.magnitude" 
 -- OG:before:super.gen: "R.magnitude" 
 -- $Invocation:gen: "R.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "R.magnitude" 
 -- isConstant: "Invocation" "R.magnitude" 
 -- notConst: R in R: var MultArgR 
 -- needorigin: "R.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:4:on:0:superAdj:0"in R: var MultArgR":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "in R: var MultArgR" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: MultArgR 
 -- before:floatTest:  "in R: var MultArgR" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- rec:  "R" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"R" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:R 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "R"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "R" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:R 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "R.magnitude" :isBasicVal: true 
 -- case:B: R.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* R.magnitude" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- INV:gen:after:E.loadArgs "L.magnitude * R.magnitude" 
 -- OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L.magnitude * R.magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec: ... 
 -- $BinOp:invoke: "L.magnitude * R.magnitude"  
 -- BinaryExp:invoke: "L.magnitude" rec: "L.magnitude * R.magnitude" 
 -- M: "* R.magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- $ObjectInvocation_Binary:invoke: "* R.magnitude" >rec:"L.magnitude" ATd:"pattern" E:"* R.magnitude" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* R.magnitude" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L.magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L.magnitude 
 -- OI:invoke:B: "* R.magnitude" E: "* R.magnitude"  rec: "L.magnitude"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* R.magnitude" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* R.magnitude" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L.magnitude" E: "* R.magnitude" 
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* R.magnitude":rec:L.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * R.magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "U" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "L.magnitude * R.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "U.magnitude := L.magnitude * R.magnitude" arg: "L.magnitude * R.magnitude" ObjectGenerator 
 -- arg.super.arg: "L.magnitude * R.magnitude" BinOp 
 -- recx:BinaryExp:recx: "L.magnitude * R.magnitude" 
 -- M: "* R.magnitude" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "L.magnitude" E: "* R.magnitude" 
 -- arg:other 
 -- M:arg: "R.magnitude" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"U":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "gMult" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 66 
 -- Items:GenClass: Area descNo: 66 isValue: false 
 -- Items:GenClass: Area descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Area 66 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 -- vdtAdd: inx=8 descInx=66 vDescInx=66 vdtTop: 8 
 -- Store itemArgs: %dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "Dimension" 
 -- computeAdr: 1 :rec: "none"  E: "Dimension" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Dimension"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Dimension" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Dimensions$38 1
 -- $ObjectInvocation_Unary:getAdr: "Dimension" >ATd.off:0 (isPtn):on:0:superAdj:1"Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %uni ..."} 
 -- $pattern:getAdr: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisU ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude:  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- computeAdr:isLast:E:  "Dimension" 
 -- genClass:after:pushAddress: "Dimension" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- handleSuperArgs:E: "Dimension" theIS: "%dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1;   %Public;   thisUnit:: ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "Dimension" >staticOff:0 "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %pub ..."} 
 -- $pattern:loadArgs: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thi ..."} 
 -- ptn:loadArgs:E "Dimension" 
 -- {(ObjectInvocation_Unary; (name: "Dimension"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Dimension 
 -- Store itemArgs: %dimension "A", "L*L"{%requires Length;%Public;PrimaryUnit:: SquareMeter;SquareMeter: Unit;   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=66 vDescInx=39 vdtTop: 8 
 -- $Property:gen: "%dimension "-top-""  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "PrimaryUnit:< Unit"  
 -- $pattern:gen: "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)" } 
 -- $pattern:gen: "MultArgL:< Unit"  
 -- $pattern:gen: "MultArgR:< Unit"  
 -- $pattern:gen: "MultRes:< Unit"  
 -- $pattern:gen: "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude" } 
 -- $Property:gen: "%dimension "A", "L*L""  
 -- $Property:gen: "%requires Length"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "PrimaryUnit:: SquareMeter"  
 -- $pattern:gen: "symbol:: {   T := "A"" } 
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "A", "L*L"" 
 -- $Property:gen: "%dimension "A", "L*L""  
 -- genclass:stmt: "%requires Length" 
 -- $Property:gen: "%requires Length"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=66 vDescInx=67 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=66 vDescInx=71 vdtTop: 8 

 CLASS PrimaryUnit#67 67 1 Area$66 66 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 68 
 invoke SquareMeter 68 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 67  newDescNo:  66 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 68 
 -- Items:GenClass: SquareMeter descNo: 68 isValue: true 
 -- Items:GenClass: SquareMeter descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS SquareMeter 68 0 Area 66 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %unit "m2", 1{%Public;thisUnit:: SquareMeter;print:: ;   "SquareMeter".print} 
 -- vdtAdd: inx=1 descInx=68 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%unit "m2", 1"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "thisUnit:: SquareMeter"  
 -- $pattern:gen: "print:: {   "SquareMeter".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%unit "m2", 1" 
 -- $Property:gen: "%unit "m2", 1"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=9 descInx=68 vDescInx=70 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 70 
 -- Items:GenClass: print descNo: 70 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 70 1 SquareMeter 68
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=70 vDescInx=70 vdtTop: 2 
 -- Store itemArgs: "SquareMeter".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""SquareMeter".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "SquareMeter".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=70 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""SquareMeter".print" 
 -- $ObjectGenerator:gen: ""SquareMeter".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""SquareMeter".print" 
 -- OG:before:super.gen: ""SquareMeter".print" 
 -- $Invocation:gen: ""SquareMeter".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""SquareMeter".print" 
 -- isConstant: "Invocation" ""SquareMeter".print" 
 -- needorigin: ""SquareMeter".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""SquareMeter"" E:  ""SquareMeter"" 
 -- INV:gen:E.loadArgs ""SquareMeter"" 
 -- $String::loadArgs: ""SquareMeter""  
 -- INV:gen:after:E.loadArgs ""SquareMeter"" 
 -- OIadr: 
 -- $String::invoke: ""SquareMeter""  
 pushText "SquareMeter"
 -- IV:gen:checkTail: ""SquareMeter".print" E: ""SquareMeter"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""SquareMeter"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""SquareMeter""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 71 
 -- Items:GenClass: symbol descNo: 71 isValue: false 
 -- Items:GenClass: symbol descNo: 63 isValue: false 
 -- Items:GenClass: symbol descNo: 21 isValue: false 

 CLASS symbol 71 1 Area 66
 -- vdtTableCopy: I:1:63 I:2:0
 -- vdtAdd: inx=2 descInx=71 vDescInx=71 vdtTop: 2 
 -- Store itemArgs: T := "A" 
 -- super symbol
 -- push:super.origin: 
 -- hArgOrg:super: symbol 
 -- Store itemArgs: T := "A" 
 allocEventQ
 -- vdtAdd: inx=1 descInx=71 vDescInx=63 vdtTop: 2 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out T: var StringLib.String"  
 -- DI:gen: "out T: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out T: var StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- genclass:stmt: "T := "A"" 
 -- $Assign:gen: "T := "A""  
 -- assign: "T := "A"" 
 -- computeAdr:superAdj: 0 "T" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:2:on:0:superAdj:0"out T: var StringLib.String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- PING:String 0 T := "A" 
 -- BOBS:ATd: "out T: var StringLib.String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "out T: var StringLib.String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "T" 
 -- AssignmentStatement:gen: "T := "A"" right.label: "ObjectGenerator" ""A"" 
 -- $ObjectGenerator:gen: ""A"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""A"" 
 -- OG:before:super.gen: ""A"" 
 -- $Invocation:gen: ""A"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""A"" 
 -- isConstant: "Invocation" ""A"" 
 -- needorigin: ""A"" 
 -- needOrigin:E: ""A""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0 ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""A"" E:  ""A"" 
 -- INV:gen:E.loadArgs ""A"" 
 -- $String::loadArgs: ""A""  
 -- INV:gen:after:E.loadArgs ""A"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""A"" 
 -- $String::invoke: ""A""  
 pushText "A"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "T" dstE: "T" dstE.ATd: "out T: var StringLib.String" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":r ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 72 
 -- Items:GenClass: Length descNo: 72 isValue: false 
 -- Items:GenClass: Length descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Length 72 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 -- vdtAdd: inx=8 descInx=72 vDescInx=72 vdtTop: 8 
 -- Store itemArgs: %dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.S ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "Dimension" 
 -- computeAdr: 1 :rec: "none"  E: "Dimension" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Dimension"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Dimension" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Dimensions$38 1
 -- $ObjectInvocation_Unary:getAdr: "Dimension" >ATd.off:0 (isPtn):on:0:superAdj:1"Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %uni ..."} 
 -- $pattern:getAdr: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisU ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude:  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- computeAdr:isLast:E:  "Dimension" 
 -- genClass:after:pushAddress: "Dimension" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- handleSuperArgs:E: "Dimension" theIS: "%dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Me ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "Dimension" >staticOff:0 "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %pub ..."} 
 -- $pattern:loadArgs: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thi ..."} 
 -- ptn:loadArgs:E "Dimension" 
 -- {(ObjectInvocation_Unary; (name: "Dimension"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Dimension 
 -- Store itemArgs: %dimension "L"{%requires Area;%Public;PrimaryUnit:: Meter;Meter: Unit;   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.S ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=72 vDescInx=39 vdtTop: 8 
 -- $Property:gen: "%dimension "-top-""  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "PrimaryUnit:< Unit"  
 -- $pattern:gen: "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)" } 
 -- $pattern:gen: "MultArgL:< Unit"  
 -- $pattern:gen: "MultArgR:< Unit"  
 -- $pattern:gen: "MultRes:< Unit"  
 -- $pattern:gen: "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude" } 
 -- $Property:gen: "%dimension "L""  
 -- $Property:gen: "%requires Area"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "PrimaryUnit:: Meter"  
 -- $pattern:gen: "symbol:: {   T := "L"" } 
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "L"" 
 -- $Property:gen: "%dimension "L""  
 -- genclass:stmt: "%requires Area" 
 -- $Property:gen: "%requires Area"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=72 vDescInx=73 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=72 vDescInx=81 vdtTop: 8 

 CLASS PrimaryUnit#73 73 1 Length$72 72 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 74 
 invoke Meter 74 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 73  newDescNo:  72 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 74 
 -- Items:GenClass: Meter descNo: 74 isValue: true 
 -- Items:GenClass: Meter descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Meter 74 0 Length 72 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := ...} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := magnitude;fromPrimary: ...}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %unit "m", 1{%Public;thisUnit:: Meter;argUnit:: Meter;resUnit:: Area.SquareMeter;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := ...} 
 -- vdtAdd: inx=1 descInx=74 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%unit "m", 1"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "thisUnit:: Meter"  
 -- $pattern:gen: "argUnit:: Meter"  
 -- $pattern:gen: "resUnit:: Area.SquareMeter"  
 -- $pattern:gen: "toPrimary:: {   base.magnitude := magnitude" } 
 -- $pattern:gen: "fromPrimary:: {   magnitude := base.magnitude" } 
 -- $pattern:gen: "print:: {   "Meter".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%unit "m", 1" 
 -- $Property:gen: "%unit "m", 1"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=74 vDescInx=78 vdtTop: 9 
 -- vdtAdd: inx=8 descInx=74 vDescInx=79 vdtTop: 9 
 -- vdtAdd: inx=9 descInx=74 vDescInx=80 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 78 
 -- Items:GenClass: toPrimary descNo: 78 isValue: false 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 78 1 Meter 74
 -- vdtTableCopy: I:1:49 I:2:0
 -- vdtAdd: inx=2 descInx=78 vDescInx=78 vdtTop: 2 
 -- Store itemArgs: base.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super toPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "base.magnitude := magnitude" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: toPrimary 
 -- Store itemArgs: base.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=78 vDescInx=49 vdtTop: 2 
 -- $var:gen: "out base: var PrimaryUnit"  
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- $ObjectGenerator:gen: "PrimaryUnit" >OGid:"Unit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "PrimaryUnit" 
 -- OG:before:super.gen: "PrimaryUnit" 
 -- $Invocation:gen: "PrimaryUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "PrimaryUnit" 
 -- isConstant: "Invocation" "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "PrimaryUnit" E:  "PrimaryUnit" 
 -- INV:gen:E.loadArgs "PrimaryUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "PrimaryUnit" >staticOff:0 "PrimaryUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "PrimaryUnit:< Unit" >E:"PrimaryUnit":descNo:0 
 -- ptn:loadArgs:E "PrimaryUnit" 
 -- {(ObjectInvocation_Unary; (name: "PrimaryUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "PrimaryUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit" 
 -- $ObjectInvocation_Unary:invoke: "PrimaryUnit" >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:"PrimaryUnit" unique:"False" 
 -- OI:invoke: "PrimaryUnit" 
 -- 
 -- OI:invoke:B: "PrimaryUnit" E: "PrimaryUnit"  rec: "PrimaryUnit"  useRtnV: false "PrimaryUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: "PrimaryUnit:< Unit" E: "PrimaryUnit" useRTNv: "False" 
 -- ptn:invoke: "PrimaryUnit" E: "PrimaryUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 4 adr:none 
 -- isStatic: true rec: "PrimaryUnit" 
 invokeVal  PrimaryUnit 40 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- genclass:stmt: "base.magnitude := magnitude" 
 -- $Assign:gen: "base.magnitude := magnitude"  
 -- assign: "base.magnitude := magnitude" 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"out base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "out base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "out base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "base.magnitude := magnitude" right.label: "ObjectGenerator" "magnitude" 
 -- $ObjectGenerator:gen: "magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "magnitude" 
 -- OG:before:super.gen: "magnitude" 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "toPrimary" on: 1 isValueObj: false 
 -- origin: Meter origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg toPrimary$78 1
 rswap 0
 rdouble 0
 pushg 2 toPrimary$78
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 toPrimary$78
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- rec: "base" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"bas ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "magnitude" 
 -- isArgOfAssignI2IwithUniValArg "base.magnitude := magnitude" arg: "magnitude" ObjectGenerator 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 79 
 -- Items:GenClass: fromPrimary descNo: 79 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 79 1 Meter 74
 -- vdtTableCopy: I:1:50 I:2:0
 -- vdtAdd: inx=2 descInx=79 vDescInx=79 vdtTop: 2 
 -- Store itemArgs: magnitude := base.magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super fromPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "magnitude := base.magnitude" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: fromPrimary 
 -- Store itemArgs: magnitude := base.magnitude 
 -- in base: var PrimaryUnit true 0 
 -- DI:store: "base" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  base 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=79 vDescInx=50 vdtTop: 2 
 -- $var:gen: "in base: var PrimaryUnit"  
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- genclass:stmt: "magnitude := base.magnitude" 
 -- $Assign:gen: "magnitude := base.magnitude"  
 -- assign: "magnitude := base.magnitude" 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "fromPrimary" on: 1 isValueObj: false 
 -- origin: Meter origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg fromPrimary$79 1
 rswap 0
 rdouble 0
 pushg 2 fromPrimary$79
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 fromPrimary$79
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "magnitude := base.magnitude" right.label: "ObjectGenerator" "base.magnitude" 
 -- $ObjectGenerator:gen: "base.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "base.magnitude" 
 -- OG:before:super.gen: "base.magnitude" 
 -- $Invocation:gen: "base.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude" 
 -- isConstant: "Invocation" "base.magnitude" 
 -- notConst: base in base: var PrimaryUnit 
 -- needorigin: "base.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"in base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "in base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "in base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- rec:  "base" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"base" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "base"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "base" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- rec: "magnitude" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "base.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "magnitude := base.magnitude" arg: "base.magnitude" ObjectGenerator 
 -- arg.super.arg: "base" ObjectInvocation_Unary 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- recx: "base" argx: "magnitude" 
 -- checkInt2IntWithUnitArg:rec: "base" E: "magnitude" 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- Address:store:originIsVal: 
 fovstoreg 1 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 80 
 -- Items:GenClass: print descNo: 80 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 80 1 Meter 74
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=80 vDescInx=80 vdtTop: 2 
 -- Store itemArgs: "Meter".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""Meter".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "Meter".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=80 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Meter".print" 
 -- $ObjectGenerator:gen: ""Meter".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Meter".print" 
 -- OG:before:super.gen: ""Meter".print" 
 -- $Invocation:gen: ""Meter".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Meter".print" 
 -- isConstant: "Invocation" ""Meter".print" 
 -- needorigin: ""Meter".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Meter"" E:  ""Meter"" 
 -- INV:gen:E.loadArgs ""Meter"" 
 -- $String::loadArgs: ""Meter""  
 -- INV:gen:after:E.loadArgs ""Meter"" 
 -- OIadr: 
 -- $String::invoke: ""Meter""  
 pushText "Meter"
 -- IV:gen:checkTail: ""Meter".print" E: ""Meter"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Meter"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Meter""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 81 
 -- Items:GenClass: symbol descNo: 81 isValue: false 
 -- Items:GenClass: symbol descNo: 63 isValue: false 
 -- Items:GenClass: symbol descNo: 21 isValue: false 

 CLASS symbol 81 1 Length 72
 -- vdtTableCopy: I:1:63 I:2:0
 -- vdtAdd: inx=2 descInx=81 vDescInx=81 vdtTop: 2 
 -- Store itemArgs: T := "L" 
 -- super symbol
 -- push:super.origin: 
 -- hArgOrg:super: symbol 
 -- Store itemArgs: T := "L" 
 allocEventQ
 -- vdtAdd: inx=1 descInx=81 vDescInx=63 vdtTop: 2 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out T: var StringLib.String"  
 -- DI:gen: "out T: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out T: var StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- genclass:stmt: "T := "L"" 
 -- $Assign:gen: "T := "L""  
 -- assign: "T := "L"" 
 -- computeAdr:superAdj: 0 "T" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:2:on:0:superAdj:0"out T: var StringLib.String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- PING:String 0 T := "L" 
 -- BOBS:ATd: "out T: var StringLib.String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "out T: var StringLib.String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "T" 
 -- AssignmentStatement:gen: "T := "L"" right.label: "ObjectGenerator" ""L"" 
 -- $ObjectGenerator:gen: ""L"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""L"" 
 -- OG:before:super.gen: ""L"" 
 -- $Invocation:gen: ""L"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""L"" 
 -- isConstant: "Invocation" ""L"" 
 -- needorigin: ""L"" 
 -- needOrigin:E: ""L""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0 ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""L"" E:  ""L"" 
 -- INV:gen:E.loadArgs ""L"" 
 -- $String::loadArgs: ""L""  
 -- INV:gen:after:E.loadArgs ""L"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""L"" 
 -- $String::invoke: ""L""  
 pushText "L"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "T" dstE: "T" dstE.ATd: "out T: var StringLib.String" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":r ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 82 
 -- Items:GenClass: Temperature descNo: 82 isValue: false 
 -- Items:GenClass: Temperature descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Temperature 82 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 -- vdtAdd: inx=8 descInx=82 vDescInx=82 vdtTop: 8 
 -- Store itemArgs: %Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitud ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "Dimension" 
 -- computeAdr: 1 :rec: "none"  E: "Dimension" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Dimension"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Dimension" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Dimensions$38 1
 -- $ObjectInvocation_Unary:getAdr: "Dimension" >ATd.off:0 (isPtn):on:0:superAdj:1"Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %uni ..."} 
 -- $pattern:getAdr: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisU ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude:  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- computeAdr:isLast:E:  "Dimension" 
 -- genClass:after:pushAddress: "Dimension" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- handleSuperArgs:E: "Dimension" theIS: "%Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      mag ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "Dimension" >staticOff:0 "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %pub ..."} 
 -- $pattern:loadArgs: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thi ..."} 
 -- ptn:loadArgs:E "Dimension" 
 -- {(ObjectInvocation_Unary; (name: "Dimension"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Dimension 
 -- Store itemArgs: %Public{Celsius: Unit;   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitud ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=82 vDescInx=39 vdtTop: 8 
 -- $Property:gen: "%dimension "-top-""  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "PrimaryUnit:< Unit"  
 -- $pattern:gen: "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)" } 
 -- $pattern:gen: "MultArgL:< Unit"  
 -- $pattern:gen: "MultArgR:< Unit"  
 -- $pattern:gen: "MultRes:< Unit"  
 -- $pattern:gen: "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude" } 
 -- $Property:gen: "%Public"  
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 83 
 -- Items:GenClass: Time descNo: 83 isValue: false 
 -- Items:GenClass: Time descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Time 83 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 -- vdtAdd: inx=8 descInx=83 vDescInx=83 vdtTop: 8 
 -- Store itemArgs: %dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude; ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "Dimension" 
 -- computeAdr: 1 :rec: "none"  E: "Dimension" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Dimension"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Dimension" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Dimensions$38 1
 -- $ObjectInvocation_Unary:getAdr: "Dimension" >ATd.off:0 (isPtn):on:0:superAdj:1"Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %uni ..."} 
 -- $pattern:getAdr: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisU ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude:  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- computeAdr:isLast:E:  "Dimension" 
 -- genClass:after:pushAddress: "Dimension" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- handleSuperArgs:E: "Dimension" theIS: "%dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base. ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "Dimension" >staticOff:0 "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %pub ..."} 
 -- $pattern:loadArgs: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thi ..."} 
 -- ptn:loadArgs:E "Dimension" 
 -- {(ObjectInvocation_Unary; (name: "Dimension"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Dimension 
 -- Store itemArgs: %dimension "T"{%Public;PrimaryUnit:: Second;Second: Unit;   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude; ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=83 vDescInx=39 vdtTop: 8 
 -- $Property:gen: "%dimension "-top-""  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "PrimaryUnit:< Unit"  
 -- $pattern:gen: "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)" } 
 -- $pattern:gen: "MultArgL:< Unit"  
 -- $pattern:gen: "MultArgR:< Unit"  
 -- $pattern:gen: "MultRes:< Unit"  
 -- $pattern:gen: "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude" } 
 -- $Property:gen: "%dimension "T""  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "PrimaryUnit:: Second"  
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "T"" 
 -- $Property:gen: "%dimension "T""  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=83 vDescInx=84 vdtTop: 8 

 CLASS PrimaryUnit#84 84 1 Time$83 83 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 85 
 invoke Second 85 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 84  newDescNo:  83 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 85 
 -- Items:GenClass: Second descNo: 85 isValue: true 
 -- Items:GenClass: Second descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Second 85 0 Time 83 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Second".print ...} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print::  ...}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %unit "s", 1{%public;thisUnit:: Second;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Second".print ...} 
 -- vdtAdd: inx=1 descInx=85 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%unit "s", 1"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "thisUnit:: Second"  
 -- $pattern:gen: "toPrimary:: {   base.magnitude := magnitude" } 
 -- $pattern:gen: "fromPrimary:: {   magnitude := base.magnitude" } 
 -- $pattern:gen: "print:: {   "Second".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%unit "s", 1" 
 -- $Property:gen: "%unit "s", 1"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=85 vDescInx=87 vdtTop: 9 
 -- vdtAdd: inx=8 descInx=85 vDescInx=88 vdtTop: 9 
 -- vdtAdd: inx=9 descInx=85 vDescInx=89 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 87 
 -- Items:GenClass: toPrimary descNo: 87 isValue: false 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 87 1 Second 85
 -- vdtTableCopy: I:1:49 I:2:0
 -- vdtAdd: inx=2 descInx=87 vDescInx=87 vdtTop: 2 
 -- Store itemArgs: base.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super toPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "base.magnitude := magnitude" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: toPrimary 
 -- Store itemArgs: base.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=87 vDescInx=49 vdtTop: 2 
 -- $var:gen: "out base: var PrimaryUnit"  
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- $ObjectGenerator:gen: "PrimaryUnit" >OGid:"Unit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "PrimaryUnit" 
 -- OG:before:super.gen: "PrimaryUnit" 
 -- $Invocation:gen: "PrimaryUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "PrimaryUnit" 
 -- isConstant: "Invocation" "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "PrimaryUnit" E:  "PrimaryUnit" 
 -- INV:gen:E.loadArgs "PrimaryUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "PrimaryUnit" >staticOff:0 "PrimaryUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "PrimaryUnit:< Unit" >E:"PrimaryUnit":descNo:0 
 -- ptn:loadArgs:E "PrimaryUnit" 
 -- {(ObjectInvocation_Unary; (name: "PrimaryUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "PrimaryUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit" 
 -- $ObjectInvocation_Unary:invoke: "PrimaryUnit" >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:"PrimaryUnit" unique:"False" 
 -- OI:invoke: "PrimaryUnit" 
 -- 
 -- OI:invoke:B: "PrimaryUnit" E: "PrimaryUnit"  rec: "PrimaryUnit"  useRtnV: false "PrimaryUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: "PrimaryUnit:< Unit" E: "PrimaryUnit" useRTNv: "False" 
 -- ptn:invoke: "PrimaryUnit" E: "PrimaryUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 4 adr:none 
 -- isStatic: true rec: "PrimaryUnit" 
 invokeVal  PrimaryUnit 40 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- genclass:stmt: "base.magnitude := magnitude" 
 -- $Assign:gen: "base.magnitude := magnitude"  
 -- assign: "base.magnitude := magnitude" 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"out base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "out base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "out base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "base.magnitude := magnitude" right.label: "ObjectGenerator" "magnitude" 
 -- $ObjectGenerator:gen: "magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "magnitude" 
 -- OG:before:super.gen: "magnitude" 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "toPrimary" on: 1 isValueObj: false 
 -- origin: Second origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg toPrimary$87 1
 rswap 0
 rdouble 0
 pushg 2 toPrimary$87
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 toPrimary$87
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- rec: "base" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"bas ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "magnitude" 
 -- isArgOfAssignI2IwithUniValArg "base.magnitude := magnitude" arg: "magnitude" ObjectGenerator 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 88 
 -- Items:GenClass: fromPrimary descNo: 88 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 88 1 Second 85
 -- vdtTableCopy: I:1:50 I:2:0
 -- vdtAdd: inx=2 descInx=88 vDescInx=88 vdtTop: 2 
 -- Store itemArgs: magnitude := base.magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super fromPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "magnitude := base.magnitude" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: fromPrimary 
 -- Store itemArgs: magnitude := base.magnitude 
 -- in base: var PrimaryUnit true 0 
 -- DI:store: "base" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  base 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=88 vDescInx=50 vdtTop: 2 
 -- $var:gen: "in base: var PrimaryUnit"  
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- genclass:stmt: "magnitude := base.magnitude" 
 -- $Assign:gen: "magnitude := base.magnitude"  
 -- assign: "magnitude := base.magnitude" 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "fromPrimary" on: 1 isValueObj: false 
 -- origin: Second origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg fromPrimary$88 1
 rswap 0
 rdouble 0
 pushg 2 fromPrimary$88
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 fromPrimary$88
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "magnitude := base.magnitude" right.label: "ObjectGenerator" "base.magnitude" 
 -- $ObjectGenerator:gen: "base.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "base.magnitude" 
 -- OG:before:super.gen: "base.magnitude" 
 -- $Invocation:gen: "base.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude" 
 -- isConstant: "Invocation" "base.magnitude" 
 -- notConst: base in base: var PrimaryUnit 
 -- needorigin: "base.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"in base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "in base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "in base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- rec:  "base" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"base" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "base"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "base" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- rec: "magnitude" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "base.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "magnitude := base.magnitude" arg: "base.magnitude" ObjectGenerator 
 -- arg.super.arg: "base" ObjectInvocation_Unary 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- recx: "base" argx: "magnitude" 
 -- checkInt2IntWithUnitArg:rec: "base" E: "magnitude" 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- Address:store:originIsVal: 
 fovstoreg 1 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 89 
 -- Items:GenClass: print descNo: 89 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 89 1 Second 85
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=89 vDescInx=89 vdtTop: 2 
 -- Store itemArgs: "Second".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""Second".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "Second".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=89 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Second".print" 
 -- $ObjectGenerator:gen: ""Second".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Second".print" 
 -- OG:before:super.gen: ""Second".print" 
 -- $Invocation:gen: ""Second".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Second".print" 
 -- isConstant: "Invocation" ""Second".print" 
 -- needorigin: ""Second".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Second"" E:  ""Second"" 
 -- INV:gen:E.loadArgs ""Second"" 
 -- $String::loadArgs: ""Second""  
 -- INV:gen:after:E.loadArgs ""Second"" 
 -- OIadr: 
 -- $String::invoke: ""Second""  
 pushText "Second"
 -- IV:gen:checkTail: ""Second".print" E: ""Second"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Second"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Second""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 90 
 -- Items:GenClass: Velocity descNo: 90 isValue: false 
 -- Items:GenClass: Velocity descNo: 39 isValue: false 
 -- Items:GenClass: Dimension descNo: 21 isValue: false 

 CLASS Velocity 90 1 Dimensions 38
 -- vdtTableCopy: I:1:39 V:2:44 V:3:63 V:4:45 V:5:46 V:6:47 V:7:64 I:8:0
 -- vdtAdd: inx=8 descInx=90 vDescInx=90 vdtTop: 8 
 -- Store itemArgs: %dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Dimension
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "Dimension" 
 -- computeAdr: 1 :rec: "none"  E: "Dimension" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Dimension"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Dimension" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg Dimensions$38 1
 -- $ObjectInvocation_Unary:getAdr: "Dimension" >ATd.off:0 (isPtn):on:0:superAdj:1"Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %uni ..."} 
 -- $pattern:getAdr: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thisU ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Dimension"  ATd: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude:  ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- computeAdr:isLast:E:  "Dimension" 
 -- genClass:after:pushAddress: "Dimension" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Dimension":rec:- 
 -- handleSuperArgs:E: "Dimension" theIS: "%dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "MpS", "m*s^-1",  ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "Dimension" >staticOff:0 "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %pub ..."} 
 -- $pattern:loadArgs: "Dimension: {   %dimension "-top-";   %public;   PrimaryUnit:< Unit;   Unit: Value;      %unit "U", 1;      %public;      magnitude: var Float;      thi ..."} 
 -- ptn:loadArgs:E "Dimension" 
 -- {(ObjectInvocation_Unary; (name: "Dimension"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Dimension 
 -- Store itemArgs: %dimension "MpSD", "L/T"{%requires Length, Time;%Public;PrimaryUnit:: MeterPerSecond;MeterPerSecond: Unit;   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=90 vDescInx=39 vdtTop: 8 
 -- $Property:gen: "%dimension "-top-""  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "PrimaryUnit:< Unit"  
 -- $pattern:gen: "symbol:< {   %globals;   out T: var StringLib.String;   inner(Symbol)" } 
 -- $pattern:gen: "MultArgL:< Unit"  
 -- $pattern:gen: "MultArgR:< Unit"  
 -- $pattern:gen: "MultRes:< Unit"  
 -- $pattern:gen: "gMult:< {   in L: var MultArgL;   in R: var MultArgR;   out U: var MultRes;   U.magnitude := L.magnitude * R.magnitude" } 
 -- $Property:gen: "%dimension "MpSD", "L/T""  
 -- $Property:gen: "%requires Length, Time"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "PrimaryUnit:: MeterPerSecond"  
 -- $pattern:gen: "symbol:: {   T := "V"" } 
 -- $pattern:gen: "MultArgL:: Length.Meter"  
 -- $pattern:gen: "MultArgR:: Time.Minutes"  
 -- $pattern:gen: "MultRes:: MeterPerSecond"  
 rtnAlloc 1
 toSuper 39
DO:
 mvStack 
 L1:
 -- genclass:stmt: "%dimension "MpSD", "L/T"" 
 -- $Property:gen: "%dimension "MpSD", "L/T""  
 -- genclass:stmt: "%requires Length, Time" 
 -- $Property:gen: "%requires Length, Time"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 -- genclass:stmt: "test" 
 -- $ObjectGenerator:gen: "test" >OGid:"test" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "test" 
 -- OG:before:super.gen: "test" 
 -- $Invocation:gen: "test" >useRtnV:"False"superAdj: 0 descNo: 95 
 -- INV:gen: "test" 
 -- isConstant: "Invocation" "test" 
 -- needorigin: "test" 
 -- needOrigin:E: "test"  E.ATd: "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;    ...}" 
 -- doNeedOrigin:Ex: "test" 
 -- computeAdr:superAdj: 0 "test" 
 -- computeAdr: 1 :rec: "none"  E: "test" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "test"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "test" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "test" >ATd.off:0 (isPtn):on:0:superAdj:0"test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.p ..."} 
 -- $pattern:getAdr: "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:- 
 -- computeAdr:isLast:E:  "test" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:- 
 -- rec:  "test" E:  "test" 
 -- INV:gen:E.loadArgs "test" 
 -- $ObjectInvocation_Unary:loadArgs: "test" >staticOff:0 "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;    ..."} 
 -- $pattern:loadArgs: "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   ..."} 
 -- ptn:loadArgs:E "test" 
 -- {(ObjectInvocation_Unary; (name: "test"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "test" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "test" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:- 
 -- $ObjectInvocation_Unary:invoke: "test" >rec:"test" ATd:"pattern" E:"test" E.ATd:"test" unique:"False" 
 -- OI:invoke: "test" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:test 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:test 
 -- OI:invoke:B: "test" E: "test"  rec: "test"  useRtnV: false "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newlin ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern test 
 -- $pattern:invoke: "test: {   V: var MeterPerSecond;   L: var Length.Meter;   T: var Time.second;   L := 10"m";   L.print;   newline;   T := 20"s";   T.print;   newline;   V ..."} 
 -- ptn:invoke: "test" E: "test" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:test 
 invoke test 95 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:test 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:test 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: test :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"test":rec:test 
 L2:
 rtnInner  M
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=90 vDescInx=91 vdtTop: 8 
 -- vdtAdd: inx=3 descInx=90 vDescInx=101 vdtTop: 8 
 -- vdtAdd: inx=4 descInx=90 vDescInx=92 vdtTop: 8 
 -- vdtAdd: inx=5 descInx=90 vDescInx=93 vdtTop: 8 
 -- vdtAdd: inx=6 descInx=90 vDescInx=94 vdtTop: 8 

 CLASS PrimaryUnit#91 91 1 Velocity$90 90 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 96 
 invoke MeterPerSecond 96 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 91  newDescNo:  90 

 CLASS MultArgL#92 92 1 Velocity$90 90 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 74 
 invoke Meter 74 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 92  newDescNo:  90 

 CLASS MultArgR#93 93 1 Velocity$90 90 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 102 
 invoke Minutes 102 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 93  newDescNo:  90 

 CLASS MultRes#94 94 1 Velocity$90 90 isVstub
 -- Load origin:OG.isVirtualArg: false 
 -- OG.super.on/descNo: 0 96 
 invoke MeterPerSecond 96 0 1
 pushThis 
 rstoreg   2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 setThisStack 
 pushThis 
 rpushg  2
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdt:a:dNo: 94  newDescNo:  90 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 96 
 -- Items:GenClass: MeterPerSecond descNo: 96 isValue: true 
 -- Items:GenClass: MeterPerSecond descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS MeterPerSecond 96 0 Velocity 90 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %unit "MpS", "m*s^-1", "m/s", 1{%Public;thisUnit:: MeterPerSecond;print:: ;   "MpS".print} 
 -- vdtAdd: inx=1 descInx=96 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%unit "MpS", "m*s^-1", "m/s", 1"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "thisUnit:: MeterPerSecond"  
 -- $pattern:gen: "print:: {   "MpS".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%unit "MpS", "m*s^-1", "m/s", 1" 
 -- $Property:gen: "%unit "MpS", "m*s^-1", "m/s", 1"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=9 descInx=96 vDescInx=100 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 100 
 -- Items:GenClass: print descNo: 100 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 100 1 MeterPerSecond 96
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=100 vDescInx=100 vdtTop: 2 
 -- Store itemArgs: "MpS".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""MpS".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "MpS".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=100 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""MpS".print" 
 -- $ObjectGenerator:gen: ""MpS".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""MpS".print" 
 -- OG:before:super.gen: ""MpS".print" 
 -- $Invocation:gen: ""MpS".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""MpS".print" 
 -- isConstant: "Invocation" ""MpS".print" 
 -- needorigin: ""MpS".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""MpS"" E:  ""MpS"" 
 -- INV:gen:E.loadArgs ""MpS"" 
 -- $String::loadArgs: ""MpS""  
 -- INV:gen:after:E.loadArgs ""MpS"" 
 -- OIadr: 
 -- $String::invoke: ""MpS""  
 pushText "MpS"
 -- IV:gen:checkTail: ""MpS".print" E: ""MpS"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""MpS"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""MpS""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 101 
 -- Items:GenClass: symbol descNo: 101 isValue: false 
 -- Items:GenClass: symbol descNo: 63 isValue: false 
 -- Items:GenClass: symbol descNo: 21 isValue: false 

 CLASS symbol 101 1 Velocity 90
 -- vdtTableCopy: I:1:63 I:2:0
 -- vdtAdd: inx=2 descInx=101 vDescInx=101 vdtTop: 2 
 -- Store itemArgs: T := "V" 
 -- super symbol
 -- push:super.origin: 
 -- hArgOrg:super: symbol 
 -- Store itemArgs: T := "V" 
 allocEventQ
 -- vdtAdd: inx=1 descInx=101 vDescInx=63 vdtTop: 2 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out T: var StringLib.String"  
 -- DI:gen: "out T: var StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out T: var StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
 toSuper 63
DO:
 mvStack 
 L1:
 -- genclass:stmt: "T := "V"" 
 -- $Assign:gen: "T := "V""  
 -- assign: "T := "V"" 
 -- computeAdr:superAdj: 0 "T" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:2:on:0:superAdj:0"out T: var StringLib.String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- PING:String 0 T := "V" 
 -- BOBS:ATd: "out T: var StringLib.String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "out T: var StringLib.String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "T" 
 -- AssignmentStatement:gen: "T := "V"" right.label: "ObjectGenerator" ""V"" 
 -- $ObjectGenerator:gen: ""V"" >OGid:"String" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""V"" 
 -- OG:before:super.gen: ""V"" 
 -- $Invocation:gen: ""V"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: ""V"" 
 -- isConstant: "Invocation" ""V"" 
 -- needorigin: ""V"" 
 -- needOrigin:E: ""V""  E.ATd: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0 ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""V"" E:  ""V"" 
 -- INV:gen:E.loadArgs ""V"" 
 -- $String::loadArgs: ""V""  
 -- INV:gen:after:E.loadArgs ""V"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: String: ""V"" 
 -- $String::invoke: ""V""  
 pushText "V"
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "T" dstE: "T" dstE.ATd: "out T: var StringLib.String" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":r ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-2,1)=[]
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 102 
 -- Items:GenClass: Minutes descNo: 102 isValue: true 
 -- Items:GenClass: Minutes descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Minutes 102 0 Time 83 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   magnitude := base.magnitude / 60;print:: ;    ...} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   magnitude := base.magnitude ...}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %unit "min", 60{%Public;thisUnit:: Minutes;toPrimary:: ;   base.magnitude := magnitude * 60;fromPrimary:: ;   magnitude := base.magnitude / 60;print:: ;    ...} 
 -- vdtAdd: inx=1 descInx=102 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%unit "min", 60"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "thisUnit:: Minutes"  
 -- $pattern:gen: "toPrimary:: {   base.magnitude := magnitude * 60" } 
 -- $pattern:gen: "fromPrimary:: {   magnitude := base.magnitude / 60" } 
 -- $pattern:gen: "print:: {   "Minutes".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%unit "min", 60" 
 -- $Property:gen: "%unit "min", 60"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=102 vDescInx=104 vdtTop: 9 
 -- vdtAdd: inx=8 descInx=102 vDescInx=105 vdtTop: 9 
 -- vdtAdd: inx=9 descInx=102 vDescInx=106 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 104 
 -- Items:GenClass: toPrimary descNo: 104 isValue: false 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 104 1 Minutes 102
 -- vdtTableCopy: I:1:49 I:2:0
 -- vdtAdd: inx=2 descInx=104 vDescInx=104 vdtTop: 2 
 -- Store itemArgs: base.magnitude := magnitude * 60 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super toPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "base.magnitude := magnitude * 60" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: toPrimary 
 -- Store itemArgs: base.magnitude := magnitude * 60 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=104 vDescInx=49 vdtTop: 2 
 -- $var:gen: "out base: var PrimaryUnit"  
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- $ObjectGenerator:gen: "PrimaryUnit" >OGid:"Unit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "PrimaryUnit" 
 -- OG:before:super.gen: "PrimaryUnit" 
 -- $Invocation:gen: "PrimaryUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "PrimaryUnit" 
 -- isConstant: "Invocation" "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "PrimaryUnit" E:  "PrimaryUnit" 
 -- INV:gen:E.loadArgs "PrimaryUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "PrimaryUnit" >staticOff:0 "PrimaryUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "PrimaryUnit:< Unit" >E:"PrimaryUnit":descNo:0 
 -- ptn:loadArgs:E "PrimaryUnit" 
 -- {(ObjectInvocation_Unary; (name: "PrimaryUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "PrimaryUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit" 
 -- $ObjectInvocation_Unary:invoke: "PrimaryUnit" >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:"PrimaryUnit" unique:"False" 
 -- OI:invoke: "PrimaryUnit" 
 -- 
 -- OI:invoke:B: "PrimaryUnit" E: "PrimaryUnit"  rec: "PrimaryUnit"  useRtnV: false "PrimaryUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: "PrimaryUnit:< Unit" E: "PrimaryUnit" useRTNv: "False" 
 -- ptn:invoke: "PrimaryUnit" E: "PrimaryUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 4 adr:none 
 -- isStatic: true rec: "PrimaryUnit" 
 invokeVal  PrimaryUnit 40 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- genclass:stmt: "base.magnitude := magnitude * 60" 
 -- $Assign:gen: "base.magnitude := magnitude * 60"  
 -- assign: "base.magnitude := magnitude * 60" 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"out base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "out base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "out base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "base.magnitude := magnitude * 60" right.label: "ObjectGenerator" "magnitude * 60" 
 -- $ObjectGenerator:gen: "magnitude * 60" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "magnitude * 60" 
 -- OG:before:super.gen: "magnitude * 60" 
 -- $Invocation:gen: "magnitude * 60" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude * 60" 
 -- isConstant: "Invocation" "magnitude * 60" 
 -- needorigin: "magnitude * 60" 
 -- needOrigin:E: "magnitude * 60"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "magnitude * 60" 
 -- computeAdr:superAdj: 0 "magnitude * 60" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude * 60" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "magnitude * 60"  
 -- $BinOp:loadOrigin: "magnitude * 60"  
 -- BinaryExp:loadOrigin:empty: "magnitude * 60" superAdj: 0 
 -- $BinOp:getAdr: "magnitude * 60"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude * 60"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude * 60" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "magnitude * 60" E:  "magnitude * 60" 
 -- INV:gen:E.loadArgs "magnitude * 60" 
 -- $BinOp:loadArgs: "magnitude * 60"  
 -- BinaryExp:loadArgs: "magnitude * 60" superAdj: 0 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "toPrimary" on: 1 isValueObj: false 
 -- origin: Minutes origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg toPrimary$104 1
 rswap 0
 rdouble 0
 pushg 2 toPrimary$104
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 toPrimary$104
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* 60":descNo:65} 
 -- ptn:loadArgs:E "* 60" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 60));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "60" 
 -- E: "ObjectGenerator" 60 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* 60" "ObjectInvocation_Binary" ActArg:  "60" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* 60" 
 -- $ObjectGenerator:gen: "60" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "60" 
 -- OG:before:super.gen: "60" 
 -- $Invocation:gen: "60" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "60" 
 -- isConstant: "Invocation" "60" 
 -- needorigin: "60" 
 -- needOrigin:E: "60"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "60" E:  "60" 
 -- INV:gen:E.loadArgs "60" 
 -- $ConstLiteral:loadArgs: "60"  
 -- INV:gen:after:E.loadArgs "60" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "60" 
 -- $ConstLiteral:invoke: "60"  
 pushc 60
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "60" :isBasicVal: true 
 -- case:B: 60 ObjectGenerator 9 1 1 false true 
 -- convDone: false 
 i2f
 -- end:loadArgs:NonVirt: "* 60" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:after:E.loadArgs "magnitude * 60" 
 -- OIadr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- IV:E.invoke:useRtnVal: true E: BinOp "magnitude * 60" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $BinOp:invoke: "magnitude * 60"  
 -- BinaryExp:invoke: "magnitude" rec: "magnitude * 60" 
 -- M: "* 60" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $ObjectInvocation_Binary:invoke: "* 60" >rec:"magnitude" ATd:"pattern" E:"* 60" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* 60" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "* 60" E: "* 60"  rec: "magnitude"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* 60" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* 60" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "magnitude" E: "* 60" 
 -- arg:integer 
 fmult
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"* 60":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"* 60":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * 60 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "base" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"bas ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "magnitude * 60" 
 -- isArgOfAssignI2IwithUniValArg "base.magnitude := magnitude * 60" arg: "magnitude * 60" ObjectGenerator 
 -- arg.super.arg: "magnitude * 60" BinOp 
 -- recx:BinaryExp:recx: "magnitude * 60" 
 -- M: "* 60" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "magnitude" E: "* 60" 
 -- arg:integer 
 -- M:arg: "60" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 105 
 -- Items:GenClass: fromPrimary descNo: 105 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 105 1 Minutes 102
 -- vdtTableCopy: I:1:50 I:2:0
 -- vdtAdd: inx=2 descInx=105 vDescInx=105 vdtTop: 2 
 -- Store itemArgs: magnitude := base.magnitude / 60 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super fromPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "magnitude := base.magnitude / 60" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: fromPrimary 
 -- Store itemArgs: magnitude := base.magnitude / 60 
 -- in base: var PrimaryUnit true 0 
 -- DI:store: "base" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  base 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=105 vDescInx=50 vdtTop: 2 
 -- $var:gen: "in base: var PrimaryUnit"  
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- genclass:stmt: "magnitude := base.magnitude / 60" 
 -- $Assign:gen: "magnitude := base.magnitude / 60"  
 -- assign: "magnitude := base.magnitude / 60" 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "fromPrimary" on: 1 isValueObj: false 
 -- origin: Minutes origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg fromPrimary$105 1
 rswap 0
 rdouble 0
 pushg 2 fromPrimary$105
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 fromPrimary$105
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "magnitude := base.magnitude / 60" right.label: "ObjectGenerator" "base.magnitude / 60" 
 -- $ObjectGenerator:gen: "base.magnitude / 60" >OGid:"/" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "base.magnitude / 60" 
 -- OG:before:super.gen: "base.magnitude / 60" 
 -- $Invocation:gen: "base.magnitude / 60" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude / 60" 
 -- isConstant: "Invocation" "base.magnitude / 60" 
 -- needorigin: "base.magnitude / 60" 
 -- needOrigin:E: "base.magnitude / 60"  E.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "base.magnitude / 60" 
 -- computeAdr:superAdj: 0 "base.magnitude / 60" 
 -- computeAdr: 1 :rec: "none"  E: "base.magnitude / 60" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "base.magnitude / 60"  
 -- $BinOp:loadOrigin: "base.magnitude / 60"  
 -- BinaryExp:loadOrigin:empty: "base.magnitude / 60" superAdj: 0 
 -- $BinOp:getAdr: "base.magnitude / 60"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "base.magnitude / 60" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "base.magnitude / 60" E:  "base.magnitude / 60" 
 -- INV:gen:E.loadArgs "base.magnitude / 60" 
 -- $BinOp:loadArgs: "base.magnitude / 60"  
 -- BinaryExp:loadArgs: "base.magnitude / 60" superAdj: 0 
 -- $Invocation:gen: "base.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude" 
 -- isConstant: "Invocation" "base.magnitude" 
 -- notConst: base in base: var PrimaryUnit 
 -- needorigin: "base.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"in base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "in base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "in base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- rec:  "base" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"base" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "base"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "base" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- $pattern:loadArgs: "/  : {   %basic 121;   in V: var float;   out R: var float" >E:"/ 60":descNo:99} 
 -- ptn:loadArgs:E "/ 60" 
 -- {(ObjectInvocation_Binary; (name: "/"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 60));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "60" 
 -- E: "ObjectGenerator" 60 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "/ 60" "ObjectInvocation_Binary" ActArg:  "60" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/ 60"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "60" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "60" 
 -- OG:before:super.gen: "60" 
 -- $Invocation:gen: "60" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "60" 
 -- isConstant: "Invocation" "60" 
 -- needorigin: "60" 
 -- needOrigin:E: "60"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "60" E:  "60" 
 -- INV:gen:E.loadArgs "60" 
 -- $ConstLiteral:loadArgs: "60"  
 -- INV:gen:after:E.loadArgs "60" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "60" 
 -- $ConstLiteral:invoke: "60"  
 pushc 60
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "60" :isBasicVal: true 
 -- case:B: 60 ObjectGenerator 9 1 1 false true 
 -- convDone: false 
 i2f
 -- end:loadArgs:NonVirt: "/ 60" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- INV:gen:after:E.loadArgs "base.magnitude / 60" 
 -- OIadr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- IV:E.invoke:useRtnVal: true E: BinOp "base.magnitude / 60" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- $BinOp:invoke: "base.magnitude / 60"  
 -- BinaryExp:invoke: "base.magnitude" rec: "base.magnitude / 60" 
 -- M: "/ 60" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- $ObjectInvocation_Binary:invoke: "/ 60" >rec:"base.magnitude" ATd:"pattern" E:"/ 60" E.ATd:"/  " unique:"False" 
 -- OI:invoke: "/ 60" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base.magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base.magnitude 
 -- OI:invoke:B: "/ 60" E: "/ 60"  rec: "base.magnitude"  useRtnV: true "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern /   
 -- $pattern:invoke: "/  : {   %basic 121;   in V: var float;   out R: var float" E: "/ 60" useRTNv: "True"} 
 -- ptn:invoke: "/  " E: "/ 60" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "base.magnitude" E: "/ 60" 
 -- arg:integer 
 fdiv
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ 60":rec:base.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ 60":rec:base.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: / 60 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "magnitude" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "base.magnitude / 60" 
 -- isArgOfAssignI2IwithUniValArg "magnitude := base.magnitude / 60" arg: "base.magnitude / 60" ObjectGenerator 
 -- arg.super.arg: "base.magnitude / 60" BinOp 
 -- recx:BinaryExp:recx: "base.magnitude / 60" 
 -- M: "/ 60" label: "ObjectInvocation_Binary" M.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "base.magnitude" E: "/ 60" 
 -- arg:integer 
 -- M:arg: "60" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- Address:store:originIsVal: 
 fovstoreg 1 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 106 
 -- Items:GenClass: print descNo: 106 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 106 1 Minutes 102
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=106 vDescInx=106 vdtTop: 2 
 -- Store itemArgs: "Minutes".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""Minutes".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "Minutes".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=106 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Minutes".print" 
 -- $ObjectGenerator:gen: ""Minutes".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Minutes".print" 
 -- OG:before:super.gen: ""Minutes".print" 
 -- $Invocation:gen: ""Minutes".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Minutes".print" 
 -- isConstant: "Invocation" ""Minutes".print" 
 -- needorigin: ""Minutes".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Minutes"" E:  ""Minutes"" 
 -- INV:gen:E.loadArgs ""Minutes"" 
 -- $String::loadArgs: ""Minutes""  
 -- INV:gen:after:E.loadArgs ""Minutes"" 
 -- OIadr: 
 -- $String::invoke: ""Minutes""  
 pushText "Minutes"
 -- IV:gen:checkTail: ""Minutes".print" E: ""Minutes"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Minutes"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Minutes""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 95 
 -- Items:GenClass: test descNo: 95 isValue: false 
 -- Items:GenClass: test descNo: 21 isValue: false 

 CLASS test 95 1 Velocity 90
 -- Store itemArgs: V: var MeterPerSecond{L: var Length.Meter;T: var Time.second;L := 10"m";L.print;newline;T := 20"s";T.print;newline;V := L / T;V.print} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=95 vDescInx=95 vdtTop: 1 
 mvStack 
 -- $var:gen: "V: var MeterPerSecond"  
 -- DI:gen: "V: var MeterPerSecond" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  V 
 -- $ObjectGenerator:gen: "MeterPerSecond" >OGid:"MeterPerSecond" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "MeterPerSecond" 
 -- OG:before:super.gen: "MeterPerSecond" 
 -- $Invocation:gen: "MeterPerSecond" >useRtnV:"False"superAdj: 0 descNo: 96 
 -- INV:gen: "MeterPerSecond" 
 -- isConstant: "Invocation" "MeterPerSecond" 
 -- needorigin: "MeterPerSecond" 
 -- needOrigin:E: "MeterPerSecond"  E.ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "MeterPerSecond" E:  "MeterPerSecond" 
 -- INV:gen:E.loadArgs "MeterPerSecond" 
 -- $ObjectInvocation_Unary:loadArgs: "MeterPerSecond" >staticOff:0 "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ..."} 
 -- $pattern:loadArgs: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" >E:"MeterPerSecond":desc ...} 
 -- ptn:loadArgs:E "MeterPerSecond" 
 -- {(ObjectInvocation_Unary; (name: "MeterPerSecond"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "MeterPerSecond" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "MeterPerSecond" 
 -- $ObjectInvocation_Unary:invoke: "MeterPerSecond" >rec:"MeterPerSecond" ATd:"pattern" isValueObj E:"MeterPerSecond" E.ATd:"MeterPerSecond" unique:"False" 
 -- OI:invoke: "MeterPerSecond" 
 -- 
 -- OI:invoke:B: "MeterPerSecond" E: "MeterPerSecond"  rec: "MeterPerSecond"  useRtnV: false "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit::  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern MeterPerSecond 
 -- $pattern:invoke: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" E: "MeterPerSecond" useRTN ...} 
 -- ptn:invoke: "MeterPerSecond" E: "MeterPerSecond" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  MeterPerSecond 96 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: MeterPerSecond :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "L: var Length.Meter"  
 -- DI:gen: "L: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- $ObjectGenerator:gen: "Length.Meter" >OGid:"Meter" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Length.Meter" 
 -- OG:before:super.gen: "Length.Meter" 
 -- $Invocation:gen: "Length.Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.Meter" 
 -- isConstant: "Invocation" "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Length" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 adr:none 
 invokeVal  Meter 74 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "T: var Time.second"  
 -- DI:gen: "T: var Time.second" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  T 
 -- $ObjectGenerator:gen: "Time.second" >OGid:"Second" IS.isempty! staticOff=6 descNo=0 superAdj=0 
 -- OG:gen: "Time.second" 
 -- OG:before:super.gen: "Time.second" 
 -- $Invocation:gen: "Time.second" >useRtnV:"False"superAdj: 0 descNo: 85 
 -- INV:gen: "Time.second" 
 -- isConstant: "Invocation" "Time.second" 
 -- needorigin: "Time.second" 
 -- needOrigin:E: "second"  E.ATd: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magn ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := b ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Time" E:  "second" 
 -- INV:gen:E.loadArgs "second" 
 -- $ObjectInvocation_Unary:loadArgs: "second" >staticOff:0 "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;    ..."} 
 -- $pattern:loadArgs: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := bas ..."} 
 -- ptn:loadArgs:E "second" 
 -- {(ObjectInvocation_Unary; (name: "second"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "second" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "second" 
 -- $ObjectInvocation_Unary:invoke: "second" >rec:"Time" ATd:"pattern" isValueObj E:"second" E.ATd:"Second" unique:"False" 
 -- OI:invoke: "second" 
 -- 
 -- OI:invoke:B: "second" E: "second"  rec: "Time"  useRtnV: false "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnit ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Second 
 -- $pattern:invoke: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base. ..."} 
 -- ptn:invoke: "Second" E: "second" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 adr:none 
 invokeVal  Second 85 5
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: second :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := 10"m"" 
 -- $Assign:gen: "L := 10"m""  
 -- assign: "L := 10"m"" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "L: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := 10"m"" right.label: "ObjectGenerator" "10"m"" 
 -- $ObjectGenerator:gen: "10"m"" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10"m"" 
 -- OG:before:super.gen: "10"m"" 
 -- $Invocation:gen: "10"m"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10"m"" 
 -- isConstant: "Invocation" "10"m"" 
 -- needorigin: "10"m"" 
 -- needOrigin:E: "10"m""  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V:  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10"m"" E:  "10"m"" 
 -- INV:gen:E.loadArgs "10"m"" 
 -- $ConstLiteral:loadArgs: "10"m""  
 -- INV:gen:after:E.loadArgs "10"m"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10"m"" 
 -- $ConstLiteral:invoke: "10"m""  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var Length.Meter" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "10"m"" 
 -- isArgOfAssignI2IwithUniValArg "L := 10"m"" arg: "10"m"" ObjectGenerator 
 -- arg.super.arg: "10"m"" ConstLiteral 
 -- dstDI: "L: var Length.Meter" 
 i2f
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "L.print" 
 -- $ObjectGenerator:gen: "L.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.print" 
 -- OG:before:super.gen: "L.print" 
 -- $Invocation:gen: "L.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "L.print" 
 -- isConstant: "Invocation" "L.print" 
 -- notConst: L L: var Length.Meter 
 -- needorigin: "L.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L.print" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "L: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "print"  A.E: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L: var Length.Meter" >E:"L" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "print"  rec: "L"  useRtnV: true "L: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var Length.Meter" E: "print">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- rec:  "L" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- OI:invoke:B: "print" E: "print"  rec: "L"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- isDI 
 -- isStatic: true rec: "L" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "T := 20"s"" 
 -- $Assign:gen: "T := 20"s""  
 -- assign: "T := 20"s"" 
 -- computeAdr:superAdj: 0 "T" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:6:on:0:superAdj:0"T: var Time.second":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "T: var Time.second" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: Time.second 
 -- before:floatTest:  "T: var Time.second" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- computeAdr:isLast:E:  "T" 
 -- AssignmentStatement:gen: "T := 20"s"" right.label: "ObjectGenerator" "20"s"" 
 -- $ObjectGenerator:gen: "20"s"" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "20"s"" 
 -- OG:before:super.gen: "20"s"" 
 -- $Invocation:gen: "20"s"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "20"s"" 
 -- isConstant: "Invocation" "20"s"" 
 -- needorigin: "20"s"" 
 -- needOrigin:E: "20"s""  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V:  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "20"s"" E:  "20"s"" 
 -- INV:gen:E.loadArgs "20"s"" 
 -- $ConstLiteral:loadArgs: "20"s""  
 -- INV:gen:after:E.loadArgs "20"s"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "20"s"" 
 -- $ConstLiteral:invoke: "20"s""  
 pushc 20
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "T" dstE: "T" dstE.ATd: "T: var Time.second" useRtn: false :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "20"s"" 
 -- isArgOfAssignI2IwithUniValArg "T := 20"s"" arg: "20"s"" ObjectGenerator 
 -- arg.super.arg: "20"s"" ConstLiteral 
 -- dstDI: "T: var Time.second" 
 i2f
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.print" 
 -- $ObjectGenerator:gen: "T.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T.print" 
 -- OG:before:super.gen: "T.print" 
 -- $Invocation:gen: "T.print" >useRtnV:"False"superAdj: 0 descNo: 89 
 -- INV:gen: "T.print" 
 -- isConstant: "Invocation" "T.print" 
 -- notConst: T T: var Time.second 
 -- needorigin: "T.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Second".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Second" 
 -- computeAdr:superAdj: 0 "T.print" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:6:on:0:superAdj:0"T: var Time.second":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "T: var Time.second" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: Time.second 
 -- before:floatTest:  "T: var Time.second" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "print"  A.E: "T" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Second".print":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue ...} 
 -- $pattern:getAdr: "print:: {   "Second".print" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: var Time.second" superAdj:0 
 -- $var:loadArgs: "T: var Time.second" >E:"T" 
 -- $pattern:loadArgs: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := bas ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- OI:invoke:B: "T" E: "print"  rec: "T"  useRtnV: true "T: var Time.second" 
 -- OI:invoke:before:ATdx.invoke: var T 
 -- $var:invoke: "T: var Time.second" E: "print">newOff:6 useRTNv: "True" 
 -- DI:invoke: "T: var Time.second" 
 -- isValueObj:isAdr: true objSize: 2  rec "T" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 6
 pushc 85
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- rec:  "T" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Second".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Second".print" >E:"print":descNo:89} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"T" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- origin:isValueObj "Second" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- OI:invoke:B: "print" E: "print"  rec: "T"  useRtnV: false "print:: {   "Second".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Second".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- isDI 
 -- isStatic: true rec: "T" 
 invoke print 89 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "V := L / T" 
 -- $Assign:gen: "V := L / T"  
 -- assign: "V := L / T" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"V: var MeterPerSecond":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "V: var MeterPerSecond" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- DI:OG: MeterPerSecond 
 -- before:floatTest:  "V: var MeterPerSecond" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := L / T" right.label: "ObjectGenerator" "L / T" 
 -- $ObjectGenerator:gen: "L / T" >OGid:"/" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L / T" 
 -- OG:before:super.gen: "L / T" 
 -- $Invocation:gen: "L / T" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L / T" 
 -- isConstant: "Invocation" "L / T" 
 -- needorigin: "L / T" 
 -- needOrigin:E: "L / T"  E.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "L / T" 
 -- computeAdr:superAdj: 0 "L / T" 
 -- computeAdr: 1 :rec: "none"  E: "L / T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L / T"  
 -- $BinOp:loadOrigin: "L / T"  
 -- BinaryExp:loadOrigin:empty: "L / T" superAdj: 0 
 -- $BinOp:getAdr: "L / T"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L / T" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L / T" E:  "L / T" 
 -- INV:gen:E.loadArgs "L / T" 
 -- $BinOp:loadArgs: "L / T"  
 -- BinaryExp:loadArgs: "L / T" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var Length.Meter 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "L: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L: var Length.Meter" >E:"L" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var Length.Meter" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L" ,E: "L" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "/  : {   %basic 121;   in V: var float;   out R: var float" >E:"/ T":descNo:99} 
 -- ptn:loadArgs:E "/ T" 
 -- {(ObjectInvocation_Binary; (name: "/"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "T");     (Arguments)));   (Items descNo: 0 or ...} 
 -- args: "T" 
 -- E: "ObjectGenerator" T 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "/ T" "ObjectInvocation_Binary" ActArg:  "T" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/ T"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "T" >OGid:"Second" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T" 
 -- OG:before:super.gen: "T" 
 -- $Invocation:gen: "T" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "T" 
 -- isConstant: "Invocation" "T" 
 -- notConst: T T: var Time.second 
 -- needorigin: "T" 
 -- needOrigin:E: "T"  E.ATd: "T: var Time.second" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "T" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:6:on:0:superAdj:0"T: var Time.second":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "T: var Time.second" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: Time.second 
 -- before:floatTest:  "T: var Time.second" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- computeAdr:isLast:E:  "T" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- rec:  "T" E:  "T" 
 -- INV:gen:E.loadArgs "T" 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: var Time.second" superAdj:0 
 -- $var:loadArgs: "T: var Time.second" >E:"T" 
 -- $pattern:loadArgs: "Second: Unit{   %unit "s", 1;   %public;   thisUnit:: Second;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := bas ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "T" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "T" :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"var" isValueObj E:"T" E.ATd:"T" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- OI:invoke:B: "T" E: "T"  rec: "T"  useRtnV: true "T: var Time.second" 
 -- OI:invoke:before:ATdx.invoke: var T 
 -- $var:invoke: "T: var Time.second" E: "T">newOff:6 useRTNv: "True" 
 -- DI:invoke: "T: var Time.second" 
 -- isValueObj:isAdr: false objSize: 2  rec "T" ,E: "T" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 6 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: T 
 -- end:loadArgs:NonVirt: "/ T" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L / T" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L / T" :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L / T"  
 -- BinaryExp:invoke: "L" rec: "L / T" 
 -- M: "/ T" :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "/ T" >rec:"L" ATd:"pattern" E:"/ T" E.ATd:"/  " unique:"False" 
 -- OI:invoke: "/ T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "float" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "/ T" E: "/ T"  rec: "L"  useRtnV: true "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern /   
 -- $pattern:invoke: "/  : {   %basic 121;   in V: var float;   out R: var float" E: "/ T" useRTNv: "True"} 
 -- ptn:invoke: "/  " E: "/ T" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "/ T" 
 -- arg:unit 
 -- rec:other: 
 fdiv
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ T":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ T":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: / T :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "V" dstE: "V" dstE.ATd: "V: var MeterPerSecond" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "L / T" 
 -- isArgOfAssignI2IwithUniValArg "V := L / T" arg: "L / T" ObjectGenerator 
 -- arg.super.arg: "L / T" BinOp 
 -- recx:BinaryExp:recx: "L / T" 
 -- M: "/ T" label: "ObjectInvocation_Binary" M.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "L" E: "/ T" 
 -- arg:unit 
 -- rec:other: 
 -- M:arg: "T" ObjectGenerator false 
 -- dstDI: "V: var MeterPerSecond" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -3 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "V.print" 
 -- $ObjectGenerator:gen: "V.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V.print" 
 -- OG:before:super.gen: "V.print" 
 -- $Invocation:gen: "V.print" >useRtnV:"False"superAdj: 0 descNo: 100 
 -- INV:gen: "V.print" 
 -- isConstant: "Invocation" "V.print" 
 -- notConst: V V: var MeterPerSecond 
 -- needorigin: "V.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "MpS".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "MeterPerSecond" 
 -- computeAdr:superAdj: 0 "V.print" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"V: var MeterPerSecond":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "V: var MeterPerSecond" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue ... 
 -- DI:OG: MeterPerSecond 
 -- before:floatTest:  "V: var MeterPerSecond" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr: 2 :rec: "V"  E: "print"  A.E: "V" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "MpS".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T  ...} 
 -- $pattern:getAdr: "print:: {   "MpS".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var MeterPerSecond" superAdj:0 
 -- $var:loadArgs: "V: var MeterPerSecond" >E:"V" 
 -- $pattern:loadArgs: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" >E:"V":descNo:96} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "print"  rec: "V"  useRtnV: true "V: var MeterPerSecond" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var MeterPerSecond" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "V: var MeterPerSecond" 
 -- isValueObj:isAdr: true objSize: 2  rec "V" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 96
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "V" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- rec:  "V" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "MpS".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "MpS".print" >E:"print":descNo:100} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"V" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- origin:isValueObj "MeterPerSecond" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- OI:invoke:B: "print" E: "print"  rec: "V"  useRtnV: false "print:: {   "MpS".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "MpS".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- isDI 
 -- isStatic: true rec: "V" 
 invoke print 100 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -3 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 L2:
 -- pushReturn:  "test" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 98 
 -- Items:GenClass: newline descNo: 98 isValue: false 
 -- Items:GenClass: newline descNo: 21 isValue: false 

 CLASS newline 98 0 BETA 2
 -- Store itemArgs: %globals{put(10)} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=98 vDescInx=98 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "put(10)" 
 -- $ObjectGenerator:gen: "put(10)" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put(10)" 
 -- OG:before:super.gen: "put(10)" 
 -- $Invocation:gen: "put(10)" >useRtnV:"False"superAdj: 0 descNo: 54 
 -- INV:gen: "put(10)" 
 -- isConstant: "Invocation" "put(10)" 
 -- needorigin: "put(10)" 
 -- needOrigin:E: "put(10)"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put(10)" E:  "put(10)" 
 -- INV:gen:E.loadArgs "put(10)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(10)" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"10"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put(10)":descNo:54} 
 -- ptn:loadArgs:E "put(10)" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 10));   (Items descNo: 0 origDescNo ...} 
 -- args: "put(10)" 
 -- E: "ObjectGenerator" 10 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put(10)" "ObjectInvocation_KeyWord" ActArg:  "10" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(10)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "10" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "10" 
 -- OG:before:super.gen: "10" 
 -- $Invocation:gen: "10" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "10" 
 -- isConstant: "Invocation" "10" 
 -- needorigin: "10" 
 -- needOrigin:E: "10"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "10" E:  "10" 
 -- INV:gen:E.loadArgs "10" 
 -- $ConstLiteral:loadArgs: "10"  
 -- INV:gen:after:E.loadArgs "10" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "10" 
 -- $ConstLiteral:invoke: "10"  
 pushc 10
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "10" :isBasicVal: true 
 -- case:B: 10 ObjectGenerator 3 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "put(10)" 
 -- INV:gen:after:E.loadArgs "put(10)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(10)" 
 -- $ObjectInvocation_KeyWord:invoke: "put(10)" >rec:"put(10)" ATd:"pattern" E:"put(10)" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put(10)" 
 -- 
 -- OI:invoke:B: "put(10)" E: "put(10)"  rec: "put(10)"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put(10)" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put(10)" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put(10) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "newline" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:0 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 107 
 -- Items:GenClass: StringLib descNo: 107 isValue: false 
 -- Items:GenClass: StringLib descNo: 21 isValue: false 

 CLASS StringLib 107 1 LIB 33
 -- Store itemArgs: %id "String module"{%module LIB;%public;String: Value;   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: v ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=107 vDescInx=107 vdtTop: 1 
 saveStringOrigin
 mvStack 
 -- $Property:gen: "%id "String module""  
 -- $Property:gen: "%module LIB"  
 -- $Property:gen: "%public"  
 -- $pattern:gen: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actually  ..."} 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "String module"" 
 -- $Property:gen: "%id "String module""  
 -- genclass:stmt: "%module LIB" 
 -- $Property:gen: "%module LIB"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "StringLib" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 18 
 -- Items:GenClass: $18 descNo: 18 isValue: false 
 -- Items:GenClass: $18 descNo: 21 isValue: false 

 CLASS $18 18 1 loop 14
 -- Store itemArgs: leave(loop) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=18 vDescInx=18 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "leave(loop)" 
 -- $ObjectGenerator:gen: "leave(loop)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(loop)" 
 -- OG:before:super.gen: "leave(loop)" 
 -- $Invocation:gen: "leave(loop)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(loop)" 
 -- isConstant: "Invocation" "leave(loop)" 
 -- needorigin: "leave(loop)" 
 -- needOrigin:E: "leave(loop)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(loop)" 
 -- computeAdr:superAdj: 0 "leave(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(loop)" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(loop)" >ATd.off:0 (isPtn):on:5:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "leave(loop)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- computeAdr:isLast:E:  "leave(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- rec:  "leave(loop)" E:  "leave(loop)" 
 -- INV:gen:E.loadArgs "leave(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(loop)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(loop)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loo ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(loop)" >rec:"leave(loop)" ATd:"pattern" E:"leave(loop)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:B: "leave(loop)" E: "leave(loop)"  rec: "leave(loop)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(loop)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(loop)" ptnKind: 0 useRtnV: false 
 break  1 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:C: leave(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 108 
 -- Items:GenClass: Boolean descNo: 108 isValue: true 
 -- Items:GenClass: Boolean descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Boolean 108 0 BETA 2 isValueObj
 -- Store itemArgs: %id "Boolean"{%globals inSub;%basic 4, 8;%public;_thisBasicValue: var Universal;&&  : ;   %basic 70;   in B: var boolean;   out R: var boolean;||  : ;   %b ...} 
 -- vdtAdd: inx=1 descInx=108 vDescInx=108 vdtTop: 1 
 -- $Property:gen: "%id "Boolean""  
 -- $Property:gen: "%globals inSub"  
 -- $Property:gen: "%basic 4, 8"  
 -- $Property:gen: "%public"  
 -- $var:gen: "_thisBasicValue: var Universal"  
 -- DI:gen: "_thisBasicValue: var Universal" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  _thisBasicValue 
DO:
 L1:
 -- genclass:stmt: "%id "Boolean"" 
 -- $Property:gen: "%id "Boolean""  
 -- genclass:stmt: "%globals inSub" 
 -- $Property:gen: "%globals inSub"  
 -- genclass:stmt: "%basic 4, 8" 
 -- $Property:gen: "%basic 4, 8"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Boolean" 
 rtnV
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 23 
 -- Items:GenClass: True descNo: 23 isValue: false 
 -- Items:GenClass: True descNo: 21 isValue: false 

 CLASS True 23 0 BETA 2
 -- Store itemArgs: %globals{out B: var boolean;B := 1} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=23 vDescInx=23 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out B: var boolean"  
 -- DI:gen: "out B: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "B := 1" 
 -- $Assign:gen: "B := 1"  
 -- assign: "B := 1" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:1:on:0:superAdj:0"out B: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var boolean" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out B: var boolean" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := 1" right.label: "ObjectGenerator" "1" 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var boolean" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "1" 
 -- isArgOfAssignI2IwithUniValArg "B := 1" arg: "1" ObjectGenerator 
 -- arg.super.arg: "1" ConstLiteral 
 -- dstDI: "out B: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg True$23 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "True" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 24 
 -- Items:GenClass: repeat$24 descNo: 24 isValue: false 
 -- Items:GenClass: repeat$24 descNo: 21 isValue: false 

 CLASS repeat$24 24 1 for:to:repeat$30 30
 -- Store itemArgs: c1 := get[inx]{c2 := Veq.get[inx];if (c1 <> c2) :then ;   Beq := false;   leave(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=24 vDescInx=24 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "c1 := get[inx]" 
 -- $Assign:gen: "c1 := get[inx]"  
 -- assign: "c1 := get[inx]" 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:2:on:2:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- AssignmentStatement:gen: "c1 := get[inx]" right.label: "ObjectGenerator" "get[inx]" 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 4 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:4:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 1 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$30$30
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "c1" dstE: "c1" dstE.ATd: "c1: var char" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c1 := get[inx]" arg: "get[inx]" ObjectGenerator 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- dstDI: "c1: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "c2 := Veq.get[inx]" 
 -- $Assign:gen: "c2 := Veq.get[inx]"  
 -- assign: "c2 := Veq.get[inx]" 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:3:on:2:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx]" right.label: "ObjectGenerator" "Veq.get[inx]" 
 -- $ObjectGenerator:gen: "Veq.get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx]" 
 -- $Invocation:gen: "Veq.get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "Veq.get[inx]" 
 -- isConstant: "Invocation" "Veq.get[inx]" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "Veq.get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 3 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:3:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 3 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:2 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "Veq" E: "get[inx]"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "get[inx]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "get[inx]" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg repeat$24$24 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec:  "Veq" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 1 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$30$30
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"Veq" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "Veq"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec: "c2" dstE: "c2" dstE.ATd: "c2: var char" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "Veq.get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c2 := Veq.get[inx]" arg: "Veq.get[inx]" ObjectGenerator 
 -- arg.super.arg: "Veq" ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- recx: "Veq" argx: "get[inx]" 
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- dstDI: "c2: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$14 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $ObjectGenerator:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OG:before:super.gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $Invocation:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- isConstant: "Invocation" "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- needorigin: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- needOrigin:E: "if (c1 <> c2) :then {   Beq := false;   leave(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100; ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" E:  "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- INV:gen:E.loadArgs "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $IfThen:loadArgs: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" } 
 -- INV:gen:after:E.loadArgs "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 <> c2) :then {   Beq := false;   leave(loop)}" 
 -- $IfThen:invoke: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" } 
 -- $IfThen:gen: "if (c1 <> c2) :then {   Beq := false;   leave(loop)" } 
 -- $ObjectGenerator:gen: "(c1 <> c2)" >OGid:"<>" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(c1 <> c2)" 
 -- OG:before:super.gen: "(c1 <> c2)" 
 -- $Invocation:gen: "(c1 <> c2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(c1 <> c2)" 
 -- isConstant: "Invocation" "(c1 <> c2)" 
 -- needorigin: "(c1 <> c2)" 
 -- needOrigin:E: "(c1 <> c2)"  E.ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(c1 <> c2)" 
 -- computeAdr:superAdj: 0 "(c1 <> c2)" 
 -- computeAdr: 1 :rec: "none"  E: "(c1 <> c2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(c1 <> c2)"  
 -- $BracketedExp:loadOrigin: "(c1 <> c2)"  
 -- computeAdr:superAdj: 0 "c1 <> c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 <> c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 <> c2"  
 -- $BinOp:loadOrigin: "c1 <> c2"  
 -- BinaryExp:loadOrigin:empty: "c1 <> c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 <> c2"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 <> c2"  ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 <> c2" 
 -- BE:loadOrigin:E: c1 <> c2 
 -- $BinOp:getAdr: "c1 <> c2"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 <> c2"  ATd: "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 <> c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 <> c2" E:  "c1 <> c2" 
 -- INV:gen:E.loadArgs "c1 <> c2" 
 -- $BinOp:loadArgs: "c1 <> c2"  
 -- BinaryExp:loadArgs: "c1 <> c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:2:on:2:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:2 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 2 loop$14
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "<>  : {   %basic 55;   in V: var char;   out B: var boolean" >E:"<> c2":descNo:25} 
 -- ptn:loadArgs:E "<> c2" 
 -- {(ObjectInvocation_Binary; (name: "<>"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in V: var char 
 -- NonVirt: "<> c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "<> c2"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$24" on: 2 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:3:on:2:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 3 loop$14
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- formalArg:isPtn: "in V: var char" :isBasicVal: true :valueObj: true 
 -- :actArg: "c2" :isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "<> c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 <> c2" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 <> c2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 <> c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 <> c2" 
 -- M: "<> c2" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "<> c2" >rec:"c1" ATd:"pattern" E:"<> c2" E.ATd:"<>  " unique:"False" 
 -- OI:invoke: "<> c2" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "char" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "<> c2" E: "<> c2"  rec: "c1"  useRtnV: true "<>  : {   %basic 55;   in V: var char;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <>   
 -- $pattern:invoke: "<>  : {   %basic 55;   in V: var char;   out B: var boolean" E: "<> c2" useRTNv: "True"} 
 -- ptn:invoke: "<>  " E: "<> c2" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "c1" E: "<> c2" 
 -- arg:other 
 ne
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<> c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <> c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "Beq := false{   leave(loop)" >OGid:"$26" singular! staticOff=0 descNo=26 superAdj=0} 
 -- OG:gen: "Beq := false{   leave(loop)}" 
 pushThis 
 -- before objTmpStack:add:  26   "$26" 
 invoke $26 26 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 26 
 -- Items:GenClass: $26 descNo: 26 isValue: false 
 -- Items:GenClass: $26 descNo: 21 isValue: false 

 CLASS $26 26 1 repeat$24 24
 -- Store itemArgs: Beq := false{leave(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=26 vDescInx=26 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := false" 
 -- $Assign:gen: "Beq := false"  
 -- assign: "Beq := false" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$26" on: 4 isValueObj: false 
 -- origin: repeat$24 origin:isValueObj: false 
 rpushg $26$26 1
 -- items:goOrigin:encOG: "repeat$24" on: 3 isValueObj: false 
 -- origin: for:to:repeat$30 origin:isValueObj: false 
 rpushg repeat$24$24 1
 -- items:goOrigin:encOG: "for:to:repeat$30" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg for:to:repeat$30$30 4
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := false" right.label: "ObjectGenerator" "false" 
 -- $ObjectGenerator:gen: "false" >OGid:"False" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "false" 
 -- OG:before:super.gen: "false" 
 -- $Invocation:gen: "false" >useRtnV:"True"superAdj: 0 descNo: 27 
 -- INV:gen: "false" 
 -- isConstant: "Invocation" "false" 
 -- needorigin: "false" 
 -- needOrigin:E: "false"  E.ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   out B: var boolean;   B := 0}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "false" E:  "false" 
 -- INV:gen:E.loadArgs "false" 
 -- $ObjectInvocation_Unary:loadArgs: "false" >staticOff:0 "False: {   %globals;   out B: var boolean;   B := 0" superAdj:0} 
 -- $pattern:loadArgs: "False: {   %globals;   out B: var boolean;   B := 0" >E:"false":descNo:27} 
 -- ptn:loadArgs:E "false" 
 -- {(ObjectInvocation_Unary; (name: "false"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "false" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false" 
 -- $ObjectInvocation_Unary:invoke: "false" >rec:"false" ATd:"pattern" E:"false" E.ATd:"False" unique:"False" 
 -- OI:invoke: "false" 
 -- 
 -- OI:invoke:B: "false" E: "false"  rec: "false"  useRtnV: true "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- $pattern:invoke: "False: {   %globals;   out B: var boolean;   B := 0" E: "false" useRTNv: "True"} 
 -- ptn:invoke: "False" E: "false" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: false :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "false" 
 -- isArgOfAssignI2IwithUniValArg "Beq := false" arg: "false" ObjectGenerator 
 -- arg.super.arg: "false" ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg =$13 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(loop)" 
 -- $ObjectGenerator:gen: "leave(loop)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(loop)" 
 -- OG:before:super.gen: "leave(loop)" 
 -- $Invocation:gen: "leave(loop)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(loop)" 
 -- isConstant: "Invocation" "leave(loop)" 
 -- needorigin: "leave(loop)" 
 -- needOrigin:E: "leave(loop)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(loop)" 
 -- computeAdr:superAdj: 0 "leave(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(loop)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(loop)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(loop)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- computeAdr:isLast:E:  "leave(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:- 
 -- rec:  "leave(loop)" E:  "leave(loop)" 
 -- INV:gen:E.loadArgs "leave(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(loop)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(loop)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loo ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(loop)" >rec:"leave(loop)" ATd:"pattern" E:"leave(loop)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- OI:invoke:B: "leave(loop)" E: "leave(loop)"  rec: "leave(loop)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(loop)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(loop)" ptnKind: 0 useRtnV: false 
 break  3 2 14 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 -- 
 -- OI:invoke:C: leave(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(loop)":rec:leave(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 27 
 -- Items:GenClass: False descNo: 27 isValue: false 
 -- Items:GenClass: False descNo: 21 isValue: false 

 CLASS False 27 0 BETA 2
 -- Store itemArgs: %globals{out B: var boolean;B := 0} 
 allocEventQ
 -- vdtAdd: inx=1 descInx=27 vDescInx=27 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $var:gen: "out B: var boolean"  
 -- DI:gen: "out B: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  B 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "B := 0" 
 -- $Assign:gen: "B := 0"  
 -- assign: "B := 0" 
 -- computeAdr:superAdj: 0 "B" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:1:on:0:superAdj:0"out B: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out B: var boolean" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F o ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out B: var boolean" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr:isLast:E:  "B" 
 -- AssignmentStatement:gen: "B := 0" right.label: "ObjectGenerator" "0" 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "B" dstE: "B" dstE.ATd: "out B: var boolean" useRtn: false :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "0" 
 -- isArgOfAssignI2IwithUniValArg "B := 0" arg: "0" ObjectGenerator 
 -- arg.super.arg: "0" ConstLiteral 
 -- dstDI: "out B: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg False$27 1
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "False" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 30 
 -- Items:GenClass: for:to:repeat$30 descNo: 30 isValue: false 
 -- Items:GenClass: for:to:repeat$30 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$30 30 4 loop 14
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);" >stati ...} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" length 
 -- E: "ObjectGenerator" c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)} 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" "ObjectInvocation_KeyWord" ActAr ... "1 ..." i ... true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"  isComposit ... false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" "ObjectInvocation_KeyWord" ActAr ... "l ..." i ... false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}"  isComposit ... false 
 -- $ObjectGenerator:gen: "length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "length" 
 -- OG:before:super.gen: "length" 
 -- $Invocation:gen: "length" >useRtnV:"True"superAdj: 4 descNo: 15 
 -- INV:gen: "length" 
 -- isConstant: "Invocation" "length" 
 -- needorigin: "length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 4 "length" 
 -- computeAdr: 1 :rec: "none"  E: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length" >on:2 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg loop$14 4
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: = origin:isValueObj: false 
 rpushg loop$14 1
 -- items:goOrigin:encOG: "=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg =$13 1
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:2:superAdj:4"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- rec:  "length" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:4} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"length" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:B: "length" E: "length"  rec: "length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"length":rec:length 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "length" :isBasicVal: true 
 -- case:B: length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- args:  "repeat:< object" "c1 := get[inx]{   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop)}" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=30 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(length):repeat{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 <> c2) :then ;      Beq := false;      leave(loop);}" 
 -- vdtAdd: inx=2 descInx=30 vDescInx=24 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 109 
 -- Items:GenClass: <= descNo: 109 isValue: false 
 -- Items:GenClass: <= descNo: 58 isValue: false 
 -- Items:GenClass: <= descNo: 21 isValue: false 
 -- got:sub:vEq:  52  isValueObj:  false 5 
 -- OG:reAlloc: descNo: 0 21 "%basic 52{   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OG:reAlloc: descNo: 0 0 "%ID Object{   %basic 64;   %public;   ==  : ;      %basic 56;      in objx: ref Object;      out V: var boolean;   =/=  : ;      %basic 57;      i ...}" 
 -- Pattern:Qalloc: == 
 -- Pattern:Qalloc: =/= 
 -- Pattern:Qalloc: suspend 
 -- Pattern:Qalloc: attach 
 -- Pattern:Qalloc: call 
 -- Pattern:Qalloc: resume 
 -- Pattern:Qalloc: onResume 
 -- Pattern:Qalloc: onSuspend 
 -- Pattern:Qalloc: dumpObj 
 -- Pattern:Qalloc: X_asString 
 -- Pattern:Qalloc:B: X_asString 
 -- dataitem:qalloc: "Veq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: false 
 -- diSize: 1 IT.qSize: 4 
 -- Items:Qalloc:objSize: 4  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 4  newDescNo: 0 "" 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 5 
 -- Items:Qalloc:objSize: 5  newDescNo: 0 "" 
 -- Items:Qalloc:END:objSize: 5  newDescNo: 0 "" 

 CLASS <= 58 1 Value 4
 -- Store itemArgs: %basic 52{in Veq: var this(Value);out Beq: var boolean} 
 -- in Veq: var this(Value) true 18 
 -- DI:store: "Veq" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: Veq off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  Veq 31 3
 L4:
 -- Store:Origin: 21 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=58 vDescInx=58 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 52"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 52" 
 -- $Property:gen: "%basic 52"  
 L2:
 -- pushReturn:  "<=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- got:sub:vEq:  52  isValueObj:  false 6 
 -- OG:reAlloc: descNo: 0 5 "loop: obj {      -- "Hello"  <= "World" since H <= W;      -- "Qweabc" <= "Qwevwxy" since a <= e;      -- "Qweayc" <= "Qwexby";      -- "Qwe"    < ...}" 
 -- OG:reAlloc:String: 
 -- currentDcl:this: 
 -- reAllocatedOff: "Veq" 2 
 -- dataitem:qalloc: "Beq" isValue: true  isPrimitive: true  isValObj:  true  isBasicValue: true 
 -- diSize: 1 IT.qSize: 3 
 -- reAllocatedOff: "Beq" 3 
 -- dataitem:qalloc: "loop" isValue: false  isPrimitive: false  isValObj:  false  isBasicValue: false 
 -- DI:Qalloc:off: 4 "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Q ..."}" 
 -- OG:Qalloc: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - fa ...}" q ... 110 
 -- reAllocatedOff: "loop" 4 

 CLASS <= 109 1 String 10
 -- vdtTableCopy: I:1:58
 -- Store itemArgs: loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwe ..."} 
 -- Store:Origin: 5 
 rShiftUp  1
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- super <=
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwer ..."}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 rShiftDown  1
 -- hArgOrg:super: <= 
 -- Store itemArgs: loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwe ..."} 
 -- in Veq: var this(Value) true 18 
 pushThis 
 rstoreg  Veq 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=109 vDescInx=58 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 52"  
 -- $var:gen: "in Veq: var this(Value)"  
 -- DI:gen: "in Veq: var this(Value)" DI:isConst: false :isBasicValue: false :primNo: 18 
 -- DI:add:BP4:  Veq 
 -- inArg: in Veq: var this(Value) 
 -- $var:gen: "out Beq: var boolean"  
 -- DI:gen: "out Beq: var boolean" DI:isConst: false :isBasicValue: true :primNo: 4 
 -- DI:add:BP1:  Beq 
 -- $obj:gen: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty"  ..."} 
 -- DI:gen: "loop: obj {   -- "Hello"  <= "World" since H <= W;   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= ...}" D ... true : ... false : ... 0 
 -- DI:add:BP4:  loop 
 -- $ObjectGenerator:gen: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= ..."} 
 -- OG:gen: "-- "Hello"  <= "World" since H <= W{   -- "Qweabc" <= "Qwevwxy" since a <= e;   -- "Qweayc" <= "Qwexby";   -- "Qwe"    <= "Qwerty";   -- "Qwerty" <= "Qwe" - false ...}" 
 pushThis 
 -- before objTmpStack:add:  110   "loop" 
 invoke loop 110 4 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "<=" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 110 
 -- Items:GenClass: loop descNo: 110 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 110 1 <= 109
 -- Store itemArgs: -- "Hello"  <= "World" since H <= W{-- "Qweabc" <= "Qwevwxy" since a <= e;-- "Qweayc" <= "Qwexby";-- "Qwe"    <= "Qwerty";-- "Qwerty" <= "Qwe" - false;-- " ..."} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=110 vDescInx=110 vdtTop: 1 
 mvStack 
 -- $var:gen: "L: var integer"  
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 -- $var:gen: "L1: var integer"  
 -- DI:gen: "L1: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L1 
 -- $var:gen: "L2: var integer"  
 -- DI:gen: "L2: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L1 := length{-- min length of this and V}" 
 -- $Assign:gen: "L1 := length{-- min length of this and V" } 
 -- assign: "L1 := length{-- min length of this and V}" 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:0:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- AssignmentStatement:gen: "L1 := length{-- min length of this and V}" right.label: "ObjectGenerator" "length{-- min length of this and V}" 
 -- $ObjectGenerator:gen: "length{-- min length of this and V" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "length{-- min length of this and V}" 
 -- OG:before:super.gen: "length{-- min length of this and V}" 
 -- $Invocation:gen: "length{-- min length of this and V" >useRtnV:"True"superAdj: 0 descNo: 15} 
 -- INV:gen: "length{-- min length of this and V}" 
 -- isConstant: "Invocation" "length{-- min length of this and V}" 
 -- needorigin: "length{-- min length of this and V}" 
 -- needOrigin:E: "length{-- min length of this and V}"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length{-- min length of this and V}" 
 -- computeAdr:superAdj: 0 "length{-- min length of this and V}" 
 -- computeAdr: 1 :rec: "none"  E: "length{-- min length of this and V}" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "length{-- min length of this and V" } 
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "length{-- min length of this and V" >on:2 superAdj:0 isValueObj:"False"} 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- items:goOrigin:encOG: "<=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg <=$109 1
 -- $ObjectInvocation_Unary:getAdr: "length{-- min length of this and V" >ATd.off:0 (isPtn):on:2:superAdj:0"length: ;   out V: var integer;   V := get[0] -- actually an index  ..."} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:-} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "length{-- min length of this and V}"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:-} 
 -- computeAdr:isLast:E:  "length{-- min length of this and V}" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:-} 
 -- rec:  "length{-- min length of this and V}" E:  "length{-- min length of this and V}" 
 -- INV:gen:E.loadArgs "length{-- min length of this and V}" 
 -- $ObjectInvocation_Unary:loadArgs: "length{-- min length of this and V" >staticOff:0 "length: ;   out V: var integer;   V := get[0] -- actually an index error, accessing le ..."} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length;-- min length of this and V":descNo:15} 
 -- ptn:loadArgs:E "length{-- min length of this and V}" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments --<14> min length of this and V))} 
 -- args: "-- min length of this and V" 
 -- INV:gen:after:E.loadArgs "length{-- min length of this and V}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length{-- min length of this and V}" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $ObjectInvocation_Unary:invoke: "length{-- min length of this and V" >rec:"length;-- min length of this and V" ATd:"pattern" E:"length;-- min length of this and V" E.ATd:" ..."} 
 -- OI:invoke: "length{-- min length of this and V}" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V} 
 -- OI:invoke:B: "length{-- min length of this and V}" E: "length{-- min length of this and V}"  rec: "length{-- min length of this and V}"  useRtnV: true "length: {   out V:  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length;-- min length of this and V" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length{-- min length of this and V}" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":re ...} 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min l ...} 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length o ...} 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V ...} 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length o ...} 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this and V ...} 
 -- OI:invoke:C: length{-- min length of this and V} :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length{-- min length of this and V":rec:length;-- min length of this ...} 
 -- rec: "L1" dstE: "L1" dstE.ATd: "L1: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "length{-- min length of this and V}" 
 -- isArgOfAssignI2IwithUniValArg "L1 := length{-- min length of this and V}" arg: "length{-- min length of this and V}" ObjectGenerator 
 -- arg.super.arg: "length{-- min length of this and V}" ObjectInvocation_Unary 
 -- dstDI: "L1: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$110 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "L2 := Veq.length" 
 -- $Assign:gen: "L2 := Veq.length"  
 -- assign: "L2 := Veq.length" 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:0:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- AssignmentStatement:gen: "L2 := Veq.length" right.label: "ObjectGenerator" "Veq.length" 
 -- $ObjectGenerator:gen: "Veq.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.length" 
 -- OG:before:super.gen: "Veq.length" 
 -- $Invocation:gen: "Veq.length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "Veq.length" 
 -- isConstant: "Invocation" "Veq.length" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "Veq.length" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:1:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 matchEq: {      inx: var integer;      c1: var char;      c2: var char;      isEmpty: do ;         if (L1 = 0) :then ;            Beq := L1 <= L2;            ...} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "Veq" E: "length"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "length" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 rpushg loop$110 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec:  "Veq" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"Veq" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:B: "length" E: "length"  rec: "Veq"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:Veq 
 -- rec: "L2" dstE: "L2" dstE.ATd: "L2: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "Veq.length" 
 -- isArgOfAssignI2IwithUniValArg "L2 := Veq.length" arg: "Veq.length" ObjectGenerator 
 -- arg.super.arg: "Veq" ObjectInvocation_Unary 
 -- arg.super.arg: "length" ObjectInvocation_Unary 
 -- recx: "Veq" argx: "length" 
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "length" 
 -- dstDI: "L2: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$110 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $ObjectGenerator:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OG:before:super.gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $Invocation:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- isConstant: "Invocation" "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- needorigin: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- needOrigin:E: "if (L1 < L2) :then {   L := L1;:else ;   L := L2}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;    ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" E:  "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- INV:gen:E.loadArgs "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $IfThenElse:loadArgs: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" } 
 -- INV:gen:after:E.loadArgs "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (L1 < L2) :then {   L := L1;:else ;   L := L2}" 
 -- $IfThenElse:invoke: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" } 
 -- $IfThenElse:gen: "if (L1 < L2) :then {   L := L1;:else ;   L := L2" } 
 -- $ObjectGenerator:gen: "(L1 < L2)" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L1 < L2)" 
 -- OG:before:super.gen: "(L1 < L2)" 
 -- $Invocation:gen: "(L1 < L2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L1 < L2)" 
 -- isConstant: "Invocation" "(L1 < L2)" 
 -- needorigin: "(L1 < L2)" 
 -- needOrigin:E: "(L1 < L2)"  E.ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(L1 < L2)" 
 -- computeAdr:superAdj: 0 "(L1 < L2)" 
 -- computeAdr: 1 :rec: "none"  E: "(L1 < L2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L1 < L2)"  
 -- $BracketedExp:loadOrigin: "(L1 < L2)"  
 -- computeAdr:superAdj: 0 "L1 < L2" 
 -- computeAdr: 1 :rec: "none"  E: "L1 < L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 < L2"  
 -- $BinOp:loadOrigin: "L1 < L2"  
 -- BinaryExp:loadOrigin:empty: "L1 < L2" superAdj: 0 
 -- $BinOp:getAdr: "L1 < L2"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 < L2" 
 -- BE:loadOrigin:E: L1 < L2 
 -- $BinOp:getAdr: "L1 < L2"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 < L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L1 < L2" E:  "L1 < L2" 
 -- INV:gen:E.loadArgs "L1 < L2" 
 -- $BinOp:loadArgs: "L1 < L2"  
 -- BinaryExp:loadArgs: "L1 < L2" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:0:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$110
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 < L2" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" >E:"< L2":descNo:111} 
 -- ptn:loadArgs:E "< L2" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "L2" 
 -- E: "ObjectGenerator" L2 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "< L2" "ObjectInvocation_Binary" ActArg:  "L2" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L2"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:0:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$110
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L2" :isBasicVal: true 
 -- case:B: L2 ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 < L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 < L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 < L2"  
 -- BinaryExp:invoke: "L1" rec: "L1 < L2" 
 -- M: "< L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "< L2" >rec:"L1" ATd:"pattern" E:"< L2" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< L2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "integer" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "< L2" E: "< L2"  rec: "L1"  useRtnV: true "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" E: "< L2" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< L2" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "< L2" 
 -- arg:other 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "L := L1" >OGid:"$112" singular! staticOff=0 descNo=112 superAdj=0 
 -- OG:gen: "L := L1" 
 pushThis 
 -- before objTmpStack:add:  112   "$112" 
 invoke $112 112 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "L := L2" >OGid:"$113" singular! staticOff=0 descNo=113 superAdj=0 
 -- OG:gen: "L := L2" 
 pushThis 
 -- before objTmpStack:add:  113   "$113" 
 invoke $113 113 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "matchEq" 
 -- $ObjectGenerator:gen: "matchEq" >OGid:"matchEq" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "matchEq" 
 -- OG:before:super.gen: "matchEq" 
 -- $Invocation:gen: "matchEq" >useRtnV:"False"superAdj: 0 descNo: 114 
 -- INV:gen: "matchEq" 
 -- isConstant: "Invocation" "matchEq" 
 -- needorigin: "matchEq" 
 -- needOrigin:E: "matchEq"  E.ATd: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         l ...}" 
 -- doNeedOrigin:Ex: "matchEq" 
 -- computeAdr:superAdj: 0 "matchEq" 
 -- computeAdr: 1 :rec: "none"  E: "matchEq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "matchEq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "matchEq" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "matchEq" >ATd.off:0 (isPtn):on:0:superAdj:0"matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0 ..."} 
 -- $pattern:getAdr: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);  ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- computeAdr:isLast:E:  "matchEq" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- rec:  "matchEq" E:  "matchEq" 
 -- INV:gen:E.loadArgs "matchEq" 
 -- $ObjectInvocation_Unary:loadArgs: "matchEq" >staticOff:0 "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         B ..."} 
 -- $pattern:loadArgs: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq) ..."} 
 -- ptn:loadArgs:E "matchEq" 
 -- {(ObjectInvocation_Unary; (name: "matchEq"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "matchEq" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "matchEq" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:- 
 -- $ObjectInvocation_Unary:invoke: "matchEq" >rec:"matchEq" ATd:"pattern" E:"matchEq" E.ATd:"matchEq" unique:"False" 
 -- OI:invoke: "matchEq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- OI:invoke:B: "matchEq" E: "matchEq"  rec: "matchEq"  useRtnV: false "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern matchEq 
 -- $pattern:invoke: "matchEq: {   inx: var integer;   c1: var char;   c2: var char;   isEmpty: do ;      if (L1 = 0) :then ;         Beq := L1 <= L2;         leave(matchEq);  ..."} 
 -- ptn:invoke: "matchEq" E: "matchEq" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 invoke matchEq 114 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: matchEq :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"matchEq":rec:matchEq 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 112 
 -- Items:GenClass: $112 descNo: 112 isValue: false 
 -- Items:GenClass: $112 descNo: 21 isValue: false 

 CLASS $112 112 1 loop 110
 -- Store itemArgs: L := L1 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=112 vDescInx=112 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L1" 
 -- $Assign:gen: "L := L1"  
 -- assign: "L := L1" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$112" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $112$112 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := L1" right.label: "ObjectGenerator" "L1" 
 -- $ObjectGenerator:gen: "L1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1" 
 -- OG:before:super.gen: "L1" 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$112" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $112$112 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:1:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$110
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L1" 
 -- isArgOfAssignI2IwithUniValArg "L := L1" arg: "L1" ObjectGenerator 
 -- arg.super.arg: "L1" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$110 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 113 
 -- Items:GenClass: $113 descNo: 113 isValue: false 
 -- Items:GenClass: $113 descNo: 21 isValue: false 

 CLASS $113 113 1 loop 110
 -- Store itemArgs: L := L2 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=113 vDescInx=113 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := L2" 
 -- $Assign:gen: "L := L2"  
 -- assign: "L := L2" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$113" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $113$113 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := L2" right.label: "ObjectGenerator" "L2" 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$113" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $113$113 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:1:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$110
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L2" 
 -- isArgOfAssignI2IwithUniValArg "L := L2" arg: "L2" ObjectGenerator 
 -- arg.super.arg: "L2" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg loop$110 2
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 114 
 -- Items:GenClass: matchEq descNo: 114 isValue: false 
 -- Items:GenClass: matchEq descNo: 21 isValue: false 

 CLASS matchEq 114 1 loop 110
 -- Store itemArgs: inx: var integer{c1: var char;c2: var char;isEmpty: do ;   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=114 vDescInx=114 vdtTop: 1 
 mvStack 
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 -- $var:gen: "c1: var char"  
 -- DI:gen: "c1: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c1 
 -- $var:gen: "c2: var char"  
 -- DI:gen: "c2: var char" DI:isConst: false :isBasicValue: true :primNo: 3 
 -- DI:add:BP1:  c2 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "isEmpty: do {   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 -- $do:gen: "isEmpty: do {   if (L1 = 0) :then ;      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)" } 
 -- $ObjectGenerator:gen: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)" >OGid:"isEmpty" singula ...} 
 -- OG:gen: "if (L1 = 0) :then {      Beq := L1 <= L2;      leave(matchEq);   if (L2 = 0) :then ;      Beq := false;      leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  115   "isEmpty" 
 invoke isEmpty 115 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 -- $do:gen: "loop: do {   inx := inx + 1;   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)" } 
 -- $ObjectGenerator:gen: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)" >OGid:"loop" singula ...} 
 -- OG:gen: "inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  118   "loop" 
 invoke loop 118 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "doit: do {   if (c1 = c2) :then ;      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 -- $do:gen: "doit: do {   if (c1 = c2) :then ;      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)" } 
 -- $ObjectGenerator:gen: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)" >OGid:"doit" s ...} 
 -- OG:gen: "if (c1 = c2) :then {      -- we have inx = LBeq := L1 <= L2;      leave(matchEq);   :else ;      Beq := c1 < c2;      leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  121   "doit" 
 invoke doit 121 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "matchEq" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 115 
 -- Items:GenClass: isEmpty descNo: 115 isValue: false 
 -- Items:GenClass: isEmpty descNo: 21 isValue: false 

 CLASS isEmpty 115 1 matchEq 114
 -- Store itemArgs: if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq);if (L2 = 0) :then ;   Beq := false;   leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=115 vDescInx=115 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $ObjectGenerator:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $Invocation:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- isConstant: "Invocation" "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- needorigin: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- needOrigin:E: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" E:  "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- INV:gen:E.loadArgs "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $IfThen:loadArgs: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" } 
 -- INV:gen:after:E.loadArgs "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)}" 
 -- $IfThen:invoke: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" } 
 -- $IfThen:gen: "if (L1 = 0) :then {   Beq := L1 <= L2;   leave(matchEq)" } 
 -- $ObjectGenerator:gen: "(L1 = 0)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L1 = 0)" 
 -- OG:before:super.gen: "(L1 = 0)" 
 -- $Invocation:gen: "(L1 = 0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L1 = 0)" 
 -- isConstant: "Invocation" "(L1 = 0)" 
 -- needorigin: "(L1 = 0)" 
 -- needOrigin:E: "(L1 = 0)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(L1 = 0)" 
 -- computeAdr:superAdj: 0 "(L1 = 0)" 
 -- computeAdr: 1 :rec: "none"  E: "(L1 = 0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L1 = 0)"  
 -- $BracketedExp:loadOrigin: "(L1 = 0)"  
 -- computeAdr:superAdj: 0 "L1 = 0" 
 -- computeAdr: 1 :rec: "none"  E: "L1 = 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 = 0"  
 -- $BinOp:loadOrigin: "L1 = 0"  
 -- BinaryExp:loadOrigin:empty: "L1 = 0" superAdj: 0 
 -- $BinOp:getAdr: "L1 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 = 0" 
 -- BE:loadOrigin:E: L1 = 0 
 -- $BinOp:getAdr: "L1 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 = 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 = 0" E:  "L1 = 0" 
 -- INV:gen:E.loadArgs "L1 = 0" 
 -- $BinOp:loadArgs: "L1 = 0"  
 -- BinaryExp:loadArgs: "L1 = 0" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:2:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$110
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 = 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= 0":descNo:11} 
 -- ptn:loadArgs:E "= 0" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 = 0" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 = 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 = 0"  
 -- BinaryExp:invoke: "L1" rec: "L1 = 0" 
 -- M: "= 0" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "= 0" >rec:"L1" ATd:"pattern" E:"= 0" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= 0" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "= 0" E: "= 0"  rec: "L1"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= 0" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= 0" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "Beq := L1 <= L2{   leave(matchEq)" >OGid:"$116" singular! staticOff=0 descNo=116 superAdj=0} 
 -- OG:gen: "Beq := L1 <= L2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  116   "$116" 
 invoke $116 116 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $ObjectGenerator:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $Invocation:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- isConstant: "Invocation" "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- needorigin: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- needOrigin:E: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100 ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" E:  "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- INV:gen:E.loadArgs "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $IfThen:loadArgs: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" } 
 -- INV:gen:after:E.loadArgs "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (L2 = 0) :then {   Beq := false;   leave(matchEq)}" 
 -- $IfThen:invoke: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" } 
 -- $IfThen:gen: "if (L2 = 0) :then {   Beq := false;   leave(matchEq)" } 
 -- $ObjectGenerator:gen: "(L2 = 0)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(L2 = 0)" 
 -- OG:before:super.gen: "(L2 = 0)" 
 -- $Invocation:gen: "(L2 = 0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(L2 = 0)" 
 -- isConstant: "Invocation" "(L2 = 0)" 
 -- needorigin: "(L2 = 0)" 
 -- needOrigin:E: "(L2 = 0)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(L2 = 0)" 
 -- computeAdr:superAdj: 0 "(L2 = 0)" 
 -- computeAdr: 1 :rec: "none"  E: "(L2 = 0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(L2 = 0)"  
 -- $BracketedExp:loadOrigin: "(L2 = 0)"  
 -- computeAdr:superAdj: 0 "L2 = 0" 
 -- computeAdr: 1 :rec: "none"  E: "L2 = 0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L2 = 0"  
 -- $BinOp:loadOrigin: "L2 = 0"  
 -- BinaryExp:loadOrigin:empty: "L2 = 0" superAdj: 0 
 -- $BinOp:getAdr: "L2 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L2 = 0" 
 -- BE:loadOrigin:E: L2 = 0 
 -- $BinOp:getAdr: "L2 = 0"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2 = 0"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L2 = 0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L2 = 0" E:  "L2 = 0" 
 -- INV:gen:E.loadArgs "L2 = 0" 
 -- $BinOp:loadArgs: "L2 = 0"  
 -- BinaryExp:loadArgs: "L2 = 0" superAdj: 0 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:2:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$110
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L2 = 0" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= 0":descNo:11} 
 -- ptn:loadArgs:E "= 0" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0" 
 -- E: "ObjectGenerator" 0 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= 0" "ObjectInvocation_Binary" ActArg:  "0" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= 0"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "0" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0" 
 -- OG:before:super.gen: "0" 
 -- $Invocation:gen: "0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0" 
 -- isConstant: "Invocation" "0" 
 -- needorigin: "0" 
 -- needOrigin:E: "0"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0" E:  "0" 
 -- INV:gen:E.loadArgs "0" 
 -- $ConstLiteral:loadArgs: "0"  
 -- INV:gen:after:E.loadArgs "0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "0" 
 -- $ConstLiteral:invoke: "0"  
 pushc 0
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= 0" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- INV:gen:after:E.loadArgs "L2 = 0" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L2 = 0" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $BinOp:invoke: "L2 = 0"  
 -- BinaryExp:invoke: "L2" rec: "L2 = 0" 
 -- M: "= 0" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- $ObjectInvocation_Binary:invoke: "= 0" >rec:"L2" ATd:"pattern" E:"= 0" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= 0" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- origin:isValueObj "Value" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "= 0" E: "= 0"  rec: "L2"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= 0" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= 0" ptnKind: 1 useRtnV: true 
 -- rec: "L2" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L2: var integer" 
 -- bobs: 1 OGx: integer 
 eq
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= 0":rec:L2 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = 0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L7
 L6:
 -- $ObjectGenerator:gen: "Beq := false{   leave(matchEq)" >OGid:"$117" singular! staticOff=0 descNo=117 superAdj=0} 
 -- OG:gen: "Beq := false{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  117   "$117" 
 invoke $117 117 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "isEmpty" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 116 
 -- Items:GenClass: $116 descNo: 116 isValue: false 
 -- Items:GenClass: $116 descNo: 21 isValue: false 

 CLASS $116 116 1 isEmpty 115
 -- Store itemArgs: Beq := L1 <= L2{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=116 vDescInx=116 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := L1 <= L2" 
 -- $Assign:gen: "Beq := L1 <= L2"  
 -- assign: "Beq := L1 <= L2" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$116" on: 4 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $116$116 1
 -- items:goOrigin:encOG: "isEmpty" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := L1 <= L2" right.label: "ObjectGenerator" "L1 <= L2" 
 -- $ObjectGenerator:gen: "L1 <= L2" >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2" 
 -- $Invocation:gen: "L1 <= L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1 <= L2" 
 -- isConstant: "Invocation" "L1 <= L2" 
 -- needorigin: "L1 <= L2" 
 -- needOrigin:E: "L1 <= L2"  E.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- doNeedOrigin:Ex: "L1 <= L2" 
 -- computeAdr:superAdj: 0 "L1 <= L2" 
 -- computeAdr: 1 :rec: "none"  E: "L1 <= L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 <= L2"  
 -- $BinOp:loadOrigin: "L1 <= L2"  
 -- BinaryExp:loadOrigin:empty: "L1 <= L2" superAdj: 0 
 -- $BinOp:getAdr: "L1 <= L2"  
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 <= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 <= L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 <= L2" E:  "L1 <= L2" 
 -- INV:gen:E.loadArgs "L1 <= L2" 
 -- $BinOp:loadArgs: "L1 <= L2"  
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$116" on: 3 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $116$116 1
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:3:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$110
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 <= L2" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" >E:"<= L2":descNo:58} 
 -- ptn:loadArgs:E "<= L2" 
 -- {(ObjectInvocation_Binary; (name: "<="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L2");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "L2" 
 -- E: "ObjectGenerator" L2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "<= L2" "ObjectInvocation_Binary" ActArg:  "L2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$116" on: 3 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $116$116 1
 -- items:goOrigin:encOG: "isEmpty" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:3:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$110
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 <= L2"  
 -- BinaryExp:invoke: "L1" rec: "L1 <= L2" 
 -- M: "<= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "<= L2" >rec:"L1" ATd:"pattern" E:"<= L2" E.ATd:"<=  " unique:"False" 
 -- OI:invoke: "<= L2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "<= L2" E: "<= L2"  rec: "L1"  useRtnV: true "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- $pattern:invoke: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" E: "<= L2" useRTNv: "True"} 
 -- ptn:invoke: "<=  " E: "<= L2" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <= L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "L1 <= L2" 
 -- isArgOfAssignI2IwithUniValArg "Beq := L1 <= L2" arg: "L1 <= L2" ObjectGenerator 
 -- arg.super.arg: "L1 <= L2" BinOp 
 -- recx:BinaryExp:recx: "L1 <= L2" 
 -- M: "<= L2" label: "ObjectInvocation_Binary" M.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "<= L2" 
 -- arg:other 
 -- M:arg: "L2" ObjectGenerator false 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 117 
 -- Items:GenClass: $117 descNo: 117 isValue: false 
 -- Items:GenClass: $117 descNo: 21 isValue: false 

 CLASS $117 117 1 isEmpty 115
 -- Store itemArgs: Beq := false{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=117 vDescInx=117 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := false" 
 -- $Assign:gen: "Beq := false"  
 -- assign: "Beq := false" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$117" on: 4 isValueObj: false 
 -- origin: isEmpty origin:isValueObj: false 
 rpushg $117$117 1
 -- items:goOrigin:encOG: "isEmpty" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg isEmpty$115 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := false" right.label: "ObjectGenerator" "false" 
 -- $ObjectGenerator:gen: "false" >OGid:"False" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "false" 
 -- OG:before:super.gen: "false" 
 -- $Invocation:gen: "false" >useRtnV:"True"superAdj: 0 descNo: 27 
 -- INV:gen: "false" 
 -- isConstant: "Invocation" "false" 
 -- needorigin: "false" 
 -- needOrigin:E: "false"  E.ATd: "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   out B: var boolean;   B := 0}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "false" E:  "false" 
 -- INV:gen:E.loadArgs "false" 
 -- $ObjectInvocation_Unary:loadArgs: "false" >staticOff:0 "False: {   %globals;   out B: var boolean;   B := 0" superAdj:0} 
 -- $pattern:loadArgs: "False: {   %globals;   out B: var boolean;   B := 0" >E:"false":descNo:27} 
 -- ptn:loadArgs:E "false" 
 -- {(ObjectInvocation_Unary; (name: "false"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "false" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "false" 
 -- $ObjectInvocation_Unary:invoke: "false" >rec:"false" ATd:"pattern" E:"false" E.ATd:"False" unique:"False" 
 -- OI:invoke: "false" 
 -- 
 -- OI:invoke:B: "false" E: "false"  rec: "false"  useRtnV: true "False: {   %globals;   out B: var boolean;   B := 0}" 
 -- OI:invoke:before:ATdx.invoke: pattern False 
 -- $pattern:invoke: "False: {   %globals;   out B: var boolean;   B := 0" E: "false" useRTNv: "True"} 
 -- ptn:invoke: "False" E: "false" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke False 27 0 0
 -- global:pushOut: B off: 1 
 pushg 1 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 1 
 -- GeneralPTN:invoke:after:callInvoke: 1 
 -- OI:invoke:V: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: false :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "false" 
 -- isArgOfAssignI2IwithUniValArg "Beq := false" arg: "false" ObjectGenerator 
 -- arg.super.arg: "false" ObjectInvocation_Unary 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 118 
 -- Items:GenClass: loop descNo: 118 isValue: false 
 -- Items:GenClass: loop descNo: 21 isValue: false 

 CLASS loop 118 1 matchEq 114
 -- Store itemArgs: inx := inx + 1{c1 := get[inx];c2 := Veq.get[inx];if (c1 = c2) :then ;   if (inx < L) :then ;      restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=118 vDescInx=118 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inx := inx + 1" 
 -- $Assign:gen: "inx := inx + 1"  
 -- assign: "inx := inx + 1" 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- AssignmentStatement:gen: "inx := inx + 1" right.label: "ObjectGenerator" "inx + 1" 
 -- $ObjectGenerator:gen: "inx + 1" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx + 1" 
 -- OG:before:super.gen: "inx + 1" 
 -- $Invocation:gen: "inx + 1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx + 1" 
 -- isConstant: "Invocation" "inx + 1" 
 -- needorigin: "inx + 1" 
 -- needOrigin:E: "inx + 1"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "inx + 1" 
 -- computeAdr:superAdj: 0 "inx + 1" 
 -- computeAdr: 1 :rec: "none"  E: "inx + 1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx + 1"  
 -- $BinOp:loadOrigin: "inx + 1"  
 -- BinaryExp:loadOrigin:empty: "inx + 1" superAdj: 0 
 -- $BinOp:getAdr: "inx + 1"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx + 1"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx + 1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx + 1" E:  "inx + 1" 
 -- INV:gen:E.loadArgs "inx + 1" 
 -- $BinOp:loadArgs: "inx + 1"  
 -- BinaryExp:loadArgs: "inx + 1" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$114
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "inx + 1" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ 1":descNo:60} 
 -- ptn:loadArgs:E "+ 1" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "1" 
 -- E: "ObjectGenerator" 1 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ 1" "ObjectInvocation_Binary" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 1"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "+ 1" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx + 1" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx + 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx + 1"  
 -- BinaryExp:invoke: "inx" rec: "inx + 1" 
 -- M: "+ 1" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "+ 1" >rec:"inx" ATd:"pattern" E:"+ 1" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "+ 1" E: "+ 1"  rec: "inx"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ 1" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 1" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 plus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ 1":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "inx" dstE: "inx" dstE.ATd: "inx: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "inx + 1" 
 -- isArgOfAssignI2IwithUniValArg "inx := inx + 1" arg: "inx + 1" ObjectGenerator 
 -- arg.super.arg: "inx + 1" BinOp 
 -- recx:BinaryExp:recx: "inx + 1" 
 -- M: "+ 1" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "+ 1" 
 -- arg:integer 
 -- M:arg: "1" ObjectGenerator false 
 -- dstDI: "inx: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$114 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "c1 := get[inx]" 
 -- $Assign:gen: "c1 := get[inx]"  
 -- assign: "c1 := get[inx]" 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:1:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- AssignmentStatement:gen: "c1 := get[inx]" right.label: "ObjectGenerator" "get[inx]" 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 4 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- items:goOrigin:encOG: "matchEq" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- items:goOrigin:encOG: "<=" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg <=$109 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:4:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$114
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "c1" dstE: "c1" dstE.ATd: "c1: var char" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c1 := get[inx]" arg: "get[inx]" ObjectGenerator 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- dstDI: "c1: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$114 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "c2 := Veq.get[inx]" 
 -- $Assign:gen: "c2 := Veq.get[inx]"  
 -- assign: "c2 := Veq.get[inx]" 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:1:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- AssignmentStatement:gen: "c2 := Veq.get[inx]" right.label: "ObjectGenerator" "Veq.get[inx]" 
 -- $ObjectGenerator:gen: "Veq.get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Veq.get[inx]" 
 -- OG:before:super.gen: "Veq.get[inx]" 
 -- $Invocation:gen: "Veq.get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "Veq.get[inx]" 
 -- isConstant: "Invocation" "Veq.get[inx]" 
 -- notConst: Veq in Veq: var this(Value) 
 -- needorigin: "Veq.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "Veq.get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "Veq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Veq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Veq" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- $ObjectInvocation_Unary:getAdr: "Veq" >ATd.off:2:on:3:superAdj:0"in Veq: var this(Value)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- PING:String 0 inx := inx + 1{   c1 := get[inx];   c2 := Veq.get[inx];   if (c1 = c2) :then ;      if (inx < L) :then ;         restart(loop)} 
 -- BOBS:ATd: "in Veq: var this(Value)" 
 -- String:vEq:  "Veq" off:  2 ATd: "in Veq: var this(Value)" 
 -- E.on: 3 
 -- beforeIsValueObj:E: "Veq"  ATd: "in Veq: var this(Value)" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Veq"  E: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:2 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Veq" >staticOff:0 "in Veq: var this(Value)" superAdj:0 
 -- $var:loadArgs: "in Veq: var this(Value)" >E:"Veq" 
 -- $pattern:loadArgs: "this: {   %basic 18;   in this: ref Object" >E:"Veq":descNo:31} 
 -- $ObjectInvocation_Unary:invoke: "Veq" >rec:"Veq" ATd:"var" isValueObj E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "Veq" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "Veq" E: "get[inx]"  rec: "Veq"  useRtnV: true "in Veq: var this(Value)" 
 -- OI:invoke:before:ATdx.invoke: var Veq 
 -- $var:invoke: "in Veq: var this(Value)" E: "get[inx]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in Veq: var this(Value)" 
 -- isValueObj:isAdr: true objSize: 2  rec "Veq" ,E: "get[inx]" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 rpushg loop$118 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: Veq :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec:  "Veq" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$114
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"Veq" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "Veq"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 2 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:Veq 
 -- rec: "c2" dstE: "c2" dstE.ATd: "c2: var char" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "Veq.get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "c2 := Veq.get[inx]" arg: "Veq.get[inx]" ObjectGenerator 
 -- arg.super.arg: "Veq" ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- recx: "Veq" argx: "get[inx]" 
 -- checkInt2IntWithUnitArg:rec: "Veq" E: "get[inx]" 
 -- arg:other 
 -- dstDI: "c2: var char" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg matchEq$114 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $ObjectGenerator:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OG:before:super.gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $Invocation:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- isConstant: "Invocation" "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- needorigin: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- needOrigin:E: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;    ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" E:  "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- INV:gen:E.loadArgs "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $IfThen:loadArgs: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" } 
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)}" 
 -- $IfThen:invoke: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" } 
 -- $IfThen:gen: "if (c1 = c2) :then {   if (inx < L) :then ;      restart(loop)" } 
 -- $ObjectGenerator:gen: "(c1 = c2)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(c1 = c2)" 
 -- OG:before:super.gen: "(c1 = c2)" 
 -- $Invocation:gen: "(c1 = c2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(c1 = c2)" 
 -- isConstant: "Invocation" "(c1 = c2)" 
 -- needorigin: "(c1 = c2)" 
 -- needOrigin:E: "(c1 = c2)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(c1 = c2)" 
 -- computeAdr:superAdj: 0 "(c1 = c2)" 
 -- computeAdr: 1 :rec: "none"  E: "(c1 = c2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(c1 = c2)"  
 -- $BracketedExp:loadOrigin: "(c1 = c2)"  
 -- computeAdr:superAdj: 0 "c1 = c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 = c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 = c2"  
 -- $BinOp:loadOrigin: "c1 = c2"  
 -- BinaryExp:loadOrigin:empty: "c1 = c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- BE:loadOrigin:E: c1 = c2 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 = c2" E:  "c1 = c2" 
 -- INV:gen:E.loadArgs "c1 = c2" 
 -- $BinOp:loadArgs: "c1 = c2"  
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:1:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 3 matchEq$114
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= c2":descNo:11} 
 -- ptn:loadArgs:E "= c2" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:1:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 4 matchEq$114
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 5 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 = c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 = c2" 
 -- M: "= c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "= c2" >rec:"c1" ATd:"pattern" E:"= c2" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "= c2" E: "= c2"  rec: "c1"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= c2" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= c2" ptnKind: 1 useRtnV: true 
 -- rec: "c1" "Invocation" OGx.label: "ObjectGenerator" OGx: char 
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: char 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "if (inx < L) :then {      restart(loop)" >OGid:"$119" singular! staticOff=0 descNo=119 superAdj=0} 
 -- OG:gen: "if (inx < L) :then {      restart(loop)}" 
 pushThis 
 -- before objTmpStack:add:  119   "$119" 
 invoke $119 119 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 5 vTopMax: 5 rTop: -8 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "loop" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 119 
 -- Items:GenClass: $119 descNo: 119 isValue: false 
 -- Items:GenClass: $119 descNo: 21 isValue: false 

 CLASS $119 119 1 loop 118
 -- Store itemArgs: if (inx < L) :then {   restart(loop)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=119 vDescInx=119 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (inx < L) :then {   restart(loop)}" 
 -- $ObjectGenerator:gen: "if (inx < L) :then {   restart(loop)" >OGid:"if:then$0" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "if (inx < L) :then {   restart(loop)}" 
 -- OG:before:super.gen: "if (inx < L) :then {   restart(loop)}" 
 -- $Invocation:gen: "if (inx < L) :then {   restart(loop)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (inx < L) :then {   restart(loop)}" 
 -- isConstant: "Invocation" "if (inx < L) :then {   restart(loop)}" 
 -- needorigin: "if (inx < L) :then {   restart(loop)}" 
 -- needOrigin:E: "if (inx < L) :then {   restart(loop)}"  E.ATd: "if(cond: var boolean):then{thenPart:< object}: {   %OSDvisibility skipInternal;   %basic 100;   %globals inS ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (inx < L) :then {   restart(loop)}" E:  "if (inx < L) :then {   restart(loop)}" 
 -- INV:gen:E.loadArgs "if (inx < L) :then {   restart(loop)}" 
 -- $IfThen:loadArgs: "if (inx < L) :then {   restart(loop)" } 
 -- INV:gen:after:E.loadArgs "if (inx < L) :then {   restart(loop)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThen "if (inx < L) :then {   restart(loop)}" 
 -- $IfThen:invoke: "if (inx < L) :then {   restart(loop)" } 
 -- $IfThen:gen: "if (inx < L) :then {   restart(loop)" } 
 -- $ObjectGenerator:gen: "(inx < L)" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(inx < L)" 
 -- OG:before:super.gen: "(inx < L)" 
 -- $Invocation:gen: "(inx < L)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(inx < L)" 
 -- isConstant: "Invocation" "(inx < L)" 
 -- needorigin: "(inx < L)" 
 -- needOrigin:E: "(inx < L)"  E.ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(inx < L)" 
 -- computeAdr:superAdj: 0 "(inx < L)" 
 -- computeAdr: 1 :rec: "none"  E: "(inx < L)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(inx < L)"  
 -- $BracketedExp:loadOrigin: "(inx < L)"  
 -- computeAdr:superAdj: 0 "inx < L" 
 -- computeAdr: 1 :rec: "none"  E: "inx < L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "inx < L"  
 -- $BinOp:loadOrigin: "inx < L"  
 -- BinaryExp:loadOrigin:empty: "inx < L" superAdj: 0 
 -- $BinOp:getAdr: "inx < L"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx < L"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx < L" 
 -- BE:loadOrigin:E: inx < L 
 -- $BinOp:getAdr: "inx < L"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx < L"  ATd: "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "inx < L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "inx < L" E:  "inx < L" 
 -- INV:gen:E.loadArgs "inx < L" 
 -- $BinOp:loadArgs: "inx < L"  
 -- BinaryExp:loadArgs: "inx < L" superAdj: 0 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$119" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $119$119 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:2:on:2:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:2 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 2 matchEq$114
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- left:#I "inx < L" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" >E:"< L":descNo:111} 
 -- ptn:loadArgs:E "< L" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L");     (Arguments)));   (Items descNo: 0 or ...} 
 -- args: "L" 
 -- E: "ObjectGenerator" L 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "< L" "ObjectInvocation_Binary" ActArg:  "L" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< L"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$119" on: 3 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg $119$119 1
 -- items:goOrigin:encOG: "loop" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg loop$118 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:3:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 2 loop$110
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L" :isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "< L" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- INV:gen:after:E.loadArgs "inx < L" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- IV:E.invoke:useRtnVal: true E: BinOp "inx < L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $BinOp:invoke: "inx < L"  
 -- BinaryExp:invoke: "inx" rec: "inx < L" 
 -- M: "< L" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- $ObjectInvocation_Binary:invoke: "< L" >rec:"inx" ATd:"pattern" E:"< L" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- origin:isValueObj "integer" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "< L" E: "< L"  rec: "inx"  useRtnV: true "<  : {   %basic 51;   in V: var integer;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var integer;   out B: var boolean" E: "< L" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< L" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "inx" E: "< L" 
 -- arg:other 
 lt
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< L":rec:inx 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"$120" singular! staticOff=0 descNo=120 superAdj=0 
 -- OG:gen: "restart(loop)" 
 pushThis 
 -- before objTmpStack:add:  120   "$120" 
 invoke $120 120 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L4:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 120 
 -- Items:GenClass: $120 descNo: 120 isValue: false 
 -- Items:GenClass: $120 descNo: 21 isValue: false 

 CLASS $120 120 1 $119 119
 -- Store itemArgs: restart(loop) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=120 vDescInx=120 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "restart(loop)" 
 -- $ObjectGenerator:gen: "restart(loop)" >OGid:"restart" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "restart(loop)" 
 -- OG:before:super.gen: "restart(loop)" 
 -- $Invocation:gen: "restart(loop)" >useRtnV:"False"superAdj: 0 descNo: 61 
 -- INV:gen: "restart(loop)" 
 -- isConstant: "Invocation" "restart(loop)" 
 -- needorigin: "restart(loop)" 
 -- needOrigin:E: "restart(loop)"  E.ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- doNeedOrigin:Ex: "restart(loop)" 
 -- computeAdr:superAdj: 0 "restart(loop)" 
 -- computeAdr: 1 :rec: "none"  E: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "restart(loop)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "restart(loop)" >on:8 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "restart(loop)" >ATd.off:0 (isPtn):on:8:superAdj:0"restart(V: var integer):  -- odd parameter type!{   %basic 102":Adr:off:0 size:0 isFlo ...} 
 -- $pattern:getAdr: "restart(V: var integer):  -- odd parameter type!{   %basic 102" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- E.on: 8 
 -- beforeIsValueObj:E: "restart(loop)"  ATd: "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- computeAdr:isLast:E:  "restart(loop)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:- 
 -- rec:  "restart(loop)" E:  "restart(loop)" 
 -- INV:gen:E.loadArgs "restart(loop)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "restart(loop)" >staticOff:0 "restart(V: var integer):  -- odd parameter type!{   %basic 102" superAdj:0arg:"loop"} 
 -- $pattern:loadArgs: "restart(V: var integer):  -- odd parameter type!{   %basic 102" >E:"restart(loop)":descNo:61} 
 -- INV:gen:after:E.loadArgs "restart(loop)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "restart(loop)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart ..." 
 -- $ObjectInvocation_KeyWord:invoke: "restart(loop)" >rec:"restart(loop)" ATd:"pattern" E:"restart(loop)" E.ATd:"restart(V: var integer)" unique:"False" 
 -- OI:invoke: "restart(loop)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- OI:invoke:B: "restart(loop)" E: "restart(loop)"  rec: "restart(loop)"  useRtnV: false "restart(V: var integer):  -- odd parameter type!{   %basic 102}" 
 -- OI:invoke:before:ATdx.invoke: pattern restart(V: var integer) 
 -- $pattern:invoke: "restart(V: var integer):  -- odd parameter type!{   %basic 102" E: "restart(loop)" useRTNv: "False"} 
 -- ptn:invoke: "restart(V: var integer)" E: "restart(loop)" ptnKind: 0 useRtnV: false 
 break  2 1 118 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 -- 
 -- OI:invoke:C: restart(loop) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"restart(loop)":rec:restart(loop) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 121 
 -- Items:GenClass: doit descNo: 121 isValue: false 
 -- Items:GenClass: doit descNo: 21 isValue: false 

 CLASS doit 121 1 matchEq 114
 -- Store itemArgs: if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=121 vDescInx=121 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $ObjectGenerator:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" >OGid:"if:then$0" IS.isempty! ...} 
 -- OG:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OG:before:super.gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $Invocation:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- isConstant: "Invocation" "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- needorigin: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- needOrigin:E: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}"  E.ATd: "if(cond: var boolean):then{ ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" E:  "if (c1 = c2) :then {   -- we have inx = ...}" 
 -- INV:gen:E.loadArgs "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $IfThenElse:loadArgs: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" } 
 -- INV:gen:after:E.loadArgs "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)}" 
 -- $IfThenElse:invoke: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" } 
 -- $IfThenElse:gen: "if (c1 = c2) :then {   -- we have inx = LBeq := L1 <= L2;   leave(matchEq);:else ;   Beq := c1 < c2;   leave(matchEq)" } 
 -- $ObjectGenerator:gen: "(c1 = c2)" >OGid:"=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(c1 = c2)" 
 -- OG:before:super.gen: "(c1 = c2)" 
 -- $Invocation:gen: "(c1 = c2)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(c1 = c2)" 
 -- isConstant: "Invocation" "(c1 = c2)" 
 -- needorigin: "(c1 = c2)" 
 -- needOrigin:E: "(c1 = c2)"  E.ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- doNeedOrigin:Ex: "(c1 = c2)" 
 -- computeAdr:superAdj: 0 "(c1 = c2)" 
 -- computeAdr: 1 :rec: "none"  E: "(c1 = c2)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(c1 = c2)"  
 -- $BracketedExp:loadOrigin: "(c1 = c2)"  
 -- computeAdr:superAdj: 0 "c1 = c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 = c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 = c2"  
 -- $BinOp:loadOrigin: "c1 = c2"  
 -- BinaryExp:loadOrigin:empty: "c1 = c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- BE:loadOrigin:E: c1 = c2 
 -- $BinOp:getAdr: "c1 = c2"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1 = c2"  ATd: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 = c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 = c2" E:  "c1 = c2" 
 -- INV:gen:E.loadArgs "c1 = c2" 
 -- $BinOp:loadArgs: "c1 = c2"  
 -- BinaryExp:loadArgs: "c1 = c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:1:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 3 matchEq$114
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" >E:"= c2":descNo:11} 
 -- ptn:loadArgs:E "= c2" 
 -- {(ObjectInvocation_Binary; (name: "="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "= c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "= c2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:1:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 4 matchEq$114
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "= c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 = c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 = c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 = c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 = c2" 
 -- M: "= c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "= c2" >rec:"c1" ATd:"pattern" E:"= c2" E.ATd:"=  " unique:"False" 
 -- OI:invoke: "= c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "= c2" E: "= c2"  rec: "c1"  useRtnV: true "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )}" 
 -- OI:invoke:before:ATdx.invoke: pattern =   
 -- $pattern:invoke: "=  :< {   %basic 50;   in Veq: var this(Value);   out Beq: var boolean;   inner(= )" E: "= c2" useRTNv: "True"} 
 -- ptn:invoke: "=  " E: "= c2" ptnKind: 1 useRtnV: true 
 -- rec: "c1" "Invocation" OGx.label: "ObjectGenerator" OGx: char 
 -- rec.ATd: "c1: var char" 
 -- bobs: 3 OGx: char 
 eq
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"= c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: = c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L4
 L3:
 -- $ObjectGenerator:gen: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)" >OGid:"$122" singular! staticOff=0 descNo=122 superAdj=0} 
 -- OG:gen: "-- we have inx = LBeq := L1 <= L2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  122   "$122" 
 invoke $122 122 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L5
 L4:
 -- $ObjectGenerator:gen: "Beq := c1 < c2{   leave(matchEq)" >OGid:"$123" singular! staticOff=0 descNo=123 superAdj=0} 
 -- OG:gen: "Beq := c1 < c2{   leave(matchEq)}" 
 pushThis 
 -- before objTmpStack:add:  123   "$123" 
 invoke $123 123 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L5:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "doit" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 122 
 -- Items:GenClass: $122 descNo: 122 isValue: false 
 -- Items:GenClass: $122 descNo: 21 isValue: false 

 CLASS $122 122 1 doit 121
 -- Store itemArgs: -- we have inx = LBeq := L1 <= L2{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=122 vDescInx=122 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := L1 <= L2" 
 -- $Assign:gen: "Beq := L1 <= L2"  
 -- assign: "Beq := L1 <= L2" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$122" on: 4 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $122$122 1
 -- items:goOrigin:encOG: "doit" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := L1 <= L2" right.label: "ObjectGenerator" "L1 <= L2" 
 -- $ObjectGenerator:gen: "L1 <= L2" >OGid:"<=" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1 <= L2" 
 -- OG:before:super.gen: "L1 <= L2" 
 -- $Invocation:gen: "L1 <= L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1 <= L2" 
 -- isConstant: "Invocation" "L1 <= L2" 
 -- needorigin: "L1 <= L2" 
 -- needOrigin:E: "L1 <= L2"  E.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- doNeedOrigin:Ex: "L1 <= L2" 
 -- computeAdr:superAdj: 0 "L1 <= L2" 
 -- computeAdr: 1 :rec: "none"  E: "L1 <= L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 <= L2"  
 -- $BinOp:loadOrigin: "L1 <= L2"  
 -- BinaryExp:loadOrigin:empty: "L1 <= L2" superAdj: 0 
 -- $BinOp:getAdr: "L1 <= L2"  
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1 <= L2"  ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 <= L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L1 <= L2" E:  "L1 <= L2" 
 -- INV:gen:E.loadArgs "L1 <= L2" 
 -- $BinOp:loadArgs: "L1 <= L2"  
 -- BinaryExp:loadArgs: "L1 <= L2" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var integer 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$122" on: 3 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $122$122 1
 -- items:goOrigin:encOG: "doit" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:3:on:3:superAdj:0"L1: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L1: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L1: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L1"  ATd: "L1: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var integer" superAdj:0 
 -- $var:loadArgs: "L1: var integer" >E:"L1" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var integer" E: "L1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "L1: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- isCompositeValueObj: false E: "L1" "L1: var integer" true 
 -- E.ATd.isValueObj: false rec: "L1" 
 pushg 3 loop$110
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- left:#I "L1 <= L2" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" >E:"<= L2":descNo:58} 
 -- ptn:loadArgs:E "<= L2" 
 -- {(ObjectInvocation_Binary; (name: "<="); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L2");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "L2" 
 -- E: "ObjectGenerator" L2 
 -- E.arg: "var" in Veq: var this(Value) 
 -- NonVirt: "<= L2" "ObjectInvocation_Binary" ActArg:  "L2" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "<= L2"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L2" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2" 
 -- OG:before:super.gen: "L2" 
 -- $Invocation:gen: "L2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L2" 
 -- isConstant: "Invocation" "L2" 
 -- notConst: L2 L2: var integer 
 -- needorigin: "L2" 
 -- needOrigin:E: "L2"  E.ATd: "L2: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L2" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$122" on: 3 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $122$122 1
 -- items:goOrigin:encOG: "doit" on: 2 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq" on: 1 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:3:superAdj:0"L2: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "L2: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L2: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L2"  ATd: "L2: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr:isLast:E:  "L2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- rec:  "L2" E:  "L2" 
 -- INV:gen:E.loadArgs "L2" 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var integer" superAdj:0 
 -- $var:loadArgs: "L2: var integer" >E:"L2" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"L2" E.ATd:"L2" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "L2"  rec: "L2"  useRtnV: true "L2: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var integer" E: "L2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- isCompositeValueObj: false E: "L2" "L2: var integer" true 
 -- E.ATd.isValueObj: false rec: "L2" 
 pushg 4 loop$110
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- vEq: 
 -- end:loadArgs:NonVirt: "<= L2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 <= L2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 <= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 <= L2"  
 -- BinaryExp:invoke: "L1" rec: "L1 <= L2" 
 -- M: "<= L2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "<= L2" >rec:"L1" ATd:"pattern" E:"<= L2" E.ATd:"<=  " unique:"False" 
 -- OI:invoke: "<= L2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "Value" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "<= L2" E: "<= L2"  rec: "L1"  useRtnV: true "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <=   
 -- $pattern:invoke: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean" E: "<= L2" useRTNv: "True"} 
 -- ptn:invoke: "<=  " E: "<= L2" ptnKind: 1 useRtnV: true 
 -- rec: "L1" "Invocation" OGx.label: "ObjectGenerator" OGx: integer 
 -- rec.ATd: "L1: var integer" 
 -- bobs: 1 OGx: integer 
 le
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"<= L2":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: <= L2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "L1 <= L2" 
 -- isArgOfAssignI2IwithUniValArg "Beq := L1 <= L2" arg: "L1 <= L2" ObjectGenerator 
 -- arg.super.arg: "L1 <= L2" BinOp 
 -- recx:BinaryExp:recx: "L1 <= L2" 
 -- M: "<= L2" label: "ObjectInvocation_Binary" M.ATd: "<=  :< {   %basic 52;   in Veq: var this(Value);   out Beq: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "<= L2" 
 -- arg:other 
 -- M:arg: "L2" ObjectGenerator false 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 123 
 -- Items:GenClass: $123 descNo: 123 isValue: false 
 -- Items:GenClass: $123 descNo: 21 isValue: false 

 CLASS $123 123 1 doit 121
 -- Store itemArgs: Beq := c1 < c2{leave(matchEq)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=123 vDescInx=123 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "Beq := c1 < c2" 
 -- $Assign:gen: "Beq := c1 < c2"  
 -- assign: "Beq := c1 < c2" 
 -- computeAdr:superAdj: 0 "Beq" 
 -- computeAdr: 1 :rec: "none"  E: "Beq" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Beq"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Beq" >on:4 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$123" on: 4 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $123$123 1
 -- items:goOrigin:encOG: "doit" on: 3 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- items:goOrigin:encOG: "matchEq" on: 2 isValueObj: false 
 -- origin: loop origin:isValueObj: false 
 rpushg matchEq$114 1
 -- items:goOrigin:encOG: "loop" on: 1 isValueObj: false 
 -- origin: <= origin:isValueObj: false 
 rpushg loop$110 1
 -- $ObjectInvocation_Unary:getAdr: "Beq" >ATd.off:3:on:4:superAdj:0"out Beq: var boolean":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out Beq: var boolean" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: boolean 
 -- before:floatTest:  "out Beq: var boolean" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "Beq"  ATd: "out Beq: var boolean" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- computeAdr:isLast:E:  "Beq" 
 -- AssignmentStatement:gen: "Beq := c1 < c2" right.label: "ObjectGenerator" "c1 < c2" 
 -- $ObjectGenerator:gen: "c1 < c2" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c1 < c2" 
 -- OG:before:super.gen: "c1 < c2" 
 -- $Invocation:gen: "c1 < c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1 < c2" 
 -- isConstant: "Invocation" "c1 < c2" 
 -- needorigin: "c1 < c2" 
 -- needOrigin:E: "c1 < c2"  E.ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "c1 < c2" 
 -- computeAdr:superAdj: 0 "c1 < c2" 
 -- computeAdr: 1 :rec: "none"  E: "c1 < c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "c1 < c2"  
 -- $BinOp:loadOrigin: "c1 < c2"  
 -- BinaryExp:loadOrigin:empty: "c1 < c2" superAdj: 0 
 -- $BinOp:getAdr: "c1 < c2"  
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1 < c2"  ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "c1 < c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "c1 < c2" E:  "c1 < c2" 
 -- INV:gen:E.loadArgs "c1 < c2" 
 -- $BinOp:loadArgs: "c1 < c2"  
 -- BinaryExp:loadArgs: "c1 < c2" superAdj: 0 
 -- $Invocation:gen: "c1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c1" 
 -- isConstant: "Invocation" "c1" 
 -- notConst: c1 c1: var char 
 -- needorigin: "c1" 
 -- needOrigin:E: "c1"  E.ATd: "c1: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c1" 
 -- computeAdr: 1 :rec: "none"  E: "c1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c1" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$123" on: 2 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $123$123 1
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- $ObjectInvocation_Unary:getAdr: "c1" >ATd.off:3:on:2:superAdj:0"c1: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c1: var char" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c1: var char" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c1"  ATd: "c1: var char" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- computeAdr:isLast:E:  "c1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- rec:  "c1" E:  "c1" 
 -- INV:gen:E.loadArgs "c1" 
 -- $ObjectInvocation_Unary:loadArgs: "c1" >staticOff:0 "c1: var char" superAdj:0 
 -- $var:loadArgs: "c1: var char" >E:"c1" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c1" 
 -- {(ObjectInvocation_Unary; (name: "c1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c1" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c1" >rec:"c1" ATd:"var" isValueObj E:"c1" E.ATd:"c1" unique:"False" 
 -- OI:invoke: "c1" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "c1" E: "c1"  rec: "c1"  useRtnV: true "c1: var char" 
 -- OI:invoke:before:ATdx.invoke: var c1 
 -- $var:invoke: "c1: var char" E: "c1">newOff:3 useRTNv: "True" 
 -- DI:invoke: "c1: var char" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- isCompositeValueObj: false E: "c1" "c1: var char" true 
 -- E.ATd.isValueObj: false rec: "c1" 
 pushg 3 matchEq$114
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- 
 -- OI:invoke:C: c1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $pattern:loadArgs: "<  : {   %basic 51;   in V: var char;   out B: var boolean" >E:"< c2":descNo:124} 
 -- ptn:loadArgs:E "< c2" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "c2");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "c2" 
 -- E: "ObjectGenerator" c2 
 -- E.arg: "var" in V: var char 
 -- NonVirt: "< c2" "ObjectInvocation_Binary" ActArg:  "c2" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< c2"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "c2" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "c2" 
 -- OG:before:super.gen: "c2" 
 -- $Invocation:gen: "c2" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "c2" 
 -- isConstant: "Invocation" "c2" 
 -- notConst: c2 c2: var char 
 -- needorigin: "c2" 
 -- needOrigin:E: "c2"  E.ATd: "c2: var char" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "c2" 
 -- computeAdr: 1 :rec: "none"  E: "c2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "c2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "c2" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$123" on: 2 isValueObj: false 
 -- origin: doit origin:isValueObj: false 
 rpushg $123$123 1
 -- items:goOrigin:encOG: "doit" on: 1 isValueObj: false 
 -- origin: matchEq origin:isValueObj: false 
 rpushg doit$121 1
 -- $ObjectInvocation_Unary:getAdr: "c2" >ATd.off:4:on:2:superAdj:0"c2: var char":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $var:getAdr: "c2: var char" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- DI:OG: char 
 -- before:floatTest:  "c2: var char" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "c2"  ATd: "c2: var char" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- computeAdr:isLast:E:  "c2" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- rec:  "c2" E:  "c2" 
 -- INV:gen:E.loadArgs "c2" 
 -- $ObjectInvocation_Unary:loadArgs: "c2" >staticOff:0 "c2: var char" superAdj:0 
 -- $var:loadArgs: "c2: var char" >E:"c2" 
 -- $pattern:loadArgs: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;       ..."} 
 -- ptn:loadArgs:E "c2" 
 -- {(ObjectInvocation_Unary; (name: "c2"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "c2" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "c2" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:- 
 -- $ObjectInvocation_Unary:invoke: "c2" >rec:"c2" ATd:"var" isValueObj E:"c2" E.ATd:"c2" unique:"False" 
 -- OI:invoke: "c2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- OI:invoke:B: "c2" E: "c2"  rec: "c2"  useRtnV: true "c2: var char" 
 -- OI:invoke:before:ATdx.invoke: var c2 
 -- $var:invoke: "c2: var char" E: "c2">newOff:4 useRTNv: "True" 
 -- DI:invoke: "c2: var char" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- isCompositeValueObj: false E: "c2" "c2: var char" true 
 -- E.ATd.isValueObj: false rec: "c2" 
 pushg 4 matchEq$114
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- 
 -- OI:invoke:C: c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c2":rec:c2 
 -- formalArg:isPtn: "in V: var char" :isBasicVal: true :valueObj: true 
 -- :actArg: "c2" :isBasicVal: true 
 -- case:B: c2 ObjectGenerator 3 0 3 false false 
 -- end:loadArgs:NonVirt: "< c2" 
 -- BinaryExp:loadArgs:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- INV:gen:after:E.loadArgs "c1 < c2" 
 -- OIadr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "c1 < c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $BinOp:invoke: "c1 < c2"  
 -- BinaryExp:invoke: "c1" rec: "c1 < c2" 
 -- M: "< c2" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- $ObjectInvocation_Binary:invoke: "< c2" >rec:"c1" ATd:"pattern" E:"< c2" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< c2" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- origin:isValueObj "char" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"c1":rec:c1 
 -- OI:invoke:B: "< c2" E: "< c2"  rec: "c1"  useRtnV: true "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 51;   in V: var char;   out B: var boolean" E: "< c2" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< c2" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "c1" E: "< c2" 
 -- arg:other 
 lt
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"< c2":rec:c1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < c2 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "Beq" dstE: "Beq" dstE.ATd: "out Beq: var boolean" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "c1 < c2" 
 -- isArgOfAssignI2IwithUniValArg "Beq := c1 < c2" arg: "c1 < c2" ObjectGenerator 
 -- arg.super.arg: "c1 < c2" BinOp 
 -- recx:BinaryExp:recx: "c1 < c2" 
 -- M: "< c2" label: "ObjectInvocation_Binary" M.ATd: "<  : {   %basic 51;   in V: var char;   out B: var boolean}" 
 -- checkInt2IntWithUnitArg:rec: "c1" E: "< c2" 
 -- arg:other 
 -- M:arg: "c2" ObjectGenerator false 
 -- dstDI: "out Beq: var boolean" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"Beq":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg <=$109 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "leave(matchEq)" 
 -- $ObjectGenerator:gen: "leave(matchEq)" >OGid:"leave" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "leave(matchEq)" 
 -- OG:before:super.gen: "leave(matchEq)" 
 -- $Invocation:gen: "leave(matchEq)" >useRtnV:"False"superAdj: 0 descNo: 19 
 -- INV:gen: "leave(matchEq)" 
 -- isConstant: "Invocation" "leave(matchEq)" 
 -- needorigin: "leave(matchEq)" 
 -- needOrigin:E: "leave(matchEq)"  E.ATd: "leave(V: var integer): {   %basic 103}" 
 -- doNeedOrigin:Ex: "leave(matchEq)" 
 -- computeAdr:superAdj: 0 "leave(matchEq)" 
 -- computeAdr: 1 :rec: "none"  E: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "leave(matchEq)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "leave(matchEq)" >on:7 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "leave(matchEq)" >ATd.off:0 (isPtn):on:7:superAdj:0"leave(V: var integer): {   %basic 103":Adr:off:0 size:0 isFloat:F isUnitVal:F superAd ...} 
 -- $pattern:getAdr: "leave(V: var integer): {   %basic 103" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- E.on: 7 
 -- beforeIsValueObj:E: "leave(matchEq)"  ATd: "leave(V: var integer): {   %basic 103}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- computeAdr:isLast:E:  "leave(matchEq)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:- 
 -- rec:  "leave(matchEq)" E:  "leave(matchEq)" 
 -- INV:gen:E.loadArgs "leave(matchEq)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "leave(matchEq)" >staticOff:0 "leave(V: var integer): {   %basic 103" superAdj:0arg:"matchEq"} 
 -- $pattern:loadArgs: "leave(V: var integer): {   %basic 103" >E:"leave(matchEq)":descNo:19} 
 -- INV:gen:after:E.loadArgs "leave(matchEq)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "leave(matchEq)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "leave(matchEq)" >rec:"leave(matchEq)" ATd:"pattern" E:"leave(matchEq)" E.ATd:"leave(V: var integer)" unique:"False" 
 -- OI:invoke: "leave(matchEq)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- OI:invoke:B: "leave(matchEq)" E: "leave(matchEq)"  rec: "leave(matchEq)"  useRtnV: false "leave(V: var integer): {   %basic 103}" 
 -- OI:invoke:before:ATdx.invoke: pattern leave(V: var integer) 
 -- $pattern:invoke: "leave(V: var integer): {   %basic 103" E: "leave(matchEq)" useRTNv: "False"} 
 -- ptn:invoke: "leave(V: var integer)" E: "leave(matchEq)" ptnKind: 0 useRtnV: false 
 break  2 2 114 0
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 -- 
 -- OI:invoke:C: leave(matchEq) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"leave(matchEq)":rec:leave(matchEq) 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 125 
 -- Items:GenClass: puttext descNo: 125 isValue: false 
 -- Items:GenClass: puttext descNo: 21 isValue: false 

 CLASS puttext 125 1 ConsoleIF 8
 -- Store itemArgs: inner(puttext) 
 -- T: var LIB.StringLib.String true 5 
 pushThis 
 rstoreg  T 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=125 vDescInx=125 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(puttext)" 
 -- $ObjectGenerator:gen: "inner(puttext)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(puttext)" 
 -- OG:before:super.gen: "inner(puttext)" 
 -- $Invocation:gen: "inner(puttext)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(puttext)" 
 -- isConstant: "Invocation" "inner(puttext)" 
 -- needorigin: "inner(puttext)" 
 -- needOrigin:E: "inner(puttext)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(puttext)" 
 -- computeAdr:superAdj: 0 "inner(puttext)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(puttext)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(puttext)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(puttext)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(puttext)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(puttext)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- computeAdr:isLast:E:  "inner(puttext)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:- 
 -- rec:  "inner(puttext)" E:  "inner(puttext)" 
 -- INV:gen:E.loadArgs "inner(puttext)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(puttext)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"puttext"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(puttext)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(puttext)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(puttext)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(puttext)" >rec:"inner(puttext)" ATd:"pattern" E:"inner(puttext)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(puttext)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- OI:invoke:B: "inner(puttext)" E: "inner(puttext)"  rec: "inner(puttext)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(puttext)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(puttext)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 -- 
 -- OI:invoke:C: inner(puttext) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(puttext)":rec:inner(puttext) 
 L2:
 -- pushReturn:  "puttext" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=125 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 126 
 -- Items:GenClass: putint descNo: 126 isValue: false 
 -- Items:GenClass: putint descNo: 21 isValue: false 

 CLASS putint 126 1 ConsoleIF 8
 -- Store itemArgs: inner(putint) 
 -- V: var Integer true 1 
 -- DI:store: "V" 
 pushThis 
 storeg integer$5 2
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=126 vDescInx=126 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(putint)" 
 -- $ObjectGenerator:gen: "inner(putint)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(putint)" 
 -- OG:before:super.gen: "inner(putint)" 
 -- $Invocation:gen: "inner(putint)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(putint)" 
 -- isConstant: "Invocation" "inner(putint)" 
 -- needorigin: "inner(putint)" 
 -- needOrigin:E: "inner(putint)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(putint)" 
 -- computeAdr:superAdj: 0 "inner(putint)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(putint)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(putint)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(putint)" >on:2 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(putint)" >ATd.off:0 (isPtn):on:2:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F  ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "inner(putint)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- computeAdr:isLast:E:  "inner(putint)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:- 
 -- rec:  "inner(putint)" E:  "inner(putint)" 
 -- INV:gen:E.loadArgs "inner(putint)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(putint)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"putint"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(putint)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(putint)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(putint)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(p ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(putint)" >rec:"inner(putint)" ATd:"pattern" E:"inner(putint)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(putint)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- OI:invoke:B: "inner(putint)" E: "inner(putint)"  rec: "inner(putint)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(putint)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(putint)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 -- 
 -- OI:invoke:C: inner(putint) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(putint)":rec:inner(putint) 
 L2:
 -- pushReturn:  "putint" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=2 descInx=126 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 127 
 -- Items:GenClass: workspace descNo: 127 isValue: false 
 -- Items:GenClass: workspace descNo: 21 isValue: false 

 CLASS workspace 127 1 BETAworld 1
 -- Store itemArgs: %id "workspace"{%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib;%domain_boundary;--AbstractEx;--AccessEx;--ApplyPred;--ArduinoEx;--ArmBasicS ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=127 vDescInx=127 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "workspace""  
 -- $Property:gen: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib"  
 -- Module:genMI:  "demo" 
 -- $Property:gen: "%domain_boundary"  
 -- $ModuleItem:gen: "--AbstractEx{" } 
 -- $ModuleItem:gen: "--AccessEx{" } 
 -- $ModuleItem:gen: "--ApplyPred{" } 
 -- $ModuleItem:gen: "--ArduinoEx{" } 
 -- $ModuleItem:gen: "--ArmBasicSys{" } 
 -- $ModuleItem:gen: "--ArmLed{" } 
 -- $ModuleItem:gen: "--ArmMultiCore{" } 
 -- $ModuleItem:gen: "--CAStest{" } 
 -- $ModuleItem:gen: "--CAStestCore{" } 
 -- $ModuleItem:gen: "--CoroutineEx{" } 
 -- $ModuleItem:gen: "--CppEx{" } 
 -- $ModuleItem:gen: "--DumpObjEx{" } 
 -- $ModuleItem:gen: "--Errors{" } 
 -- $ModuleItem:gen: "--FoolishUnitEx{" } 
 -- $ModuleItem:gen: "--ForkGC{" } 
 -- $ModuleItem:gen: "--FuncVirtExVclass{" } 
 -- $ModuleItem:gen: "--FunctionalVirtEx{" } 
 -- $ModuleItem:gen: "--Jurgen{" } 
 -- $ModuleItem:gen: "--LLVMex{" } 
 -- $ModuleItem:gen: "--ListLiteralEx{" } 
 -- $ModuleItem:gen: "--LockTestCore{" } 
 -- $ModuleItem:gen: "--MVRsystem{" } 
 -- $ModuleItem:gen: "--MapEx{" } 
 -- $ModuleItem:gen: "--MiniVal{" } 
 -- $ModuleItem:gen: "--NewInner{" } 
 -- $ModuleItem:gen: "--NewSyntax{" } 
 -- $ModuleItem:gen: "--NoneEx{" } 
 -- $ModuleItem:gen: "--ObjectAndValues{" } 
 -- $ModuleItem:gen: "--ReadersSingleWriter{" } 
 -- $ModuleItem:gen: "--RemoteSuperVC{" } 
 -- $ModuleItem:gen: "--Restrictions{" } 
 -- $ModuleItem:gen: "--SlideEx{" } 
 -- $ModuleItem:gen: "--Sub1{" } 
 -- $ModuleItem:gen: "--TST{" } 
 -- $ModuleItem:gen: "--TstBreak{" } 
 -- $ModuleItem:gen: "--UnitIssues{" } 
 -- $ModuleItem:gen: "--UnitKindEx{" } 
 -- $ModuleItem:gen: "--UnitTest{" } 
 -- $ModuleItem:gen: "--ValueArray{" } 
 -- $ModuleItem:gen: "--ValueConv{" } 
 -- $ModuleItem:gen: "--ValueEx{" } 
 -- $ModuleItem:gen: "--ValueItemEx{" } 
 -- $ModuleItem:gen: "--ValueTypes{" } 
 -- $ModuleItem:gen: "--VirtError{" } 
 -- $ModuleItem:gen: "--VirtualEx{" } 
 -- $ModuleItem:gen: "--Visibility{" } 
 -- $ModuleItem:gen: "--demo{" } 
 -- ModuleItem:gen demo 
 -- $ModuleItem:gen: "--embodyex{" } 
 -- $ModuleItem:gen: "--hello{" } 
 -- $ModuleItem:gen: "--qbetaCmp{" } 
 -- $ModuleItem:gen: "--test{" } 
 -- $ModuleItem:gen: "--tiny{" } 
 -- $ModuleItem:gen: "--tinyA{" } 
 -- $ModuleItem:gen: "--tinyAA{" } 
 -- $ModuleItem:gen: "--tinyAB{" } 
 -- $ModuleItem:gen: "--tinyAC{" } 
 -- $ModuleItem:gen: "--tinyB{" } 
 -- $ModuleItem:gen: "--tinyC{" } 
 -- $ModuleItem:gen: "--tinyD{" } 
 -- $ModuleItem:gen: "--tinyE{" } 
 -- $ModuleItem:gen: "--tinyF{" } 
 -- $ModuleItem:gen: "--tinyG{" } 
 -- $ModuleItem:gen: "--tinyH{" } 
 -- $ModuleItem:gen: "--tinyI{" } 
 -- $ModuleItem:gen: "--tinyJ{" } 
 -- $ModuleItem:gen: "--tinyP{" } 
 -- $ModuleItem:gen: "--tinyQ{" } 
 -- $ModuleItem:gen: "--tinyR{" } 
 -- $ModuleItem:gen: "--tinyS{" } 
 -- $ModuleItem:gen: "--tinyV{" } 
 -- $ModuleItem:gen: "--tinyW{" } 
 -- $ModuleItem:gen: "--tinyX{" } 
 -- $ModuleItem:gen: "--tinyY{" } 
 -- $ModuleItem:gen: "--tinyZ{" } 
 -- $obj:gen: "demo: obj {   %id "demo";   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionE ..."} 
 -- $ObjectGenerator:gen: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx; ..."} 
 -- OG:gen: "%id "demo"{   --AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexEx;-- ...}" 
 pushThis 
 -- before objTmpStack:add:  128   "demo" 
 invoke demo 128 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "workspace"" 
 -- $Property:gen: "%id "workspace""  
 -- genclass:stmt: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib" 
 -- $Property:gen: "%visible BETA, LIB, LIB.BasicIO, LIB.Dimensions, LIB.StringLib"  
 -- genclass:stmt: "%domain_boundary" 
 -- $Property:gen: "%domain_boundary"  
 L2:
 -- pushReturn:  "workspace" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 128 
 -- Items:GenClass: demo descNo: 128 isValue: false 
 -- Items:GenClass: demo descNo: 21 isValue: false 

 CLASS demo 128 1 workspace 127
 -- Store itemArgs: %id "demo"{--AnimalMonitorSystem;--ArrayDemos;--Bank;--BasicValueSub;--BinTreeMerge;--Break;--COSex;--ChemicalPlantSystem;--CoArg;--CollectionEx;--ComplexE ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=128 vDescInx=128 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%id "demo""  
 -- $ModuleItem:gen: "--AnimalMonitorSystem{" } 
 -- $ModuleItem:gen: "--ArrayDemos{" } 
 -- $ModuleItem:gen: "--Bank{" } 
 -- $ModuleItem:gen: "--BasicValueSub{" } 
 -- $ModuleItem:gen: "--BinTreeMerge{" } 
 -- $ModuleItem:gen: "--Break{" } 
 -- $ModuleItem:gen: "--COSex{" } 
 -- $ModuleItem:gen: "--ChemicalPlantSystem{" } 
 -- $ModuleItem:gen: "--CoArg{" } 
 -- $ModuleItem:gen: "--CollectionEx{" } 
 -- $ModuleItem:gen: "--ComplexEx{" } 
 -- $ModuleItem:gen: "--FactorialEx{" } 
 -- $ModuleItem:gen: "--FileDemo{" } 
 -- $ModuleItem:gen: "--ForkJoinEx{" } 
 -- $ModuleItem:gen: "--Formater{" } 
 -- $ModuleItem:gen: "--ISoLA2022{" } 
 -- $ModuleItem:gen: "--KBprocess{" } 
 -- $ModuleItem:gen: "--LibraEx{" } 
 -- $ModuleItem:gen: "--MixedScheduling{" } 
 -- $ModuleItem:gen: "--MonitorDemo{" } 
 -- $ModuleItem:gen: "--NonBlockingIOex{" } 
 -- $ModuleItem:gen: "--NullList{" } 
 -- $ModuleItem:gen: "--PointEx{" } 
 -- $ModuleItem:gen: "--Robots{" } 
 -- $ModuleItem:gen: "--SCPex{" } 
 -- $ModuleItem:gen: "--SimpleEx{" } 
 -- $ModuleItem:gen: "--SimpleThreadEx{" } 
 -- $ModuleItem:gen: "--SocketEx{" } 
 -- $ModuleItem:gen: "--Static{" } 
 -- $ModuleItem:gen: "--TempEx{" } 
 -- $ModuleItem:gen: "--ToyCar{" } 
 -- $ModuleItem:gen: "--UnitEx{" } 
 -- ModuleItem:gen UnitEx 
 -- $ModuleItem:gen: "--Units{" } 
 -- $ModuleItem:gen: "--ValueDemo{" } 
 -- $ModuleItem:gen: "--localsEx{" } 
 -- $obj:gen: "UnitEx: obj {   %requires Dimensions, Area, Length, Temperature, Velocity, Time;   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.Squ ..."} 
 -- $ObjectGenerator:gen: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.SquareM ..."} 
 -- OG:gen: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{   %visible Dimensions;   Figure: ;      theArea:< ;         out A: var Area.SquareMeter;          ...}" 
 pushThis 
 -- before objTmpStack:add:  129   "UnitEx" 
 invoke UnitEx 129 2 1
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%id "demo"" 
 -- $Property:gen: "%id "demo""  
 L2:
 -- pushReturn:  "demo" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 129 
 -- Items:GenClass: UnitEx descNo: 129 isValue: false 
 -- Items:GenClass: UnitEx descNo: 21 isValue: false 

 CLASS UnitEx 129 1 demo 128
 -- Store itemArgs: %requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter;      inner(th ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=129 vDescInx=129 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%requires Dimensions, Area, Length, Temperature, Velocity, Time"  
 -- $Property:gen: "%visible Dimensions"  
 -- $var:gen: "L1: var Length.Meter"  
 -- DI:gen: "L1: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L1 
 -- $ObjectGenerator:gen: "Length.Meter" >OGid:"Meter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Length.Meter" 
 -- OG:before:super.gen: "Length.Meter" 
 -- $Invocation:gen: "Length.Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.Meter" 
 -- isConstant: "Invocation" "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Length" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  Meter 74 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "L2: var Length.Foot"  
 -- DI:gen: "L2: var Length.Foot" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L2 
 -- $ObjectGenerator:gen: "Length.Foot" >OGid:"Foot" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Length.Foot" 
 -- OG:before:super.gen: "Length.Foot" 
 -- $Invocation:gen: "Length.Foot" >useRtnV:"False"superAdj: 0 descNo: 130 
 -- INV:gen: "Length.Foot" 
 -- isConstant: "Invocation" "Length.Foot" 
 -- needorigin: "Length.Foot" 
 -- needOrigin:E: "Foot"  E.ATd: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ; ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;       ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Foot" 
 -- INV:gen:E.loadArgs "Foot" 
 -- $ObjectInvocation_Unary:loadArgs: "Foot" >staticOff:0 "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0 ..."} 
 -- $pattern:loadArgs: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ..."} 
 -- ptn:loadArgs:E "Foot" 
 -- {(ObjectInvocation_Unary; (name: "Foot"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Foot" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Foot" 
 -- $ObjectInvocation_Unary:invoke: "Foot" >rec:"Length" ATd:"pattern" isValueObj E:"Foot" E.ATd:"Foot" unique:"False" 
 -- OI:invoke: "Foot" 
 -- 
 -- OI:invoke:B: "Foot" E: "Foot"  rec: "Length"  useRtnV: false "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnit ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Foot 
 -- $pattern:invoke: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('! ..."} 
 -- ptn:invoke: "Foot" E: "Foot" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 adr:none 
 invokeVal  Foot 130 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Foot :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "L3: var Length.Meter"  
 -- DI:gen: "L3: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L3 
 -- $ObjectGenerator:gen: "Length.Meter" >OGid:"Meter" IS.isempty! staticOff=6 descNo=0 superAdj=0 
 -- OG:gen: "Length.Meter" 
 -- OG:before:super.gen: "Length.Meter" 
 -- $Invocation:gen: "Length.Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.Meter" 
 -- isConstant: "Invocation" "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Length" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 adr:none 
 invokeVal  Meter 74 5
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $obj:gen: "R: obj Rectangle"  
 -- DI:gen: "R: obj Rectangle" DI:isConst: true :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- $ObjectGenerator:gen: "Rectangle" >OGid:"Rectangle" IS.isempty! staticOff=8 descNo=0 superAdj=0 
 -- OG:gen: "Rectangle" 
 -- OG:before:super.gen: "Rectangle" 
 -- $Invocation:gen: "Rectangle" >useRtnV:"False"superAdj: 0 descNo: 133 
 -- INV:gen: "Rectangle" 
 -- isConstant: "Invocation" "Rectangle" 
 -- needorigin: "Rectangle" 
 -- needOrigin:E: "Rectangle"  E.ATd: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Me ...}" 
 -- doNeedOrigin:Ex: "Rectangle" 
 -- computeAdr:superAdj: 0 "Rectangle" 
 -- computeAdr: 1 :rec: "none"  E: "Rectangle" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Rectangle"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Rectangle" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "Rectangle" >ATd.off:0 (isPtn):on:0:superAdj:0"Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w ..."} 
 -- $pattern:getAdr: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width : ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:- 
 -- computeAdr:isLast:E:  "Rectangle" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:- 
 -- rec:  "Rectangle" E:  "Rectangle" 
 -- INV:gen:E.loadArgs "Rectangle" 
 -- $ObjectInvocation_Unary:loadArgs: "Rectangle" >staticOff:0 "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter; ..."} 
 -- $pattern:loadArgs: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width ..."} 
 -- ptn:loadArgs:E "Rectangle" 
 -- {(ObjectInvocation_Unary; (name: "Rectangle"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Rectangle" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Rectangle" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":re ... 
 -- $ObjectInvocation_Unary:invoke: "Rectangle" >rec:"Rectangle" ATd:"pattern" E:"Rectangle" E.ATd:"Rectangle" unique:"False" 
 -- OI:invoke: "Rectangle" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:Rectangle 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:Rectangle 
 -- OI:invoke:B: "Rectangle" E: "Rectangle"  rec: "Rectangle"  useRtnV: false "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: va ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Rectangle 
 -- $pattern:invoke: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width : ..."} 
 -- ptn:invoke: "Rectangle" E: "Rectangle" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 8 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:Rectangle 
 invoke Rectangle 133 8 1
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:Rectangle 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:Rectangle 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Rectangle :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Rectangle":rec:Rectangle 
 -- $var:gen: "V: var Velocity.MeterPerSecond"  
 -- DI:gen: "V: var Velocity.MeterPerSecond" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  V 
 -- $ObjectGenerator:gen: "Velocity.MeterPerSecond" >OGid:"MeterPerSecond" IS.isempty! staticOff=9 descNo=0 superAdj=0 
 -- OG:gen: "Velocity.MeterPerSecond" 
 -- OG:before:super.gen: "Velocity.MeterPerSecond" 
 -- $Invocation:gen: "Velocity.MeterPerSecond" >useRtnV:"False"superAdj: 0 descNo: 96 
 -- INV:gen: "Velocity.MeterPerSecond" 
 -- isConstant: "Invocation" "Velocity.MeterPerSecond" 
 -- needorigin: "Velocity.MeterPerSecond" 
 -- needOrigin:E: "MeterPerSecond"  E.ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Velocity" E:  "MeterPerSecond" 
 -- INV:gen:E.loadArgs "MeterPerSecond" 
 -- $ObjectInvocation_Unary:loadArgs: "MeterPerSecond" >staticOff:0 "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ..."} 
 -- $pattern:loadArgs: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" >E:"MeterPerSecond":desc ...} 
 -- ptn:loadArgs:E "MeterPerSecond" 
 -- {(ObjectInvocation_Unary; (name: "MeterPerSecond"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "MeterPerSecond" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "MeterPerSecond" 
 -- $ObjectInvocation_Unary:invoke: "MeterPerSecond" >rec:"Velocity" ATd:"pattern" isValueObj E:"MeterPerSecond" E.ATd:"MeterPerSecond" unique:"False" 
 -- OI:invoke: "MeterPerSecond" 
 -- 
 -- OI:invoke:B: "MeterPerSecond" E: "MeterPerSecond"  rec: "Velocity"  useRtnV: false "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterP ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern MeterPerSecond 
 -- $pattern:invoke: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" E: "MeterPerSecond" useRTN ...} 
 -- ptn:invoke: "MeterPerSecond" E: "MeterPerSecond" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 9 adr:none 
 invokeVal  MeterPerSecond 96 8
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: MeterPerSecond :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "T: var Time.Minutes"  
 -- DI:gen: "T: var Time.Minutes" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  T 
 -- $ObjectGenerator:gen: "Time.Minutes" >OGid:"Minutes" IS.isempty! staticOff=11 descNo=0 superAdj=0 
 -- OG:gen: "Time.Minutes" 
 -- OG:before:super.gen: "Time.Minutes" 
 -- $Invocation:gen: "Time.Minutes" >useRtnV:"False"superAdj: 0 descNo: 102 
 -- INV:gen: "Time.Minutes" 
 -- isConstant: "Invocation" "Time.Minutes" 
 -- needorigin: "Time.Minutes" 
 -- needOrigin:E: "Minutes"  E.ATd: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary::  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magni ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Time" E:  "Minutes" 
 -- INV:gen:E.loadArgs "Minutes" 
 -- $ObjectInvocation_Unary:loadArgs: "Minutes" >staticOff:0 "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitu ..."} 
 -- $pattern:loadArgs: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnit ..."} 
 -- ptn:loadArgs:E "Minutes" 
 -- {(ObjectInvocation_Unary; (name: "Minutes"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Minutes" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Minutes" 
 -- $ObjectInvocation_Unary:invoke: "Minutes" >rec:"Time" ATd:"pattern" isValueObj E:"Minutes" E.ATd:"Minutes" unique:"False" 
 -- OI:invoke: "Minutes" 
 -- 
 -- OI:invoke:B: "Minutes" E: "Minutes"  rec: "Time"  useRtnV: false "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Minutes 
 -- $pattern:invoke: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnitud ..."} 
 -- ptn:invoke: "Minutes" E: "Minutes" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 11 adr:none 
 invokeVal  Minutes 102 10
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Minutes :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "A: var Area.SquareMeter"  
 -- DI:gen: "A: var Area.SquareMeter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  A 
 -- $ObjectGenerator:gen: "Area.SquareMeter" >OGid:"SquareMeter" IS.isempty! staticOff=13 descNo=0 superAdj=0 
 -- OG:gen: "Area.SquareMeter" 
 -- OG:before:super.gen: "Area.SquareMeter" 
 -- $Invocation:gen: "Area.SquareMeter" >useRtnV:"False"superAdj: 0 descNo: 68 
 -- INV:gen: "Area.SquareMeter" 
 -- isConstant: "Invocation" "Area.SquareMeter" 
 -- needorigin: "Area.SquareMeter" 
 -- needOrigin:E: "SquareMeter"  E.ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Area" E:  "SquareMeter" 
 -- INV:gen:E.loadArgs "SquareMeter" 
 -- $ObjectInvocation_Unary:loadArgs: "SquareMeter" >staticOff:0 "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print ..."} 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"SquareMeter":descNo:68} 
 -- ptn:loadArgs:E "SquareMeter" 
 -- {(ObjectInvocation_Unary; (name: "SquareMeter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "SquareMeter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "SquareMeter" 
 -- $ObjectInvocation_Unary:invoke: "SquareMeter" >rec:"Area" ATd:"pattern" isValueObj E:"SquareMeter" E.ATd:"SquareMeter" unique:"False" 
 -- OI:invoke: "SquareMeter" 
 -- 
 -- OI:invoke:B: "SquareMeter" E: "SquareMeter"  rec: "Area"  useRtnV: false "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "Square ..."}" 
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- $pattern:invoke: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" E: "SquareMeter" useRTNv: "False"} 
 -- ptn:invoke: "SquareMeter" E: "SquareMeter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 13 adr:none 
 invokeVal  SquareMeter 68 12
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: SquareMeter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%requires Dimensions, Area, Length, Temperature, Velocity, Time" 
 -- $Property:gen: "%requires Dimensions, Area, Length, Temperature, Velocity, Time"  
 -- genclass:stmt: "%visible Dimensions" 
 -- $Property:gen: "%visible Dimensions"  
 -- genclass:stmt: ""Hello UnitEx\n".print" 
 -- $ObjectGenerator:gen: ""Hello UnitEx\n".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Hello UnitEx\n".print" 
 -- OG:before:super.gen: ""Hello UnitEx\n".print" 
 -- $Invocation:gen: ""Hello UnitEx\n".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Hello UnitEx\n".print" 
 -- isConstant: "Invocation" ""Hello UnitEx\n".print" 
 -- needorigin: ""Hello UnitEx\n".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Hello UnitEx\n"" E:  ""Hello UnitEx\n"" 
 -- INV:gen:E.loadArgs ""Hello UnitEx\n"" 
 -- $String::loadArgs: ""Hello UnitEx\n""  
 -- INV:gen:after:E.loadArgs ""Hello UnitEx\n"" 
 -- OIadr: 
 -- $String::invoke: ""Hello UnitEx\n""  
 pushText "Hello UnitEx\n"
 -- IV:gen:checkTail: ""Hello UnitEx\n".print" E: ""Hello UnitEx\n"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Hello UnitEx\n"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Hello UnitEx\n""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L1 := Length.F2M(12.0)" 
 -- $Assign:gen: "L1 := Length.F2M(12.0)"  
 -- assign: "L1 := Length.F2M(12.0)" 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- AssignmentStatement:gen: "L1 := Length.F2M(12.0)" right.label: "ObjectGenerator" "Length.F2M(12.0)" 
 -- $ObjectGenerator:gen: "Length.F2M(12.0)" >OGid:"F2M" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Length.F2M(12.0)" 
 -- OG:before:super.gen: "Length.F2M(12.0)" 
 -- $Invocation:gen: "Length.F2M(12.0)" >useRtnV:"True"superAdj: 0 descNo: 134 
 -- INV:gen: "Length.F2M(12.0)" 
 -- isConstant: "Invocation" "Length.F2M(12.0)" 
 -- needorigin: "Length.F2M(12.0)" 
 -- needOrigin:E: "F2M(12.0)"  E.ATd: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- doNeedOrigin:Ex: "F2M(12.0)" 
 -- computeAdr:superAdj: 0 "Length.F2M(12.0)" 
 -- computeAdr: 1 :rec: "none"  E: "Length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Length" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- IV:viaIncl:on: 1 "Dimensions"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.Squar ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: true "Dimensions" 
 -- IV:viaIncl:on: 0 "LIB"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter; ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "LIB" 
 -- items:goOrigin:encOG: "UnitEx" on: 3 isValueObj: false 
 -- origin: demo origin:isValueObj: false 
 rpushg UnitEx$129 1
 -- items:goOrigin:encOG: "demo" on: 2 isValueObj: false 
 -- origin: workspace origin:isValueObj: false 
 rpushg demo$128 1
 -- items:goOrigin:encOG: "workspace" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- $ObjectInvocation_Unary:getAdr: "Length" >ATd.off:0 (isPtn):on:0:superAdj:0"--Length{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ...} 
 -- $ModuleItem:getAdr: "--Length{" } 
 -- $obj:getAdr: "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit::  ..."} 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Length"  E: "F2M(12.0)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "F2M(12.0)" >ATd.off:0 (isPtn):on:0:superAdj:0"F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')": ...} 
 -- $pattern:getAdr: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" } 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Length" >staticOff:0 "--Length{" superAdj:0} 
 -- $ModuleItem:loadArgs: "--Length{" } 
 -- $ObjectInvocation_Unary:invoke: "Length" >rec:"Length" ATd:"ModuleItem" E:"F2M(12.0)" E.ATd:"F2M" unique:"False" 
 -- OI:invoke: "Length" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- OI:invoke:B: "Length" E: "F2M(12.0)"  rec: "Length"  useRtnV: true "--Length{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem Length 
 -- $ModuleItem:invoke: "--Length{" E: "F2M(12.0)" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit::  ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg Length 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- 
 -- OI:invoke:C: Length :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Length" E: "F2M(12.0)" 
 -- arg:float 
 -- computeAdr:isLast:E:  "F2M(12.0)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- rec:  "Length" E:  "F2M(12.0)" 
 -- INV:gen:E.loadArgs "F2M(12.0)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "F2M(12.0)" >staticOff:0 "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" superAdj:0arg:"12.0 ..."} 
 -- $pattern:loadArgs: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" >E:"F2M(12.0)":descNo:134} 
 -- ptn:loadArgs:E "F2M(12.0)" 
 -- {(ObjectInvocation_KeyWord; (name: "F2M"); (Arguments;  (name: "F2M");  (name: "(");  (ObjectGenerator;   (Invocation;    (FloatLiteral 12.0));   (Items descNo: 0 origDesc ...} 
 -- args: "F2M(12.0)" 
 -- E: "ObjectGenerator" 12.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "F2M(12.0)" "ObjectInvocation_KeyWord" ActArg:  "12.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "F2M(12.0)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "12.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "12.0" 
 -- OG:before:super.gen: "12.0" 
 -- $Invocation:gen: "12.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "12.0" 
 -- isConstant: "Invocation" "12.0" 
 -- needorigin: "12.0" 
 -- needOrigin:E: "12.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "12.0" E:  "12.0" 
 -- INV:gen:E.loadArgs "12.0" 
 -- $FloatLiteral:loadArgs: "12.0"  
 -- INV:gen:after:E.loadArgs "12.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "12.0" 
 -- $FloatLiteral:invoke: "12.0"  
 pushFloatConst 12.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "12.0" :isBasicVal: true 
 -- case:B: 12.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "F2M(12.0)" 
 -- INV:gen:after:E.loadArgs "F2M(12.0)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "F2M(12.0)" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":r ... 
 -- $ObjectInvocation_KeyWord:invoke: "F2M(12.0)" >rec:"Length" ATd:"pattern" E:"F2M(12.0)" E.ATd:"F2M" unique:"False" 
 -- OI:invoke: "F2M(12.0)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- OI:invoke:B: "F2M(12.0)" E: "F2M(12.0)"  rec: "Length"  useRtnV: true "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OI:invoke:before:ATdx.invoke: pattern F2M 
 -- $pattern:invoke: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" E: "F2M(12.0)" useRTNv: "True"} 
 -- ptn:invoke: "F2M" E: "F2M(12.0)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 invoke F2M 134 0 0
 -- global:pushOut: R off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- OI:invoke:C: F2M(12.0) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(12.0)":rec:Length 
 -- rec: "L1" dstE: "L1" dstE.ATd: "L1: var Length.Meter" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" Length.F2M(12.0) 
 -- pushValue: A: off: 4 size: 5 descNo: -1 Length.F2M(12.0) 
 pushvalue  off:4 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:2 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "L1" off: 2 size: 2 mode: 0 
 vassign  2 2 0
 -- assign:adr.store:B: 
 -- genclass:stmt: "L1.print" 
 -- $ObjectGenerator:gen: "L1.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1.print" 
 -- OG:before:super.gen: "L1.print" 
 -- $Invocation:gen: "L1.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "L1.print" 
 -- isConstant: "Invocation" "L1.print" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L1.print" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr: 2 :rec: "L1"  E: "print"  A.E: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "print"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L1" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- rec:  "L1" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L1" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:B: "print" E: "print"  rec: "L1"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- isDI 
 -- isStatic: true rec: "L1" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L2.fromPrimary(L1.toPrimary)" 
 -- $ObjectGenerator:gen: "L2.fromPrimary(L1.toPrimary)" >OGid:"fromPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2.fromPrimary(L1.toPrimary)" 
 -- OG:before:super.gen: "L2.fromPrimary(L1.toPrimary)" 
 -- $Invocation:gen: "L2.fromPrimary(L1.toPrimary)" >useRtnV:"False"superAdj: 0 descNo: 135 
 -- INV:gen: "L2.fromPrimary(L1.toPrimary)" 
 -- isConstant: "Invocation" "L2.fromPrimary(L1.toPrimary)" 
 -- notConst: L2 L2: var Length.Foot 
 -- needorigin: "L2.fromPrimary(L1.toPrimary)" 
 -- needOrigin:E: "fromPrimary(L1.toPrimary)"  E.ATd: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- doNeedOrigin:Ex: "fromPrimary(L1.toPrimary)" 
 -- origin:isValueObj: "Foot" 
 -- computeAdr:superAdj: 0 "L2.fromPrimary(L1.toPrimary)" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:0:superAdj:0"L2: var Length.Foot":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $var:getAdr: "L2: var Length.Foot" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Foot 
 -- before:floatTest:  "L2: var Length.Foot" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr: 2 :rec: "L2"  E: "fromPrimary(L1.toPrimary)"  A.E: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "fromPrimary(L1.toPrimary)" >ATd.off:0 (isPtn):on:0:superAdj:0"fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048":Adr:of ...} 
 -- $pattern:getAdr: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var Length.Foot" superAdj:0 
 -- $var:loadArgs: "L2: var Length.Foot" >E:"L2" 
 -- $pattern:loadArgs: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"fromPrimary(L1.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "fromPrimary(L1.toPrimary)"  rec: "L2"  useRtnV: true "L2: var Length.Foot" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var Length.Foot" E: "fromPrimary(L1.toPrimary)">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var Length.Foot" 
 -- isValueObj:isAdr: true objSize: 2  rec "L2" ,E: "fromPrimary(L1.toPrimary)" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 130
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L2" E: "fromPrimary(L1.toPrimary)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "fromPrimary(L1.toPrimary)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- rec:  "L2" E:  "fromPrimary(L1.toPrimary)" 
 -- INV:gen:E.loadArgs "fromPrimary(L1.toPrimary)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fromPrimary(L1.toPrimary)" >staticOff:0 "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" superAdj:0arg:"L1.toPrima ..."} 
 -- $pattern:loadArgs: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" >E:"fromPrimary(L1.toPrimary)":descNo:135} 
 -- ptn:loadArgs:E "fromPrimary(L1.toPrimary)" 
 -- {(ObjectInvocation_KeyWord; (name: "fromPrimary"); (Arguments;  (name: "fromPrimary");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (nam ...} 
 -- args: "fromPrimary(L1.toPrimary)" 
 -- E: "ObjectGenerator" L1.toPrimary 
 -- E.arg: "var" in base: var PrimaryUnit 
 -- NonVirt: "fromPrimary(L1.toPrimary)" "ObjectInvocation_KeyWord" ActArg:  "L1.toPrimary" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "fromPrimary(L1.toPrimary)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L1.toPrimary" >OGid:"toPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1.toPrimary" 
 -- OG:before:super.gen: "L1.toPrimary" 
 -- $Invocation:gen: "L1.toPrimary" >useRtnV:"True"superAdj: 0 descNo: 78 
 -- INV:gen: "L1.toPrimary" 
 -- isConstant: "Invocation" "L1.toPrimary" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1.toPrimary" 
 -- needOrigin:E: "toPrimary"  E.ATd: "toPrimary:: {   base.magnitude := magnitude}" 
 -- doNeedOrigin:Ex: "toPrimary" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L1.toPrimary" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr: 2 :rec: "L1"  E: "toPrimary"  A.E: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "toPrimary" >ATd.off:0 (isPtn):on:0:superAdj:0"toPrimary:: {   base.magnitude := magnitude":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj ...} 
 -- $pattern:getAdr: "toPrimary:: {   base.magnitude := magnitude" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "toPrimary"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "toPrimary">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L1" ,E: "toPrimary" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "toPrimary" 
 -- computeAdr:isLast:E:  "toPrimary" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- rec:  "L1" E:  "toPrimary" 
 -- INV:gen:E.loadArgs "toPrimary" 
 -- $ObjectInvocation_Unary:loadArgs: "toPrimary" >staticOff:0 "toPrimary:: {   base.magnitude := magnitude" superAdj:0} 
 -- $pattern:loadArgs: "toPrimary:: {   base.magnitude := magnitude" >E:"toPrimary":descNo:78} 
 -- ptn:loadArgs:E "toPrimary" 
 -- {(ObjectInvocation_Unary; (name: "toPrimary"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "toPrimary" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "toPrimary" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec ... 
 -- $ObjectInvocation_Unary:invoke: "toPrimary" >rec:"L1" ATd:"pattern" E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "toPrimary" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- OI:invoke:B: "toPrimary" E: "toPrimary"  rec: "L1"  useRtnV: true "toPrimary:: {   base.magnitude := magnitude}" 
 -- OI:invoke:before:ATdx.invoke: pattern toPrimary 
 -- $pattern:invoke: "toPrimary:: {   base.magnitude := magnitude" E: "toPrimary" useRTNv: "True"} 
 -- ptn:invoke: "toPrimary" E: "toPrimary" ptnKind: 3 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- isDI 
 -- isStatic: true rec: "L1" 
 invoke toPrimary 78 0 0
 -- global:pushOut: base off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke:X: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- OI:invoke:C: toPrimary :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L1 
 -- formalArg:isPtn: "in base: var PrimaryUnit" :isBasicVal: false :valueObj: true 
 -- :actArg: "L1.toPrimary" :isBasicVal: false 
 -- case:B: L1.toPrimary ObjectGenerator 0 0 0 true false 
 -- pushValue: D: off: 4 size: 2 0 in base: var PrimaryUnit 
 pushvalue  off:4 size:2 descNo: 0
 pushc 1
 -- end:loadArgs:NonVirt: "fromPrimary(L1.toPrimary)" 
 -- INV:gen:after:E.loadArgs "fromPrimary(L1.toPrimary)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fromPrimary(L1.toPrimary)" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue: ... 
 -- $ObjectInvocation_KeyWord:invoke: "fromPrimary(L1.toPrimary)" >rec:"L2" ATd:"pattern" E:"fromPrimary(L1.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "fromPrimary(L1.toPrimary)" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- origin:isValueObj "Foot" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- OI:invoke:B: "fromPrimary(L1.toPrimary)" E: "fromPrimary(L1.toPrimary)"  rec: "L2"  useRtnV: false "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- OI:invoke:before:ATdx.invoke: pattern fromPrimary 
 -- $pattern:invoke: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" E: "fromPrimary(L1.toPrimary)" useRTNv: "False"} 
 -- ptn:invoke: "fromPrimary" E: "fromPrimary(L1.toPrimary)" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- isDI 
 -- isStatic: true rec: "L2" 
 invoke fromPrimary 135 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: fromPrimary(L1.toPrimary) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L1.toPrimary)":rec:L2 
 -- genclass:stmt: "L2.print" 
 -- $ObjectGenerator:gen: "L2.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L2.print" 
 -- OG:before:super.gen: "L2.print" 
 -- $Invocation:gen: "L2.print" >useRtnV:"False"superAdj: 0 descNo: 136 
 -- INV:gen: "L2.print" 
 -- isConstant: "Invocation" "L2.print" 
 -- notConst: L2 L2: var Length.Foot 
 -- needorigin: "L2.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Foot".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Foot" 
 -- computeAdr:superAdj: 0 "L2.print" 
 -- computeAdr: 1 :rec: "none"  E: "L2" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L2"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L2" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L2" >ATd.off:4:on:0:superAdj:0"L2: var Length.Foot":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $var:getAdr: "L2: var Length.Foot" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Foot 
 -- before:floatTest:  "L2: var Length.Foot" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- computeAdr: 2 :rec: "L2"  E: "print"  A.E: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Foot".print":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ...} 
 -- $pattern:getAdr: "print:: {   "Foot".print" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L2" >staticOff:0 "L2: var Length.Foot" superAdj:0 
 -- $var:loadArgs: "L2: var Length.Foot" >E:"L2" 
 -- $pattern:loadArgs: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ..."} 
 -- ptn:loadArgs:E "L2" 
 -- {(ObjectInvocation_Unary; (name: "L2"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L2" >rec:"L2" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L2" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L2":rec:L2 
 -- OI:invoke:B: "L2" E: "print"  rec: "L2"  useRtnV: true "L2: var Length.Foot" 
 -- OI:invoke:before:ATdx.invoke: var L2 
 -- $var:invoke: "L2: var Length.Foot" E: "print">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L2: var Length.Foot" 
 -- isValueObj:isAdr: true objSize: 2  rec "L2" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 130
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- 
 -- OI:invoke:C: L2 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L2" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- rec:  "L2" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Foot".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Foot".print" >E:"print":descNo:136} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L2" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- origin:isValueObj "Foot" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- OI:invoke:B: "print" E: "print"  rec: "L2"  useRtnV: false "print:: {   "Foot".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Foot".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- isDI 
 -- isStatic: true rec: "L2" 
 invoke print 136 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L2 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L3 := Length.F2M(3.0)" 
 -- $Assign:gen: "L3 := Length.F2M(3.0)"  
 -- assign: "L3 := Length.F2M(3.0)" 
 -- computeAdr:superAdj: 0 "L3" 
 -- computeAdr: 1 :rec: "none"  E: "L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L3" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L3" >ATd.off:6:on:0:superAdj:0"L3: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L3: var Length.Meter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L3: var Length.Meter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- computeAdr:isLast:E:  "L3" 
 -- AssignmentStatement:gen: "L3 := Length.F2M(3.0)" right.label: "ObjectGenerator" "Length.F2M(3.0)" 
 -- $ObjectGenerator:gen: "Length.F2M(3.0)" >OGid:"F2M" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Length.F2M(3.0)" 
 -- OG:before:super.gen: "Length.F2M(3.0)" 
 -- $Invocation:gen: "Length.F2M(3.0)" >useRtnV:"True"superAdj: 0 descNo: 134 
 -- INV:gen: "Length.F2M(3.0)" 
 -- isConstant: "Invocation" "Length.F2M(3.0)" 
 -- needorigin: "Length.F2M(3.0)" 
 -- needOrigin:E: "F2M(3.0)"  E.ATd: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- doNeedOrigin:Ex: "F2M(3.0)" 
 -- computeAdr:superAdj: 0 "Length.F2M(3.0)" 
 -- computeAdr: 1 :rec: "none"  E: "Length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Length" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- IV:viaIncl:on: 1 "Dimensions"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.Squar ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: true "Dimensions" 
 -- IV:viaIncl:on: 0 "LIB"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter; ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "LIB" 
 -- items:goOrigin:encOG: "UnitEx" on: 3 isValueObj: false 
 -- origin: demo origin:isValueObj: false 
 rpushg UnitEx$129 1
 -- items:goOrigin:encOG: "demo" on: 2 isValueObj: false 
 -- origin: workspace origin:isValueObj: false 
 rpushg demo$128 1
 -- items:goOrigin:encOG: "workspace" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- $ObjectInvocation_Unary:getAdr: "Length" >ATd.off:0 (isPtn):on:0:superAdj:0"--Length{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ...} 
 -- $ModuleItem:getAdr: "--Length{" } 
 -- $obj:getAdr: "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit::  ..."} 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Length"  E: "F2M(3.0)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "F2M(3.0)" >ATd.off:0 (isPtn):on:0:superAdj:0"F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')":A ...} 
 -- $pattern:getAdr: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" } 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Length" >staticOff:0 "--Length{" superAdj:0} 
 -- $ModuleItem:loadArgs: "--Length{" } 
 -- $ObjectInvocation_Unary:invoke: "Length" >rec:"Length" ATd:"ModuleItem" E:"F2M(3.0)" E.ATd:"F2M" unique:"False" 
 -- OI:invoke: "Length" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- OI:invoke:B: "Length" E: "F2M(3.0)"  rec: "Length"  useRtnV: true "--Length{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem Length 
 -- $ModuleItem:invoke: "--Length{" E: "F2M(3.0)" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit::  ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg Length 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- 
 -- OI:invoke:C: Length :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Length" E: "F2M(3.0)" 
 -- arg:float 
 -- computeAdr:isLast:E:  "F2M(3.0)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- rec:  "Length" E:  "F2M(3.0)" 
 -- INV:gen:E.loadArgs "F2M(3.0)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "F2M(3.0)" >staticOff:0 "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" superAdj:0arg:"3.0"} 
 -- $pattern:loadArgs: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" >E:"F2M(3.0)":descNo:134} 
 -- ptn:loadArgs:E "F2M(3.0)" 
 -- {(ObjectInvocation_KeyWord; (name: "F2M"); (Arguments;  (name: "F2M");  (name: "(");  (ObjectGenerator;   (Invocation;    (FloatLiteral 3.0));   (Items descNo: 0 origDescN ...} 
 -- args: "F2M(3.0)" 
 -- E: "ObjectGenerator" 3.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "F2M(3.0)" "ObjectInvocation_KeyWord" ActArg:  "3.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "F2M(3.0)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "3.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "3.0" 
 -- OG:before:super.gen: "3.0" 
 -- $Invocation:gen: "3.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "3.0" 
 -- isConstant: "Invocation" "3.0" 
 -- needorigin: "3.0" 
 -- needOrigin:E: "3.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "3.0" E:  "3.0" 
 -- INV:gen:E.loadArgs "3.0" 
 -- $FloatLiteral:loadArgs: "3.0"  
 -- INV:gen:after:E.loadArgs "3.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.0" 
 -- $FloatLiteral:invoke: "3.0"  
 pushFloatConst 3.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "3.0" :isBasicVal: true 
 -- case:B: 3.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "F2M(3.0)" 
 -- INV:gen:after:E.loadArgs "F2M(3.0)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "F2M(3.0)" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "F2M(3.0)" >rec:"Length" ATd:"pattern" E:"F2M(3.0)" E.ATd:"F2M" unique:"False" 
 -- OI:invoke: "F2M(3.0)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- OI:invoke:B: "F2M(3.0)" E: "F2M(3.0)"  rec: "Length"  useRtnV: true "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OI:invoke:before:ATdx.invoke: pattern F2M 
 -- $pattern:invoke: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" E: "F2M(3.0)" useRTNv: "True"} 
 -- ptn:invoke: "F2M" E: "F2M(3.0)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 invoke F2M 134 0 0
 -- global:pushOut: R off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- OI:invoke:C: F2M(3.0) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.0)":rec:Length 
 -- rec: "L3" dstE: "L3" dstE.ATd: "L3: var Length.Meter" useRtn: false :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" Length.F2M(3.0) 
 -- pushValue: A: off: 4 size: 5 descNo: -1 Length.F2M(3.0) 
 pushvalue  off:4 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:2 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "L3" off: 6 size: 2 mode: 0 
 vassign  6 2 0
 -- assign:adr.store:B: 
 -- genclass:stmt: "R.set(L1,L3)" 
 -- $ObjectGenerator:gen: "R.set(L1,L3)" >OGid:"set" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "R.set(L1,L3)" 
 -- OG:before:super.gen: "R.set(L1,L3)" 
 -- $Invocation:gen: "R.set(L1,L3)" >useRtnV:"False"superAdj: 0 descNo: 137 
 -- INV:gen: "R.set(L1,L3)" 
 -- isConstant: "Invocation" "R.set(L1,L3)" 
 -- needorigin: "R.set(L1,L3)" 
 -- needOrigin:E: "set(L1,L3)"  E.ATd: "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- doNeedOrigin:Ex: "set(L1,L3)" 
 -- computeAdr:superAdj: 0 "R.set(L1,L3)" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:8:on:0:superAdj:0"R: obj Rectangle":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $obj:getAdr: "R: obj Rectangle" >newOff:8,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "set(L1,L3)" 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Function:getAdr: "set(L1,L3)" >ATd.off:0 (isPtn):on:0:superAdj:0"set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h": ...} 
 -- $pattern:getAdr: "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h" } 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "R" >staticOff:0 "R: obj Rectangle" superAdj:0 
 -- $obj:loadArgs: "R: obj Rectangle" >E:"R" 
 -- $pattern:loadArgs: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width ..."} 
 -- ptn:loadArgs:E "R" 
 -- {(ObjectInvocation_Unary; (name: "R"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "R" >rec:"R" ATd:"obj" E:"set(L1,L3)" E.ATd:"set" unique:"False" 
 -- OI:invoke: "R" 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- OI:invoke:B: "R" E: "set(L1,L3)"  rec: "R"  useRtnV: true "R: obj Rectangle" 
 -- OI:invoke:before:ATdx.invoke: obj R 
 -- $obj:invoke: "R: obj Rectangle" E: "set(L1,L3)">newOff:8 useRTNv: "True" 
 -- DI:invoke: "R: obj Rectangle" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 rpushg UnitEx$129 8
 -- OI:invoke:V: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- 
 -- OI:invoke:X: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- 
 -- OI:invoke:C: R :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "R" E: "set(L1,L3)" 
 -- arg:unit 
 -- rec:other: 
 -- computeAdr:isLast:E:  "set(L1,L3)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- rec:  "R" E:  "set(L1,L3)" 
 -- INV:gen:E.loadArgs "set(L1,L3)" 
 -- $ObjectInvocation_Function:loadArgs: "set(L1,L3)" >staticOff:0 "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h" superAdj:0arg:"L1"a ...} 
 -- $pattern:loadArgs: "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h" >E:"set(L1,L3)":descNo:137} 
 -- ptn:loadArgs:E "set(L1,L3)" 
 -- {(ObjectInvocation_Function; (name: "set"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L1");     (Arguments)));   (Items descNo: ...} 
 -- args: "(L1,L3)" 
 -- E: "ObjectGenerator" L1 
 -- E: "ObjectGenerator" L3 
 -- E.arg: "var" in w: var Length.Meter 
 -- NonVirt: "set(L1,L3)" "ObjectInvocation_Function" ActArg:  "L1" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "set(L1,L3)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L1" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1" 
 -- OG:before:super.gen: "L1" 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "L1">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L1" ,E: "L1" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 2 size: 2 74 in w: var Length.Meter 
 pushvalue  off:2 size:2 descNo: 74
 pushc 1
 -- end:loadArgs:NonVirt: "set(L1,L3)" 
 -- E.arg: "var" in h: var Length.Meter 
 -- NonVirt: "set(L1,L3)" "ObjectInvocation_Function" ActArg:  "L3" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "set(L1,L3)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L3" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L3" 
 -- OG:before:super.gen: "L3" 
 -- $Invocation:gen: "L3" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L3" 
 -- isConstant: "Invocation" "L3" 
 -- notConst: L3 L3: var Length.Meter 
 -- needorigin: "L3" 
 -- needOrigin:E: "L3"  E.ATd: "L3: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L3" 
 -- computeAdr: 1 :rec: "none"  E: "L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L3" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L3" >ATd.off:6:on:0:superAdj:0"L3: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L3: var Length.Meter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L3: var Length.Meter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- computeAdr:isLast:E:  "L3" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- rec:  "L3" E:  "L3" 
 -- INV:gen:E.loadArgs "L3" 
 -- $ObjectInvocation_Unary:loadArgs: "L3" >staticOff:0 "L3: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L3: var Length.Meter" >E:"L3" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L3" 
 -- {(ObjectInvocation_Unary; (name: "L3"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L3" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L3" :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L3" >rec:"L3" ATd:"var" isValueObj E:"L3" E.ATd:"L3" unique:"False" 
 -- OI:invoke: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- OI:invoke:B: "L3" E: "L3"  rec: "L3"  useRtnV: true "L3: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L3 
 -- $var:invoke: "L3: var Length.Meter" E: "L3">newOff:6 useRTNv: "True" 
 -- DI:invoke: "L3: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L3" ,E: "L3" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 6
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:C: L3 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 6 size: 2 74 in h: var Length.Meter 
 pushvalue  off:6 size:2 descNo: 74
 pushc 1
 -- end:loadArgs:NonVirt: "set(L1,L3)" 
 -- INV:gen:after:E.loadArgs "set(L1,L3)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "set(L1,L3)" :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3 ..." 
 -- $ObjectInvocation_Function:invoke: "set(L1,L3)" >rec:"R" ATd:"pattern" E:"set(L1,L3)" E.ATd:"set" unique:"False" 
 -- OI:invoke: "set(L1,L3)" 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- OI:invoke:B: "set(L1,L3)" E: "set(L1,L3)"  rec: "R"  useRtnV: false "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h}" 
 -- OI:invoke:before:ATdx.invoke: pattern set 
 -- $pattern:invoke: "set: {   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h" E: "set(L1,L3)" useRTNv: "False"} 
 -- ptn:invoke: "set" E: "set(L1,L3)" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 invoke set 137 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -7 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: set(L1,L3) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 8 
 -- OG:gen:end: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"set(L1,L3)":rec:R 
 -- genclass:stmt: "R.print" 
 -- $ObjectGenerator:gen: "R.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "R.print" 
 -- OG:before:super.gen: "R.print" 
 -- $Invocation:gen: "R.print" >useRtnV:"False"superAdj: 0 descNo: 141 
 -- INV:gen: "R.print" 
 -- isConstant: "Invocation" "R.print" 
 -- needorigin: "R.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print; ...}" 
 -- doNeedOrigin:Ex: "print" 
 -- computeAdr:superAdj: 0 "R.print" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:8:on:0:superAdj:0"R: obj Rectangle":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $obj:getAdr: "R: obj Rectangle" >newOff:8,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "print" 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimete ..."} 
 -- $pattern:getAdr: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.prin ..."} 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "R" >staticOff:0 "R: obj Rectangle" superAdj:0 
 -- $obj:loadArgs: "R: obj Rectangle" >E:"R" 
 -- $pattern:loadArgs: "Rectangle: Figure{   width: var Length.Meter;   heigth: var Length.Meter;   set: ;      in w: var Length.Meter;      in h: var Length.Meter;      width ..."} 
 -- ptn:loadArgs:E "R" 
 -- {(ObjectInvocation_Unary; (name: "R"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "R" >rec:"R" ATd:"obj" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "R" 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- OI:invoke:B: "R" E: "print"  rec: "R"  useRtnV: true "R: obj Rectangle" 
 -- OI:invoke:before:ATdx.invoke: obj R 
 -- $obj:invoke: "R: obj Rectangle" E: "print">newOff:8 useRTNv: "True" 
 -- DI:invoke: "R: obj Rectangle" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 rpushg UnitEx$129 8
 -- OI:invoke:V: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- 
 -- OI:invoke:X: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- 
 -- OI:invoke:C: R :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "R" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- rec:  "R" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;    ..."} 
 -- $pattern:loadArgs: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.pr ..."} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"R" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- OI:invoke:B: "print" E: "print"  rec: "R"  useRtnV: false "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.prin ..."} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- isDI 
 -- isStatic: true rec: "R" 
 invoke print 141 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -8 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 8 
 -- OG:gen:end: :Adr:off:8 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"print":rec:R 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -9 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "T := 3"min"" 
 -- $Assign:gen: "T := 3"min""  
 -- assign: "T := 3"min"" 
 -- computeAdr:superAdj: 0 "T" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:11:on:0:superAdj:0"T: var Time.Minutes":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $var:getAdr: "T: var Time.Minutes" >newOff:11,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Time.Minutes 
 -- before:floatTest:  "T: var Time.Minutes" ObjectGenerator 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- computeAdr:isLast:E:  "T" 
 -- AssignmentStatement:gen: "T := 3"min"" right.label: "ObjectGenerator" "3"min"" 
 -- $ObjectGenerator:gen: "3"min"" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "3"min"" 
 -- OG:before:super.gen: "3"min"" 
 -- $Invocation:gen: "3"min"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "3"min"" 
 -- isConstant: "Invocation" "3"min"" 
 -- needorigin: "3"min"" 
 -- needOrigin:E: "3"min""  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "3"min"" E:  "3"min"" 
 -- INV:gen:E.loadArgs "3"min"" 
 -- $ConstLiteral:loadArgs: "3"min""  
 -- INV:gen:after:E.loadArgs "3"min"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "3"min"" 
 -- $ConstLiteral:invoke: "3"min""  
 pushc 3
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "T" dstE: "T" dstE.ATd: "T: var Time.Minutes" useRtn: false :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "3"min"" 
 -- isArgOfAssignI2IwithUniValArg "T := 3"min"" arg: "3"min"" ObjectGenerator 
 -- arg.super.arg: "3"min"" ConstLiteral 
 -- dstDI: "T: var Time.Minutes" 
 i2f
 -- assign:adr.store:A: 
 -- store: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 11 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -9 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.print" 
 -- $ObjectGenerator:gen: "T.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T.print" 
 -- OG:before:super.gen: "T.print" 
 -- $Invocation:gen: "T.print" >useRtnV:"False"superAdj: 0 descNo: 106 
 -- INV:gen: "T.print" 
 -- isConstant: "Invocation" "T.print" 
 -- notConst: T T: var Time.Minutes 
 -- needorigin: "T.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Minutes".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Minutes" 
 -- computeAdr:superAdj: 0 "T.print" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:11:on:0:superAdj:0"T: var Time.Minutes":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $var:getAdr: "T: var Time.Minutes" >newOff:11,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Time.Minutes 
 -- before:floatTest:  "T: var Time.Minutes" ObjectGenerator 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "print"  A.E: "T" 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Minutes".print":Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isVal ...} 
 -- $pattern:getAdr: "print:: {   "Minutes".print" } 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: var Time.Minutes" superAdj:0 
 -- $var:loadArgs: "T: var Time.Minutes" >E:"T" 
 -- $pattern:loadArgs: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnit ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- OI:invoke:B: "T" E: "print"  rec: "T"  useRtnV: true "T: var Time.Minutes" 
 -- OI:invoke:before:ATdx.invoke: var T 
 -- $var:invoke: "T: var Time.Minutes" E: "print">newOff:11 useRTNv: "True" 
 -- DI:invoke: "T: var Time.Minutes" 
 -- isValueObj:isAdr: true objSize: 2  rec "T" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- Address:loadAdr: :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 11
 pushc 102
 -- OI:invoke:V: adr: :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- rec:  "T" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Minutes".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Minutes".print" >E:"print":descNo:106} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"T" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- origin:isValueObj "Minutes" 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- OI:invoke:B: "print" E: "print"  rec: "T"  useRtnV: false "print:: {   "Minutes".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Minutes".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- isDI 
 -- isStatic: true rec: "T" 
 invoke print 106 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -10 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 11 
 -- OG:gen:end: :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:T 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -11 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "V := Velocity.mult(L1,T)" 
 -- $Assign:gen: "V := Velocity.mult(L1,T)"  
 -- assign: "V := Velocity.mult(L1,T)" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:9:on:0:superAdj:0"V: var Velocity.MeterPerSecond":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- $var:getAdr: "V: var Velocity.MeterPerSecond" >newOff:9,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- DI:OG: Velocity.MeterPerSecond 
 -- before:floatTest:  "V: var Velocity.MeterPerSecond" ObjectGenerator 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := Velocity.mult(L1,T)" right.label: "ObjectGenerator" "Velocity.mult(L1,T)" 
 -- $ObjectGenerator:gen: "Velocity.mult(L1,T)" >OGid:"mult" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Velocity.mult(L1,T)" 
 -- OG:before:super.gen: "Velocity.mult(L1,T)" 
 -- $Invocation:gen: "Velocity.mult(L1,T)" >useRtnV:"True"superAdj: 0 descNo: 142 
 -- INV:gen: "Velocity.mult(L1,T)" 
 -- isConstant: "Invocation" "Velocity.mult(L1,T)" 
 -- needorigin: "Velocity.mult(L1,T)" 
 -- needOrigin:E: "mult(L1,T)"  E.ATd: "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude}" 
 -- doNeedOrigin:Ex: "mult(L1,T)" 
 -- computeAdr:superAdj: 0 "Velocity.mult(L1,T)" 
 -- computeAdr: 1 :rec: "none"  E: "Velocity" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Velocity"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Velocity" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- IV:viaIncl:on: 1 "Dimensions"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.Squar ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: true "Dimensions" 
 -- IV:viaIncl:on: 0 "LIB"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter; ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "LIB" 
 -- items:goOrigin:encOG: "UnitEx" on: 3 isValueObj: false 
 -- origin: demo origin:isValueObj: false 
 rpushg UnitEx$129 1
 -- items:goOrigin:encOG: "demo" on: 2 isValueObj: false 
 -- origin: workspace origin:isValueObj: false 
 rpushg demo$128 1
 -- items:goOrigin:encOG: "workspace" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- $ObjectInvocation_Unary:getAdr: "Velocity" >ATd.off:0 (isPtn):on:0:superAdj:0"--Velocity{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ...} 
 -- $ModuleItem:getAdr: "--Velocity{" } 
 -- $obj:getAdr: "Velocity: obj Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit  ..."} 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Velocity"  E: "mult(L1,T)" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Function:getAdr: "mult(L1,T)" >ATd.off:0 (isPtn):on:0:superAdj:0"mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond; ..."} 
 -- $pattern:getAdr: "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Velocity" >staticOff:0 "--Velocity{" superAdj:0} 
 -- $ModuleItem:loadArgs: "--Velocity{" } 
 -- $ObjectInvocation_Unary:invoke: "Velocity" >rec:"Velocity" ATd:"ModuleItem" E:"mult(L1,T)" E.ATd:"mult" unique:"False" 
 -- OI:invoke: "Velocity" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- OI:invoke:B: "Velocity" E: "mult(L1,T)"  rec: "Velocity"  useRtnV: true "--Velocity{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem Velocity 
 -- $ModuleItem:invoke: "--Velocity{" E: "mult(L1,T)" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "Velocity: obj Dimension{   %dimension "MpSD", "L/T";   %requires Length, Time;   %Public;   PrimaryUnit:: MeterPerSecond;   MeterPerSecond: Unit;      %unit  ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg Velocity 6
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- 
 -- OI:invoke:C: Velocity :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Velocity" E: "mult(L1,T)" 
 -- arg:unit 
 -- rec:other: 
 -- computeAdr:isLast:E:  "mult(L1,T)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- rec:  "Velocity" E:  "mult(L1,T)" 
 -- INV:gen:E.loadArgs "mult(L1,T)" 
 -- $ObjectInvocation_Function:loadArgs: "mult(L1,T)" >staticOff:0 "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L ..."} 
 -- $pattern:loadArgs: "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude" >E:"mult(L1,T)":de ...} 
 -- ptn:loadArgs:E "mult(L1,T)" 
 -- {(ObjectInvocation_Function; (name: "mult"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L1");     (Arguments)));   (Items descNo ...} 
 -- args: "(L1,T)" 
 -- E: "ObjectGenerator" L1 
 -- E: "ObjectGenerator" T 
 -- E.arg: "var" in L: var Length.Meter 
 -- NonVirt: "mult(L1,T)" "ObjectInvocation_Function" ActArg:  "L1" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "mult(L1,T)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L1" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1" 
 -- OG:before:super.gen: "L1" 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "L1">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L1" ,E: "L1" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 2 size: 2 74 in L: var Length.Meter 
 pushvalue  off:2 size:2 descNo: 74
 pushc 1
 -- end:loadArgs:NonVirt: "mult(L1,T)" 
 -- E.arg: "var" in T: var Time.Minutes 
 -- NonVirt: "mult(L1,T)" "ObjectInvocation_Function" ActArg:  "T" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "mult(L1,T)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "T" >OGid:"Minutes" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T" 
 -- OG:before:super.gen: "T" 
 -- $Invocation:gen: "T" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "T" 
 -- isConstant: "Invocation" "T" 
 -- notConst: T T: var Time.Minutes 
 -- needorigin: "T" 
 -- needOrigin:E: "T"  E.ATd: "T: var Time.Minutes" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "T" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:11:on:0:superAdj:0"T: var Time.Minutes":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F ... 
 -- $var:getAdr: "T: var Time.Minutes" >newOff:11,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Time.Minutes 
 -- before:floatTest:  "T: var Time.Minutes" ObjectGenerator 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- computeAdr:isLast:E:  "T" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- rec:  "T" E:  "T" 
 -- INV:gen:E.loadArgs "T" 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: var Time.Minutes" superAdj:0 
 -- $var:loadArgs: "T: var Time.Minutes" >E:"T" 
 -- $pattern:loadArgs: "Minutes: Unit{   %unit "min", 60;   %Public;   thisUnit:: Minutes;   toPrimary:: ;      base.magnitude := magnitude * 60;   fromPrimary:: ;      magnit ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "T" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "T" :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"var" isValueObj E:"T" E.ATd:"T" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- OI:invoke:B: "T" E: "T"  rec: "T"  useRtnV: true "T: var Time.Minutes" 
 -- OI:invoke:before:ATdx.invoke: var T 
 -- $var:invoke: "T: var Time.Minutes" E: "T">newOff:11 useRTNv: "True" 
 -- DI:invoke: "T: var Time.Minutes" 
 -- isValueObj:isAdr: false objSize: 2  rec "T" ,E: "T" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- Address:loadAdr: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 11
 pushc 102
 -- OI:invoke:V: adr: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 11 
 -- OG:gen:end: :Adr:off:11 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 11 size: 2 102 in T: var Time.Minutes 
 pushvalue  off:11 size:2 descNo: 102
 pushc 1
 -- end:loadArgs:NonVirt: "mult(L1,T)" 
 -- INV:gen:after:E.loadArgs "mult(L1,T)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Function "mult(L1,T)" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T) ..." 
 -- $ObjectInvocation_Function:invoke: "mult(L1,T)" >rec:"Velocity" ATd:"pattern" E:"mult(L1,T)" E.ATd:"mult" unique:"False" 
 -- OI:invoke: "mult(L1,T)" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- OI:invoke:B: "mult(L1,T)" E: "mult(L1,T)"  rec: "Velocity"  useRtnV: true "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.mag ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern mult 
 -- $pattern:invoke: "mult: {   in L: var Length.Meter;   in T: var Time.Minutes;   out R: var MeterPerSecond;   R.magnitude := L.magnitude * T.magnitude" E: "mult(L1,T)" useR ...} 
 -- ptn:invoke: "mult" E: "mult(L1,T)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 invoke mult 142 0 0
 -- global:pushOut: R off: 6 
 pushc 6
 pushc 0
 -- callInvoke:after:pushOut: 6 
 -- GeneralPTN:invoke:after:callInvoke: 6 
 -- GeneralPTN:invoke:end: 6 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- OI:invoke:C: mult(L1,T) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(L1,T)":rec:Velocity 
 -- rec: "V" dstE: "V" dstE.ATd: "V: var Velocity.MeterPerSecond" useRtn: false :Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":r ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" Velocity.mult(L1,T) 
 -- pushValue: A: off: 6 size: 7 descNo: -1 Velocity.mult(L1,T) 
 pushvalue  off:6 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:9 size:2 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "V" off: 9 size: 2 mode: 0 
 vassign  9 2 0
 -- assign:adr.store:B: 
 -- genclass:stmt: "V.print" 
 -- $ObjectGenerator:gen: "V.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V.print" 
 -- OG:before:super.gen: "V.print" 
 -- $Invocation:gen: "V.print" >useRtnV:"False"superAdj: 0 descNo: 100 
 -- INV:gen: "V.print" 
 -- isConstant: "Invocation" "V.print" 
 -- notConst: V V: var Velocity.MeterPerSecond 
 -- needorigin: "V.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "MpS".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "MeterPerSecond" 
 -- computeAdr:superAdj: 0 "V.print" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:9:on:0:superAdj:0"V: var Velocity.MeterPerSecond":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- $var:getAdr: "V: var Velocity.MeterPerSecond" >newOff:9,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique: ... 
 -- DI:OG: Velocity.MeterPerSecond 
 -- before:floatTest:  "V: var Velocity.MeterPerSecond" ObjectGenerator 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr: 2 :rec: "V"  E: "print"  A.E: "V" 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "MpS".print":Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T  ...} 
 -- $pattern:getAdr: "print:: {   "MpS".print" } 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "V: var Velocity.MeterPerSecond" superAdj:0 
 -- $var:loadArgs: "V: var Velocity.MeterPerSecond" >E:"V" 
 -- $pattern:loadArgs: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" >E:"V":descNo:96} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "print"  rec: "V"  useRtnV: true "V: var Velocity.MeterPerSecond" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "V: var Velocity.MeterPerSecond" E: "print">newOff:9 useRTNv: "True" 
 -- DI:invoke: "V: var Velocity.MeterPerSecond" 
 -- isValueObj:isAdr: true objSize: 2  rec "V" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- Address:loadAdr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 9
 pushc 96
 -- OI:invoke:V: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "V" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- rec:  "V" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "MpS".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "MpS".print" >E:"print":descNo:100} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"V" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- origin:isValueObj "MeterPerSecond" 
 -- :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- OI:invoke:B: "print" E: "print"  rec: "V"  useRtnV: false "print:: {   "MpS".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "MpS".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- isDI 
 -- isStatic: true rec: "V" 
 invoke print 100 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -12 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 9 
 -- OG:gen:end: :Adr:off:9 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:V 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -13 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: ""The minimum of ".print" 
 -- $ObjectGenerator:gen: ""The minimum of ".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""The minimum of ".print" 
 -- OG:before:super.gen: ""The minimum of ".print" 
 -- $Invocation:gen: ""The minimum of ".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""The minimum of ".print" 
 -- isConstant: "Invocation" ""The minimum of ".print" 
 -- needorigin: ""The minimum of ".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""The minimum of "" E:  ""The minimum of "" 
 -- INV:gen:E.loadArgs ""The minimum of "" 
 -- $String::loadArgs: ""The minimum of ""  
 -- INV:gen:after:E.loadArgs ""The minimum of "" 
 -- OIadr: 
 -- $String::invoke: ""The minimum of ""  
 pushText "The minimum of "
 -- IV:gen:checkTail: ""The minimum of ".print" E: ""The minimum of "" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""The minimum of "" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""The minimum of ""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -13 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L1.print" 
 -- $ObjectGenerator:gen: "L1.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1.print" 
 -- OG:before:super.gen: "L1.print" 
 -- $Invocation:gen: "L1.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "L1.print" 
 -- isConstant: "Invocation" "L1.print" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L1.print" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr: 2 :rec: "L1"  E: "print"  A.E: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "print"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L1" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- rec:  "L1" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L1" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:B: "print" E: "print"  rec: "L1"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- isDI 
 -- isStatic: true rec: "L1" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -14 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- genclass:stmt: "" and ".print" 
 -- $ObjectGenerator:gen: "" and ".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "" and ".print" 
 -- OG:before:super.gen: "" and ".print" 
 -- $Invocation:gen: "" and ".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: "" and ".print" 
 -- isConstant: "Invocation" "" and ".print" 
 -- needorigin: "" and ".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "" and "" E:  "" and "" 
 -- INV:gen:E.loadArgs "" and "" 
 -- $String::loadArgs: "" and ""  
 -- INV:gen:after:E.loadArgs "" and "" 
 -- OIadr: 
 -- $String::invoke: "" and ""  
 pushText " and "
 -- IV:gen:checkTail: "" and ".print" E: "" and "" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"" and "" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: "" and ""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -14 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L3.print" 
 -- $ObjectGenerator:gen: "L3.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L3.print" 
 -- OG:before:super.gen: "L3.print" 
 -- $Invocation:gen: "L3.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "L3.print" 
 -- isConstant: "Invocation" "L3.print" 
 -- notConst: L3 L3: var Length.Meter 
 -- needorigin: "L3.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L3.print" 
 -- computeAdr: 1 :rec: "none"  E: "L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L3" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L3" >ATd.off:6:on:0:superAdj:0"L3: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L3: var Length.Meter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L3: var Length.Meter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- computeAdr: 2 :rec: "L3"  E: "print"  A.E: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L3" >staticOff:0 "L3: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L3: var Length.Meter" >E:"L3" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L3" 
 -- {(ObjectInvocation_Unary; (name: "L3"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L3" >rec:"L3" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- OI:invoke:B: "L3" E: "print"  rec: "L3"  useRtnV: true "L3: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L3 
 -- $var:invoke: "L3: var Length.Meter" E: "print">newOff:6 useRTNv: "True" 
 -- DI:invoke: "L3: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L3" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 6
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- 
 -- OI:invoke:C: L3 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L3" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- rec:  "L3" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L3" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- OI:invoke:B: "print" E: "print"  rec: "L3"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- isDI 
 -- isStatic: true rec: "L3" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -15 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- genclass:stmt: "" is ".print" 
 -- $ObjectGenerator:gen: "" is ".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "" is ".print" 
 -- OG:before:super.gen: "" is ".print" 
 -- $Invocation:gen: "" is ".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: "" is ".print" 
 -- isConstant: "Invocation" "" is ".print" 
 -- needorigin: "" is ".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "" is "" E:  "" is "" 
 -- INV:gen:E.loadArgs "" is "" 
 -- $String::loadArgs: "" is ""  
 -- INV:gen:after:E.loadArgs "" is "" 
 -- OIadr: 
 -- $String::invoke: "" is ""  
 pushText " is "
 -- IV:gen:checkTail: "" is ".print" E: "" is "" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"" is "" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: "" is ""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -15 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L1.min(L3).print" 
 -- $ObjectGenerator:gen: "L1.min(L3).print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1.min(L3).print" 
 -- OG:before:super.gen: "L1.min(L3).print" 
 -- $Invocation:gen: "L1.min(L3).print" >useRtnV:"False"superAdj: 0 descNo: 162 descNo: 80 
 -- INV:gen: "L1.min(L3).print" 
 -- isConstant: "Invocation" "L1.min(L3).print" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1.min(L3).print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "min(L3)" 
 -- origin:isValueObj: "Unit" 
 -- computeAdr:superAdj: 0 "L1.min(L3).print" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr: 2 :rec: "L1"  E: "min(L3)"  A.E: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "min(L3)" >ATd.off:0 (isPtn):on:0:superAdj:0"min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;   ..."} 
 -- $pattern:getAdr: "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"min(L3)" E.ATd:"min" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "min(L3)"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "min(L3)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L1" ,E: "min(L3)" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "min(L3)" 
 -- arg:unit 
 -- rec:other: 
 -- computeAdr: 3 :rec: "min(L3)"  E: "print"  A.E: "min(L3)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_KeyWord:loadArgs: "min(L3)" >staticOff:0 "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude :=  ..."} 
 -- $pattern:loadArgs: "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := ..."} 
 -- ptn:loadArgs:E "min(L3)" 
 -- {(ObjectInvocation_KeyWord; (name: "min"); (Arguments;  (name: "min");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L3");     (A ...} 
 -- args: "min(L3)" 
 -- E: "ObjectGenerator" L3 
 -- E.arg: "var" in V: var thisUnit 
 -- NonVirt: "min(L3)" "ObjectInvocation_KeyWord" ActArg:  "L3" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "min(L3)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L3" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L3" 
 -- OG:before:super.gen: "L3" 
 -- $Invocation:gen: "L3" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L3" 
 -- isConstant: "Invocation" "L3" 
 -- notConst: L3 L3: var Length.Meter 
 -- needorigin: "L3" 
 -- needOrigin:E: "L3"  E.ATd: "L3: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L3" 
 -- computeAdr: 1 :rec: "none"  E: "L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L3" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L3" >ATd.off:6:on:0:superAdj:0"L3: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L3: var Length.Meter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L3: var Length.Meter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- computeAdr:isLast:E:  "L3" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- rec:  "L3" E:  "L3" 
 -- INV:gen:E.loadArgs "L3" 
 -- $ObjectInvocation_Unary:loadArgs: "L3" >staticOff:0 "L3: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L3: var Length.Meter" >E:"L3" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L3" 
 -- {(ObjectInvocation_Unary; (name: "L3"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L3" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L3" :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L3" >rec:"L3" ATd:"var" isValueObj E:"L3" E.ATd:"L3" unique:"False" 
 -- OI:invoke: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- OI:invoke:B: "L3" E: "L3"  rec: "L3"  useRtnV: true "L3: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L3 
 -- $var:invoke: "L3: var Length.Meter" E: "L3">newOff:6 useRTNv: "True" 
 -- DI:invoke: "L3: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L3" ,E: "L3" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 6
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:C: L3 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 6 size: 2 0 in V: var thisUnit 
 pushvalue  off:6 size:2 descNo: 0
 pushc 1
 -- end:loadArgs:NonVirt: "min(L3)" 
 -- $ObjectInvocation_KeyWord:invoke: "min(L3)" >rec:"L1" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "min(L3)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"min(L3)":rec:L1 
 -- OI:invoke:B: "min(L3)" E: "print"  rec: "L1"  useRtnV: true "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern min 
 -- $pattern:invoke: "min: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude < V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V ..."} 
 -- ptn:invoke: "min" E: "print" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke min 162 0 0
 -- global:pushOut: R off: 6 
 pushc 6
 pushc 0
 -- callInvoke:after:pushOut: 6 
 -- GeneralPTN:invoke:after:callInvoke: 6 
 -- GeneralPTN:invoke:end: 6 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:C: min(L3) :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- rec:  "min(L3)" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"min(L3)" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:min(L3) 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:min(L3) 
 -- OI:invoke:B: "print" E: "print"  rec: "min(L3)"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:min(L3) 
 -- isPtn 
 -- isStatic: true rec: "min(L3)" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -16 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:min(L3) 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:min(L3) 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:min(L3) 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -17 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: ""The maximum of ".print" 
 -- $ObjectGenerator:gen: ""The maximum of ".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""The maximum of ".print" 
 -- OG:before:super.gen: ""The maximum of ".print" 
 -- $Invocation:gen: ""The maximum of ".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""The maximum of ".print" 
 -- isConstant: "Invocation" ""The maximum of ".print" 
 -- needorigin: ""The maximum of ".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""The maximum of "" E:  ""The maximum of "" 
 -- INV:gen:E.loadArgs ""The maximum of "" 
 -- $String::loadArgs: ""The maximum of ""  
 -- INV:gen:after:E.loadArgs ""The maximum of "" 
 -- OIadr: 
 -- $String::invoke: ""The maximum of ""  
 pushText "The maximum of "
 -- IV:gen:checkTail: ""The maximum of ".print" E: ""The maximum of "" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""The maximum of "" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""The maximum of ""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -17 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L1.print" 
 -- $ObjectGenerator:gen: "L1.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1.print" 
 -- OG:before:super.gen: "L1.print" 
 -- $Invocation:gen: "L1.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "L1.print" 
 -- isConstant: "Invocation" "L1.print" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L1.print" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr: 2 :rec: "L1"  E: "print"  A.E: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "print"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L1" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- rec:  "L1" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L1" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:B: "print" E: "print"  rec: "L1"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- isDI 
 -- isStatic: true rec: "L1" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -18 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- genclass:stmt: "" and ".print" 
 -- $ObjectGenerator:gen: "" and ".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "" and ".print" 
 -- OG:before:super.gen: "" and ".print" 
 -- $Invocation:gen: "" and ".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: "" and ".print" 
 -- isConstant: "Invocation" "" and ".print" 
 -- needorigin: "" and ".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "" and "" E:  "" and "" 
 -- INV:gen:E.loadArgs "" and "" 
 -- $String::loadArgs: "" and ""  
 -- INV:gen:after:E.loadArgs "" and "" 
 -- OIadr: 
 -- $String::invoke: "" and ""  
 pushText " and "
 -- IV:gen:checkTail: "" and ".print" E: "" and "" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"" and "" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: "" and ""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -18 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L3.print" 
 -- $ObjectGenerator:gen: "L3.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L3.print" 
 -- OG:before:super.gen: "L3.print" 
 -- $Invocation:gen: "L3.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "L3.print" 
 -- isConstant: "Invocation" "L3.print" 
 -- notConst: L3 L3: var Length.Meter 
 -- needorigin: "L3.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L3.print" 
 -- computeAdr: 1 :rec: "none"  E: "L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L3" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L3" >ATd.off:6:on:0:superAdj:0"L3: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L3: var Length.Meter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L3: var Length.Meter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- computeAdr: 2 :rec: "L3"  E: "print"  A.E: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L3" >staticOff:0 "L3: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L3: var Length.Meter" >E:"L3" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L3" 
 -- {(ObjectInvocation_Unary; (name: "L3"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L3" >rec:"L3" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- OI:invoke:B: "L3" E: "print"  rec: "L3"  useRtnV: true "L3: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L3 
 -- $var:invoke: "L3: var Length.Meter" E: "print">newOff:6 useRTNv: "True" 
 -- DI:invoke: "L3: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L3" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 6
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- 
 -- OI:invoke:C: L3 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L3" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- rec:  "L3" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L3" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- OI:invoke:B: "print" E: "print"  rec: "L3"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- isDI 
 -- isStatic: true rec: "L3" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -19 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L3 
 -- genclass:stmt: "" is ".print" 
 -- $ObjectGenerator:gen: "" is ".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "" is ".print" 
 -- OG:before:super.gen: "" is ".print" 
 -- $Invocation:gen: "" is ".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: "" is ".print" 
 -- isConstant: "Invocation" "" is ".print" 
 -- needorigin: "" is ".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "" is "" E:  "" is "" 
 -- INV:gen:E.loadArgs "" is "" 
 -- $String::loadArgs: "" is ""  
 -- INV:gen:after:E.loadArgs "" is "" 
 -- OIadr: 
 -- $String::invoke: "" is ""  
 pushText " is "
 -- IV:gen:checkTail: "" is ".print" E: "" is "" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"" is "" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: "" is ""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -19 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L1.max(L3).print" 
 -- $ObjectGenerator:gen: "L1.max(L3).print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1.max(L3).print" 
 -- OG:before:super.gen: "L1.max(L3).print" 
 -- $Invocation:gen: "L1.max(L3).print" >useRtnV:"False"superAdj: 0 descNo: 166 descNo: 80 
 -- INV:gen: "L1.max(L3).print" 
 -- isConstant: "Invocation" "L1.max(L3).print" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1.max(L3).print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "max(L3)" 
 -- origin:isValueObj: "Unit" 
 -- computeAdr:superAdj: 0 "L1.max(L3).print" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr: 2 :rec: "L1"  E: "max(L3)"  A.E: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "max(L3)" >ATd.off:0 (isPtn):on:0:superAdj:0"max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;   ..."} 
 -- $pattern:getAdr: "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V ..."} 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"max(L3)" E.ATd:"max" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "max(L3)"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "max(L3)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L1" ,E: "max(L3)" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "max(L3)" 
 -- arg:unit 
 -- rec:other: 
 -- computeAdr: 3 :rec: "max(L3)"  E: "print"  A.E: "max(L3)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_KeyWord:loadArgs: "max(L3)" >staticOff:0 "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude :=  ..."} 
 -- $pattern:loadArgs: "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := ..."} 
 -- ptn:loadArgs:E "max(L3)" 
 -- {(ObjectInvocation_KeyWord; (name: "max"); (Arguments;  (name: "max");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L3");     (A ...} 
 -- args: "max(L3)" 
 -- E: "ObjectGenerator" L3 
 -- E.arg: "var" in V: var thisUnit 
 -- NonVirt: "max(L3)" "ObjectInvocation_KeyWord" ActArg:  "L3" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "max(L3)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L3" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L3" 
 -- OG:before:super.gen: "L3" 
 -- $Invocation:gen: "L3" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L3" 
 -- isConstant: "Invocation" "L3" 
 -- notConst: L3 L3: var Length.Meter 
 -- needorigin: "L3" 
 -- needOrigin:E: "L3"  E.ATd: "L3: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L3" 
 -- computeAdr: 1 :rec: "none"  E: "L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L3" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L3" >ATd.off:6:on:0:superAdj:0"L3: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L3: var Length.Meter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L3: var Length.Meter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- computeAdr:isLast:E:  "L3" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- rec:  "L3" E:  "L3" 
 -- INV:gen:E.loadArgs "L3" 
 -- $ObjectInvocation_Unary:loadArgs: "L3" >staticOff:0 "L3: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L3: var Length.Meter" >E:"L3" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L3" 
 -- {(ObjectInvocation_Unary; (name: "L3"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L3" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L3" :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L3" >rec:"L3" ATd:"var" isValueObj E:"L3" E.ATd:"L3" unique:"False" 
 -- OI:invoke: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- OI:invoke:B: "L3" E: "L3"  rec: "L3"  useRtnV: true "L3: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L3 
 -- $var:invoke: "L3: var Length.Meter" E: "L3">newOff:6 useRTNv: "True" 
 -- DI:invoke: "L3: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L3" ,E: "L3" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 6
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:C: L3 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 6 size: 2 0 in V: var thisUnit 
 pushvalue  off:6 size:2 descNo: 0
 pushc 1
 -- end:loadArgs:NonVirt: "max(L3)" 
 -- $ObjectInvocation_KeyWord:invoke: "max(L3)" >rec:"L1" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "max(L3)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"max(L3)":rec:L1 
 -- OI:invoke:B: "max(L3)" E: "print"  rec: "L1"  useRtnV: true "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern max 
 -- $pattern:invoke: "max: {   in V: var thisUnit;   out R: var thisUnit;   if (magnitude > V.magnitude) :then ;      R.magnitude := magnitude;   :else ;      R.magnitude := V ..."} 
 -- ptn:invoke: "max" E: "print" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 invoke max 166 0 0
 -- global:pushOut: R off: 6 
 pushc 6
 pushc 0
 -- callInvoke:after:pushOut: 6 
 -- GeneralPTN:invoke:after:callInvoke: 6 
 -- GeneralPTN:invoke:end: 6 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- OI:invoke:C: max(L3) :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L1" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- rec:  "max(L3)" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L1 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"max(L3)" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:max(L3) 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:max(L3) 
 -- OI:invoke:B: "print" E: "print"  rec: "max(L3)"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:max(L3) 
 -- isPtn 
 -- isStatic: true rec: "max(L3)" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -20 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:max(L3) 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:max(L3) 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:max(L3) 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -21 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "A := L1 * L3" 
 -- $Assign:gen: "A := L1 * L3"  
 -- assign: "A := L1 * L3" 
 -- computeAdr:superAdj: 0 "A" 
 -- computeAdr: 1 :rec: "none"  E: "A" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "A"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "A" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "A" >ATd.off:13:on:0:superAdj:0"A: var Area.SquareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "A: var Area.SquareMeter" >newOff:13,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter" ObjectGenerator 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdr:isLast:E:  "A" 
 -- AssignmentStatement:gen: "A := L1 * L3" right.label: "ObjectGenerator" "L1 * L3" 
 -- $ObjectGenerator:gen: "L1 * L3" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L1 * L3" 
 -- OG:before:super.gen: "L1 * L3" 
 -- $Invocation:gen: "L1 * L3" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1 * L3" 
 -- isConstant: "Invocation" "L1 * L3" 
 -- needorigin: "L1 * L3" 
 -- needOrigin:E: "L1 * L3"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "L1 * L3" 
 -- computeAdr:superAdj: 0 "L1 * L3" 
 -- computeAdr: 1 :rec: "none"  E: "L1 * L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L1 * L3"  
 -- $BinOp:loadOrigin: "L1 * L3"  
 -- BinaryExp:loadOrigin:empty: "L1 * L3" superAdj: 0 
 -- $BinOp:getAdr: "L1 * L3"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L1 * L3" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L1 * L3" E:  "L1 * L3" 
 -- INV:gen:E.loadArgs "L1 * L3" 
 -- $BinOp:loadArgs: "L1 * L3"  
 -- BinaryExp:loadArgs: "L1 * L3" superAdj: 0 
 -- $Invocation:gen: "L1" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L1" 
 -- isConstant: "Invocation" "L1" 
 -- notConst: L1 L1: var Length.Meter 
 -- needorigin: "L1" 
 -- needOrigin:E: "L1"  E.ATd: "L1: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L1" 
 -- computeAdr: 1 :rec: "none"  E: "L1" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L1"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L1" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L1" >ATd.off:2:on:0:superAdj:0"L1: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L1: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L1: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- computeAdr:isLast:E:  "L1" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- rec:  "L1" E:  "L1" 
 -- INV:gen:E.loadArgs "L1" 
 -- $ObjectInvocation_Unary:loadArgs: "L1" >staticOff:0 "L1: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L1: var Length.Meter" >E:"L1" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L1" 
 -- {(ObjectInvocation_Unary; (name: "L1"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L1" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L1" >rec:"L1" ATd:"var" isValueObj E:"L1" E.ATd:"L1" unique:"False" 
 -- OI:invoke: "L1" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "L1" E: "L1"  rec: "L1"  useRtnV: true "L1: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L1 
 -- $var:invoke: "L1: var Length.Meter" E: "L1">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L1: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L1" ,E: "L1" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- 
 -- OI:invoke:C: L1 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* L3":descNo:65} 
 -- ptn:loadArgs:E "* L3" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "L3");     (Arguments)));   (Items descNo: 0 o ...} 
 -- args: "L3" 
 -- E: "ObjectGenerator" L3 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* L3" "ObjectInvocation_Binary" ActArg:  "L3" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* L3" 
 -- $ObjectGenerator:gen: "L3" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L3" 
 -- OG:before:super.gen: "L3" 
 -- $Invocation:gen: "L3" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L3" 
 -- isConstant: "Invocation" "L3" 
 -- notConst: L3 L3: var Length.Meter 
 -- needorigin: "L3" 
 -- needOrigin:E: "L3"  E.ATd: "L3: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L3" 
 -- computeAdr: 1 :rec: "none"  E: "L3" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L3"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L3" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L3" >ATd.off:6:on:0:superAdj:0"L3: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue: ... 
 -- $var:getAdr: "L3: var Length.Meter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L3: var Length.Meter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- computeAdr:isLast:E:  "L3" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- rec:  "L3" E:  "L3" 
 -- INV:gen:E.loadArgs "L3" 
 -- $ObjectInvocation_Unary:loadArgs: "L3" >staticOff:0 "L3: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L3: var Length.Meter" >E:"L3" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L3" 
 -- {(ObjectInvocation_Unary; (name: "L3"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L3" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L3" :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L3" >rec:"L3" ATd:"var" isValueObj E:"L3" E.ATd:"L3" unique:"False" 
 -- OI:invoke: "L3" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- OI:invoke:B: "L3" E: "L3"  rec: "L3"  useRtnV: true "L3: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L3 
 -- $var:invoke: "L3: var Length.Meter" E: "L3">newOff:6 useRTNv: "True" 
 -- DI:invoke: "L3: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "L3" ,E: "L3" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- Address:loadAdr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 6 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- 
 -- OI:invoke:C: L3 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L3":rec:L3 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: L3 
 -- end:loadArgs:NonVirt: "* L3" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- INV:gen:after:E.loadArgs "L1 * L3" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L1 * L3" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $BinOp:invoke: "L1 * L3"  
 -- BinaryExp:invoke: "L1" rec: "L1 * L3" 
 -- M: "* L3" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- $ObjectInvocation_Binary:invoke: "* L3" >rec:"L1" ATd:"pattern" E:"* L3" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* L3" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- origin:isValueObj "float" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L1":rec:L1 
 -- OI:invoke:B: "* L3" E: "* L3"  rec: "L1"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* L3" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* L3" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "* L3" 
 -- arg:unit 
 -- rec:other: 
 fmult
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* L3":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* L3":rec:L1 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * L3 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "A" dstE: "A" dstE.ATd: "A: var Area.SquareMeter" useRtn: false :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "L1 * L3" 
 -- isArgOfAssignI2IwithUniValArg "A := L1 * L3" arg: "L1 * L3" ObjectGenerator 
 -- arg.super.arg: "L1 * L3" BinOp 
 -- recx:BinaryExp:recx: "L1 * L3" 
 -- M: "* L3" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "L1" E: "* L3" 
 -- arg:unit 
 -- rec:other: 
 -- M:arg: "L3" ObjectGenerator false 
 -- dstDI: "A: var Area.SquareMeter" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 13 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -21 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "A.print" 
 -- $ObjectGenerator:gen: "A.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "A.print" 
 -- OG:before:super.gen: "A.print" 
 -- $Invocation:gen: "A.print" >useRtnV:"False"superAdj: 0 descNo: 70 
 -- INV:gen: "A.print" 
 -- isConstant: "Invocation" "A.print" 
 -- notConst: A A: var Area.SquareMeter 
 -- needorigin: "A.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "SquareMeter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "SquareMeter" 
 -- computeAdr:superAdj: 0 "A.print" 
 -- computeAdr: 1 :rec: "none"  E: "A" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "A"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "A" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "A" >ATd.off:13:on:0:superAdj:0"A: var Area.SquareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "A: var Area.SquareMeter" >newOff:13,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter" ObjectGenerator 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdr: 2 :rec: "A"  E: "print"  A.E: "A" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "SquareMeter".print":Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F i ...} 
 -- $pattern:getAdr: "print:: {   "SquareMeter".print" } 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "A" >staticOff:0 "A: var Area.SquareMeter" superAdj:0 
 -- $var:loadArgs: "A: var Area.SquareMeter" >E:"A" 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"A":descNo:68} 
 -- ptn:loadArgs:E "A" 
 -- {(ObjectInvocation_Unary; (name: "A"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "A" >rec:"A" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "A" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:B: "A" E: "print"  rec: "A"  useRtnV: true "A: var Area.SquareMeter" 
 -- OI:invoke:before:ATdx.invoke: var A 
 -- $var:invoke: "A: var Area.SquareMeter" E: "print">newOff:13 useRTNv: "True" 
 -- DI:invoke: "A: var Area.SquareMeter" 
 -- isValueObj:isAdr: true objSize: 2  rec "A" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- Address:loadAdr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 13
 pushc 68
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- 
 -- OI:invoke:C: A :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "A" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- rec:  "A" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "SquareMeter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "SquareMeter".print" >E:"print":descNo:70} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"A" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- origin:isValueObj "SquareMeter" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- OI:invoke:B: "print" E: "print"  rec: "A"  useRtnV: false "print:: {   "SquareMeter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "SquareMeter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- isDI 
 -- isStatic: true rec: "A" 
 invoke print 70 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -22 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 13 
 -- OG:gen:end: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -23 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "temperatureEx" 
 -- $ObjectGenerator:gen: "temperatureEx" >OGid:"temperatureEx" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "temperatureEx" 
 -- OG:before:super.gen: "temperatureEx" 
 -- $Invocation:gen: "temperatureEx" >useRtnV:"False"superAdj: 0 descNo: 143 
 -- INV:gen: "temperatureEx" 
 -- isConstant: "Invocation" "temperatureEx" 
 -- needorigin: "temperatureEx" 
 -- needOrigin:E: "temperatureEx"  E.ATd: "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   n ...}" 
 -- doNeedOrigin:Ex: "temperatureEx" 
 -- computeAdr:superAdj: 0 "temperatureEx" 
 -- computeAdr: 1 :rec: "none"  E: "temperatureEx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "temperatureEx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "temperatureEx" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "temperatureEx" >ATd.off:0 (isPtn):on:0:superAdj:0"temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := T ..."} 
 -- $pattern:getAdr: "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrima ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:- 
 -- computeAdr:isLast:E:  "temperatureEx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:- 
 -- rec:  "temperatureEx" E:  "temperatureEx" 
 -- INV:gen:E.loadArgs "temperatureEx" 
 -- $ObjectInvocation_Unary:loadArgs: "temperatureEx" >staticOff:0 "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsi ..."} 
 -- $pattern:loadArgs: "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPri ..."} 
 -- ptn:loadArgs:E "temperatureEx" 
 -- {(ObjectInvocation_Unary; (name: "temperatureEx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "temperatureEx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "temperatureEx" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatu ..." 
 -- $ObjectInvocation_Unary:invoke: "temperatureEx" >rec:"temperatureEx" ATd:"pattern" E:"temperatureEx" E.ATd:"temperatureEx" unique:"False" 
 -- OI:invoke: "temperatureEx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:temperatureEx 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:temperatureEx 
 -- OI:invoke:B: "temperatureEx" E: "temperatureEx"  rec: "temperatureEx"  useRtnV: false "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern temperatureEx 
 -- $pattern:invoke: "temperatureEx: {   C: var Temperature.Celsius;   F: var Temperature.Fahrenheit;   C := Temperature.FasCelsius(100.0);   C.print;   newline;   F.fromPrima ..."} 
 -- ptn:invoke: "temperatureEx" E: "temperatureEx" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:temperatureEx 
 invoke temperatureEx 143 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -24 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:temperatureEx 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:temperatureEx 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: temperatureEx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"temperatureEx":rec:temperatureEx 
 -- genclass:stmt: "lengthEx" 
 -- $ObjectGenerator:gen: "lengthEx" >OGid:"LengthEx" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "lengthEx" 
 -- OG:before:super.gen: "lengthEx" 
 -- $Invocation:gen: "lengthEx" >useRtnV:"False"superAdj: 0 descNo: 156 
 -- INV:gen: "lengthEx" 
 -- isConstant: "Invocation" "lengthEx" 
 -- needorigin: "lengthEx" 
 -- needOrigin:E: "lengthEx"  E.ATd: "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary ...}" 
 -- doNeedOrigin:Ex: "lengthEx" 
 -- computeAdr:superAdj: 0 "lengthEx" 
 -- computeAdr: 1 :rec: "none"  E: "lengthEx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "lengthEx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "lengthEx" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "lengthEx" >ATd.off:0 (isPtn):on:0:superAdj:0"LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n". ..."} 
 -- $pattern:getAdr: "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:- 
 -- computeAdr:isLast:E:  "lengthEx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:- 
 -- rec:  "lengthEx" E:  "lengthEx" 
 -- INV:gen:E.loadArgs "lengthEx" 
 -- $ObjectInvocation_Unary:loadArgs: "lengthEx" >staticOff:0 "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   ..."} 
 -- $pattern:loadArgs: "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary); ..."} 
 -- ptn:loadArgs:E "lengthEx" 
 -- {(ObjectInvocation_Unary; (name: "lengthEx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "lengthEx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "lengthEx" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec: ... 
 -- $ObjectInvocation_Unary:invoke: "lengthEx" >rec:"lengthEx" ATd:"pattern" E:"lengthEx" E.ATd:"LengthEx" unique:"False" 
 -- OI:invoke: "lengthEx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:lengthEx 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:lengthEx 
 -- OI:invoke:B: "lengthEx" E: "lengthEx"  rec: "lengthEx"  useRtnV: false "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern LengthEx 
 -- $pattern:invoke: "LengthEx: {   L: var Length.Meter;   F: var Length.Foot;   L := Length.F2M(3.05);   "kuk:\n".print;   L.print;   newline;   F.fromPrimary(L.toPrimary);   ..."} 
 -- ptn:invoke: "LengthEx" E: "lengthEx" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:lengthEx 
 invoke LengthEx 156 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -25 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:lengthEx 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:lengthEx 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: lengthEx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"lengthEx":rec:lengthEx 
 -- genclass:stmt: "A := 15.6"m2"" 
 -- $Assign:gen: "A := 15.6"m2""  
 -- assign: "A := 15.6"m2"" 
 -- computeAdr:superAdj: 0 "A" 
 -- computeAdr: 1 :rec: "none"  E: "A" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "A"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "A" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "A" >ATd.off:13:on:0:superAdj:0"A: var Area.SquareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "A: var Area.SquareMeter" >newOff:13,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter" ObjectGenerator 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdr:isLast:E:  "A" 
 -- AssignmentStatement:gen: "A := 15.6"m2"" right.label: "ObjectGenerator" "15.6"m2"" 
 -- $ObjectGenerator:gen: "15.6"m2"" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "15.6"m2"" 
 -- OG:before:super.gen: "15.6"m2"" 
 -- $Invocation:gen: "15.6"m2"" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "15.6"m2"" 
 -- isConstant: "Invocation" "15.6"m2"" 
 -- needorigin: "15.6"m2"" 
 -- needOrigin:E: "15.6"m2""  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "15.6"m2"" E:  "15.6"m2"" 
 -- INV:gen:E.loadArgs "15.6"m2"" 
 -- $FloatLiteral:loadArgs: "15.6"m2""  
 -- INV:gen:after:E.loadArgs "15.6"m2"" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "15.6"m2"" 
 -- $FloatLiteral:invoke: "15.6"m2""  
 pushFloatConst 15.600000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "A" dstE: "A" dstE.ATd: "A: var Area.SquareMeter" useRtn: false :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "15.6"m2"" 
 -- isArgOfAssignI2IwithUniValArg "A := 15.6"m2"" arg: "15.6"m2"" ObjectGenerator 
 -- arg.super.arg: "15.6"m2"" FloatLiteral 
 -- dstDI: "A: var Area.SquareMeter" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 13 address:storeg
 -- stack: vpop : vTop: -3 vTopMax: 0 rTop: -25 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "A.print" 
 -- $ObjectGenerator:gen: "A.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "A.print" 
 -- OG:before:super.gen: "A.print" 
 -- $Invocation:gen: "A.print" >useRtnV:"False"superAdj: 0 descNo: 70 
 -- INV:gen: "A.print" 
 -- isConstant: "Invocation" "A.print" 
 -- notConst: A A: var Area.SquareMeter 
 -- needorigin: "A.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "SquareMeter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "SquareMeter" 
 -- computeAdr:superAdj: 0 "A.print" 
 -- computeAdr: 1 :rec: "none"  E: "A" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "A"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "A" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "A" >ATd.off:13:on:0:superAdj:0"A: var Area.SquareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVal ... 
 -- $var:getAdr: "A: var Area.SquareMeter" >newOff:13,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "A: var Area.SquareMeter" ObjectGenerator 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdr: 2 :rec: "A"  E: "print"  A.E: "A" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "SquareMeter".print":Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F i ...} 
 -- $pattern:getAdr: "print:: {   "SquareMeter".print" } 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "A" >staticOff:0 "A: var Area.SquareMeter" superAdj:0 
 -- $var:loadArgs: "A: var Area.SquareMeter" >E:"A" 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"A":descNo:68} 
 -- ptn:loadArgs:E "A" 
 -- {(ObjectInvocation_Unary; (name: "A"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "A" >rec:"A" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "A" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:B: "A" E: "print"  rec: "A"  useRtnV: true "A: var Area.SquareMeter" 
 -- OI:invoke:before:ATdx.invoke: var A 
 -- $var:invoke: "A: var Area.SquareMeter" E: "print">newOff:13 useRTNv: "True" 
 -- DI:invoke: "A: var Area.SquareMeter" 
 -- isValueObj:isAdr: true objSize: 2  rec "A" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- Address:loadAdr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 13
 pushc 68
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- 
 -- OI:invoke:C: A :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "A" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- rec:  "A" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "SquareMeter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "SquareMeter".print" >E:"print":descNo:70} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"A" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- origin:isValueObj "SquareMeter" 
 -- :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- OI:invoke:B: "print" E: "print"  rec: "A"  useRtnV: false "print:: {   "SquareMeter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "SquareMeter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- isDI 
 -- isStatic: true rec: "A" 
 invoke print 70 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: -3 vTopMax: 0 rTop: -26 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 13 
 -- OG:gen:end: :Adr:off:13 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:A 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -3 vTopMax: 0 rTop: -27 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "UnitEx" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:14 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 130 
 -- Items:GenClass: Foot descNo: 130 isValue: true 
 -- Items:GenClass: Foot descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Foot 130 0 Length 72 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrimary:: ;   put('!');   magnitude := base.magnitude  ...} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrimary:: ;   put('!');   magnitude  ...}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %unit "F", 0.3048{thisUnit:: Foot;%Public;toPrimary:: ;   base.magnitude := (magnitude * 0.3048);fromPrimary:: ;   put('!');   magnitude := base.magnitude  ...} 
 -- vdtAdd: inx=1 descInx=130 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%unit "F", 0.3048"  
 -- $pattern:gen: "thisUnit:: Foot"  
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "toPrimary:: {   base.magnitude := (magnitude * 0.3048)" } 
 -- $pattern:gen: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" } 
 -- $pattern:gen: "print:: {   "Foot".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%unit "F", 0.3048" 
 -- $Property:gen: "%unit "F", 0.3048"  
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=130 vDescInx=157 vdtTop: 9 
 -- vdtAdd: inx=8 descInx=130 vDescInx=135 vdtTop: 9 
 -- vdtAdd: inx=9 descInx=130 vDescInx=136 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 157 
 -- Items:GenClass: toPrimary descNo: 157 isValue: false 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 157 1 Foot 130
 -- vdtTableCopy: I:1:49 I:2:0
 -- vdtAdd: inx=2 descInx=157 vDescInx=157 vdtTop: 2 
 -- Store itemArgs: base.magnitude := (magnitude * 0.3048) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super toPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "base.magnitude := (magnitude * 0.3048)" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: toPrimary 
 -- Store itemArgs: base.magnitude := (magnitude * 0.3048) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=157 vDescInx=49 vdtTop: 2 
 -- $var:gen: "out base: var PrimaryUnit"  
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- $ObjectGenerator:gen: "PrimaryUnit" >OGid:"Unit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "PrimaryUnit" 
 -- OG:before:super.gen: "PrimaryUnit" 
 -- $Invocation:gen: "PrimaryUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "PrimaryUnit" 
 -- isConstant: "Invocation" "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "PrimaryUnit" E:  "PrimaryUnit" 
 -- INV:gen:E.loadArgs "PrimaryUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "PrimaryUnit" >staticOff:0 "PrimaryUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "PrimaryUnit:< Unit" >E:"PrimaryUnit":descNo:0 
 -- ptn:loadArgs:E "PrimaryUnit" 
 -- {(ObjectInvocation_Unary; (name: "PrimaryUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "PrimaryUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit" 
 -- $ObjectInvocation_Unary:invoke: "PrimaryUnit" >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:"PrimaryUnit" unique:"False" 
 -- OI:invoke: "PrimaryUnit" 
 -- 
 -- OI:invoke:B: "PrimaryUnit" E: "PrimaryUnit"  rec: "PrimaryUnit"  useRtnV: false "PrimaryUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: "PrimaryUnit:< Unit" E: "PrimaryUnit" useRTNv: "False" 
 -- ptn:invoke: "PrimaryUnit" E: "PrimaryUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 4 adr:none 
 -- isStatic: true rec: "PrimaryUnit" 
 invokeVal  PrimaryUnit 40 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- genclass:stmt: "base.magnitude := (magnitude * 0.3048)" 
 -- $Assign:gen: "base.magnitude := (magnitude * 0.3048)"  
 -- assign: "base.magnitude := (magnitude * 0.3048)" 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"out base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "out base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "out base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "base.magnitude := (magnitude * 0.3048)" right.label: "ObjectGenerator" "(magnitude * 0.3048)" 
 -- $ObjectGenerator:gen: "(magnitude * 0.3048)" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(magnitude * 0.3048)" 
 -- OG:before:super.gen: "(magnitude * 0.3048)" 
 -- $Invocation:gen: "(magnitude * 0.3048)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(magnitude * 0.3048)" 
 -- isConstant: "Invocation" "(magnitude * 0.3048)" 
 -- needorigin: "(magnitude * 0.3048)" 
 -- needOrigin:E: "(magnitude * 0.3048)"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(magnitude * 0.3048)" 
 -- computeAdr:superAdj: 0 "(magnitude * 0.3048)" 
 -- computeAdr: 1 :rec: "none"  E: "(magnitude * 0.3048)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(magnitude * 0.3048)"  
 -- $BracketedExp:loadOrigin: "(magnitude * 0.3048)"  
 -- computeAdr:superAdj: 0 "magnitude * 0.3048" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude * 0.3048" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "magnitude * 0.3048"  
 -- $BinOp:loadOrigin: "magnitude * 0.3048"  
 -- BinaryExp:loadOrigin:empty: "magnitude * 0.3048" superAdj: 0 
 -- $BinOp:getAdr: "magnitude * 0.3048"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude * 0.3048"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude * 0.3048" 
 -- BE:loadOrigin:E: magnitude * 0.3048 
 -- $BinOp:getAdr: "magnitude * 0.3048"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude * 0.3048"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude * 0.3048" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "magnitude * 0.3048" E:  "magnitude * 0.3048" 
 -- INV:gen:E.loadArgs "magnitude * 0.3048" 
 -- $BinOp:loadArgs: "magnitude * 0.3048"  
 -- BinaryExp:loadArgs: "magnitude * 0.3048" superAdj: 0 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "toPrimary" on: 1 isValueObj: false 
 -- origin: Foot origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg toPrimary$157 1
 rswap 0
 rdouble 0
 pushg 2 toPrimary$157
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 toPrimary$157
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* 0.3048":descNo:65} 
 -- ptn:loadArgs:E "* 0.3048" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (FloatLiteral 0.3048));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0.3048" 
 -- E: "ObjectGenerator" 0.3048 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* 0.3048" "ObjectInvocation_Binary" ActArg:  "0.3048" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* 0.3048" 
 -- $ObjectGenerator:gen: "0.3048" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0.3048" 
 -- OG:before:super.gen: "0.3048" 
 -- $Invocation:gen: "0.3048" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0.3048" 
 -- isConstant: "Invocation" "0.3048" 
 -- needorigin: "0.3048" 
 -- needOrigin:E: "0.3048"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R:  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0.3048" E:  "0.3048" 
 -- INV:gen:E.loadArgs "0.3048" 
 -- $FloatLiteral:loadArgs: "0.3048"  
 -- INV:gen:after:E.loadArgs "0.3048" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "0.3048" 
 -- $FloatLiteral:invoke: "0.3048"  
 pushFloatConst 0.304800
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "0.3048" :isBasicVal: true 
 -- case:B: 0.3048 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "* 0.3048" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:after:E.loadArgs "magnitude * 0.3048" 
 -- OIadr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- IV:E.invoke:useRtnVal: true E: BinOp "magnitude * 0.3048" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitu ... 
 -- $BinOp:invoke: "magnitude * 0.3048"  
 -- BinaryExp:invoke: "magnitude" rec: "magnitude * 0.3048" 
 -- M: "* 0.3048" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $ObjectInvocation_Binary:invoke: "* 0.3048" >rec:"magnitude" ATd:"pattern" E:"* 0.3048" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* 0.3048" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "* 0.3048" E: "* 0.3048"  rec: "magnitude"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* 0.3048" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* 0.3048" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "magnitude" E: "* 0.3048" 
 -- arg:float 
 fmult
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"* 0.3048":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"* 0.3048":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * 0.3048 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "base" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"bas ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "(magnitude * 0.3048)" 
 -- isArgOfAssignI2IwithUniValArg "base.magnitude := (magnitude * 0.3048)" arg: "(magnitude * 0.3048)" ObjectGenerator 
 -- arg.super.arg: "(magnitude * 0.3048)" BracketedExp 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 135 
 -- Items:GenClass: fromPrimary descNo: 135 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 135 1 Foot 130
 -- vdtTableCopy: I:1:50 I:2:0
 -- vdtAdd: inx=2 descInx=135 vDescInx=135 vdtTop: 2 
 -- Store itemArgs: put('!'){magnitude := base.magnitude / 0.3048} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super fromPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "put('!'){magnitude := base.magnitude / 0.3048}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: fromPrimary 
 -- Store itemArgs: put('!'){magnitude := base.magnitude / 0.3048} 
 -- in base: var PrimaryUnit true 0 
 -- DI:store: "base" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  base 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=135 vDescInx=50 vdtTop: 2 
 -- $var:gen: "in base: var PrimaryUnit"  
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- genclass:stmt: "put('!')" 
 -- $ObjectGenerator:gen: "put('!')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('!')" 
 -- OG:before:super.gen: "put('!')" 
 -- $Invocation:gen: "put('!')" >useRtnV:"False"superAdj: 0 descNo: 54 
 -- INV:gen: "put('!')" 
 -- isConstant: "Invocation" "put('!')" 
 -- needorigin: "put('!')" 
 -- needOrigin:E: "put('!')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('!')" E:  "put('!')" 
 -- INV:gen:E.loadArgs "put('!')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('!')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'!'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('!')":descNo:54} 
 -- ptn:loadArgs:E "put('!')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: '!'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put('!')" 
 -- E: "ObjectGenerator" '!' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('!')" "ObjectInvocation_KeyWord" ActArg:  "'!'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('!')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'!'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'!'" 
 -- OG:before:super.gen: "'!'" 
 -- $Invocation:gen: "'!'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'!'" 
 -- isConstant: "Invocation" "'!'" 
 -- needorigin: "'!'" 
 -- needOrigin:E: "'!'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'!'" E:  "'!'" 
 -- INV:gen:E.loadArgs "'!'" 
 -- $Char::loadArgs: "'!'"  
 -- INV:gen:after:E.loadArgs "'!'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'!'" 
 -- $Char::invoke: "'!'"  
 pushc 33
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'!'" :isBasicVal: true 
 -- case:B: '!' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('!')" 
 -- INV:gen:after:E.loadArgs "put('!')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('!')" 
 -- $ObjectInvocation_KeyWord:invoke: "put('!')" >rec:"put('!')" ATd:"pattern" E:"put('!')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('!')" 
 -- 
 -- OI:invoke:B: "put('!')" E: "put('!')"  rec: "put('!')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('!')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('!')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('!') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "magnitude := base.magnitude / 0.3048" 
 -- $Assign:gen: "magnitude := base.magnitude / 0.3048"  
 -- assign: "magnitude := base.magnitude / 0.3048" 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "fromPrimary" on: 1 isValueObj: false 
 -- origin: Foot origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg fromPrimary$135 1
 rswap 0
 rdouble 0
 pushg 2 fromPrimary$135
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 fromPrimary$135
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "magnitude := base.magnitude / 0.3048" right.label: "ObjectGenerator" "base.magnitude / 0.3048" 
 -- $ObjectGenerator:gen: "base.magnitude / 0.3048" >OGid:"/" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "base.magnitude / 0.3048" 
 -- OG:before:super.gen: "base.magnitude / 0.3048" 
 -- $Invocation:gen: "base.magnitude / 0.3048" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude / 0.3048" 
 -- isConstant: "Invocation" "base.magnitude / 0.3048" 
 -- needorigin: "base.magnitude / 0.3048" 
 -- needOrigin:E: "base.magnitude / 0.3048"  E.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "base.magnitude / 0.3048" 
 -- computeAdr:superAdj: 0 "base.magnitude / 0.3048" 
 -- computeAdr: 1 :rec: "none"  E: "base.magnitude / 0.3048" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "base.magnitude / 0.3048"  
 -- $BinOp:loadOrigin: "base.magnitude / 0.3048"  
 -- BinaryExp:loadOrigin:empty: "base.magnitude / 0.3048" superAdj: 0 
 -- $BinOp:getAdr: "base.magnitude / 0.3048"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "base.magnitude / 0.3048" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "base.magnitude / 0.3048" E:  "base.magnitude / 0.3048" 
 -- INV:gen:E.loadArgs "base.magnitude / 0.3048" 
 -- $BinOp:loadArgs: "base.magnitude / 0.3048"  
 -- BinaryExp:loadArgs: "base.magnitude / 0.3048" superAdj: 0 
 -- $Invocation:gen: "base.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude" 
 -- isConstant: "Invocation" "base.magnitude" 
 -- notConst: base in base: var PrimaryUnit 
 -- needorigin: "base.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"in base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "in base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "in base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- rec:  "base" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"base" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "base"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float"
 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "base" 

 fpushg 4 

-- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- $pattern:loadArgs: "/  : {   %basic 121;   in V: var float;   out R: var float" >E:"/ 0.3048":descNo:99} 
 -- ptn:loadArgs:E "/ 0.3048" 
 -- {(ObjectInvocation_Binary; (name: "/"); (Arguments;  (ObjectGenerator;   (Invocation;    (FloatLiteral 0.3048));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "0.3048" 
 -- E: "ObjectGenerator" 0.3048 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "/ 0.3048" "ObjectInvocation_Binary" ActArg:  "0.3048" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/ 0.3048"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "0.3048" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "0.3048" 
 -- OG:before:super.gen: "0.3048" 
 -- $Invocation:gen: "0.3048" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "0.3048" 
 -- isConstant: "Invocation" "0.3048" 
 -- needorigin: "0.3048" 
 -- needOrigin:E: "0.3048"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R:  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "0.3048" E:  "0.3048" 
 -- INV:gen:E.loadArgs "0.3048" 
 -- $FloatLiteral:loadArgs: "0.3048"  
 -- INV:gen:after:E.loadArgs "0.3048" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "0.3048" 
 -- $FloatLiteral:invoke: "0.3048"  
 pushFloatConst 0.304800
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "0.3048" :isBasicVal: true 
 -- case:B: 0.3048 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "/ 0.3048" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- INV:gen:after:E.loadArgs "base.magnitude / 0.3048" 
 -- OIadr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- IV:E.invoke:useRtnVal: true E: BinOp "base.magnitude / 0.3048" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:ba ... 
 -- $BinOp:invoke: "base.magnitude / 0.3048"  
 -- BinaryExp:invoke: "base.magnitude" rec: "base.magnitude / 0.3048" 
 -- M: "/ 0.3048" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- $ObjectInvocation_Binary:invoke: "/ 0.3048" >rec:"base.magnitude" ATd:"pattern" E:"/ 0.3048" E.ATd:"/  " unique:"False" 
 -- OI:invoke: "/ 0.3048" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base.magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base.magnitude 
 -- OI:invoke:B: "/ 0.3048" E: "/ 0.3048"  rec: "base.magnitude"  useRtnV: true "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern /   
 -- $pattern:invoke: "/  : {   %basic 121;   in V: var float;   out R: var float" E: "/ 0.3048" useRTNv: "True"} 
 -- ptn:invoke: "/  " E: "/ 0.3048" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "base.magnitude" E: "/ 0.3048" 
 -- arg:float 
 fdiv
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ 0.3048":rec:base.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"/ 0.3048":rec:base.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: / 0.3048 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "magnitude" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "base.magnitude / 0.3048" 
 -- isArgOfAssignI2IwithUniValArg "magnitude := base.magnitude / 0.3048" arg: "base.magnitude / 0.3048" ObjectGenerator 
 -- arg.super.arg: "base.magnitude / 0.3048" BinOp 
 -- recx:BinaryExp:recx: "base.magnitude / 0.3048" 
 -- M: "/ 0.3048" label: "ObjectInvocation_Binary" M.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "base.magnitude" E: "/ 0.3048" 
 -- arg:float 
 -- M:arg: "0.3048" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- Address:store:originIsVal: 
 fovstoreg 1 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 136 
 -- Items:GenClass: print descNo: 136 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 136 1 Foot 130
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=136 vDescInx=136 vdtTop: 2 
 -- Store itemArgs: "Foot".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""Foot".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "Foot".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=136 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Foot".print" 
 -- $ObjectGenerator:gen: ""Foot".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Foot".print" 
 -- OG:before:super.gen: ""Foot".print" 
 -- $Invocation:gen: ""Foot".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Foot".print" 
 -- isConstant: "Invocation" ""Foot".print" 
 -- needorigin: ""Foot".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Foot"" E:  ""Foot"" 
 -- INV:gen:E.loadArgs ""Foot"" 
 -- $String::loadArgs: ""Foot""  
 -- INV:gen:after:E.loadArgs ""Foot"" 
 -- OIadr: 
 -- $String::invoke: ""Foot""  
 pushText "Foot"
 -- IV:gen:checkTail: ""Foot".print" E: ""Foot"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Foot"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Foot""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 132 
 -- Items:GenClass: Figure descNo: 132 isValue: false 
 -- Items:GenClass: Figure descNo: 21 isValue: false 

 CLASS Figure 132 1 UnitEx 129
 -- Store itemArgs: theArea:< {   out A: var Area.SquareMeter;   inner(theArea);print:< ;   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print; ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=132 vDescInx=132 vdtTop: 1 
 mvStack 
 -- $pattern:gen: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)" } 
 -- $pattern:gen: "print:< {   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.pri ..."} 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 L2:
 -- pushReturn:  "Figure" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=132 vDescInx=139 vdtTop: 2 
 -- vdtAdd: inx=3 descInx=132 vDescInx=138 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 139 
 -- Items:GenClass: theArea descNo: 139 isValue: false 
 -- Items:GenClass: theArea descNo: 21 isValue: false 

 CLASS theArea 139 1 Figure 132
 -- Store itemArgs: out A: var Area.SquareMeter{inner(theArea)} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=139 vDescInx=139 vdtTop: 1 
 mvStack 
 -- $var:gen: "out A: var Area.SquareMeter"  
 -- DI:gen: "out A: var Area.SquareMeter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  A 
 -- $ObjectGenerator:gen: "Area.SquareMeter" >OGid:"SquareMeter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Area.SquareMeter" 
 -- OG:before:super.gen: "Area.SquareMeter" 
 -- $Invocation:gen: "Area.SquareMeter" >useRtnV:"False"superAdj: 0 descNo: 68 
 -- INV:gen: "Area.SquareMeter" 
 -- isConstant: "Invocation" "Area.SquareMeter" 
 -- needorigin: "Area.SquareMeter" 
 -- needOrigin:E: "SquareMeter"  E.ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Area" E:  "SquareMeter" 
 -- INV:gen:E.loadArgs "SquareMeter" 
 -- $ObjectInvocation_Unary:loadArgs: "SquareMeter" >staticOff:0 "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print ..."} 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"SquareMeter":descNo:68} 
 -- ptn:loadArgs:E "SquareMeter" 
 -- {(ObjectInvocation_Unary; (name: "SquareMeter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "SquareMeter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "SquareMeter" 
 -- $ObjectInvocation_Unary:invoke: "SquareMeter" >rec:"Area" ATd:"pattern" isValueObj E:"SquareMeter" E.ATd:"SquareMeter" unique:"False" 
 -- OI:invoke: "SquareMeter" 
 -- 
 -- OI:invoke:B: "SquareMeter" E: "SquareMeter"  rec: "Area"  useRtnV: false "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "Square ..."}" 
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- $pattern:invoke: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" E: "SquareMeter" useRTNv: "False"} 
 -- ptn:invoke: "SquareMeter" E: "SquareMeter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  SquareMeter 68 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: SquareMeter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(theArea)" 
 -- $ObjectGenerator:gen: "inner(theArea)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(theArea)" 
 -- OG:before:super.gen: "inner(theArea)" 
 -- $Invocation:gen: "inner(theArea)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(theArea)" 
 -- isConstant: "Invocation" "inner(theArea)" 
 -- needorigin: "inner(theArea)" 
 -- needOrigin:E: "inner(theArea)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(theArea)" 
 -- computeAdr:superAdj: 0 "inner(theArea)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(theArea)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(theArea)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(theArea)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(theArea)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(theArea)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:- 
 -- computeAdr:isLast:E:  "inner(theArea)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:- 
 -- rec:  "inner(theArea)" E:  "inner(theArea)" 
 -- INV:gen:E.loadArgs "inner(theArea)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(theArea)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"theArea"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(theArea)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(theArea)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(theArea)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner( ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(theArea)" >rec:"inner(theArea)" ATd:"pattern" E:"inner(theArea)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(theArea)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:inner(theArea) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:inner(theArea) 
 -- OI:invoke:B: "inner(theArea)" E: "inner(theArea)"  rec: "inner(theArea)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(theArea)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(theArea)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:inner(theArea) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:inner(theArea) 
 -- 
 -- OI:invoke:C: inner(theArea) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(theArea)":rec:inner(theArea) 
 L2:
 -- pushReturn:  "theArea" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=139 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 138 
 -- Items:GenClass: print descNo: 138 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 138 1 Figure 132
 -- Store itemArgs: printMore:< {   inner(printMore);AR: var Area.SquareMeter;"Figure:".print;inner(print);"\nArea:".print;AR := theArea;AR.print;printMore} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=138 vDescInx=138 vdtTop: 1 
 mvStack 
 -- $pattern:gen: "printMore:< {   inner(printMore)" } 
 -- $var:gen: "AR: var Area.SquareMeter"  
 -- DI:gen: "AR: var Area.SquareMeter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  AR 
 -- $ObjectGenerator:gen: "Area.SquareMeter" >OGid:"SquareMeter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Area.SquareMeter" 
 -- OG:before:super.gen: "Area.SquareMeter" 
 -- $Invocation:gen: "Area.SquareMeter" >useRtnV:"False"superAdj: 0 descNo: 68 
 -- INV:gen: "Area.SquareMeter" 
 -- isConstant: "Invocation" "Area.SquareMeter" 
 -- needorigin: "Area.SquareMeter" 
 -- needOrigin:E: "SquareMeter"  E.ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Area" E:  "SquareMeter" 
 -- INV:gen:E.loadArgs "SquareMeter" 
 -- $ObjectInvocation_Unary:loadArgs: "SquareMeter" >staticOff:0 "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print ..."} 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"SquareMeter":descNo:68} 
 -- ptn:loadArgs:E "SquareMeter" 
 -- {(ObjectInvocation_Unary; (name: "SquareMeter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "SquareMeter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "SquareMeter" 
 -- $ObjectInvocation_Unary:invoke: "SquareMeter" >rec:"Area" ATd:"pattern" isValueObj E:"SquareMeter" E.ATd:"SquareMeter" unique:"False" 
 -- OI:invoke: "SquareMeter" 
 -- 
 -- OI:invoke:B: "SquareMeter" E: "SquareMeter"  rec: "Area"  useRtnV: false "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "Square ..."}" 
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- $pattern:invoke: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" E: "SquareMeter" useRTNv: "False"} 
 -- ptn:invoke: "SquareMeter" E: "SquareMeter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  SquareMeter 68 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: SquareMeter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: ""Figure:".print" 
 -- $ObjectGenerator:gen: ""Figure:".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Figure:".print" 
 -- OG:before:super.gen: ""Figure:".print" 
 -- $Invocation:gen: ""Figure:".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Figure:".print" 
 -- isConstant: "Invocation" ""Figure:".print" 
 -- needorigin: ""Figure:".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Figure:"" E:  ""Figure:"" 
 -- INV:gen:E.loadArgs ""Figure:"" 
 -- $String::loadArgs: ""Figure:""  
 -- INV:gen:after:E.loadArgs ""Figure:"" 
 -- OIadr: 
 -- $String::invoke: ""Figure:""  
 pushText "Figure:"
 -- IV:gen:checkTail: ""Figure:".print" E: ""Figure:"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Figure:"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Figure:""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "inner(print)" 
 -- $ObjectGenerator:gen: "inner(print)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(print)" 
 -- OG:before:super.gen: "inner(print)" 
 -- $Invocation:gen: "inner(print)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(print)" 
 -- isConstant: "Invocation" "inner(print)" 
 -- needorigin: "inner(print)" 
 -- needOrigin:E: "inner(print)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(print)" 
 -- computeAdr:superAdj: 0 "inner(print)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(print)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(print)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(print)" >on:4 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(print)" >ATd.off:0 (isPtn):on:4:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal:F s ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "inner(print)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- computeAdr:isLast:E:  "inner(print)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:- 
 -- rec:  "inner(print)" E:  "inner(print)" 
 -- INV:gen:E.loadArgs "inner(print)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(print)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"print"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(print)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(print)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(print)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(pr ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(print)" >rec:"inner(print)" ATd:"pattern" E:"inner(print)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(print)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- OI:invoke:B: "inner(print)" E: "inner(print)"  rec: "inner(print)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(print)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(print)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  3
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- 
 -- OI:invoke:C: inner(print) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(print)":rec:inner(print) 
 -- genclass:stmt: ""\nArea:".print" 
 -- $ObjectGenerator:gen: ""\nArea:".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""\nArea:".print" 
 -- OG:before:super.gen: ""\nArea:".print" 
 -- $Invocation:gen: ""\nArea:".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""\nArea:".print" 
 -- isConstant: "Invocation" ""\nArea:".print" 
 -- needorigin: ""\nArea:".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""\nArea:"" E:  ""\nArea:"" 
 -- INV:gen:E.loadArgs ""\nArea:"" 
 -- $String::loadArgs: ""\nArea:""  
 -- INV:gen:after:E.loadArgs ""\nArea:"" 
 -- OIadr: 
 -- $String::invoke: ""\nArea:""  
 pushText "\nArea:"
 -- IV:gen:checkTail: ""\nArea:".print" E: ""\nArea:"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""\nArea:"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""\nArea:""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "AR := theArea" 
 -- $Assign:gen: "AR := theArea"  
 -- assign: "AR := theArea" 
 -- computeAdr:superAdj: 0 "AR" 
 -- computeAdr: 1 :rec: "none"  E: "AR" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "AR"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "AR" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "AR" >ATd.off:2:on:0:superAdj:0"AR: var Area.SquareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- $var:getAdr: "AR: var Area.SquareMeter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "AR: var Area.SquareMeter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- computeAdr:isLast:E:  "AR" 
 -- AssignmentStatement:gen: "AR := theArea" right.label: "ObjectGenerator" "theArea" 
 -- $ObjectGenerator:gen: "theArea" >OGid:"theArea" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "theArea" 
 -- OG:before:super.gen: "theArea" 
 -- $Invocation:gen: "theArea" >useRtnV:"True"superAdj: 0 descNo: 139 
 -- INV:gen: "theArea" 
 -- isConstant: "Invocation" "theArea" 
 -- needorigin: "theArea" 
 -- needOrigin:E: "theArea"  E.ATd: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- doNeedOrigin:Ex: "theArea" 
 -- computeAdr:superAdj: 0 "theArea" 
 -- computeAdr: 1 :rec: "none"  E: "theArea" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "theArea"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "theArea" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: Figure origin:isValueObj: false 
 rpushg print$138 1
 -- $ObjectInvocation_Unary:getAdr: "theArea" >ATd.off:0 (isPtn):on:1:superAdj:0"theArea:< {   out A: var Area.SquareMeter;   inner(theArea)":Adr:off:0 size:0 isFloat:F isUnit ...} 
 -- $pattern:getAdr: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "theArea"  ATd: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:- 
 -- computeAdr:isLast:E:  "theArea" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:- 
 -- rec:  "theArea" E:  "theArea" 
 -- INV:gen:E.loadArgs "theArea" 
 -- $ObjectInvocation_Unary:loadArgs: "theArea" >staticOff:0 "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)" superAdj:0} 
 -- $pattern:loadArgs: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)" >E:"theArea":descNo:139} 
 -- ptn:loadArgs:E "theArea" 
 -- {(ObjectInvocation_Unary; (name: "theArea"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "theArea" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "theArea" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:- 
 -- $ObjectInvocation_Unary:invoke: "theArea" >rec:"theArea" ATd:"pattern" E:"theArea" E.ATd:"theArea" unique:"False" 
 -- OI:invoke: "theArea" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- OI:invoke:B: "theArea" E: "theArea"  rec: "theArea"  useRtnV: true "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)}" 
 -- OI:invoke:before:ATdx.invoke: pattern theArea 
 -- $pattern:invoke: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)" E: "theArea" useRTNv: "True"} 
 -- ptn:invoke: "theArea" E: "theArea" ptnKind: 1 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- isPtn 
 -- isStatic: false rec: "theArea" 
 invokev 2 0 theArea$139 0
 -- global:pushOut: A off: 2 
 pushc 2
 pushc 0
 -- GeneralPTN:invoke:after:pushOut: 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- OI:invoke:C: theArea :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"theArea":rec:theArea 
 -- rec: "AR" dstE: "AR" dstE.ATd: "AR: var Area.SquareMeter" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec: ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" theArea 
 -- pushValue: A: off: 2 size: 3 descNo: -1 theArea 
 pushvalue  off:2 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:2 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "AR" off: 2 size: 2 mode: 0 
 vassign  2 2 0
 -- assign:adr.store:B: 
 -- genclass:stmt: "AR.print" 
 -- $ObjectGenerator:gen: "AR.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "AR.print" 
 -- OG:before:super.gen: "AR.print" 
 -- $Invocation:gen: "AR.print" >useRtnV:"False"superAdj: 0 descNo: 70 
 -- INV:gen: "AR.print" 
 -- isConstant: "Invocation" "AR.print" 
 -- notConst: AR AR: var Area.SquareMeter 
 -- needorigin: "AR.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "SquareMeter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "SquareMeter" 
 -- computeAdr:superAdj: 0 "AR.print" 
 -- computeAdr: 1 :rec: "none"  E: "AR" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "AR"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "AR" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "AR" >ATd.off:2:on:0:superAdj:0"AR: var Area.SquareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- $var:getAdr: "AR: var Area.SquareMeter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "AR: var Area.SquareMeter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- computeAdr: 2 :rec: "AR"  E: "print"  A.E: "AR" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "SquareMeter".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F is ...} 
 -- $pattern:getAdr: "print:: {   "SquareMeter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "AR" >staticOff:0 "AR: var Area.SquareMeter" superAdj:0 
 -- $var:loadArgs: "AR: var Area.SquareMeter" >E:"AR" 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"AR":descNo:68} 
 -- ptn:loadArgs:E "AR" 
 -- {(ObjectInvocation_Unary; (name: "AR"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "AR" >rec:"AR" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "AR" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:AR 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"AR":rec:AR 
 -- OI:invoke:B: "AR" E: "print"  rec: "AR"  useRtnV: true "AR: var Area.SquareMeter" 
 -- OI:invoke:before:ATdx.invoke: var AR 
 -- $var:invoke: "AR: var Area.SquareMeter" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "AR: var Area.SquareMeter" 
 -- isValueObj:isAdr: true objSize: 2  rec "AR" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 68
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- 
 -- OI:invoke:C: AR :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "AR" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- rec:  "AR" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "SquareMeter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "SquareMeter".print" >E:"print":descNo:70} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"AR" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- origin:isValueObj "SquareMeter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- OI:invoke:B: "print" E: "print"  rec: "AR"  useRtnV: false "print:: {   "SquareMeter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "SquareMeter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- isDI 
 -- isStatic: true rec: "AR" 
 invoke print 70 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:AR 
 -- genclass:stmt: "printMore" 
 -- $ObjectGenerator:gen: "printMore" >OGid:"printMore" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "printMore" 
 -- OG:before:super.gen: "printMore" 
 -- $Invocation:gen: "printMore" >useRtnV:"False"superAdj: 0 descNo: 140 
 -- INV:gen: "printMore" 
 -- isConstant: "Invocation" "printMore" 
 -- needorigin: "printMore" 
 -- needOrigin:E: "printMore"  E.ATd: "printMore:< {   inner(printMore)}" 
 -- doNeedOrigin:Ex: "printMore" 
 -- computeAdr:superAdj: 0 "printMore" 
 -- computeAdr: 1 :rec: "none"  E: "printMore" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "printMore"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "printMore" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "printMore" >ATd.off:0 (isPtn):on:0:superAdj:0"printMore:< {   inner(printMore)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique ...} 
 -- $pattern:getAdr: "printMore:< {   inner(printMore)" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:- 
 -- computeAdr:isLast:E:  "printMore" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:- 
 -- rec:  "printMore" E:  "printMore" 
 -- INV:gen:E.loadArgs "printMore" 
 -- $ObjectInvocation_Unary:loadArgs: "printMore" >staticOff:0 "printMore:< {   inner(printMore)" superAdj:0} 
 -- $pattern:loadArgs: "printMore:< {   inner(printMore)" >E:"printMore":descNo:140} 
 -- ptn:loadArgs:E "printMore" 
 -- {(ObjectInvocation_Unary; (name: "printMore"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "printMore" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "printMore" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":re ... 
 -- $ObjectInvocation_Unary:invoke: "printMore" >rec:"printMore" ATd:"pattern" E:"printMore" E.ATd:"printMore" unique:"False" 
 -- OI:invoke: "printMore" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:printMore 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:printMore 
 -- OI:invoke:B: "printMore" E: "printMore"  rec: "printMore"  useRtnV: false "printMore:< {   inner(printMore)}" 
 -- OI:invoke:before:ATdx.invoke: pattern printMore 
 -- $pattern:invoke: "printMore:< {   inner(printMore)" E: "printMore" useRTNv: "False"} 
 -- ptn:invoke: "printMore" E: "printMore" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:printMore 
 -- isPtn 
 -- isStatic: false rec: "printMore" 
 invokev 2 0 printMore$140 0
 -- GeneralPTN:invoke:after:pushOut: 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:printMore 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:printMore 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: printMore :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"printMore":rec:printMore 
 L2:
 -- pushReturn:  "print" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=3 descInx=138 vDescInx=0 vdtTop: 3 
 -- vdtAdd: inx=2 descInx=138 vDescInx=140 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 140 
 -- Items:GenClass: printMore descNo: 140 isValue: false 
 -- Items:GenClass: printMore descNo: 21 isValue: false 

 CLASS printMore 140 1 print 138
 -- Store itemArgs: inner(printMore) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=140 vDescInx=140 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "inner(printMore)" 
 -- $ObjectGenerator:gen: "inner(printMore)" >OGid:"inner" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inner(printMore)" 
 -- OG:before:super.gen: "inner(printMore)" 
 -- $Invocation:gen: "inner(printMore)" >useRtnV:"False"superAdj: 0 descNo: 12 
 -- INV:gen: "inner(printMore)" 
 -- isConstant: "Invocation" "inner(printMore)" 
 -- needorigin: "inner(printMore)" 
 -- needOrigin:E: "inner(printMore)"  E.ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- doNeedOrigin:Ex: "inner(printMore)" 
 -- computeAdr:superAdj: 0 "inner(printMore)" 
 -- computeAdr: 1 :rec: "none"  E: "inner(printMore)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "inner(printMore)"  
 -- $ObjectInvocation_KeyWord:loadOrigin: "inner(printMore)" >on:5 superAdj:0 isValueObj:"False" 
 -- $ObjectInvocation_KeyWord:getAdr: "inner(printMore)" >ATd.off:0 (isPtn):on:5:superAdj:0"inner: {   %basic 101;   in inner: ref Object":Adr:off:0 size:0 isFloat:F isUnitVal ...} 
 -- $pattern:getAdr: "inner: {   %basic 101;   in inner: ref Object" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:- 
 -- E.on: 5 
 -- beforeIsValueObj:E: "inner(printMore)"  ATd: "inner: {   %basic 101;   in inner: ref Object}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:- 
 -- computeAdr:isLast:E:  "inner(printMore)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:- 
 -- rec:  "inner(printMore)" E:  "inner(printMore)" 
 -- INV:gen:E.loadArgs "inner(printMore)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "inner(printMore)" >staticOff:0 "inner: {   %basic 101;   in inner: ref Object" superAdj:0arg:"printMore"} 
 -- $pattern:loadArgs: "inner: {   %basic 101;   in inner: ref Object" >E:"inner(printMore)":descNo:12} 
 -- INV:gen:after:E.loadArgs "inner(printMore)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "inner(printMore)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inne ..." 
 -- $ObjectInvocation_KeyWord:invoke: "inner(printMore)" >rec:"inner(printMore)" ATd:"pattern" E:"inner(printMore)" E.ATd:"inner" unique:"False" 
 -- OI:invoke: "inner(printMore)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:inner(printMore) 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:inner(printMore) 
 -- OI:invoke:B: "inner(printMore)" E: "inner(printMore)"  rec: "inner(printMore)"  useRtnV: false "inner: {   %basic 101;   in inner: ref Object}" 
 -- OI:invoke:before:ATdx.invoke: pattern inner 
 -- $pattern:invoke: "inner: {   %basic 101;   in inner: ref Object" E: "inner(printMore)" useRTNv: "False"} 
 -- ptn:invoke: "inner" E: "inner(printMore)" ptnKind: 0 useRtnV: false 
 pushThis 
 innerP  2
 rpopThisObj 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:inner(printMore) 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:inner(printMore) 
 -- 
 -- OI:invoke:C: inner(printMore) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"inner(printMore)":rec:inner(printMore) 
 L2:
 -- pushReturn:  "printMore" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=140 vDescInx=0 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 133 
 -- Items:GenClass: Rectangle descNo: 133 isValue: false 
 -- Items:GenClass: Rectangle descNo: 132 isValue: false 
 -- Items:GenClass: Figure descNo: 21 isValue: false 

 CLASS Rectangle 133 1 UnitEx 129
 -- vdtTableCopy: I:1:132 V:2:139 V:3:138
 -- Store itemArgs: width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h;theArea:: ;   A :=  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super Figure
 -- push:super.origin: 
 -- computeAdr:superAdj: 1 "Figure" 
 -- computeAdr: 1 :rec: "none"  E: "Figure" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Figure"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Figure" >on:0 superAdj:1 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 1 
 rpushg UnitEx$129 1
 -- $ObjectInvocation_Unary:getAdr: "Figure" >ATd.off:0 (isPtn):on:0:superAdj:1"Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      ..."} 
 -- $pattern:getAdr: "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Area ..."} 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Figure":rec:- 
 -- E.on: 0 
 -- beforeIsValueObj:E: "Figure"  ATd: "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore); ...}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Figure":rec:- 
 -- computeAdr:isLast:E:  "Figure" 
 -- genClass:after:pushAddress: "Figure" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:1 isUnique:F isValue:F originIsValue:F:E:"Figure":rec:- 
 -- handleSuperArgs:E: "Figure" theIS: "width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $ObjectInvocation_Unary:loadArgs: "Figure" >staticOff:0 "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;      ..."} 
 -- $pattern:loadArgs: "Figure: {   theArea:< ;      out A: var Area.SquareMeter;      inner(theArea);   print:< ;      printMore:< ;         inner(printMore);      AR: var Ar ..."} 
 -- ptn:loadArgs:E "Figure" 
 -- {(ObjectInvocation_Unary; (name: "Figure"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Figure 
 -- Store itemArgs: width: var Length.Meter{heigth: var Length.Meter;set: ;   in w: var Length.Meter;   in h: var Length.Meter;   width := w;   heigth := h;theArea:: ;   A :=  ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=133 vDescInx=132 vdtTop: 3 
 -- $pattern:gen: "theArea:< {   out A: var Area.SquareMeter;   inner(theArea)" } 
 -- $pattern:gen: "print:< {   printMore:< ;      inner(printMore);   AR: var Area.SquareMeter;   "Figure:".print;   inner(print);   "\nArea:".print;   AR := theArea;   AR.pri ..."} 
 -- $var:gen: "width: var Length.Meter"  
 -- DI:gen: "width: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  width 
 -- $ObjectGenerator:gen: "Length.Meter" >OGid:"Meter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Length.Meter" 
 -- OG:before:super.gen: "Length.Meter" 
 -- $Invocation:gen: "Length.Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.Meter" 
 -- isConstant: "Invocation" "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Length" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  Meter 74 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "heigth: var Length.Meter"  
 -- DI:gen: "heigth: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  heigth 
 -- $ObjectGenerator:gen: "Length.Meter" >OGid:"Meter" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Length.Meter" 
 -- OG:before:super.gen: "Length.Meter" 
 -- $Invocation:gen: "Length.Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.Meter" 
 -- isConstant: "Invocation" "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Length" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 adr:none 
 invokeVal  Meter 74 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $pattern:gen: "theArea:: {   A := Area.mult(width,heigth)" } 
 -- $pattern:gen: "print:: {   printMore:: ;      P: var Length.meter;      " Perimeter:".print;      P := Perimeter;      P.print;   "Rectangle:width:".print;   width.print;  ..."} 
 rtnAlloc 1
 toSuper 132
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- vdtAdd: inx=2 descInx=133 vDescInx=158 vdtTop: 3 
 -- vdtAdd: inx=3 descInx=133 vDescInx=141 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 158 
 -- Items:GenClass: theArea descNo: 158 isValue: false 
 -- Items:GenClass: theArea descNo: 139 isValue: false 
 -- Items:GenClass: theArea descNo: 21 isValue: false 

 CLASS theArea 158 1 Rectangle 133
 -- vdtTableCopy: I:1:139 I:2:0
 -- vdtAdd: inx=2 descInx=158 vDescInx=158 vdtTop: 2 
 -- Store itemArgs: A := Area.mult(width,heigth) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super theArea
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "A := Area.mult(width,heigth)" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: theArea 
 -- Store itemArgs: A := Area.mult(width,heigth) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=158 vDescInx=139 vdtTop: 2 
 -- $var:gen: "out A: var Area.SquareMeter"  
 -- DI:gen: "out A: var Area.SquareMeter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  A 
 -- $ObjectGenerator:gen: "Area.SquareMeter" >OGid:"SquareMeter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Area.SquareMeter" 
 -- OG:before:super.gen: "Area.SquareMeter" 
 -- $Invocation:gen: "Area.SquareMeter" >useRtnV:"False"superAdj: 0 descNo: 68 
 -- INV:gen: "Area.SquareMeter" 
 -- isConstant: "Invocation" "Area.SquareMeter" 
 -- needorigin: "Area.SquareMeter" 
 -- needOrigin:E: "SquareMeter"  E.ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Area" E:  "SquareMeter" 
 -- INV:gen:E.loadArgs "SquareMeter" 
 -- $ObjectInvocation_Unary:loadArgs: "SquareMeter" >staticOff:0 "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print ..."} 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"SquareMeter":descNo:68} 
 -- ptn:loadArgs:E "SquareMeter" 
 -- {(ObjectInvocation_Unary; (name: "SquareMeter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "SquareMeter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "SquareMeter" 
 -- $ObjectInvocation_Unary:invoke: "SquareMeter" >rec:"Area" ATd:"pattern" isValueObj E:"SquareMeter" E.ATd:"SquareMeter" unique:"False" 
 -- OI:invoke: "SquareMeter" 
 -- 
 -- OI:invoke:B: "SquareMeter" E: "SquareMeter"  rec: "Area"  useRtnV: false "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "Square ..."}" 
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- $pattern:invoke: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" E: "SquareMeter" useRTNv: "False"} 
 -- ptn:invoke: "SquareMeter" E: "SquareMeter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  SquareMeter 68 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: SquareMeter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 139
DO:
 mvStack 
 L1:
 -- genclass:stmt: "A := Area.mult(width,heigth)" 
 -- $Assign:gen: "A := Area.mult(width,heigth)"  
 -- assign: "A := Area.mult(width,heigth)" 
 -- computeAdr:superAdj: 0 "A" 
 -- computeAdr: 1 :rec: "none"  E: "A" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "A"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "A" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "A" >ATd.off:2:on:0:superAdj:0"out A: var Area.SquareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "out A: var Area.SquareMeter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F i ... 
 -- DI:OG: Area.SquareMeter 
 -- before:floatTest:  "out A: var Area.SquareMeter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdr:isLast:E:  "A" 
 -- AssignmentStatement:gen: "A := Area.mult(width,heigth)" right.label: "ObjectGenerator" "Area.mult(width,heigth)" 
 -- $ObjectGenerator:gen: "Area.mult(width,heigth)" >OGid:"mult" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Area.mult(width,heigth)" 
 -- OG:before:super.gen: "Area.mult(width,heigth)" 
 -- $Invocation:gen: "Area.mult(width,heigth)" >useRtnV:"True"superAdj: 0 descNo: 159 
 -- INV:gen: "Area.mult(width,heigth)" 
 -- isConstant: "Invocation" "Area.mult(width,heigth)" 
 -- needorigin: "Area.mult(width,heigth)" 
 -- needOrigin:E: "mult(width,heigth)"  E.ATd: "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitud ...}" 
 -- doNeedOrigin:Ex: "mult(width,heigth)" 
 -- computeAdr:superAdj: 0 "Area.mult(width,heigth)" 
 -- computeAdr: 1 :rec: "none"  E: "Area" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Area"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Area" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "theArea" on: 2 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg theArea$158 1
 -- items:goOrigin:encOG: "Rectangle" on: 1 isValueObj: false 
 -- origin: UnitEx origin:isValueObj: false 
 rpushg Rectangle$133 1
 -- IV:viaIncl:on: 1 "Dimensions"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.Squar ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: true "Dimensions" 
 -- IV:viaIncl:on: 0 "LIB"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter; ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "LIB" 
 -- items:goOrigin:encOG: "UnitEx" on: 3 isValueObj: false 
 -- origin: demo origin:isValueObj: false 
 rpushg UnitEx$129 1
 -- items:goOrigin:encOG: "demo" on: 2 isValueObj: false 
 -- origin: workspace origin:isValueObj: false 
 rpushg demo$128 1
 -- items:goOrigin:encOG: "workspace" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- $ObjectInvocation_Unary:getAdr: "Area" >ATd.off:0 (isPtn):on:2:superAdj:0"--Area{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ...} 
 -- $ModuleItem:getAdr: "--Area{" } 
 -- $obj:getAdr: "Area: obj Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Publ ..."} 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Area"  ATd: "--Area{}" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Area"  E: "mult(width,heigth)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Function:getAdr: "mult(width,heigth)" >ATd.off:0 (isPtn):on:0:superAdj:0"mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareM ..."} 
 -- $pattern:getAdr: "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Area" >staticOff:0 "--Area{" superAdj:0} 
 -- $ModuleItem:loadArgs: "--Area{" } 
 -- $ObjectInvocation_Unary:invoke: "Area" >rec:"Area" ATd:"ModuleItem" E:"mult(width,heigth)" E.ATd:"mult" unique:"False" 
 -- OI:invoke: "Area" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- OI:invoke:B: "Area" E: "mult(width,heigth)"  rec: "Area"  useRtnV: true "--Area{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem Area 
 -- $ModuleItem:invoke: "--Area{" E: "mult(width,heigth)" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "Area: obj Dimension{   %dimension "A", "L*L";   %requires Length;   %Public;   PrimaryUnit:: SquareMeter;   SquareMeter: Unit;      %unit "m2", 1;      %Publ ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg Area 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- 
 -- OI:invoke:C: Area :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Area" E: "mult(width,heigth)" 
 -- arg:unit 
 -- rec:other: 
 -- computeAdr:isLast:E:  "mult(width,heigth)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- rec:  "Area" E:  "mult(width,heigth)" 
 -- INV:gen:E.loadArgs "mult(width,heigth)" 
 -- $ObjectInvocation_Function:loadArgs: "mult(width,heigth)" >staticOff:0 "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude ..."} 
 -- $pattern:loadArgs: "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude" >E:"mult(width,heigth ..."} 
 -- ptn:loadArgs:E "mult(width,heigth)" 
 -- {(ObjectInvocation_Function; (name: "mult"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "width");     (Arguments)));   (Items des ...} 
 -- args: "(width,heigth)" 
 -- E: "ObjectGenerator" width 
 -- E: "ObjectGenerator" heigth 
 -- E.arg: "var" in A: var Length.Meter 
 -- NonVirt: "mult(width,heigth)" "ObjectInvocation_Function" ActArg:  "width" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "mult(width,heigth)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "width" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "width" 
 -- OG:before:super.gen: "width" 
 -- $Invocation:gen: "width" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "width" 
 -- isConstant: "Invocation" "width" 
 -- notConst: width width: var Length.Meter 
 -- needorigin: "width" 
 -- needOrigin:E: "width"  E.ATd: "width: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "width" 
 -- computeAdr: 1 :rec: "none"  E: "width" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "width"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "width" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "theArea" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg theArea$158 1
 -- $ObjectInvocation_Unary:getAdr: "width" >ATd.off:2:on:1:superAdj:0"width: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "width: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "width: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "width"  ATd: "width: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- computeAdr:isLast:E:  "width" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- rec:  "width" E:  "width" 
 -- INV:gen:E.loadArgs "width" 
 -- $ObjectInvocation_Unary:loadArgs: "width" >staticOff:0 "width: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "width: var Length.Meter" >E:"width" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "width" 
 -- {(ObjectInvocation_Unary; (name: "width"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "width" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "width" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- $ObjectInvocation_Unary:invoke: "width" >rec:"width" ATd:"var" isValueObj E:"width" E.ATd:"width" unique:"False" 
 -- OI:invoke: "width" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- OI:invoke:B: "width" E: "width"  rec: "width"  useRtnV: true "width: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var width 
 -- $var:invoke: "width: var Length.Meter" E: "width">newOff:2 useRTNv: "True" 
 -- DI:invoke: "width: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "width" ,E: "width" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- 
 -- OI:invoke:C: width :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 2 size: 2 74 in A: var Length.Meter 
 pushvalue  off:2 size:2 descNo: 74
 pushc 1
 -- end:loadArgs:NonVirt: "mult(width,heigth)" 
 -- E.arg: "var" in B: var Length.Meter 
 -- NonVirt: "mult(width,heigth)" "ObjectInvocation_Function" ActArg:  "heigth" isValue:  true 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "mult(width,heigth)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "heigth" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "heigth" 
 -- OG:before:super.gen: "heigth" 
 -- $Invocation:gen: "heigth" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "heigth" 
 -- isConstant: "Invocation" "heigth" 
 -- notConst: heigth heigth: var Length.Meter 
 -- needorigin: "heigth" 
 -- needOrigin:E: "heigth"  E.ATd: "heigth: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "heigth" 
 -- computeAdr: 1 :rec: "none"  E: "heigth" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "heigth"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "heigth" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "theArea" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg theArea$158 1
 -- $ObjectInvocation_Unary:getAdr: "heigth" >ATd.off:4:on:1:superAdj:0"heigth: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $var:getAdr: "heigth: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "heigth: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "heigth"  ATd: "heigth: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- computeAdr:isLast:E:  "heigth" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- rec:  "heigth" E:  "heigth" 
 -- INV:gen:E.loadArgs "heigth" 
 -- $ObjectInvocation_Unary:loadArgs: "heigth" >staticOff:0 "heigth: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "heigth: var Length.Meter" >E:"heigth" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "heigth" 
 -- {(ObjectInvocation_Unary; (name: "heigth"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "heigth" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "heigth" :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- $ObjectInvocation_Unary:invoke: "heigth" >rec:"heigth" ATd:"var" isValueObj E:"heigth" E.ATd:"heigth" unique:"False" 
 -- OI:invoke: "heigth" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- OI:invoke:B: "heigth" E: "heigth"  rec: "heigth"  useRtnV: true "heigth: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var heigth 
 -- $var:invoke: "heigth: var Length.Meter" E: "heigth">newOff:4 useRTNv: "True" 
 -- DI:invoke: "heigth: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "heigth" ,E: "heigth" "ObjectInvocation_Unary" E.isCompositeValueObj: true 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- 
 -- OI:invoke:C: heigth :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: true 
 -- pushValue: C: off: 4 size: 2 74 in B: var Length.Meter 
 pushvalue  off:4 size:2 descNo: 74
 pushc 1
 -- end:loadArgs:NonVirt: "mult(width,heigth)" 
 -- INV:gen:after:E.loadArgs "mult(width,heigth)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Function "mult(width,heigth)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mu ..." 
 -- $ObjectInvocation_Function:invoke: "mult(width,heigth)" >rec:"Area" ATd:"pattern" E:"mult(width,heigth)" E.ATd:"mult" unique:"False" 
 -- OI:invoke: "mult(width,heigth)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- OI:invoke:B: "mult(width,heigth)" E: "mult(width,heigth)"  rec: "Area"  useRtnV: true "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern mult 
 -- $pattern:invoke: "mult: {   in A: var Length.Meter;   in B: var Length.Meter;   out R: var squareMeter;   R.magnitude := A.magnitude * B.magnitude" E: "mult(width,heigth)" ...} 
 -- ptn:invoke: "mult" E: "mult(width,heigth)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 invoke mult 159 0 0
 -- global:pushOut: R off: 6 
 pushc 6
 pushc 0
 -- callInvoke:after:pushOut: 6 
 -- GeneralPTN:invoke:after:callInvoke: 6 
 -- GeneralPTN:invoke:end: 6 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- OI:invoke:V: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- OI:invoke:X: adr: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- adrx: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- OI:invoke:C: mult(width,heigth) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 6 
 -- OG:gen:end: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"mult(width,heigth)":rec:Area 
 -- rec: "A" dstE: "A" dstE.ATd: "out A: var Area.SquareMeter" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec: ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" Area.mult(width,heigth) 
 -- pushValue: A: off: 6 size: 7 descNo: -1 Area.mult(width,heigth) 
 pushvalue  off:6 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:2 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "A" off: 2 size: 2 mode: 0 
 vassign  2 2 0
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 159 
 -- Items:GenClass: mult descNo: 159 isValue: false 
 -- Items:GenClass: mult descNo: 21 isValue: false 

 CLASS mult 159 1 Area 66
 -- Store itemArgs: in A: var Length.Meter{in B: var Length.Meter;out R: var squareMeter;R.magnitude := A.magnitude * B.magnitude} 
 -- in B: var Length.Meter true 0 
 -- DI:store: "B" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: B off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  B 74 3
 L4:
 -- in A: var Length.Meter true 0 
 -- DI:store: "A" 
 jmpFalse  L5
 pushThis 
 -- vassign:B: A off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  A 74 1
 L6:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=159 vDescInx=159 vdtTop: 1 
 mvStack 
 -- $var:gen: "in A: var Length.Meter"  
 -- DI:gen: "in A: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  A 
 -- inArg: in A: var Length.Meter 
 -- $var:gen: "in B: var Length.Meter"  
 -- DI:gen: "in B: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  B 
 -- inArg: in B: var Length.Meter 
 -- $var:gen: "out R: var squareMeter"  
 -- DI:gen: "out R: var squareMeter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- $ObjectGenerator:gen: "squareMeter" >OGid:"SquareMeter" IS.isempty! staticOff=6 descNo=0 superAdj=0 
 -- OG:gen: "squareMeter" 
 -- OG:before:super.gen: "squareMeter" 
 -- $Invocation:gen: "squareMeter" >useRtnV:"False"superAdj: 0 descNo: 68 
 -- INV:gen: "squareMeter" 
 -- isConstant: "Invocation" "squareMeter" 
 -- needorigin: "squareMeter" 
 -- needOrigin:E: "squareMeter"  E.ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "squareMeter" E:  "squareMeter" 
 -- INV:gen:E.loadArgs "squareMeter" 
 -- $ObjectInvocation_Unary:loadArgs: "squareMeter" >staticOff:0 "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print ..."} 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"squareMeter":descNo:68} 
 -- ptn:loadArgs:E "squareMeter" 
 -- {(ObjectInvocation_Unary; (name: "squareMeter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "squareMeter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "squareMeter" 
 -- $ObjectInvocation_Unary:invoke: "squareMeter" >rec:"squareMeter" ATd:"pattern" isValueObj E:"squareMeter" E.ATd:"SquareMeter" unique:"False" 
 -- OI:invoke: "squareMeter" 
 -- 
 -- OI:invoke:B: "squareMeter" E: "squareMeter"  rec: "squareMeter"  useRtnV: false "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;       ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- $pattern:invoke: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" E: "squareMeter" useRTNv: "False"} 
 -- ptn:invoke: "SquareMeter" E: "squareMeter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 adr:none 
 invokeVal  SquareMeter 68 5
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: squareMeter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "R.magnitude := A.magnitude * B.magnitude" 
 -- $Assign:gen: "R.magnitude := A.magnitude * B.magnitude"  
 -- assign: "R.magnitude := A.magnitude * B.magnitude" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:6:on:0:superAdj:0"out R: var squareMeter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "out R: var squareMeter" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- DI:OG: squareMeter 
 -- before:floatTest:  "out R: var squareMeter" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := A.magnitude * B.magnitude" right.label: "ObjectGenerator" "A.magnitude * B.magnitude" 
 -- $ObjectGenerator:gen: "A.magnitude * B.magnitude" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "A.magnitude * B.magnitude" 
 -- OG:before:super.gen: "A.magnitude * B.magnitude" 
 -- $Invocation:gen: "A.magnitude * B.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "A.magnitude * B.magnitude" 
 -- isConstant: "Invocation" "A.magnitude * B.magnitude" 
 -- needorigin: "A.magnitude * B.magnitude" 
 -- needOrigin:E: "A.magnitude * B.magnitude"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "A.magnitude * B.magnitude" 
 -- computeAdr:superAdj: 0 "A.magnitude * B.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "A.magnitude * B.magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "A.magnitude * B.magnitude"  
 -- $BinOp:loadOrigin: "A.magnitude * B.magnitude"  
 -- BinaryExp:loadOrigin:empty: "A.magnitude * B.magnitude" superAdj: 0 
 -- $BinOp:getAdr: "A.magnitude * B.magnitude"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "A.magnitude * B.magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "A.magnitude * B.magnitude" E:  "A.magnitude * B.magnitude" 
 -- INV:gen:E.loadArgs "A.magnitude * B.magnitude" 
 -- $BinOp:loadArgs: "A.magnitude * B.magnitude"  
 -- BinaryExp:loadArgs: "A.magnitude * B.magnitude" superAdj: 0 
 -- $Invocation:gen: "A.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "A.magnitude" 
 -- isConstant: "Invocation" "A.magnitude" 
 -- notConst: A in A: var Length.Meter 
 -- needorigin: "A.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "A.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "A" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "A"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "A" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "A" >ATd.off:2:on:0:superAdj:0"in A: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "in A: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "in A: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- computeAdr: 2 :rec: "A"  E: "magnitude"  A.E: "A" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- rec:  "A" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"A" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"A":rec:A 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "A"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "A" 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* B.magnitude":descNo:65} 
 -- ptn:loadArgs:E "* B.magnitude" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "B");     (Arguments));    (ObjectInvocation_U ...} 
 -- args: "B.magnitude" 
 -- E: "ObjectGenerator" B.magnitude 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* B.magnitude" "ObjectInvocation_Binary" ActArg:  "B.magnitude" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* B.magnitude" 
 -- $ObjectGenerator:gen: "B.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "B.magnitude" 
 -- OG:before:super.gen: "B.magnitude" 
 -- $Invocation:gen: "B.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "B.magnitude" 
 -- isConstant: "Invocation" "B.magnitude" 
 -- notConst: B in B: var Length.Meter 
 -- needorigin: "B.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "B.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "B" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "B"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "B" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "B" >ATd.off:4:on:0:superAdj:0"in B: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "in B: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "in B: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- computeAdr: 2 :rec: "B"  E: "magnitude"  A.E: "B" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- rec:  "B" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"B" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"B":rec:B 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "B"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "B" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:B 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "B.magnitude" :isBasicVal: true 
 -- case:B: B.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* B.magnitude" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- INV:gen:after:E.loadArgs "A.magnitude * B.magnitude" 
 -- OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- IV:E.invoke:useRtnVal: true E: BinOp "A.magnitude * B.magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec: ... 
 -- $BinOp:invoke: "A.magnitude * B.magnitude"  
 -- BinaryExp:invoke: "A.magnitude" rec: "A.magnitude * B.magnitude" 
 -- M: "* B.magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A 
 -- $ObjectInvocation_Binary:invoke: "* B.magnitude" >rec:"A.magnitude" ATd:"pattern" E:"* B.magnitude" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* B.magnitude" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A.magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:A.magnitude 
 -- OI:invoke:B: "* B.magnitude" E: "* B.magnitude"  rec: "A.magnitude"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* B.magnitude" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* B.magnitude" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "A.magnitude" E: "* B.magnitude" 
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* B.magnitude":rec:A.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* B.magnitude":rec:A.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * B.magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "A.magnitude * B.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := A.magnitude * B.magnitude" arg: "A.magnitude * B.magnitude" ObjectGenerator 
 -- arg.super.arg: "A.magnitude * B.magnitude" BinOp 
 -- recx:BinaryExp:recx: "A.magnitude * B.magnitude" 
 -- M: "* B.magnitude" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "A.magnitude" E: "* B.magnitude" 
 -- arg:other 
 -- M:arg: "B.magnitude" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "mult" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 141 
 -- Items:GenClass: print descNo: 141 isValue: false 
 -- Items:GenClass: print descNo: 138 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 141 1 Rectangle 133
 -- vdtTableCopy: I:1:138 V:2:140 I:3:0
 -- vdtAdd: inx=3 descInx=141 vDescInx=141 vdtTop: 3 
 -- Store itemArgs: printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;width.print;":heigth:".print;heigth.print} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;width.print;":heigth:".print ...}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print;"Rectangle:width:".print;width.print;":heigth:".print;heigth.print} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=141 vDescInx=138 vdtTop: 3 
 -- $pattern:gen: "printMore:< {   inner(printMore)" } 
 -- $var:gen: "AR: var Area.SquareMeter"  
 -- DI:gen: "AR: var Area.SquareMeter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  AR 
 -- $ObjectGenerator:gen: "Area.SquareMeter" >OGid:"SquareMeter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Area.SquareMeter" 
 -- OG:before:super.gen: "Area.SquareMeter" 
 -- $Invocation:gen: "Area.SquareMeter" >useRtnV:"False"superAdj: 0 descNo: 68 
 -- INV:gen: "Area.SquareMeter" 
 -- isConstant: "Invocation" "Area.SquareMeter" 
 -- needorigin: "Area.SquareMeter" 
 -- needOrigin:E: "SquareMeter"  E.ATd: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Area" E:  "SquareMeter" 
 -- INV:gen:E.loadArgs "SquareMeter" 
 -- $ObjectInvocation_Unary:loadArgs: "SquareMeter" >staticOff:0 "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print ..."} 
 -- $pattern:loadArgs: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" >E:"SquareMeter":descNo:68} 
 -- ptn:loadArgs:E "SquareMeter" 
 -- {(ObjectInvocation_Unary; (name: "SquareMeter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "SquareMeter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "SquareMeter" 
 -- $ObjectInvocation_Unary:invoke: "SquareMeter" >rec:"Area" ATd:"pattern" isValueObj E:"SquareMeter" E.ATd:"SquareMeter" unique:"False" 
 -- OI:invoke: "SquareMeter" 
 -- 
 -- OI:invoke:B: "SquareMeter" E: "SquareMeter"  rec: "Area"  useRtnV: false "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "Square ..."}" 
 -- OI:invoke:before:ATdx.invoke: pattern SquareMeter 
 -- $pattern:invoke: "SquareMeter: Unit{   %unit "m2", 1;   %Public;   thisUnit:: SquareMeter;   print:: ;      "SquareMeter".print" E: "SquareMeter" useRTNv: "False"} 
 -- ptn:invoke: "SquareMeter" E: "SquareMeter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  SquareMeter 68 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: SquareMeter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $pattern:gen: "printMore:: {   P: var Length.meter;   " Perimeter:".print;   P := Perimeter;   P.print" } 
 rtnAlloc 1
 toSuper 138
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Rectangle:width:".print" 
 -- $ObjectGenerator:gen: ""Rectangle:width:".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Rectangle:width:".print" 
 -- OG:before:super.gen: ""Rectangle:width:".print" 
 -- $Invocation:gen: ""Rectangle:width:".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Rectangle:width:".print" 
 -- isConstant: "Invocation" ""Rectangle:width:".print" 
 -- needorigin: ""Rectangle:width:".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Rectangle:width:"" E:  ""Rectangle:width:"" 
 -- INV:gen:E.loadArgs ""Rectangle:width:"" 
 -- $String::loadArgs: ""Rectangle:width:""  
 -- INV:gen:after:E.loadArgs ""Rectangle:width:"" 
 -- OIadr: 
 -- $String::invoke: ""Rectangle:width:""  
 pushText "Rectangle:width:"
 -- IV:gen:checkTail: ""Rectangle:width:".print" E: ""Rectangle:width:"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Rectangle:width:"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Rectangle:width:""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "width.print" 
 -- $ObjectGenerator:gen: "width.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "width.print" 
 -- OG:before:super.gen: "width.print" 
 -- $Invocation:gen: "width.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "width.print" 
 -- isConstant: "Invocation" "width.print" 
 -- notConst: width width: var Length.Meter 
 -- needorigin: "width.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "width.print" 
 -- computeAdr: 1 :rec: "none"  E: "width" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "width"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "width" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg print$141 1
 -- $ObjectInvocation_Unary:getAdr: "width" >ATd.off:2:on:1:superAdj:0"width: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "width: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "width: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "width"  ATd: "width: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- computeAdr: 2 :rec: "width"  E: "print"  A.E: "width" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "width" >staticOff:0 "width: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "width: var Length.Meter" >E:"width" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "width" 
 -- {(ObjectInvocation_Unary; (name: "width"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "width" >rec:"width" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "width" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- OI:invoke:B: "width" E: "print"  rec: "width"  useRtnV: true "width: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var width 
 -- $var:invoke: "width: var Length.Meter" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "width: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "width" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- 
 -- OI:invoke:C: width :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "width" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- rec:  "width" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"width" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- OI:invoke:B: "print" E: "print"  rec: "width"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- isDI 
 -- isStatic: true rec: "width" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:width 
 -- genclass:stmt: "":heigth:".print" 
 -- $ObjectGenerator:gen: "":heigth:".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "":heigth:".print" 
 -- OG:before:super.gen: "":heigth:".print" 
 -- $Invocation:gen: "":heigth:".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: "":heigth:".print" 
 -- isConstant: "Invocation" "":heigth:".print" 
 -- needorigin: "":heigth:".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "":heigth:"" E:  "":heigth:"" 
 -- INV:gen:E.loadArgs "":heigth:"" 
 -- $String::loadArgs: "":heigth:""  
 -- INV:gen:after:E.loadArgs "":heigth:"" 
 -- OIadr: 
 -- $String::invoke: "":heigth:""  
 pushText ":heigth:"
 -- IV:gen:checkTail: "":heigth:".print" E: "":heigth:"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"":heigth:"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: "":heigth:""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "heigth.print" 
 -- $ObjectGenerator:gen: "heigth.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "heigth.print" 
 -- OG:before:super.gen: "heigth.print" 
 -- $Invocation:gen: "heigth.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "heigth.print" 
 -- isConstant: "Invocation" "heigth.print" 
 -- notConst: heigth heigth: var Length.Meter 
 -- needorigin: "heigth.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "heigth.print" 
 -- computeAdr: 1 :rec: "none"  E: "heigth" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "heigth"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "heigth" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg print$141 1
 -- $ObjectInvocation_Unary:getAdr: "heigth" >ATd.off:4:on:1:superAdj:0"heigth: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $var:getAdr: "heigth: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "heigth: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "heigth"  ATd: "heigth: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- computeAdr: 2 :rec: "heigth"  E: "print"  A.E: "heigth" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "heigth" >staticOff:0 "heigth: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "heigth: var Length.Meter" >E:"heigth" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "heigth" 
 -- {(ObjectInvocation_Unary; (name: "heigth"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "heigth" >rec:"heigth" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "heigth" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- OI:invoke:B: "heigth" E: "print"  rec: "heigth"  useRtnV: true "heigth: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var heigth 
 -- $var:invoke: "heigth: var Length.Meter" E: "print">newOff:4 useRTNv: "True" 
 -- DI:invoke: "heigth: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "heigth" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- 
 -- OI:invoke:C: heigth :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "heigth" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- rec:  "heigth" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth ... 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"heigth" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- OI:invoke:B: "print" E: "print"  rec: "heigth"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- isDI 
 -- isStatic: true rec: "heigth" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:heigth 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- vdtAdd: inx=2 descInx=141 vDescInx=160 vdtTop: 3 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 160 
 -- Items:GenClass: printMore descNo: 160 isValue: false 
 -- Items:GenClass: printMore descNo: 140 isValue: false 
 -- Items:GenClass: printMore descNo: 21 isValue: false 

 CLASS printMore 160 1 print 141
 -- vdtTableCopy: I:1:140 I:2:0
 -- vdtAdd: inx=2 descInx=160 vDescInx=160 vdtTop: 2 
 -- Store itemArgs: P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 -- super printMore
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 -- handleSuperArgs:E: "" theIS: "P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print}" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: printMore 
 -- Store itemArgs: P: var Length.meter{" Perimeter:".print;P := Perimeter;P.print} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=160 vDescInx=140 vdtTop: 2 
 -- $var:gen: "P: var Length.meter"  
 -- DI:gen: "P: var Length.meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  P 
 -- $ObjectGenerator:gen: "Length.meter" >OGid:"Meter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Length.meter" 
 -- OG:before:super.gen: "Length.meter" 
 -- $Invocation:gen: "Length.meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.meter" 
 -- isConstant: "Invocation" "Length.meter" 
 -- needorigin: "Length.meter" 
 -- needOrigin:E: "meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "meter" 
 -- INV:gen:E.loadArgs "meter" 
 -- $ObjectInvocation_Unary:loadArgs: "meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "meter" 
 -- {(ObjectInvocation_Unary; (name: "meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "meter" 
 -- $ObjectInvocation_Unary:invoke: "meter" >rec:"Length" ATd:"pattern" isValueObj E:"meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "meter" 
 -- 
 -- OI:invoke:B: "meter" E: "meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  Meter 74 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 140
DO:
 mvStack 
 L1:
 -- genclass:stmt: "" Perimeter:".print" 
 -- $ObjectGenerator:gen: "" Perimeter:".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "" Perimeter:".print" 
 -- OG:before:super.gen: "" Perimeter:".print" 
 -- $Invocation:gen: "" Perimeter:".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: "" Perimeter:".print" 
 -- isConstant: "Invocation" "" Perimeter:".print" 
 -- needorigin: "" Perimeter:".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "" Perimeter:"" E:  "" Perimeter:"" 
 -- INV:gen:E.loadArgs "" Perimeter:"" 
 -- $String::loadArgs: "" Perimeter:""  
 -- INV:gen:after:E.loadArgs "" Perimeter:"" 
 -- OIadr: 
 -- $String::invoke: "" Perimeter:""  
 pushText " Perimeter:"
 -- IV:gen:checkTail: "" Perimeter:".print" E: "" Perimeter:"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"" Perimeter:"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: "" Perimeter:""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "P := Perimeter" 
 -- $Assign:gen: "P := Perimeter"  
 -- assign: "P := Perimeter" 
 -- computeAdr:superAdj: 0 "P" 
 -- computeAdr: 1 :rec: "none"  E: "P" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "P" >ATd.off:2:on:0:superAdj:0"P: var Length.meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "P: var Length.meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.meter 
 -- before:floatTest:  "P: var Length.meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- computeAdr:isLast:E:  "P" 
 -- AssignmentStatement:gen: "P := Perimeter" right.label: "ObjectGenerator" "Perimeter" 
 -- $ObjectGenerator:gen: "Perimeter" >OGid:"perimeter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Perimeter" 
 -- OG:before:super.gen: "Perimeter" 
 -- $Invocation:gen: "Perimeter" >useRtnV:"True"superAdj: 0 descNo: 161 
 -- INV:gen: "Perimeter" 
 -- isConstant: "Invocation" "Perimeter" 
 -- needorigin: "Perimeter" 
 -- needOrigin:E: "Perimeter"  E.ATd: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" 
 -- doNeedOrigin:Ex: "Perimeter" 
 -- computeAdr:superAdj: 0 "Perimeter" 
 -- computeAdr: 1 :rec: "none"  E: "Perimeter" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Perimeter"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Perimeter" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "printMore" on: 2 isValueObj: false 
 -- origin: print origin:isValueObj: false 
 rpushg printMore$160 1
 -- items:goOrigin:encOG: "print" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg print$141 1
 -- $ObjectInvocation_Unary:getAdr: "Perimeter" >ATd.off:0 (isPtn):on:2:superAdj:0"perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0":Adr:off:0 size:0 isFl ...} 
 -- $pattern:getAdr: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "Perimeter"  ATd: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:- 
 -- computeAdr:isLast:E:  "Perimeter" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:- 
 -- rec:  "Perimeter" E:  "Perimeter" 
 -- INV:gen:E.loadArgs "Perimeter" 
 -- $ObjectInvocation_Unary:loadArgs: "Perimeter" >staticOff:0 "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0" superAdj:0} 
 -- $pattern:loadArgs: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0" >E:"Perimeter":descNo:161} 
 -- ptn:loadArgs:E "Perimeter" 
 -- {(ObjectInvocation_Unary; (name: "Perimeter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Perimeter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Perimeter" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec ... 
 -- $ObjectInvocation_Unary:invoke: "Perimeter" >rec:"Perimeter" ATd:"pattern" E:"Perimeter" E.ATd:"perimeter" unique:"False" 
 -- OI:invoke: "Perimeter" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- OI:invoke:B: "Perimeter" E: "Perimeter"  rec: "Perimeter"  useRtnV: true "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0}" 
 -- OI:invoke:before:ATdx.invoke: pattern perimeter 
 -- $pattern:invoke: "perimeter: {   out V: var Length.Meter;   V := (width + heigth) * 2.0" E: "Perimeter" useRTNv: "True"} 
 -- ptn:invoke: "perimeter" E: "Perimeter" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 invoke perimeter 161 0 0
 -- global:pushOut: V off: 2 
 pushc 2
 pushc 0
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- OI:invoke:C: Perimeter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Perimeter":rec:Perimeter 
 -- rec: "P" dstE: "P" dstE.ATd: "P: var Length.meter" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" Perimeter 
 -- pushValue: A: off: 2 size: 3 descNo: -1 Perimeter 
 pushvalue  off:2 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:2 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "P" off: 2 size: 2 mode: 0 
 vassign  2 2 0
 -- assign:adr.store:B: 
 -- genclass:stmt: "P.print" 
 -- $ObjectGenerator:gen: "P.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "P.print" 
 -- OG:before:super.gen: "P.print" 
 -- $Invocation:gen: "P.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "P.print" 
 -- isConstant: "Invocation" "P.print" 
 -- notConst: P P: var Length.meter 
 -- needorigin: "P.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "P.print" 
 -- computeAdr: 1 :rec: "none"  E: "P" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "P"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "P" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "P" >ATd.off:2:on:0:superAdj:0"P: var Length.meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "P: var Length.meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.meter 
 -- before:floatTest:  "P: var Length.meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- computeAdr: 2 :rec: "P"  E: "print"  A.E: "P" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "P" >staticOff:0 "P: var Length.meter" superAdj:0 
 -- $var:loadArgs: "P: var Length.meter" >E:"P" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "P" 
 -- {(ObjectInvocation_Unary; (name: "P"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "P" >rec:"P" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "P" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:P 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"P":rec:P 
 -- OI:invoke:B: "P" E: "print"  rec: "P"  useRtnV: true "P: var Length.meter" 
 -- OI:invoke:before:ATdx.invoke: var P 
 -- $var:invoke: "P: var Length.meter" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "P: var Length.meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "P" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- 
 -- OI:invoke:C: P :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "P" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- rec:  "P" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"P" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- OI:invoke:B: "print" E: "print"  rec: "P"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- isDI 
 -- isStatic: true rec: "P" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:P 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 161 
 -- Items:GenClass: perimeter descNo: 161 isValue: false 
 -- Items:GenClass: perimeter descNo: 21 isValue: false 

 CLASS perimeter 161 1 Rectangle 133
 -- Store itemArgs: out V: var Length.Meter{V := (width + heigth) * 2.0} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=161 vDescInx=161 vdtTop: 1 
 mvStack 
 -- $var:gen: "out V: var Length.Meter"  
 -- DI:gen: "out V: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  V 
 -- $ObjectGenerator:gen: "Length.Meter" >OGid:"Meter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Length.Meter" 
 -- OG:before:super.gen: "Length.Meter" 
 -- $Invocation:gen: "Length.Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.Meter" 
 -- isConstant: "Invocation" "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Length" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  Meter 74 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "V := (width + heigth) * 2.0" 
 -- $Assign:gen: "V := (width + heigth) * 2.0"  
 -- assign: "V := (width + heigth) * 2.0" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"out V: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValu ... 
 -- $var:getAdr: "out V: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "out V: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := (width + heigth) * 2.0" right.label: "ObjectGenerator" "(width + heigth) * 2.0" 
 -- $ObjectGenerator:gen: "(width + heigth) * 2.0" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(width + heigth) * 2.0" 
 -- OG:before:super.gen: "(width + heigth) * 2.0" 
 -- $Invocation:gen: "(width + heigth) * 2.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(width + heigth) * 2.0" 
 -- isConstant: "Invocation" "(width + heigth) * 2.0" 
 -- needorigin: "(width + heigth) * 2.0" 
 -- needOrigin:E: "(width + heigth) * 2.0"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(width + heigth) * 2.0" 
 -- computeAdr:superAdj: 0 "(width + heigth) * 2.0" 
 -- computeAdr: 1 :rec: "none"  E: "(width + heigth) * 2.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "(width + heigth) * 2.0"  
 -- $BinOp:loadOrigin: "(width + heigth) * 2.0"  
 -- BinaryExp:loadOrigin:empty: "(width + heigth) * 2.0" superAdj: 0 
 -- $BinOp:getAdr: "(width + heigth) * 2.0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "(width + heigth) * 2.0"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "(width + heigth) * 2.0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "(width + heigth) * 2.0" E:  "(width + heigth) * 2.0" 
 -- INV:gen:E.loadArgs "(width + heigth) * 2.0" 
 -- $BinOp:loadArgs: "(width + heigth) * 2.0"  
 -- BinaryExp:loadArgs: "(width + heigth) * 2.0" superAdj: 0 
 -- $Invocation:gen: "(width + heigth)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(width + heigth)" 
 -- isConstant: "Invocation" "(width + heigth)" 
 -- needorigin: "(width + heigth)" 
 -- needOrigin:E: "(width + heigth)"  E.ATd: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(width + heigth)" 
 -- computeAdr:superAdj: 0 "(width + heigth)" 
 -- computeAdr: 1 :rec: "none"  E: "(width + heigth)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(width + heigth)"  
 -- $BracketedExp:loadOrigin: "(width + heigth)"  
 -- computeAdr:superAdj: 0 "width + heigth" 
 -- computeAdr: 1 :rec: "none"  E: "width + heigth" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "width + heigth"  
 -- $BinOp:loadOrigin: "width + heigth"  
 -- BinaryExp:loadOrigin:empty: "width + heigth" superAdj: 0 
 -- $BinOp:getAdr: "width + heigth"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "width + heigth"  ATd: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "width + heigth" 
 -- BE:loadOrigin:E: width + heigth 
 -- $BinOp:getAdr: "width + heigth"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "width + heigth"  ATd: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "width + heigth" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "width + heigth" E:  "width + heigth" 
 -- INV:gen:E.loadArgs "width + heigth" 
 -- $BinOp:loadArgs: "width + heigth"  
 -- BinaryExp:loadArgs: "width + heigth" superAdj: 0 
 -- $Invocation:gen: "width" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "width" 
 -- isConstant: "Invocation" "width" 
 -- notConst: width width: var Length.Meter 
 -- needorigin: "width" 
 -- needOrigin:E: "width"  E.ATd: "width: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "width" 
 -- computeAdr: 1 :rec: "none"  E: "width" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "width"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "width" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "perimeter" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg perimeter$161 1
 -- $ObjectInvocation_Unary:getAdr: "width" >ATd.off:2:on:1:superAdj:0"width: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "width: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "width: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "width"  ATd: "width: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- computeAdr:isLast:E:  "width" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- rec:  "width" E:  "width" 
 -- INV:gen:E.loadArgs "width" 
 -- $ObjectInvocation_Unary:loadArgs: "width" >staticOff:0 "width: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "width: var Length.Meter" >E:"width" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "width" 
 -- {(ObjectInvocation_Unary; (name: "width"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "width" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "width" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- $ObjectInvocation_Unary:invoke: "width" >rec:"width" ATd:"var" isValueObj E:"width" E.ATd:"width" unique:"False" 
 -- OI:invoke: "width" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- OI:invoke:B: "width" E: "width"  rec: "width"  useRtnV: true "width: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var width 
 -- $var:invoke: "width: var Length.Meter" E: "width">newOff:2 useRTNv: "True" 
 -- DI:invoke: "width: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "width" ,E: "width" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- 
 -- OI:invoke:C: width :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- $pattern:loadArgs: "+  : {   %basic 109;   in V: var float;   out R: var float" >E:"+ heigth":descNo:152} 
 -- ptn:loadArgs:E "+ heigth" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "heigth");     (Arguments)));   (Items descNo: ...} 
 -- args: "heigth" 
 -- E: "ObjectGenerator" heigth 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "+ heigth" "ObjectInvocation_Binary" ActArg:  "heigth" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ heigth"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "heigth" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "heigth" 
 -- OG:before:super.gen: "heigth" 
 -- $Invocation:gen: "heigth" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "heigth" 
 -- isConstant: "Invocation" "heigth" 
 -- notConst: heigth heigth: var Length.Meter 
 -- needorigin: "heigth" 
 -- needOrigin:E: "heigth"  E.ATd: "heigth: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "heigth" 
 -- computeAdr: 1 :rec: "none"  E: "heigth" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "heigth"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "heigth" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "perimeter" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg perimeter$161 1
 -- $ObjectInvocation_Unary:getAdr: "heigth" >ATd.off:4:on:1:superAdj:0"heigth: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $var:getAdr: "heigth: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "heigth: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "heigth"  ATd: "heigth: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- computeAdr:isLast:E:  "heigth" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- rec:  "heigth" E:  "heigth" 
 -- INV:gen:E.loadArgs "heigth" 
 -- $ObjectInvocation_Unary:loadArgs: "heigth" >staticOff:0 "heigth: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "heigth: var Length.Meter" >E:"heigth" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "heigth" 
 -- {(ObjectInvocation_Unary; (name: "heigth"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "heigth" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "heigth" :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- $ObjectInvocation_Unary:invoke: "heigth" >rec:"heigth" ATd:"var" isValueObj E:"heigth" E.ATd:"heigth" unique:"False" 
 -- OI:invoke: "heigth" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- OI:invoke:B: "heigth" E: "heigth"  rec: "heigth"  useRtnV: true "heigth: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var heigth 
 -- $var:invoke: "heigth: var Length.Meter" E: "heigth">newOff:4 useRTNv: "True" 
 -- DI:invoke: "heigth: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "heigth" ,E: "heigth" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- 
 -- OI:invoke:C: heigth :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:heigth 
 -- before:pushSize:  actualArg.super.ATd.OG.isUnitValueObj: true 
 -- :actualArg.isCompositeValueObj: false 
 -- actualArg:UnitOne?: heigth 
 -- end:loadArgs:NonVirt: "+ heigth" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- INV:gen:after:E.loadArgs "width + heigth" 
 -- OIadr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- IV:E.invoke:useRtnVal: true E: BinOp "width + heigth" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- $BinOp:invoke: "width + heigth"  
 -- BinaryExp:invoke: "width" rec: "width + heigth" 
 -- M: "+ heigth" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- $ObjectInvocation_Binary:invoke: "+ heigth" >rec:"width" ATd:"pattern" E:"+ heigth" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ heigth" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- origin:isValueObj "float" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:width 
 -- OI:invoke:B: "+ heigth" E: "+ heigth"  rec: "width"  useRtnV: true "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 109;   in V: var float;   out R: var float" E: "+ heigth" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ heigth" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "width" E: "+ heigth" 
 -- arg:unit 
 -- rec:other: 
 fplus
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ heigth":rec:width 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ heigth":rec:width 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + heigth :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* 2.0":descNo:65} 
 -- ptn:loadArgs:E "* 2.0" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (FloatLiteral 2.0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "2.0" 
 -- E: "ObjectGenerator" 2.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* 2.0" "ObjectInvocation_Binary" ActArg:  "2.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* 2.0" 
 -- $ObjectGenerator:gen: "2.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "2.0" 
 -- OG:before:super.gen: "2.0" 
 -- $Invocation:gen: "2.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "2.0" 
 -- isConstant: "Invocation" "2.0" 
 -- needorigin: "2.0" 
 -- needOrigin:E: "2.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "2.0" E:  "2.0" 
 -- INV:gen:E.loadArgs "2.0" 
 -- $FloatLiteral:loadArgs: "2.0"  
 -- INV:gen:after:E.loadArgs "2.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "2.0" 
 -- $FloatLiteral:invoke: "2.0"  
 pushFloatConst 2.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "2.0" :isBasicVal: true 
 -- case:B: 2.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "* 2.0" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "(width + heigth) * 2.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "(width + heigth) * 2.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- $BinOp:invoke: "(width + heigth) * 2.0"  
 -- BinaryExp:invoke: "(width + heigth)" rec: "(width + heigth) * 2.0" 
 -- M: "* 2.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "* 2.0" >rec:"(width + heigth)" ATd:"pattern" E:"* 2.0" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* 2.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:(width + heigth) 
 -- origin:isValueObj "float" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:(width + heigth) 
 -- OI:invoke:B: "* 2.0" E: "* 2.0"  rec: "(width + heigth)"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* 2.0" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* 2.0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "(width + heigth)" E: "* 2.0" 
 -- arg:float 
 fmult
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"* 2.0":rec:(width + heigth) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"* 2.0":rec:(width + heigth) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * 2.0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "V" dstE: "V" dstE.ATd: "out V: var Length.Meter" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "(width + heigth) * 2.0" 
 -- isArgOfAssignI2IwithUniValArg "V := (width + heigth) * 2.0" arg: "(width + heigth) * 2.0" ObjectGenerator 
 -- arg.super.arg: "(width + heigth) * 2.0" BinOp 
 -- recx:BinaryExp:recx: "(width + heigth) * 2.0" 
 -- M: "* 2.0" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "(width + heigth)" E: "* 2.0" 
 -- arg:float 
 -- M:arg: "2.0" ObjectGenerator false 
 -- dstDI: "out V: var Length.Meter" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "perimeter" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 134 
 -- Items:GenClass: F2M descNo: 134 isValue: false 
 -- Items:GenClass: F2M descNo: 21 isValue: false 

 CLASS F2M 134 1 Length 72
 -- Store itemArgs: in V: var float{out R: var Meter;put('A');R.magnitude := V;put('B')} 
 -- in V: var float true 9 
 -- DI:store: "V" 
 pushThis 
 fstoreg 2 V
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=134 vDescInx=134 vdtTop: 1 
 mvStack 
 -- $var:gen: "in V: var float"  
 -- DI:gen: "in V: var float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  V 
 -- $var:gen: "out R: var Meter"  
 -- DI:gen: "out R: var Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- $ObjectGenerator:gen: "Meter" >OGid:"Meter" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Meter" 
 -- OG:before:super.gen: "Meter" 
 -- $Invocation:gen: "Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Meter" 
 -- isConstant: "Invocation" "Meter" 
 -- needorigin: "Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Meter" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Meter" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Meter"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 adr:none 
 invokeVal  Meter 74 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "put('A')" 
 -- $ObjectGenerator:gen: "put('A')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('A')" 
 -- OG:before:super.gen: "put('A')" 
 -- $Invocation:gen: "put('A')" >useRtnV:"False"superAdj: 0 descNo: 54 
 -- INV:gen: "put('A')" 
 -- isConstant: "Invocation" "put('A')" 
 -- needorigin: "put('A')" 
 -- needOrigin:E: "put('A')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('A')" E:  "put('A')" 
 -- INV:gen:E.loadArgs "put('A')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('A')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'A'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('A')":descNo:54} 
 -- ptn:loadArgs:E "put('A')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: 'A'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put('A')" 
 -- E: "ObjectGenerator" 'A' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('A')" "ObjectInvocation_KeyWord" ActArg:  "'A'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('A')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'A'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'A'" 
 -- OG:before:super.gen: "'A'" 
 -- $Invocation:gen: "'A'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'A'" 
 -- isConstant: "Invocation" "'A'" 
 -- needorigin: "'A'" 
 -- needOrigin:E: "'A'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'A'" E:  "'A'" 
 -- INV:gen:E.loadArgs "'A'" 
 -- $Char::loadArgs: "'A'"  
 -- INV:gen:after:E.loadArgs "'A'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'A'" 
 -- $Char::invoke: "'A'"  
 pushc 65
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'A'" :isBasicVal: true 
 -- case:B: 'A' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('A')" 
 -- INV:gen:after:E.loadArgs "put('A')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('A')" 
 -- $ObjectInvocation_KeyWord:invoke: "put('A')" >rec:"put('A')" ATd:"pattern" E:"put('A')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('A')" 
 -- 
 -- OI:invoke:B: "put('A')" E: "put('A')"  rec: "put('A')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('A')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('A')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('A') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "R.magnitude := V" 
 -- $Assign:gen: "R.magnitude := V"  
 -- assign: "R.magnitude := V" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:4:on:0:superAdj:0"out R: var Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- $var:getAdr: "out R: var Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F or ... 
 -- DI:OG: Meter 
 -- before:floatTest:  "out R: var Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := V" right.label: "ObjectGenerator" "V" 
 -- $ObjectGenerator:gen: "V" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V" 
 -- OG:before:super.gen: "V" 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V in V: var float 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"in V: var float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"n ..." 
 -- $var:getAdr: "in V: var float" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: float 
 -- before:floatTest:  "in V: var float" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- getAdr:isfloat:A:  in V: var float  A.isValue: true 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "in V: var float" superAdj:0 
 -- $var:loadArgs: "in V: var float" >E:"V" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "in V: var float" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "in V: var float" E: "V">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in V: var float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "in V: var float" true 
 -- E.ATd.isValueObj: false rec: "V" 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "V" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := V" arg: "V" ObjectGenerator 
 -- arg.super.arg: "V" ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "put('B')" 
 -- $ObjectGenerator:gen: "put('B')" >OGid:"put" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "put('B')" 
 -- OG:before:super.gen: "put('B')" 
 -- $Invocation:gen: "put('B')" >useRtnV:"False"superAdj: 0 descNo: 54 
 -- INV:gen: "put('B')" 
 -- isConstant: "Invocation" "put('B')" 
 -- needorigin: "put('B')" 
 -- needOrigin:E: "put('B')"  E.ATd: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- Ex:loadOrign:no:loadOrigin:  "-- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "put('B')" E:  "put('B')" 
 -- INV:gen:E.loadArgs "put('B')" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put('B')" >staticOff:0 "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" superAdj:0arg:"'B'"} 
 -- $pattern:loadArgs: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" >E:"put('B')":descNo:54} 
 -- ptn:loadArgs:E "put('B')" 
 -- {(ObjectInvocation_KeyWord; (name: "put"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (Char: 'B'));   (Items descNo: 0 origDescNo: 0)); ...} 
 -- args: "put('B')" 
 -- E: "ObjectGenerator" 'B' 
 -- E.arg: "val" in ch: val char 
 -- NonVirt: "put('B')" "ObjectInvocation_KeyWord" ActArg:  "'B'" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put('B')"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "'B'" >OGid:"char" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "'B'" 
 -- OG:before:super.gen: "'B'" 
 -- $Invocation:gen: "'B'" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "'B'" 
 -- isConstant: "Invocation" "'B'" 
 -- needorigin: "'B'" 
 -- needOrigin:E: "'B'"  E.ATd: "char: value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var ch ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %id "char";   %globals;   %basic 3, 16;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var char;   ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "'B'" E:  "'B'" 
 -- INV:gen:E.loadArgs "'B'" 
 -- $Char::loadArgs: "'B'"  
 -- INV:gen:after:E.loadArgs "'B'" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: Char: "'B'" 
 -- $Char::invoke: "'B'"  
 pushc 66
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in ch: val char" :isBasicVal: true :valueObj: true 
 -- :actArg: "'B'" :isBasicVal: true 
 -- case:B: 'B' ObjectGenerator 3 3 3 false true 
 -- end:loadArgs:NonVirt: "put('B')" 
 -- INV:gen:after:E.loadArgs "put('B')" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put('B')" 
 -- $ObjectInvocation_KeyWord:invoke: "put('B')" >rec:"put('B')" ATd:"pattern" E:"put('B')" E.ATd:"put" unique:"False" 
 -- OI:invoke: "put('B')" 
 -- 
 -- OI:invoke:B: "put('B')" E: "put('B')"  rec: "put('B')"  useRtnV: false "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char}" 
 -- OI:invoke:before:ATdx.invoke: pattern put 
 -- $pattern:invoke: "put:  -- to be eliminated{   %globals;   %basic 2;   in ch: val char" E: "put('B')" useRTNv: "False"} 
 -- ptn:invoke: "put" E: "put('B')" ptnKind: 0 useRtnV: false 
 %put 2
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: put('B') :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "F2M" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 137 
 -- Items:GenClass: set descNo: 137 isValue: false 
 -- Items:GenClass: set descNo: 21 isValue: false 

 CLASS set 137 1 Rectangle 133
 -- Store itemArgs: in w: var Length.Meter{in h: var Length.Meter;width := w;heigth := h} 
 -- in h: var Length.Meter true 0 
 -- DI:store: "h" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: h off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  h 74 3
 L4:
 -- in w: var Length.Meter true 0 
 -- DI:store: "w" 
 jmpFalse  L5
 pushThis 
 -- vassign:B: w off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  w 74 1
 L6:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=137 vDescInx=137 vdtTop: 1 
 mvStack 
 -- $var:gen: "in w: var Length.Meter"  
 -- DI:gen: "in w: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  w 
 -- inArg: in w: var Length.Meter 
 -- $var:gen: "in h: var Length.Meter"  
 -- DI:gen: "in h: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  h 
 -- inArg: in h: var Length.Meter 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "width := w" 
 -- $Assign:gen: "width := w"  
 -- assign: "width := w" 
 -- computeAdr:superAdj: 0 "width" 
 -- computeAdr: 1 :rec: "none"  E: "width" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "width"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "width" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "set" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg set$137 1
 -- $ObjectInvocation_Unary:getAdr: "width" >ATd.off:2:on:1:superAdj:0"width: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "width: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVal ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "width: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "width"  ATd: "width: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- computeAdr:isLast:E:  "width" 
 -- AssignmentStatement:gen: "width := w" right.label: "ObjectGenerator" "w" 
 -- $ObjectGenerator:gen: "w" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "w" 
 -- OG:before:super.gen: "w" 
 -- $Invocation:gen: "w" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "w" 
 -- isConstant: "Invocation" "w" 
 -- notConst: w in w: var Length.Meter 
 -- needorigin: "w" 
 -- needOrigin:E: "w"  E.ATd: "in w: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "w" 
 -- computeAdr: 1 :rec: "none"  E: "w" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "w"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "w" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "w" >ATd.off:2:on:0:superAdj:0"in w: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "in w: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "in w: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:- 
 -- computeAdr:isLast:E:  "w" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:- 
 -- rec:  "w" E:  "w" 
 -- INV:gen:E.loadArgs "w" 
 -- $ObjectInvocation_Unary:loadArgs: "w" >staticOff:0 "in w: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "in w: var Length.Meter" >E:"w" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "w" 
 -- {(ObjectInvocation_Unary; (name: "w"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "w" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "w" :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:- 
 -- $ObjectInvocation_Unary:invoke: "w" >rec:"w" ATd:"var" isValueObj E:"w" E.ATd:"w" unique:"False" 
 -- OI:invoke: "w" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:w 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:w 
 -- OI:invoke:B: "w" E: "w"  rec: "w"  useRtnV: true "in w: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var w 
 -- $var:invoke: "in w: var Length.Meter" E: "w">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in w: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "w" ,E: "w" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:w 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:w 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:w 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:w 
 -- 
 -- OI:invoke:C: w :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"w":rec:w 
 -- rec: "width" dstE: "width" dstE.ATd: "width: var Length.Meter" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"wid ..." 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: true F: false I: false 
 -- right: "w" 
 -- isArgOfAssignI2IwithUniValArg "width := w" arg: "w" ObjectGenerator 
 -- arg.super.arg: "w" ObjectInvocation_Unary 
 -- dstDI: "width: var Length.Meter" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"width":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 2 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 -- genclass:stmt: "heigth := h" 
 -- $Assign:gen: "heigth := h"  
 -- assign: "heigth := h" 
 -- computeAdr:superAdj: 0 "heigth" 
 -- computeAdr: 1 :rec: "none"  E: "heigth" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "heigth"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "heigth" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "set" on: 1 isValueObj: false 
 -- origin: Rectangle origin:isValueObj: false 
 rpushg set$137 1
 -- $ObjectInvocation_Unary:getAdr: "heigth" >ATd.off:4:on:1:superAdj:0"heigth: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $var:getAdr: "heigth: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "heigth: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "heigth"  ATd: "heigth: var Length.Meter" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- computeAdr:isLast:E:  "heigth" 
 -- AssignmentStatement:gen: "heigth := h" right.label: "ObjectGenerator" "h" 
 -- $ObjectGenerator:gen: "h" >OGid:"Meter" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "h" 
 -- OG:before:super.gen: "h" 
 -- $Invocation:gen: "h" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "h" 
 -- isConstant: "Invocation" "h" 
 -- notConst: h in h: var Length.Meter 
 -- needorigin: "h" 
 -- needOrigin:E: "h"  E.ATd: "in h: var Length.Meter" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "h" 
 -- computeAdr: 1 :rec: "none"  E: "h" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "h"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "h" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "h" >ATd.off:4:on:0:superAdj:0"in h: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "in h: var Length.Meter" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "in h: var Length.Meter" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:- 
 -- computeAdr:isLast:E:  "h" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:- 
 -- rec:  "h" E:  "h" 
 -- INV:gen:E.loadArgs "h" 
 -- $ObjectInvocation_Unary:loadArgs: "h" >staticOff:0 "in h: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "in h: var Length.Meter" >E:"h" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "h" 
 -- {(ObjectInvocation_Unary; (name: "h"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "h" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "h" :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:- 
 -- $ObjectInvocation_Unary:invoke: "h" >rec:"h" ATd:"var" isValueObj E:"h" E.ATd:"h" unique:"False" 
 -- OI:invoke: "h" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:h 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:h 
 -- OI:invoke:B: "h" E: "h"  rec: "h"  useRtnV: true "in h: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var h 
 -- $var:invoke: "in h: var Length.Meter" E: "h">newOff:4 useRTNv: "True" 
 -- DI:invoke: "in h: var Length.Meter" 
 -- isValueObj:isAdr: false objSize: 2  rec "h" ,E: "h" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:h 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:h 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:isUnitVal 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:h 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:h 
 -- 
 -- OI:invoke:C: h :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"h":rec:h 
 -- rec: "heigth" dstE: "heigth" dstE.ATd: "heigth: var Length.Meter" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:" ..." 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: true F: false I: false 
 -- right: "h" 
 -- isArgOfAssignI2IwithUniValArg "heigth := h" arg: "h" ObjectGenerator 
 -- arg.super.arg: "h" ObjectInvocation_Unary 
 -- dstDI: "heigth: var Length.Meter" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"heigth":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "set" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 142 
 -- Items:GenClass: mult descNo: 142 isValue: false 
 -- Items:GenClass: mult descNo: 21 isValue: false 

 CLASS mult 142 1 Velocity 90
 -- Store itemArgs: in L: var Length.Meter{in T: var Time.Minutes;out R: var MeterPerSecond;R.magnitude := L.magnitude * T.magnitude} 
 -- in T: var Time.Minutes true 0 
 -- DI:store: "T" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: T off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  T 102 3
 L4:
 -- in L: var Length.Meter true 0 
 -- DI:store: "L" 
 jmpFalse  L5
 pushThis 
 -- vassign:B: L off: 2 size: 2 mode: 0 
 vassign  2 2 0
 jmp L6
 L5:
 invokeVal  L 74 1
 L6:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=142 vDescInx=142 vdtTop: 1 
 mvStack 
 -- $var:gen: "in L: var Length.Meter"  
 -- DI:gen: "in L: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- inArg: in L: var Length.Meter 
 -- $var:gen: "in T: var Time.Minutes"  
 -- DI:gen: "in T: var Time.Minutes" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  T 
 -- inArg: in T: var Time.Minutes 
 -- $var:gen: "out R: var MeterPerSecond"  
 -- DI:gen: "out R: var MeterPerSecond" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- $ObjectGenerator:gen: "MeterPerSecond" >OGid:"MeterPerSecond" IS.isempty! staticOff=6 descNo=0 superAdj=0 
 -- OG:gen: "MeterPerSecond" 
 -- OG:before:super.gen: "MeterPerSecond" 
 -- $Invocation:gen: "MeterPerSecond" >useRtnV:"False"superAdj: 0 descNo: 96 
 -- INV:gen: "MeterPerSecond" 
 -- isConstant: "Invocation" "MeterPerSecond" 
 -- needorigin: "MeterPerSecond" 
 -- needOrigin:E: "MeterPerSecond"  E.ATd: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "MeterPerSecond" E:  "MeterPerSecond" 
 -- INV:gen:E.loadArgs "MeterPerSecond" 
 -- $ObjectInvocation_Unary:loadArgs: "MeterPerSecond" >staticOff:0 "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ..."} 
 -- $pattern:loadArgs: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" >E:"MeterPerSecond":desc ...} 
 -- ptn:loadArgs:E "MeterPerSecond" 
 -- {(ObjectInvocation_Unary; (name: "MeterPerSecond"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "MeterPerSecond" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "MeterPerSecond" 
 -- $ObjectInvocation_Unary:invoke: "MeterPerSecond" >rec:"MeterPerSecond" ATd:"pattern" isValueObj E:"MeterPerSecond" E.ATd:"MeterPerSecond" unique:"False" 
 -- OI:invoke: "MeterPerSecond" 
 -- 
 -- OI:invoke:B: "MeterPerSecond" E: "MeterPerSecond"  rec: "MeterPerSecond"  useRtnV: false "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit::  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern MeterPerSecond 
 -- $pattern:invoke: "MeterPerSecond: Unit{   %unit "MpS", "m*s^-1", "m/s", 1;   %Public;   thisUnit:: MeterPerSecond;   print:: ;      "MpS".print" E: "MeterPerSecond" useRTN ...} 
 -- ptn:invoke: "MeterPerSecond" E: "MeterPerSecond" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 6 adr:none 
 invokeVal  MeterPerSecond 96 5
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: MeterPerSecond :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "R.magnitude := L.magnitude * T.magnitude" 
 -- $Assign:gen: "R.magnitude := L.magnitude * T.magnitude"  
 -- assign: "R.magnitude := L.magnitude * T.magnitude" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:6:on:0:superAdj:0"out R: var MeterPerSecond":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsVa ... 
 -- $var:getAdr: "out R: var MeterPerSecond" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- DI:OG: MeterPerSecond 
 -- before:floatTest:  "out R: var MeterPerSecond" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := L.magnitude * T.magnitude" right.label: "ObjectGenerator" "L.magnitude * T.magnitude" 
 -- $ObjectGenerator:gen: "L.magnitude * T.magnitude" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.magnitude * T.magnitude" 
 -- OG:before:super.gen: "L.magnitude * T.magnitude" 
 -- $Invocation:gen: "L.magnitude * T.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L.magnitude * T.magnitude" 
 -- isConstant: "Invocation" "L.magnitude * T.magnitude" 
 -- needorigin: "L.magnitude * T.magnitude" 
 -- needOrigin:E: "L.magnitude * T.magnitude"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "L.magnitude * T.magnitude" 
 -- computeAdr:superAdj: 0 "L.magnitude * T.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "L.magnitude * T.magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L.magnitude * T.magnitude"  
 -- $BinOp:loadOrigin: "L.magnitude * T.magnitude"  
 -- BinaryExp:loadOrigin:empty: "L.magnitude * T.magnitude" superAdj: 0 
 -- $BinOp:getAdr: "L.magnitude * T.magnitude"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L.magnitude * T.magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "L.magnitude * T.magnitude" E:  "L.magnitude * T.magnitude" 
 -- INV:gen:E.loadArgs "L.magnitude * T.magnitude" 
 -- $BinOp:loadArgs: "L.magnitude * T.magnitude"  
 -- BinaryExp:loadArgs: "L.magnitude * T.magnitude" superAdj: 0 
 -- $Invocation:gen: "L.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L.magnitude" 
 -- isConstant: "Invocation" "L.magnitude" 
 -- notConst: L in L: var Length.Meter 
 -- needorigin: "L.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:0:superAdj:0"in L: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "in L: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "in L: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "magnitude"  A.E: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"L" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "L"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "L" 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* T.magnitude":descNo:65} 
 -- ptn:loadArgs:E "* T.magnitude" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "T");     (Arguments));    (ObjectInvocation_U ...} 
 -- args: "T.magnitude" 
 -- E: "ObjectGenerator" T.magnitude 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* T.magnitude" "ObjectInvocation_Binary" ActArg:  "T.magnitude" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* T.magnitude" 
 -- $ObjectGenerator:gen: "T.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T.magnitude" 
 -- OG:before:super.gen: "T.magnitude" 
 -- $Invocation:gen: "T.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "T.magnitude" 
 -- isConstant: "Invocation" "T.magnitude" 
 -- notConst: T in T: var Time.Minutes 
 -- needorigin: "T.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "T.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:4:on:0:superAdj:0"in T: var Time.Minutes":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ... 
 -- $var:getAdr: "in T: var Time.Minutes" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ... 
 -- DI:OG: Time.Minutes 
 -- before:floatTest:  "in T: var Time.Minutes" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "magnitude"  A.E: "T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- rec:  "T" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"T" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"T":rec:T 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "T"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:T 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "T" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:T 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:T 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "T.magnitude" :isBasicVal: true 
 -- case:B: T.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "* T.magnitude" 
 -- BinaryExp:loadArgs:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- INV:gen:after:E.loadArgs "L.magnitude * T.magnitude" 
 -- OIadr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L.magnitude * T.magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec: ... 
 -- $BinOp:invoke: "L.magnitude * T.magnitude"  
 -- BinaryExp:invoke: "L.magnitude" rec: "L.magnitude * T.magnitude" 
 -- M: "* T.magnitude" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L 
 -- $ObjectInvocation_Binary:invoke: "* T.magnitude" >rec:"L.magnitude" ATd:"pattern" E:"* T.magnitude" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* T.magnitude" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L.magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:L.magnitude 
 -- OI:invoke:B: "* T.magnitude" E: "* T.magnitude"  rec: "L.magnitude"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* T.magnitude" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* T.magnitude" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L.magnitude" E: "* T.magnitude" 
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* T.magnitude":rec:L.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* T.magnitude":rec:L.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * T.magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "L.magnitude * T.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := L.magnitude * T.magnitude" arg: "L.magnitude * T.magnitude" ObjectGenerator 
 -- arg.super.arg: "L.magnitude * T.magnitude" BinOp 
 -- recx:BinaryExp:recx: "L.magnitude * T.magnitude" 
 -- M: "* T.magnitude" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "L.magnitude" E: "* T.magnitude" 
 -- arg:other 
 -- M:arg: "T.magnitude" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "mult" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 162 
 -- Items:GenClass: min descNo: 162 isValue: false 
 -- Items:GenClass: min descNo: 21 isValue: false 

 CLASS min 162 1 Unit 40
 -- Store itemArgs: in V: var thisUnit{out R: var thisUnit;if (magnitude < V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude} 
 -- in V: var thisUnit true 0 
 -- DI:store: "V" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: V off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  V 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=162 vDescInx=162 vdtTop: 1 
 mvStack 
 -- $var:gen: "in V: var thisUnit"  
 -- DI:gen: "in V: var thisUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  V 
 -- inArg: in V: var thisUnit 
 -- $var:gen: "out R: var thisUnit"  
 -- DI:gen: "out R: var thisUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- $ObjectGenerator:gen: "thisUnit" >OGid:"Unit" IS.isempty! staticOff=6 descNo=0 superAdj=0 
 -- OG:gen: "thisUnit" 
 -- OG:before:super.gen: "thisUnit" 
 -- $Invocation:gen: "thisUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "thisUnit" 
 -- isConstant: "Invocation" "thisUnit" 
 -- needorigin: "thisUnit" 
 -- needOrigin:E: "thisUnit"  E.ATd: "thisUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "thisUnit" E:  "thisUnit" 
 -- INV:gen:E.loadArgs "thisUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "thisUnit" >staticOff:0 "thisUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "thisUnit:< Unit" >E:"thisUnit":descNo:0 
 -- ptn:loadArgs:E "thisUnit" 
 -- {(ObjectInvocation_Unary; (name: "thisUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "thisUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "thisUnit" 
 -- $ObjectInvocation_Unary:invoke: "thisUnit" >rec:"thisUnit" ATd:"pattern" isValueObj E:"thisUnit" E.ATd:"thisUnit" unique:"False" 
 -- OI:invoke: "thisUnit" 
 -- 
 -- origin:isValueObj "Unit" 
 -- OI:invoke:B: "thisUnit" E: "thisUnit"  rec: "thisUnit"  useRtnV: false "thisUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern thisUnit 
 -- $pattern:invoke: "thisUnit:< Unit" E: "thisUnit" useRTNv: "False" 
 -- ptn:invoke: "thisUnit" E: "thisUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 6 adr:none 
 -- isStatic: true rec: "thisUnit" 
 invokeVal  thisUnit 40 5
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: thisUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $ObjectGenerator:gen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" >OGid:"if:then$0" IS.isempty! staticOff=0 desc ...} 
 -- OG:gen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:before:super.gen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $Invocation:gen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- isConstant: "Invocation" "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- needorigin: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- needOrigin:E: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}"  E.ATd: "if(cond: var boolean):then{thenPart:< object ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" E:  "if (magnitude < V.magnitude) :then {   R.magnitude := ma ...}" 
 -- INV:gen:E.loadArgs "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $IfThenElse:loadArgs: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" } 
 -- INV:gen:after:E.loadArgs "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $IfThenElse:invoke: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" } 
 -- $IfThenElse:gen: "if (magnitude < V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" } 
 -- $ObjectGenerator:gen: "(magnitude < V.magnitude)" >OGid:"<" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(magnitude < V.magnitude)" 
 -- OG:before:super.gen: "(magnitude < V.magnitude)" 
 -- $Invocation:gen: "(magnitude < V.magnitude)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(magnitude < V.magnitude)" 
 -- isConstant: "Invocation" "(magnitude < V.magnitude)" 
 -- needorigin: "(magnitude < V.magnitude)" 
 -- needOrigin:E: "(magnitude < V.magnitude)"  E.ATd: "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(magnitude < V.magnitude)" 
 -- computeAdr:superAdj: 0 "(magnitude < V.magnitude)" 
 -- computeAdr: 1 :rec: "none"  E: "(magnitude < V.magnitude)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(magnitude < V.magnitude)"  
 -- $BracketedExp:loadOrigin: "(magnitude < V.magnitude)"  
 -- computeAdr:superAdj: 0 "magnitude < V.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude < V.magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "magnitude < V.magnitude"  
 -- $BinOp:loadOrigin: "magnitude < V.magnitude"  
 -- BinaryExp:loadOrigin:empty: "magnitude < V.magnitude" superAdj: 0 
 -- $BinOp:getAdr: "magnitude < V.magnitude"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude < V.magnitude"  ATd: "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude < V.magnitude" 
 -- BE:loadOrigin:E: magnitude < V.magnitude 
 -- $BinOp:getAdr: "magnitude < V.magnitude"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude < V.magnitude"  ATd: "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude < V.magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "magnitude < V.magnitude" E:  "magnitude < V.magnitude" 
 -- INV:gen:E.loadArgs "magnitude < V.magnitude" 
 -- $BinOp:loadArgs: "magnitude < V.magnitude"  
 -- BinaryExp:loadArgs: "magnitude < V.magnitude" superAdj: 0 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "min" on: 1 isValueObj: false 
 -- origin: Unit origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg min$162 1
 rswap 0
 rdouble 0
 pushg 2 min$162
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushg 3 min$162
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $pattern:loadArgs: "<  : {   %basic 123;   in V: var float;   out B: var boolean" >E:"< V.magnitude":descNo:163} 
 -- ptn:loadArgs:E "< V.magnitude" 
 -- {(ObjectInvocation_Binary; (name: "<"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "V");     (Arguments));    (ObjectInvocation_U ...} 
 -- args: "V.magnitude" 
 -- E: "ObjectGenerator" V.magnitude 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "< V.magnitude" "ObjectInvocation_Binary" ActArg:  "V.magnitude" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "< V.magnitude"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "V.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V.magnitude" 
 -- OG:before:super.gen: "V.magnitude" 
 -- $Invocation:gen: "V.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V.magnitude" 
 -- isConstant: "Invocation" "V.magnitude" 
 -- notConst: V in V: var thisUnit 
 -- needorigin: "V.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:0:superAdj:0"in V: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "in V: var thisUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "in V: var thisUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr: 2 :rec: "V"  E: "magnitude"  A.E: "V" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"V" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "V"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "V" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "V.magnitude" :isBasicVal: true 
 -- case:B: V.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "< V.magnitude" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:after:E.loadArgs "magnitude < V.magnitude" 
 -- OIadr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- IV:E.invoke:useRtnVal: true E: BinOp "magnitude < V.magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:ma ... 
 -- $BinOp:invoke: "magnitude < V.magnitude"  
 -- BinaryExp:invoke: "magnitude" rec: "magnitude < V.magnitude" 
 -- M: "< V.magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $ObjectInvocation_Binary:invoke: "< V.magnitude" >rec:"magnitude" ATd:"pattern" E:"< V.magnitude" E.ATd:"<  " unique:"False" 
 -- OI:invoke: "< V.magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "< V.magnitude" E: "< V.magnitude"  rec: "magnitude"  useRtnV: true "<  : {   %basic 123;   in V: var float;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern <   
 -- $pattern:invoke: "<  : {   %basic 123;   in V: var float;   out B: var boolean" E: "< V.magnitude" useRTNv: "True"} 
 -- ptn:invoke: "<  " E: "< V.magnitude" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "magnitude" E: "< V.magnitude" 
 -- arg:other 
 flt
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"< V.magnitude":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"< V.magnitude":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: < V.magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L6
 L5:
 -- $ObjectGenerator:gen: "R.magnitude := magnitude" >OGid:"$164" singular! staticOff=0 descNo=164 superAdj=0 
 -- OG:gen: "R.magnitude := magnitude" 
 pushThis 
 -- before objTmpStack:add:  164   "$164" 
 invoke $164 164 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L7
 L6:
 -- $ObjectGenerator:gen: "R.magnitude := V.magnitude" >OGid:"$165" singular! staticOff=0 descNo=165 superAdj=0 
 -- OG:gen: "R.magnitude := V.magnitude" 
 pushThis 
 -- before objTmpStack:add:  165   "$165" 
 invoke $165 165 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "min" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 164 
 -- Items:GenClass: $164 descNo: 164 isValue: false 
 -- Items:GenClass: $164 descNo: 21 isValue: false 

 CLASS $164 164 1 min 162
 -- Store itemArgs: R.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=164 vDescInx=164 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "R.magnitude := magnitude" 
 -- $Assign:gen: "R.magnitude := magnitude"  
 -- assign: "R.magnitude := magnitude" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$164" on: 1 isValueObj: false 
 -- origin: min origin:isValueObj: false 
 rpushg $164$164 1
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:6:on:1:superAdj:0"out R: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "out R: var thisUnit" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "out R: var thisUnit" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "R"  ATd: "out R: var thisUnit" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := magnitude" right.label: "ObjectGenerator" "magnitude" 
 -- $ObjectGenerator:gen: "magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "magnitude" 
 -- OG:before:super.gen: "magnitude" 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$164" on: 2 isValueObj: false 
 -- origin: min origin:isValueObj: false 
 rpushg $164$164 1
 -- items:goOrigin:encOG: "min" on: 1 isValueObj: false 
 -- origin: Unit origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg min$162 1
 rswap 0
 rdouble 0
 pushg 2 min$162
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 pushg 3 min$162
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:2:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 2 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "magnitude" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := magnitude" arg: "magnitude" ObjectGenerator 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 165 
 -- Items:GenClass: $165 descNo: 165 isValue: false 
 -- Items:GenClass: $165 descNo: 21 isValue: false 

 CLASS $165 165 1 min 162
 -- Store itemArgs: R.magnitude := V.magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=165 vDescInx=165 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "R.magnitude := V.magnitude" 
 -- $Assign:gen: "R.magnitude := V.magnitude"  
 -- assign: "R.magnitude := V.magnitude" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$165" on: 1 isValueObj: false 
 -- origin: min origin:isValueObj: false 
 rpushg $165$165 1
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:6:on:1:superAdj:0"out R: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "out R: var thisUnit" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "out R: var thisUnit" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "R"  ATd: "out R: var thisUnit" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := V.magnitude" right.label: "ObjectGenerator" "V.magnitude" 
 -- $ObjectGenerator:gen: "V.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V.magnitude" 
 -- OG:before:super.gen: "V.magnitude" 
 -- $Invocation:gen: "V.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V.magnitude" 
 -- isConstant: "Invocation" "V.magnitude" 
 -- notConst: V in V: var thisUnit 
 -- needorigin: "V.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$165" on: 1 isValueObj: false 
 -- origin: min origin:isValueObj: false 
 rpushg $165$165 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"in V: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "in V: var thisUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "in V: var thisUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var thisUnit" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr: 2 :rec: "V"  E: "magnitude"  A.E: "V" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"V" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "V"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "V" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "V.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := V.magnitude" arg: "V.magnitude" ObjectGenerator 
 -- arg.super.arg: "V" ObjectInvocation_Unary 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- recx: "V" argx: "magnitude" 
 -- checkInt2IntWithUnitArg:rec: "V" E: "magnitude" 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 166 
 -- Items:GenClass: max descNo: 166 isValue: false 
 -- Items:GenClass: max descNo: 21 isValue: false 

 CLASS max 166 1 Unit 40
 -- Store itemArgs: in V: var thisUnit{out R: var thisUnit;if (magnitude > V.magnitude) :then ;   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude} 
 -- in V: var thisUnit true 0 
 -- DI:store: "V" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: V off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  V 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=166 vDescInx=166 vdtTop: 1 
 mvStack 
 -- $var:gen: "in V: var thisUnit"  
 -- DI:gen: "in V: var thisUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  V 
 -- inArg: in V: var thisUnit 
 -- $var:gen: "out R: var thisUnit"  
 -- DI:gen: "out R: var thisUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- $ObjectGenerator:gen: "thisUnit" >OGid:"Unit" IS.isempty! staticOff=6 descNo=0 superAdj=0 
 -- OG:gen: "thisUnit" 
 -- OG:before:super.gen: "thisUnit" 
 -- $Invocation:gen: "thisUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "thisUnit" 
 -- isConstant: "Invocation" "thisUnit" 
 -- needorigin: "thisUnit" 
 -- needOrigin:E: "thisUnit"  E.ATd: "thisUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "thisUnit" E:  "thisUnit" 
 -- INV:gen:E.loadArgs "thisUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "thisUnit" >staticOff:0 "thisUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "thisUnit:< Unit" >E:"thisUnit":descNo:0 
 -- ptn:loadArgs:E "thisUnit" 
 -- {(ObjectInvocation_Unary; (name: "thisUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "thisUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "thisUnit" 
 -- $ObjectInvocation_Unary:invoke: "thisUnit" >rec:"thisUnit" ATd:"pattern" isValueObj E:"thisUnit" E.ATd:"thisUnit" unique:"False" 
 -- OI:invoke: "thisUnit" 
 -- 
 -- origin:isValueObj "Unit" 
 -- OI:invoke:B: "thisUnit" E: "thisUnit"  rec: "thisUnit"  useRtnV: false "thisUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern thisUnit 
 -- $pattern:invoke: "thisUnit:< Unit" E: "thisUnit" useRTNv: "False" 
 -- ptn:invoke: "thisUnit" E: "thisUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 6 adr:none 
 -- isStatic: true rec: "thisUnit" 
 invokeVal  thisUnit 40 5
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: thisUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $ObjectGenerator:gen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" >OGid:"if:then$0" IS.isempty! staticOff=0 desc ...} 
 -- OG:gen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OG:before:super.gen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $Invocation:gen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" >useRtnV:"False"superAdj: 0} 
 -- INV:gen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- isConstant: "Invocation" "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- needorigin: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- needOrigin:E: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}"  E.ATd: "if(cond: var boolean):then{thenPart:< object ..." 
 -- Ex:loadOrign:no:loadOrigin:  "%OSDvisibility skipInternal{   %basic 100;   %globals inSub}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" E:  "if (magnitude > V.magnitude) :then {   R.magnitude := ma ...}" 
 -- INV:gen:E.loadArgs "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $IfThenElse:loadArgs: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" } 
 -- INV:gen:after:E.loadArgs "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: IfThenElse "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude}" 
 -- $IfThenElse:invoke: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" } 
 -- $IfThenElse:gen: "if (magnitude > V.magnitude) :then {   R.magnitude := magnitude;:else ;   R.magnitude := V.magnitude" } 
 -- $ObjectGenerator:gen: "(magnitude > V.magnitude)" >OGid:">" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(magnitude > V.magnitude)" 
 -- OG:before:super.gen: "(magnitude > V.magnitude)" 
 -- $Invocation:gen: "(magnitude > V.magnitude)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(magnitude > V.magnitude)" 
 -- isConstant: "Invocation" "(magnitude > V.magnitude)" 
 -- needorigin: "(magnitude > V.magnitude)" 
 -- needOrigin:E: "(magnitude > V.magnitude)"  E.ATd: ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- doNeedOrigin:Ex: "(magnitude > V.magnitude)" 
 -- computeAdr:superAdj: 0 "(magnitude > V.magnitude)" 
 -- computeAdr: 1 :rec: "none"  E: "(magnitude > V.magnitude)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(magnitude > V.magnitude)"  
 -- $BracketedExp:loadOrigin: "(magnitude > V.magnitude)"  
 -- computeAdr:superAdj: 0 "magnitude > V.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude > V.magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "magnitude > V.magnitude"  
 -- $BinOp:loadOrigin: "magnitude > V.magnitude"  
 -- BinaryExp:loadOrigin:empty: "magnitude > V.magnitude" superAdj: 0 
 -- $BinOp:getAdr: "magnitude > V.magnitude"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude > V.magnitude"  ATd: ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude > V.magnitude" 
 -- BE:loadOrigin:E: magnitude > V.magnitude 
 -- $BinOp:getAdr: "magnitude > V.magnitude"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude > V.magnitude"  ATd: ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude > V.magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "magnitude > V.magnitude" E:  "magnitude > V.magnitude" 
 -- INV:gen:E.loadArgs "magnitude > V.magnitude" 
 -- $BinOp:loadArgs: "magnitude > V.magnitude"  
 -- BinaryExp:loadArgs: "magnitude > V.magnitude" superAdj: 0 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "max" on: 1 isValueObj: false 
 -- origin: Unit origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg max$166 1
 rswap 0
 rdouble 0
 pushg 2 max$166
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushg 3 max$166
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $pattern:loadArgs: ">  : {   %basic 125;   in V: var float;   out B: var boolean" >E:"> V.magnitude":descNo:167} 
 -- ptn:loadArgs:E "> V.magnitude" 
 -- {(ObjectInvocation_Binary; (name: ">"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "V");     (Arguments));    (ObjectInvocation_U ...} 
 -- args: "V.magnitude" 
 -- E: "ObjectGenerator" V.magnitude 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "> V.magnitude" "ObjectInvocation_Binary" ActArg:  "V.magnitude" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "> V.magnitude"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "V.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V.magnitude" 
 -- OG:before:super.gen: "V.magnitude" 
 -- $Invocation:gen: "V.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V.magnitude" 
 -- isConstant: "Invocation" "V.magnitude" 
 -- notConst: V in V: var thisUnit 
 -- needorigin: "V.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:0:superAdj:0"in V: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "in V: var thisUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "in V: var thisUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr: 2 :rec: "V"  E: "magnitude"  A.E: "V" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"V" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "V"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "V" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "V.magnitude" :isBasicVal: true 
 -- case:B: V.magnitude ObjectGenerator 9 0 9 false false 
 -- end:loadArgs:NonVirt: "> V.magnitude" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:after:E.loadArgs "magnitude > V.magnitude" 
 -- OIadr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- IV:E.invoke:useRtnVal: true E: BinOp "magnitude > V.magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:ma ... 
 -- $BinOp:invoke: "magnitude > V.magnitude"  
 -- BinaryExp:invoke: "magnitude" rec: "magnitude > V.magnitude" 
 -- M: "> V.magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $ObjectInvocation_Binary:invoke: "> V.magnitude" >rec:"magnitude" ATd:"pattern" E:"> V.magnitude" E.ATd:">  " unique:"False" 
 -- OI:invoke: "> V.magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "> V.magnitude" E: "> V.magnitude"  rec: "magnitude"  useRtnV: true ">  : {   %basic 125;   in V: var float;   out B: var boolean}" 
 -- OI:invoke:before:ATdx.invoke: pattern >   
 -- $pattern:invoke: ">  : {   %basic 125;   in V: var float;   out B: var boolean" E: "> V.magnitude" useRTNv: "True"} 
 -- ptn:invoke: ">  " E: "> V.magnitude" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "magnitude" E: "> V.magnitude" 
 -- arg:other 
 fgt
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"> V.magnitude":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"> V.magnitude":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: > V.magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 jmpFalse  L6
 L5:
 -- $ObjectGenerator:gen: "R.magnitude := magnitude" >OGid:"$168" singular! staticOff=0 descNo=168 superAdj=0 
 -- OG:gen: "R.magnitude := magnitude" 
 pushThis 
 -- before objTmpStack:add:  168   "$168" 
 invoke $168 168 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 jmp L7
 L6:
 -- $ObjectGenerator:gen: "R.magnitude := V.magnitude" >OGid:"$169" singular! staticOff=0 descNo=169 superAdj=0 
 -- OG:gen: "R.magnitude := V.magnitude" 
 pushThis 
 -- before objTmpStack:add:  169   "$169" 
 invoke $169 169 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L7:
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "max" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:7 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 168 
 -- Items:GenClass: $168 descNo: 168 isValue: false 
 -- Items:GenClass: $168 descNo: 21 isValue: false 

 CLASS $168 168 1 max 166
 -- Store itemArgs: R.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=168 vDescInx=168 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "R.magnitude := magnitude" 
 -- $Assign:gen: "R.magnitude := magnitude"  
 -- assign: "R.magnitude := magnitude" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$168" on: 1 isValueObj: false 
 -- origin: max origin:isValueObj: false 
 rpushg $168$168 1
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:6:on:1:superAdj:0"out R: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "out R: var thisUnit" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "out R: var thisUnit" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "R"  ATd: "out R: var thisUnit" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := magnitude" right.label: "ObjectGenerator" "magnitude" 
 -- $ObjectGenerator:gen: "magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "magnitude" 
 -- OG:before:super.gen: "magnitude" 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$168" on: 2 isValueObj: false 
 -- origin: max origin:isValueObj: false 
 rpushg $168$168 1
 -- items:goOrigin:encOG: "max" on: 1 isValueObj: false 
 -- origin: Unit origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg max$166 1
 rswap 0
 rdouble 0
 pushg 2 max$166
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 pushg 3 max$166
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:2:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 2 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "magnitude" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := magnitude" arg: "magnitude" ObjectGenerator 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: 1 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 169 
 -- Items:GenClass: $169 descNo: 169 isValue: false 
 -- Items:GenClass: $169 descNo: 21 isValue: false 

 CLASS $169 169 1 max 166
 -- Store itemArgs: R.magnitude := V.magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=169 vDescInx=169 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "R.magnitude := V.magnitude" 
 -- $Assign:gen: "R.magnitude := V.magnitude"  
 -- assign: "R.magnitude := V.magnitude" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 1 isValueObj: false 
 -- origin: max origin:isValueObj: false 
 rpushg $169$169 1
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:6:on:1:superAdj:0"out R: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "out R: var thisUnit" >newOff:6,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "out R: var thisUnit" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "R"  ATd: "out R: var thisUnit" 
 -- computeAdr:isFirst: :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:6 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:6 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := V.magnitude" right.label: "ObjectGenerator" "V.magnitude" 
 -- $ObjectGenerator:gen: "V.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V.magnitude" 
 -- OG:before:super.gen: "V.magnitude" 
 -- $Invocation:gen: "V.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V.magnitude" 
 -- isConstant: "Invocation" "V.magnitude" 
 -- notConst: V in V: var thisUnit 
 -- needorigin: "V.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "$169" on: 1 isValueObj: false 
 -- origin: max origin:isValueObj: false 
 rpushg $169$169 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:4:on:1:superAdj:0"in V: var thisUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "in V: var thisUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: thisUnit 
 -- before:floatTest:  "in V: var thisUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "in V: var thisUnit" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr: 2 :rec: "V"  E: "magnitude"  A.E: "V" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"V" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "V"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "V" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:V 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "V.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := V.magnitude" arg: "V.magnitude" ObjectGenerator 
 -- arg.super.arg: "V" ObjectInvocation_Unary 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- recx: "V" argx: "magnitude" 
 -- checkInt2IntWithUnitArg:rec: "V" E: "magnitude" 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:6 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 6 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 143 
 -- Items:GenClass: temperatureEx descNo: 143 isValue: false 
 -- Items:GenClass: temperatureEx descNo: 21 isValue: false 

 CLASS temperatureEx 143 1 UnitEx 129
 -- Store itemArgs: C: var Temperature.Celsius{F: var Temperature.Fahrenheit;C := Temperature.FasCelsius(100.0);C.print;newline;F.fromPrimary(C.toPrimary);F.print;newline;C.fr ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=143 vDescInx=143 vdtTop: 1 
 mvStack 
 -- $var:gen: "C: var Temperature.Celsius"  
 -- DI:gen: "C: var Temperature.Celsius" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  C 
 -- $ObjectGenerator:gen: "Temperature.Celsius" >OGid:"Celsius" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Temperature.Celsius" 
 -- OG:before:super.gen: "Temperature.Celsius" 
 -- $Invocation:gen: "Temperature.Celsius" >useRtnV:"False"superAdj: 0 descNo: 144 
 -- INV:gen: "Temperature.Celsius" 
 -- isConstant: "Invocation" "Temperature.Celsius" 
 -- needorigin: "Temperature.Celsius" 
 -- needOrigin:E: "Celsius"  E.ATd: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Temperature" E:  "Celsius" 
 -- INV:gen:E.loadArgs "Celsius" 
 -- $ObjectInvocation_Unary:loadArgs: "Celsius" >staticOff:0 "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ..."} 
 -- $pattern:loadArgs: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ..."} 
 -- ptn:loadArgs:E "Celsius" 
 -- {(ObjectInvocation_Unary; (name: "Celsius"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Celsius" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Celsius" 
 -- $ObjectInvocation_Unary:invoke: "Celsius" >rec:"Temperature" ATd:"pattern" isValueObj E:"Celsius" E.ATd:"Celsius" unique:"False" 
 -- OI:invoke: "Celsius" 
 -- 
 -- OI:invoke:B: "Celsius" E: "Celsius"  rec: "Temperature"  useRtnV: false "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;  ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Celsius 
 -- $pattern:invoke: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   p ..."} 
 -- ptn:invoke: "Celsius" E: "Celsius" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  Celsius 144 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Celsius :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "F: var Temperature.Fahrenheit"  
 -- DI:gen: "F: var Temperature.Fahrenheit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  F 
 -- $ObjectGenerator:gen: "Temperature.Fahrenheit" >OGid:"Fahrenheit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Temperature.Fahrenheit" 
 -- OG:before:super.gen: "Temperature.Fahrenheit" 
 -- $Invocation:gen: "Temperature.Fahrenheit" >useRtnV:"False"superAdj: 0 descNo: 146 
 -- INV:gen: "Temperature.Fahrenheit" 
 -- isConstant: "Invocation" "Temperature.Fahrenheit" 
 -- needorigin: "Temperature.Fahrenheit" 
 -- needOrigin:E: "Fahrenheit"  E.ATd: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPr ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      mag ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Temperature" E:  "Fahrenheit" 
 -- INV:gen:E.loadArgs "Fahrenheit" 
 -- $ObjectInvocation_Unary:loadArgs: "Fahrenheit" >staticOff:0 "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0 ..."} 
 -- $pattern:loadArgs: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      m ..."} 
 -- ptn:loadArgs:E "Fahrenheit" 
 -- {(ObjectInvocation_Unary; (name: "Fahrenheit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Fahrenheit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Fahrenheit" 
 -- $ObjectInvocation_Unary:invoke: "Fahrenheit" >rec:"Temperature" ATd:"pattern" isValueObj E:"Fahrenheit" E.ATd:"Fahrenheit" unique:"False" 
 -- OI:invoke: "Fahrenheit" 
 -- 
 -- OI:invoke:B: "Fahrenheit" E: "Fahrenheit"  rec: "Temperature"  useRtnV: false "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Fahrenheit 
 -- $pattern:invoke: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      mag ..."} 
 -- ptn:invoke: "Fahrenheit" E: "Fahrenheit" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 adr:none 
 invokeVal  Fahrenheit 146 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Fahrenheit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "C := Temperature.FasCelsius(100.0)" 
 -- $Assign:gen: "C := Temperature.FasCelsius(100.0)"  
 -- assign: "C := Temperature.FasCelsius(100.0)" 
 -- computeAdr:superAdj: 0 "C" 
 -- computeAdr: 1 :rec: "none"  E: "C" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "C" >ATd.off:2:on:0:superAdj:0"C: var Temperature.Celsius":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "C: var Temperature.Celsius" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- DI:OG: Temperature.Celsius 
 -- before:floatTest:  "C: var Temperature.Celsius" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- computeAdr:isLast:E:  "C" 
 -- AssignmentStatement:gen: "C := Temperature.FasCelsius(100.0)" right.label: "ObjectGenerator" "Temperature.FasCelsius(100.0)" 
 -- $ObjectGenerator:gen: "Temperature.FasCelsius(100.0)" >OGid:"FasCelsius" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Temperature.FasCelsius(100.0)" 
 -- OG:before:super.gen: "Temperature.FasCelsius(100.0)" 
 -- $Invocation:gen: "Temperature.FasCelsius(100.0)" >useRtnV:"True"superAdj: 0 descNo: 148 
 -- INV:gen: "Temperature.FasCelsius(100.0)" 
 -- isConstant: "Invocation" "Temperature.FasCelsius(100.0)" 
 -- needorigin: "Temperature.FasCelsius(100.0)" 
 -- needOrigin:E: "FasCelsius(100.0)"  E.ATd: "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V}" 
 -- doNeedOrigin:Ex: "FasCelsius(100.0)" 
 -- computeAdr:superAdj: 0 "Temperature.FasCelsius(100.0)" 
 -- computeAdr: 1 :rec: "none"  E: "Temperature" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Temperature"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Temperature" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "temperatureEx" on: 1 isValueObj: false 
 -- origin: UnitEx origin:isValueObj: false 
 rpushg temperatureEx$143 1
 -- IV:viaIncl:on: 1 "Dimensions"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.Squar ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: true "Dimensions" 
 -- IV:viaIncl:on: 0 "LIB"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter; ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "LIB" 
 -- items:goOrigin:encOG: "UnitEx" on: 3 isValueObj: false 
 -- origin: demo origin:isValueObj: false 
 rpushg UnitEx$129 1
 -- items:goOrigin:encOG: "demo" on: 2 isValueObj: false 
 -- origin: workspace origin:isValueObj: false 
 rpushg demo$128 1
 -- items:goOrigin:encOG: "workspace" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- $ObjectInvocation_Unary:getAdr: "Temperature" >ATd.off:0 (isPtn):on:1:superAdj:0"--Temperature{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ...} 
 -- $ModuleItem:getAdr: "--Temperature{" } 
 -- $obj:getAdr: "Temperature: obj Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      f ..."} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Temperature"  ATd: "--Temperature{}" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Temperature"  E: "FasCelsius(100.0)" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "FasCelsius(100.0)" >ATd.off:0 (isPtn):on:0:superAdj:0"FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V":Adr:off ...} 
 -- $pattern:getAdr: "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Temperature" >staticOff:0 "--Temperature{" superAdj:0} 
 -- $ModuleItem:loadArgs: "--Temperature{" } 
 -- $ObjectInvocation_Unary:invoke: "Temperature" >rec:"Temperature" ATd:"ModuleItem" E:"FasCelsius(100.0)" E.ATd:"FasCelsius" unique:"False" 
 -- OI:invoke: "Temperature" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- OI:invoke:B: "Temperature" E: "FasCelsius(100.0)"  rec: "Temperature"  useRtnV: true "--Temperature{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem Temperature 
 -- $ModuleItem:invoke: "--Temperature{" E: "FasCelsius(100.0)" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "Temperature: obj Dimension{   %Public;   Celsius: Unit;      %Public;      thisUnit:: Celsius;      toPrimary:: ;         base.magnitude := magnitude;      f ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg Temperature 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- 
 -- OI:invoke:C: Temperature :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Temperature" E: "FasCelsius(100.0)" 
 -- arg:float 
 -- computeAdr:isLast:E:  "FasCelsius(100.0)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- rec:  "Temperature" E:  "FasCelsius(100.0)" 
 -- INV:gen:E.loadArgs "FasCelsius(100.0)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "FasCelsius(100.0)" >staticOff:0 "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V" superAdj:0arg:"100.0"} 
 -- $pattern:loadArgs: "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V" >E:"FasCelsius(100.0)":descNo:148} 
 -- ptn:loadArgs:E "FasCelsius(100.0)" 
 -- {(ObjectInvocation_KeyWord; (name: "FasCelsius"); (Arguments;  (name: "FasCelsius");  (name: "(");  (ObjectGenerator;   (Invocation;    (FloatLiteral 100.0));   (Items des ...} 
 -- args: "FasCelsius(100.0)" 
 -- E: "ObjectGenerator" 100.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "FasCelsius(100.0)" "ObjectInvocation_KeyWord" ActArg:  "100.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "FasCelsius(100.0)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "100.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "100.0" 
 -- OG:before:super.gen: "100.0" 
 -- $Invocation:gen: "100.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "100.0" 
 -- isConstant: "Invocation" "100.0" 
 -- needorigin: "100.0" 
 -- needOrigin:E: "100.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: v ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "100.0" E:  "100.0" 
 -- INV:gen:E.loadArgs "100.0" 
 -- $FloatLiteral:loadArgs: "100.0"  
 -- INV:gen:after:E.loadArgs "100.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "100.0" 
 -- $FloatLiteral:invoke: "100.0"  
 pushFloatConst 100.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "100.0" :isBasicVal: true 
 -- case:B: 100.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "FasCelsius(100.0)" 
 -- INV:gen:after:E.loadArgs "FasCelsius(100.0)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "FasCelsius(100.0)" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasC ..." 
 -- $ObjectInvocation_KeyWord:invoke: "FasCelsius(100.0)" >rec:"Temperature" ATd:"pattern" E:"FasCelsius(100.0)" E.ATd:"FasCelsius" unique:"False" 
 -- OI:invoke: "FasCelsius(100.0)" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- OI:invoke:B: "FasCelsius(100.0)" E: "FasCelsius(100.0)"  rec: "Temperature"  useRtnV: true "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V}" 
 -- OI:invoke:before:ATdx.invoke: pattern FasCelsius 
 -- $pattern:invoke: "FasCelsius: {   in V: var float;   out R: var Celsius;   R.magnitude := V" E: "FasCelsius(100.0)" useRTNv: "True"} 
 -- ptn:invoke: "FasCelsius" E: "FasCelsius(100.0)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 invoke FasCelsius 148 0 0
 -- global:pushOut: R off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- OI:invoke:C: FasCelsius(100.0) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"FasCelsius(100.0)":rec:Temperature 
 -- rec: "C" dstE: "C" dstE.ATd: "C: var Temperature.Celsius" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- ... 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" Temperature.FasCelsius(100.0) 
 -- pushValue: A: off: 4 size: 5 descNo: -1 Temperature.FasCelsius(100.0) 
 pushvalue  off:4 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:2 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "C" off: 2 size: 2 mode: 0 
 vassign  2 2 0
 -- assign:adr.store:B: 
 -- genclass:stmt: "C.print" 
 -- $ObjectGenerator:gen: "C.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C.print" 
 -- OG:before:super.gen: "C.print" 
 -- $Invocation:gen: "C.print" >useRtnV:"False"superAdj: 0 descNo: 149 
 -- INV:gen: "C.print" 
 -- isConstant: "Invocation" "C.print" 
 -- notConst: C C: var Temperature.Celsius 
 -- needorigin: "C.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Celsius".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Celsius" 
 -- computeAdr:superAdj: 0 "C.print" 
 -- computeAdr: 1 :rec: "none"  E: "C" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "C" >ATd.off:2:on:0:superAdj:0"C: var Temperature.Celsius":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "C: var Temperature.Celsius" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- DI:OG: Temperature.Celsius 
 -- before:floatTest:  "C: var Temperature.Celsius" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- computeAdr: 2 :rec: "C"  E: "print"  A.E: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Celsius".print":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ...} 
 -- $pattern:getAdr: "print:: {   "Celsius".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C" >staticOff:0 "C: var Temperature.Celsius" superAdj:0 
 -- $var:loadArgs: "C: var Temperature.Celsius" >E:"C" 
 -- $pattern:loadArgs: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ..."} 
 -- ptn:loadArgs:E "C" 
 -- {(ObjectInvocation_Unary; (name: "C"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C" >rec:"C" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- OI:invoke:B: "C" E: "print"  rec: "C"  useRtnV: true "C: var Temperature.Celsius" 
 -- OI:invoke:before:ATdx.invoke: var C 
 -- $var:invoke: "C: var Temperature.Celsius" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "C: var Temperature.Celsius" 
 -- isValueObj:isAdr: true objSize: 2  rec "C" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 144
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- 
 -- OI:invoke:C: C :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- rec:  "C" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Celsius".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Celsius".print" >E:"print":descNo:149} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"C" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- origin:isValueObj "Celsius" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- OI:invoke:B: "print" E: "print"  rec: "C"  useRtnV: false "print:: {   "Celsius".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Celsius".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- isDI 
 -- isStatic: true rec: "C" 
 invoke print 149 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "F.fromPrimary(C.toPrimary)" 
 -- $ObjectGenerator:gen: "F.fromPrimary(C.toPrimary)" >OGid:"fromPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "F.fromPrimary(C.toPrimary)" 
 -- OG:before:super.gen: "F.fromPrimary(C.toPrimary)" 
 -- $Invocation:gen: "F.fromPrimary(C.toPrimary)" >useRtnV:"False"superAdj: 0 descNo: 151 
 -- INV:gen: "F.fromPrimary(C.toPrimary)" 
 -- isConstant: "Invocation" "F.fromPrimary(C.toPrimary)" 
 -- notConst: F F: var Temperature.Fahrenheit 
 -- needorigin: "F.fromPrimary(C.toPrimary)" 
 -- needOrigin:E: "fromPrimary(C.toPrimary)"  E.ATd: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0}" 
 -- doNeedOrigin:Ex: "fromPrimary(C.toPrimary)" 
 -- origin:isValueObj: "Fahrenheit" 
 -- computeAdr:superAdj: 0 "F.fromPrimary(C.toPrimary)" 
 -- computeAdr: 1 :rec: "none"  E: "F" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "F"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "F" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "F" >ATd.off:4:on:0:superAdj:0"F: var Temperature.Fahrenheit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $var:getAdr: "F: var Temperature.Fahrenheit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F ... 
 -- DI:OG: Temperature.Fahrenheit 
 -- before:floatTest:  "F: var Temperature.Fahrenheit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdr: 2 :rec: "F"  E: "fromPrimary(C.toPrimary)"  A.E: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "fromPrimary(C.toPrimary)" >ATd.off:0 (isPtn):on:0:superAdj:0"fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0":Adr:o ...} 
 -- $pattern:getAdr: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "F" >staticOff:0 "F: var Temperature.Fahrenheit" superAdj:0 
 -- $var:loadArgs: "F: var Temperature.Fahrenheit" >E:"F" 
 -- $pattern:loadArgs: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      m ..."} 
 -- ptn:loadArgs:E "F" 
 -- {(ObjectInvocation_Unary; (name: "F"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "F" >rec:"F" ATd:"var" isValueObj E:"fromPrimary(C.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F" E: "fromPrimary(C.toPrimary)"  rec: "F"  useRtnV: true "F: var Temperature.Fahrenheit" 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: "F: var Temperature.Fahrenheit" E: "fromPrimary(C.toPrimary)">newOff:4 useRTNv: "True" 
 -- DI:invoke: "F: var Temperature.Fahrenheit" 
 -- isValueObj:isAdr: true objSize: 2  rec "F" ,E: "fromPrimary(C.toPrimary)" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 146
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- 
 -- OI:invoke:C: F :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "F" E: "fromPrimary(C.toPrimary)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "fromPrimary(C.toPrimary)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- rec:  "F" E:  "fromPrimary(C.toPrimary)" 
 -- INV:gen:E.loadArgs "fromPrimary(C.toPrimary)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fromPrimary(C.toPrimary)" >staticOff:0 "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" superAdj:0arg:"C.toPrima ..."} 
 -- $pattern:loadArgs: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" >E:"fromPrimary(C.toPrimary)":descNo:151} 
 -- ptn:loadArgs:E "fromPrimary(C.toPrimary)" 
 -- {(ObjectInvocation_KeyWord; (name: "fromPrimary"); (Arguments;  (name: "fromPrimary");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (nam ...} 
 -- args: "fromPrimary(C.toPrimary)" 
 -- E: "ObjectGenerator" C.toPrimary 
 -- E.arg: "var" in base: var PrimaryUnit 
 -- NonVirt: "fromPrimary(C.toPrimary)" "ObjectInvocation_KeyWord" ActArg:  "C.toPrimary" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "fromPrimary(C.toPrimary)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "C.toPrimary" >OGid:"toPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C.toPrimary" 
 -- OG:before:super.gen: "C.toPrimary" 
 -- $Invocation:gen: "C.toPrimary" >useRtnV:"True"superAdj: 0 descNo: 150 
 -- INV:gen: "C.toPrimary" 
 -- isConstant: "Invocation" "C.toPrimary" 
 -- notConst: C C: var Temperature.Celsius 
 -- needorigin: "C.toPrimary" 
 -- needOrigin:E: "toPrimary"  E.ATd: "toPrimary:: {   base.magnitude := magnitude}" 
 -- doNeedOrigin:Ex: "toPrimary" 
 -- origin:isValueObj: "Celsius" 
 -- computeAdr:superAdj: 0 "C.toPrimary" 
 -- computeAdr: 1 :rec: "none"  E: "C" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "C" >ATd.off:2:on:0:superAdj:0"C: var Temperature.Celsius":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "C: var Temperature.Celsius" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- DI:OG: Temperature.Celsius 
 -- before:floatTest:  "C: var Temperature.Celsius" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- computeAdr: 2 :rec: "C"  E: "toPrimary"  A.E: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "toPrimary" >ATd.off:0 (isPtn):on:0:superAdj:0"toPrimary:: {   base.magnitude := magnitude":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj ...} 
 -- $pattern:getAdr: "toPrimary:: {   base.magnitude := magnitude" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C" >staticOff:0 "C: var Temperature.Celsius" superAdj:0 
 -- $var:loadArgs: "C: var Temperature.Celsius" >E:"C" 
 -- $pattern:loadArgs: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ..."} 
 -- ptn:loadArgs:E "C" 
 -- {(ObjectInvocation_Unary; (name: "C"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C" >rec:"C" ATd:"var" isValueObj E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- OI:invoke:B: "C" E: "toPrimary"  rec: "C"  useRtnV: true "C: var Temperature.Celsius" 
 -- OI:invoke:before:ATdx.invoke: var C 
 -- $var:invoke: "C: var Temperature.Celsius" E: "toPrimary">newOff:2 useRTNv: "True" 
 -- DI:invoke: "C: var Temperature.Celsius" 
 -- isValueObj:isAdr: true objSize: 2  rec "C" ,E: "toPrimary" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 144
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- 
 -- OI:invoke:C: C :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C" E: "toPrimary" 
 -- computeAdr:isLast:E:  "toPrimary" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- rec:  "C" E:  "toPrimary" 
 -- INV:gen:E.loadArgs "toPrimary" 
 -- $ObjectInvocation_Unary:loadArgs: "toPrimary" >staticOff:0 "toPrimary:: {   base.magnitude := magnitude" superAdj:0} 
 -- $pattern:loadArgs: "toPrimary:: {   base.magnitude := magnitude" >E:"toPrimary":descNo:150} 
 -- ptn:loadArgs:E "toPrimary" 
 -- {(ObjectInvocation_Unary; (name: "toPrimary"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "toPrimary" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "toPrimary" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec ... 
 -- $ObjectInvocation_Unary:invoke: "toPrimary" >rec:"C" ATd:"pattern" E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "toPrimary" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- origin:isValueObj "Celsius" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- OI:invoke:B: "toPrimary" E: "toPrimary"  rec: "C"  useRtnV: true "toPrimary:: {   base.magnitude := magnitude}" 
 -- OI:invoke:before:ATdx.invoke: pattern toPrimary 
 -- $pattern:invoke: "toPrimary:: {   base.magnitude := magnitude" E: "toPrimary" useRTNv: "True"} 
 -- ptn:invoke: "toPrimary" E: "toPrimary" ptnKind: 3 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- isDI 
 -- isStatic: true rec: "C" 
 invoke toPrimary 150 0 0
 -- global:pushOut: base off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke:X: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- OI:invoke:C: toPrimary :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:C 
 -- formalArg:isPtn: "in base: var PrimaryUnit" :isBasicVal: false :valueObj: true 
 -- :actArg: "C.toPrimary" :isBasicVal: false 
 -- case:B: C.toPrimary ObjectGenerator 0 0 0 true false 
 -- pushValue: D: off: 4 size: 2 0 in base: var PrimaryUnit 
 pushvalue  off:4 size:2 descNo: 0
 pushc 1
 -- end:loadArgs:NonVirt: "fromPrimary(C.toPrimary)" 
 -- INV:gen:after:E.loadArgs "fromPrimary(C.toPrimary)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fromPrimary(C.toPrimary)" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F ... 
 -- $ObjectInvocation_KeyWord:invoke: "fromPrimary(C.toPrimary)" >rec:"F" ATd:"pattern" E:"fromPrimary(C.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "fromPrimary(C.toPrimary)" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- origin:isValueObj "Fahrenheit" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- OI:invoke:B: "fromPrimary(C.toPrimary)" E: "fromPrimary(C.toPrimary)"  rec: "F"  useRtnV: false "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0}" 
 -- OI:invoke:before:ATdx.invoke: pattern fromPrimary 
 -- $pattern:invoke: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" E: "fromPrimary(C.toPrimary)" useRTNv: "False"} 
 -- ptn:invoke: "fromPrimary" E: "fromPrimary(C.toPrimary)" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- isDI 
 -- isStatic: true rec: "F" 
 invoke fromPrimary 151 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: fromPrimary(C.toPrimary) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(C.toPrimary)":rec:F 
 -- genclass:stmt: "F.print" 
 -- $ObjectGenerator:gen: "F.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "F.print" 
 -- OG:before:super.gen: "F.print" 
 -- $Invocation:gen: "F.print" >useRtnV:"False"superAdj: 0 descNo: 153 
 -- INV:gen: "F.print" 
 -- isConstant: "Invocation" "F.print" 
 -- notConst: F F: var Temperature.Fahrenheit 
 -- needorigin: "F.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Fahrenheit".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Fahrenheit" 
 -- computeAdr:superAdj: 0 "F.print" 
 -- computeAdr: 1 :rec: "none"  E: "F" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "F"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "F" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "F" >ATd.off:4:on:0:superAdj:0"F: var Temperature.Fahrenheit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $var:getAdr: "F: var Temperature.Fahrenheit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F ... 
 -- DI:OG: Temperature.Fahrenheit 
 -- before:floatTest:  "F: var Temperature.Fahrenheit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdr: 2 :rec: "F"  E: "print"  A.E: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Fahrenheit".print":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ...} 
 -- $pattern:getAdr: "print:: {   "Fahrenheit".print" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "F" >staticOff:0 "F: var Temperature.Fahrenheit" superAdj:0 
 -- $var:loadArgs: "F: var Temperature.Fahrenheit" >E:"F" 
 -- $pattern:loadArgs: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      m ..."} 
 -- ptn:loadArgs:E "F" 
 -- {(ObjectInvocation_Unary; (name: "F"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "F" >rec:"F" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F" E: "print"  rec: "F"  useRtnV: true "F: var Temperature.Fahrenheit" 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: "F: var Temperature.Fahrenheit" E: "print">newOff:4 useRTNv: "True" 
 -- DI:invoke: "F: var Temperature.Fahrenheit" 
 -- isValueObj:isAdr: true objSize: 2  rec "F" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 146
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- 
 -- OI:invoke:C: F :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "F" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- rec:  "F" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Fahrenheit".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Fahrenheit".print" >E:"print":descNo:153} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"F" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- origin:isValueObj "Fahrenheit" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- OI:invoke:B: "print" E: "print"  rec: "F"  useRtnV: false "print:: {   "Fahrenheit".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Fahrenheit".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- isDI 
 -- isStatic: true rec: "F" 
 invoke print 153 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "C.fromPrimary(F.toPrimary)" 
 -- $ObjectGenerator:gen: "C.fromPrimary(F.toPrimary)" >OGid:"fromPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C.fromPrimary(F.toPrimary)" 
 -- OG:before:super.gen: "C.fromPrimary(F.toPrimary)" 
 -- $Invocation:gen: "C.fromPrimary(F.toPrimary)" >useRtnV:"False"superAdj: 0 descNo: 155 
 -- INV:gen: "C.fromPrimary(F.toPrimary)" 
 -- isConstant: "Invocation" "C.fromPrimary(F.toPrimary)" 
 -- notConst: C C: var Temperature.Celsius 
 -- needorigin: "C.fromPrimary(F.toPrimary)" 
 -- needOrigin:E: "fromPrimary(F.toPrimary)"  E.ATd: "fromPrimary:: {   magnitude := base.magnitude}" 
 -- doNeedOrigin:Ex: "fromPrimary(F.toPrimary)" 
 -- origin:isValueObj: "Celsius" 
 -- computeAdr:superAdj: 0 "C.fromPrimary(F.toPrimary)" 
 -- computeAdr: 1 :rec: "none"  E: "C" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "C" >ATd.off:2:on:0:superAdj:0"C: var Temperature.Celsius":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "C: var Temperature.Celsius" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- DI:OG: Temperature.Celsius 
 -- before:floatTest:  "C: var Temperature.Celsius" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- computeAdr: 2 :rec: "C"  E: "fromPrimary(F.toPrimary)"  A.E: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "fromPrimary(F.toPrimary)" >ATd.off:0 (isPtn):on:0:superAdj:0"fromPrimary:: {   magnitude := base.magnitude":Adr:off:2 size:0 isFloat:F i ...} 
 -- $pattern:getAdr: "fromPrimary:: {   magnitude := base.magnitude" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C" >staticOff:0 "C: var Temperature.Celsius" superAdj:0 
 -- $var:loadArgs: "C: var Temperature.Celsius" >E:"C" 
 -- $pattern:loadArgs: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ..."} 
 -- ptn:loadArgs:E "C" 
 -- {(ObjectInvocation_Unary; (name: "C"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C" >rec:"C" ATd:"var" isValueObj E:"fromPrimary(F.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- OI:invoke:B: "C" E: "fromPrimary(F.toPrimary)"  rec: "C"  useRtnV: true "C: var Temperature.Celsius" 
 -- OI:invoke:before:ATdx.invoke: var C 
 -- $var:invoke: "C: var Temperature.Celsius" E: "fromPrimary(F.toPrimary)">newOff:2 useRTNv: "True" 
 -- DI:invoke: "C: var Temperature.Celsius" 
 -- isValueObj:isAdr: true objSize: 2  rec "C" ,E: "fromPrimary(F.toPrimary)" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 144
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- 
 -- OI:invoke:C: C :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C" E: "fromPrimary(F.toPrimary)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "fromPrimary(F.toPrimary)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- rec:  "C" E:  "fromPrimary(F.toPrimary)" 
 -- INV:gen:E.loadArgs "fromPrimary(F.toPrimary)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fromPrimary(F.toPrimary)" >staticOff:0 "fromPrimary:: {   magnitude := base.magnitude" superAdj:0arg:"F.toPrimary"} 
 -- $pattern:loadArgs: "fromPrimary:: {   magnitude := base.magnitude" >E:"fromPrimary(F.toPrimary)":descNo:155} 
 -- ptn:loadArgs:E "fromPrimary(F.toPrimary)" 
 -- {(ObjectInvocation_KeyWord; (name: "fromPrimary"); (Arguments;  (name: "fromPrimary");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (nam ...} 
 -- args: "fromPrimary(F.toPrimary)" 
 -- E: "ObjectGenerator" F.toPrimary 
 -- E.arg: "var" in base: var PrimaryUnit 
 -- NonVirt: "fromPrimary(F.toPrimary)" "ObjectInvocation_KeyWord" ActArg:  "F.toPrimary" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "fromPrimary(F.toPrimary)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "F.toPrimary" >OGid:"toPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "F.toPrimary" 
 -- OG:before:super.gen: "F.toPrimary" 
 -- $Invocation:gen: "F.toPrimary" >useRtnV:"True"superAdj: 0 descNo: 154 
 -- INV:gen: "F.toPrimary" 
 -- isConstant: "Invocation" "F.toPrimary" 
 -- notConst: F F: var Temperature.Fahrenheit 
 -- needorigin: "F.toPrimary" 
 -- needOrigin:E: "toPrimary"  E.ATd: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)}" 
 -- doNeedOrigin:Ex: "toPrimary" 
 -- origin:isValueObj: "Fahrenheit" 
 -- computeAdr:superAdj: 0 "F.toPrimary" 
 -- computeAdr: 1 :rec: "none"  E: "F" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "F"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "F" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "F" >ATd.off:4:on:0:superAdj:0"F: var Temperature.Fahrenheit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origin ... 
 -- $var:getAdr: "F: var Temperature.Fahrenheit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F ... 
 -- DI:OG: Temperature.Fahrenheit 
 -- before:floatTest:  "F: var Temperature.Fahrenheit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdr: 2 :rec: "F"  E: "toPrimary"  A.E: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "toPrimary" >ATd.off:0 (isPtn):on:0:superAdj:0"toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)":Adr:off:4 size:0 isFloat ...} 
 -- $pattern:getAdr: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "F" >staticOff:0 "F: var Temperature.Fahrenheit" superAdj:0 
 -- $var:loadArgs: "F: var Temperature.Fahrenheit" >E:"F" 
 -- $pattern:loadArgs: "Fahrenheit: Unit{   %Public;   thisUnit:: Fahrenheit;   toPrimary:: ;      base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);   fromPrimary:: ;      m ..."} 
 -- ptn:loadArgs:E "F" 
 -- {(ObjectInvocation_Unary; (name: "F"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "F" >rec:"F" ATd:"var" isValueObj E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F" E: "toPrimary"  rec: "F"  useRtnV: true "F: var Temperature.Fahrenheit" 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: "F: var Temperature.Fahrenheit" E: "toPrimary">newOff:4 useRTNv: "True" 
 -- DI:invoke: "F: var Temperature.Fahrenheit" 
 -- isValueObj:isAdr: true objSize: 2  rec "F" ,E: "toPrimary" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 146
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- 
 -- OI:invoke:C: F :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "F" E: "toPrimary" 
 -- computeAdr:isLast:E:  "toPrimary" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- rec:  "F" E:  "toPrimary" 
 -- INV:gen:E.loadArgs "toPrimary" 
 -- $ObjectInvocation_Unary:loadArgs: "toPrimary" >staticOff:0 "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" superAdj:0} 
 -- $pattern:loadArgs: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" >E:"toPrimary":descNo:154} 
 -- ptn:loadArgs:E "toPrimary" 
 -- {(ObjectInvocation_Unary; (name: "toPrimary"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "toPrimary" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "toPrimary" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec ... 
 -- $ObjectInvocation_Unary:invoke: "toPrimary" >rec:"F" ATd:"pattern" E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "toPrimary" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- origin:isValueObj "Fahrenheit" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- OI:invoke:B: "toPrimary" E: "toPrimary"  rec: "F"  useRtnV: true "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)}" 
 -- OI:invoke:before:ATdx.invoke: pattern toPrimary 
 -- $pattern:invoke: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" E: "toPrimary" useRTNv: "True"} 
 -- ptn:invoke: "toPrimary" E: "toPrimary" ptnKind: 3 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- isDI 
 -- isStatic: true rec: "F" 
 invoke toPrimary 154 0 0
 -- global:pushOut: base off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke:X: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- OI:invoke:C: toPrimary :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:F 
 -- formalArg:isPtn: "in base: var PrimaryUnit" :isBasicVal: false :valueObj: true 
 -- :actArg: "F.toPrimary" :isBasicVal: false 
 -- case:B: F.toPrimary ObjectGenerator 0 0 0 true false 
 -- pushValue: D: off: 4 size: 2 0 in base: var PrimaryUnit 
 pushvalue  off:4 size:2 descNo: 0
 pushc 1
 -- end:loadArgs:NonVirt: "fromPrimary(F.toPrimary)" 
 -- INV:gen:after:E.loadArgs "fromPrimary(F.toPrimary)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fromPrimary(F.toPrimary)" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F ... 
 -- $ObjectInvocation_KeyWord:invoke: "fromPrimary(F.toPrimary)" >rec:"C" ATd:"pattern" E:"fromPrimary(F.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "fromPrimary(F.toPrimary)" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- origin:isValueObj "Celsius" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- OI:invoke:B: "fromPrimary(F.toPrimary)" E: "fromPrimary(F.toPrimary)"  rec: "C"  useRtnV: false "fromPrimary:: {   magnitude := base.magnitude}" 
 -- OI:invoke:before:ATdx.invoke: pattern fromPrimary 
 -- $pattern:invoke: "fromPrimary:: {   magnitude := base.magnitude" E: "fromPrimary(F.toPrimary)" useRTNv: "False"} 
 -- ptn:invoke: "fromPrimary" E: "fromPrimary(F.toPrimary)" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- isDI 
 -- isStatic: true rec: "C" 
 invoke fromPrimary 155 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -6 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: fromPrimary(F.toPrimary) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(F.toPrimary)":rec:C 
 -- genclass:stmt: "C.print" 
 -- $ObjectGenerator:gen: "C.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "C.print" 
 -- OG:before:super.gen: "C.print" 
 -- $Invocation:gen: "C.print" >useRtnV:"False"superAdj: 0 descNo: 149 
 -- INV:gen: "C.print" 
 -- isConstant: "Invocation" "C.print" 
 -- notConst: C C: var Temperature.Celsius 
 -- needorigin: "C.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Celsius".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Celsius" 
 -- computeAdr:superAdj: 0 "C.print" 
 -- computeAdr: 1 :rec: "none"  E: "C" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "C"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "C" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "C" >ATd.off:2:on:0:superAdj:0"C: var Temperature.Celsius":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsV ... 
 -- $var:getAdr: "C: var Temperature.Celsius" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F is ... 
 -- DI:OG: Temperature.Celsius 
 -- before:floatTest:  "C: var Temperature.Celsius" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- computeAdr: 2 :rec: "C"  E: "print"  A.E: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Celsius".print":Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValu ...} 
 -- $pattern:getAdr: "print:: {   "Celsius".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "C" >staticOff:0 "C: var Temperature.Celsius" superAdj:0 
 -- $var:loadArgs: "C: var Temperature.Celsius" >E:"C" 
 -- $pattern:loadArgs: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ..."} 
 -- ptn:loadArgs:E "C" 
 -- {(ObjectInvocation_Unary; (name: "C"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "C" >rec:"C" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "C" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"C":rec:C 
 -- OI:invoke:B: "C" E: "print"  rec: "C"  useRtnV: true "C: var Temperature.Celsius" 
 -- OI:invoke:before:ATdx.invoke: var C 
 -- $var:invoke: "C: var Temperature.Celsius" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "C: var Temperature.Celsius" 
 -- isValueObj:isAdr: true objSize: 2  rec "C" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 144
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- 
 -- OI:invoke:C: C :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "C" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- rec:  "C" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Celsius".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Celsius".print" >E:"print":descNo:149} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"C" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- origin:isValueObj "Celsius" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- OI:invoke:B: "print" E: "print"  rec: "C"  useRtnV: false "print:: {   "Celsius".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Celsius".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- isDI 
 -- isStatic: true rec: "C" 
 invoke print 149 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -7 rTopMax: 0 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:C 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -8 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "temperatureEx" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 144 
 -- Items:GenClass: Celsius descNo: 144 isValue: true 
 -- Items:GenClass: Celsius descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Celsius 144 0 Temperature 82 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Celsius".print} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Celsius ..."}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %Public{thisUnit:: Celsius;toPrimary:: ;   base.magnitude := magnitude;fromPrimary:: ;   magnitude := base.magnitude;print:: ;   "Celsius".print} 
 -- vdtAdd: inx=1 descInx=144 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "thisUnit:: Celsius"  
 -- $pattern:gen: "toPrimary:: {   base.magnitude := magnitude" } 
 -- $pattern:gen: "fromPrimary:: {   magnitude := base.magnitude" } 
 -- $pattern:gen: "print:: {   "Celsius".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=144 vDescInx=150 vdtTop: 9 
 -- vdtAdd: inx=8 descInx=144 vDescInx=155 vdtTop: 9 
 -- vdtAdd: inx=9 descInx=144 vDescInx=149 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 150 
 -- Items:GenClass: toPrimary descNo: 150 isValue: false 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 150 1 Celsius 144
 -- vdtTableCopy: I:1:49 I:2:0
 -- vdtAdd: inx=2 descInx=150 vDescInx=150 vdtTop: 2 
 -- Store itemArgs: base.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super toPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "base.magnitude := magnitude" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: toPrimary 
 -- Store itemArgs: base.magnitude := magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=150 vDescInx=49 vdtTop: 2 
 -- $var:gen: "out base: var PrimaryUnit"  
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- $ObjectGenerator:gen: "PrimaryUnit" >OGid:"Unit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "PrimaryUnit" 
 -- OG:before:super.gen: "PrimaryUnit" 
 -- $Invocation:gen: "PrimaryUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "PrimaryUnit" 
 -- isConstant: "Invocation" "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "PrimaryUnit" E:  "PrimaryUnit" 
 -- INV:gen:E.loadArgs "PrimaryUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "PrimaryUnit" >staticOff:0 "PrimaryUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "PrimaryUnit:< Unit" >E:"PrimaryUnit":descNo:0 
 -- ptn:loadArgs:E "PrimaryUnit" 
 -- {(ObjectInvocation_Unary; (name: "PrimaryUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "PrimaryUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit" 
 -- $ObjectInvocation_Unary:invoke: "PrimaryUnit" >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:"PrimaryUnit" unique:"False" 
 -- OI:invoke: "PrimaryUnit" 
 -- 
 -- OI:invoke:B: "PrimaryUnit" E: "PrimaryUnit"  rec: "PrimaryUnit"  useRtnV: false "PrimaryUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: "PrimaryUnit:< Unit" E: "PrimaryUnit" useRTNv: "False" 
 -- ptn:invoke: "PrimaryUnit" E: "PrimaryUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 4 adr:none 
 -- isStatic: true rec: "PrimaryUnit" 
 invokeVal  PrimaryUnit 40 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- genclass:stmt: "base.magnitude := magnitude" 
 -- $Assign:gen: "base.magnitude := magnitude"  
 -- assign: "base.magnitude := magnitude" 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"out base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "out base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "out base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "base.magnitude := magnitude" right.label: "ObjectGenerator" "magnitude" 
 -- $ObjectGenerator:gen: "magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "magnitude" 
 -- OG:before:super.gen: "magnitude" 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "toPrimary" on: 1 isValueObj: false 
 -- origin: Celsius origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg toPrimary$150 1
 rswap 0
 rdouble 0
 pushg 2 toPrimary$150
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 toPrimary$150
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- OG:gen:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- rec: "base" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"bas ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "magnitude" 
 -- isArgOfAssignI2IwithUniValArg "base.magnitude := magnitude" arg: "magnitude" ObjectGenerator 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 155 
 -- Items:GenClass: fromPrimary descNo: 155 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 155 1 Celsius 144
 -- vdtTableCopy: I:1:50 I:2:0
 -- vdtAdd: inx=2 descInx=155 vDescInx=155 vdtTop: 2 
 -- Store itemArgs: magnitude := base.magnitude 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super fromPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "magnitude := base.magnitude" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: fromPrimary 
 -- Store itemArgs: magnitude := base.magnitude 
 -- in base: var PrimaryUnit true 0 
 -- DI:store: "base" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  base 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=155 vDescInx=50 vdtTop: 2 
 -- $var:gen: "in base: var PrimaryUnit"  
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- genclass:stmt: "magnitude := base.magnitude" 
 -- $Assign:gen: "magnitude := base.magnitude"  
 -- assign: "magnitude := base.magnitude" 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "fromPrimary" on: 1 isValueObj: false 
 -- origin: Celsius origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg fromPrimary$155 1
 rswap 0
 rdouble 0
 pushg 2 fromPrimary$155
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 fromPrimary$155
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "magnitude := base.magnitude" right.label: "ObjectGenerator" "base.magnitude" 
 -- $ObjectGenerator:gen: "base.magnitude" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "base.magnitude" 
 -- OG:before:super.gen: "base.magnitude" 
 -- $Invocation:gen: "base.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude" 
 -- isConstant: "Invocation" "base.magnitude" 
 -- notConst: base in base: var PrimaryUnit 
 -- needorigin: "base.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"in base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "in base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "in base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- rec:  "base" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"base" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "base"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "base" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- rec: "magnitude" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "base.magnitude" 
 -- isArgOfAssignI2IwithUniValArg "magnitude := base.magnitude" arg: "base.magnitude" ObjectGenerator 
 -- arg.super.arg: "base" ObjectInvocation_Unary 
 -- arg.super.arg: "magnitude" ObjectInvocation_Unary 
 -- recx: "base" argx: "magnitude" 
 -- checkInt2IntWithUnitArg:rec: "base" E: "magnitude" 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- Address:store:originIsVal: 
 fovstoreg 1 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 149 
 -- Items:GenClass: print descNo: 149 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 149 1 Celsius 144
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=149 vDescInx=149 vdtTop: 2 
 -- Store itemArgs: "Celsius".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""Celsius".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "Celsius".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=149 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Celsius".print" 
 -- $ObjectGenerator:gen: ""Celsius".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Celsius".print" 
 -- OG:before:super.gen: ""Celsius".print" 
 -- $Invocation:gen: ""Celsius".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Celsius".print" 
 -- isConstant: "Invocation" ""Celsius".print" 
 -- needorigin: ""Celsius".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Celsius"" E:  ""Celsius"" 
 -- INV:gen:E.loadArgs ""Celsius"" 
 -- $String::loadArgs: ""Celsius""  
 -- INV:gen:after:E.loadArgs ""Celsius"" 
 -- OIadr: 
 -- $String::invoke: ""Celsius""  
 pushText "Celsius"
 -- IV:gen:checkTail: ""Celsius".print" E: ""Celsius"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Celsius"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Celsius""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 146 
 -- Items:GenClass: Fahrenheit descNo: 146 isValue: true 
 -- Items:GenClass: Fahrenheit descNo: 40 isValue: true 
 -- Items:GenClass: Unit descNo: 4 isValue: true 
 -- Items:GenClass: Value descNo: 21 isValue: true 

 CLASS Fahrenheit 146 0 Temperature 82 isValueObj
 -- vdtTableCopy: I:1:40 V:2:0 V:3:0 V:4:0 V:5:0 V:6:0 V:7:49 V:8:50 V:9:51
 -- Store itemArgs: %Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrimary:: ;   magnitude := (base.magnitude * (9.0 / 5. ...} 
 -- super Unit
 -- push:super.origin: 
 -- handleSuperArgs:E: "Unit" theIS: "%Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrimary:: ;   magnitude := (base.mag ...}" 
 -- super.sig:not:none:superAdj: 0 
 -- $ObjectInvocation_Unary:loadArgs: "Unit" >staticOff:0 "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Uni ..."} 
 -- $pattern:loadArgs: "Unit: Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thisUni ..."} 
 -- ptn:loadArgs:E "Unit" 
 -- {(ObjectInvocation_Unary; (name: "Unit"); (Arguments))} 
 -- args: "" 
 -- hArgOrg:super: Unit 
 -- Store itemArgs: %Public{thisUnit:: Fahrenheit;toPrimary:: ;   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0);fromPrimary:: ;   magnitude := (base.magnitude * (9.0 / 5. ...} 
 -- vdtAdd: inx=1 descInx=146 vDescInx=40 vdtTop: 9 
 -- $Property:gen: "%unit "U", 1"  
 -- $Property:gen: "%public"  
 -- $var:gen: "magnitude: var Float"  
 -- DI:gen: "magnitude: var Float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  magnitude 
 -- $pattern:gen: "thisUnit:< Unit"  
 -- $pattern:gen: "argUnit:< Unit"  
 -- $pattern:gen: "resUnit:< Unit"  
 -- $pattern:gen: "toPrimary:< {   out base: var PrimaryUnit;   inner(toPrimary)" } 
 -- $pattern:gen: "fromPrimary:< {   in base: var PrimaryUnit;   inner(fromPrimary)" } 
 -- $pattern:gen: "print:< {   "Unit:".print;   inner(print);   put(':');   putFloat(magnitude)" } 
 -- $Property:gen: "%Public"  
 -- $pattern:gen: "thisUnit:: Fahrenheit"  
 -- $pattern:gen: "toPrimary:: {   base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" } 
 -- $pattern:gen: "fromPrimary:: {   magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" } 
 -- $pattern:gen: "print:: {   "Fahrenheit".print" } 
 rtnAlloc 1
 toSuper 40
DO:
 L1:
 -- genclass:stmt: "%Public" 
 -- $Property:gen: "%Public"  
 L2:
 rtnInner  M
 END OSDV:0 objSize:2 isIndexed:0
 -- vdtAdd: inx=7 descInx=146 vDescInx=154 vdtTop: 9 
 -- vdtAdd: inx=8 descInx=146 vDescInx=151 vdtTop: 9 
 -- vdtAdd: inx=9 descInx=146 vDescInx=153 vdtTop: 9 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 154 
 -- Items:GenClass: toPrimary descNo: 154 isValue: false 
 -- Items:GenClass: toPrimary descNo: 49 isValue: false 
 -- Items:GenClass: toPrimary descNo: 21 isValue: false 

 CLASS toPrimary 154 1 Fahrenheit 146
 -- vdtTableCopy: I:1:49 I:2:0
 -- vdtAdd: inx=2 descInx=154 vDescInx=154 vdtTop: 2 
 -- Store itemArgs: base.magnitude := (magnitude - 32.0) * (5.0 / 9.0) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super toPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: toPrimary 
 -- Store itemArgs: base.magnitude := (magnitude - 32.0) * (5.0 / 9.0) 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=154 vDescInx=49 vdtTop: 2 
 -- $var:gen: "out base: var PrimaryUnit"  
 -- DI:gen: "out base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- $ObjectGenerator:gen: "PrimaryUnit" >OGid:"Unit" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "PrimaryUnit" 
 -- OG:before:super.gen: "PrimaryUnit" 
 -- $Invocation:gen: "PrimaryUnit" >useRtnV:"False"superAdj: 0 descNo: 0 
 -- INV:gen: "PrimaryUnit" 
 -- isConstant: "Invocation" "PrimaryUnit" 
 -- needorigin: "PrimaryUnit" 
 -- needOrigin:E: "PrimaryUnit"  E.ATd: "PrimaryUnit:< Unit" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %unit "U", 1;   %public;   magnitude: var Float;   thisUnit:< Unit;   argUnit:< Unit;   resUnit:< Unit;   +?  : ;      in V: var thi ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "PrimaryUnit" E:  "PrimaryUnit" 
 -- INV:gen:E.loadArgs "PrimaryUnit" 
 -- $ObjectInvocation_Unary:loadArgs: "PrimaryUnit" >staticOff:0 "PrimaryUnit:< Unit" superAdj:0 
 -- $pattern:loadArgs: "PrimaryUnit:< Unit" >E:"PrimaryUnit":descNo:0 
 -- ptn:loadArgs:E "PrimaryUnit" 
 -- {(ObjectInvocation_Unary; (name: "PrimaryUnit"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "PrimaryUnit" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "PrimaryUnit" 
 -- $ObjectInvocation_Unary:invoke: "PrimaryUnit" >rec:"PrimaryUnit" ATd:"pattern" isValueObj E:"PrimaryUnit" E.ATd:"PrimaryUnit" unique:"False" 
 -- OI:invoke: "PrimaryUnit" 
 -- 
 -- OI:invoke:B: "PrimaryUnit" E: "PrimaryUnit"  rec: "PrimaryUnit"  useRtnV: false "PrimaryUnit:< Unit" 
 -- OI:invoke:before:ATdx.invoke: pattern PrimaryUnit 
 -- $pattern:invoke: "PrimaryUnit:< Unit" E: "PrimaryUnit" useRTNv: "False" 
 -- ptn:invoke: "PrimaryUnit" E: "PrimaryUnit" ptnKind: 1 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 1 staticOff: 4 adr:none 
 -- isStatic: true rec: "PrimaryUnit" 
 invokeVal  PrimaryUnit 40 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: PrimaryUnit :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
 toSuper 49
DO:
 mvStack 
 L1:
 -- genclass:stmt: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- $Assign:gen: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)"  
 -- assign: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"out base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "out base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isV ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "out base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" right.label: "ObjectGenerator" "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- $ObjectGenerator:gen: "(magnitude - 32.0) * (5.0 / 9.0)" >OGid:"*" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- OG:before:super.gen: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- $Invocation:gen: "(magnitude - 32.0) * (5.0 / 9.0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- isConstant: "Invocation" "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- needorigin: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- needOrigin:E: "(magnitude - 32.0) * (5.0 / 9.0)"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- computeAdr:superAdj: 0 "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- computeAdr: 1 :rec: "none"  E: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "(magnitude - 32.0) * (5.0 / 9.0)"  
 -- $BinOp:loadOrigin: "(magnitude - 32.0) * (5.0 / 9.0)"  
 -- BinaryExp:loadOrigin:empty: "(magnitude - 32.0) * (5.0 / 9.0)" superAdj: 0 
 -- $BinOp:getAdr: "(magnitude - 32.0) * (5.0 / 9.0)"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "(magnitude - 32.0) * (5.0 / 9.0)"  ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "(magnitude - 32.0) * (5.0 / 9.0)" E:  "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- INV:gen:E.loadArgs "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- $BinOp:loadArgs: "(magnitude - 32.0) * (5.0 / 9.0)"  
 -- BinaryExp:loadArgs: "(magnitude - 32.0) * (5.0 / 9.0)" superAdj: 0 
 -- $Invocation:gen: "(magnitude - 32.0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(magnitude - 32.0)" 
 -- isConstant: "Invocation" "(magnitude - 32.0)" 
 -- needorigin: "(magnitude - 32.0)" 
 -- needOrigin:E: "(magnitude - 32.0)"  E.ATd: "-  : {   %basic 110;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(magnitude - 32.0)" 
 -- computeAdr:superAdj: 0 "(magnitude - 32.0)" 
 -- computeAdr: 1 :rec: "none"  E: "(magnitude - 32.0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(magnitude - 32.0)"  
 -- $BracketedExp:loadOrigin: "(magnitude - 32.0)"  
 -- computeAdr:superAdj: 0 "magnitude - 32.0" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude - 32.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "magnitude - 32.0"  
 -- $BinOp:loadOrigin: "magnitude - 32.0"  
 -- BinaryExp:loadOrigin:empty: "magnitude - 32.0" superAdj: 0 
 -- $BinOp:getAdr: "magnitude - 32.0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude - 32.0"  ATd: "-  : {   %basic 110;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude - 32.0" 
 -- BE:loadOrigin:E: magnitude - 32.0 
 -- $BinOp:getAdr: "magnitude - 32.0"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude - 32.0"  ATd: "-  : {   %basic 110;   in V: var float;   out R: var float}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "magnitude - 32.0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "magnitude - 32.0" E:  "magnitude - 32.0" 
 -- INV:gen:E.loadArgs "magnitude - 32.0" 
 -- $BinOp:loadArgs: "magnitude - 32.0"  
 -- BinaryExp:loadArgs: "magnitude - 32.0" superAdj: 0 
 -- $Invocation:gen: "magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "magnitude" 
 -- isConstant: "Invocation" "magnitude" 
 -- notConst: magnitude magnitude: var Float 
 -- needorigin: "magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "toPrimary" on: 1 isValueObj: false 
 -- origin: Fahrenheit origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg toPrimary$154 1
 rswap 0
 rdouble 0
 pushg 2 toPrimary$154
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 toPrimary$154
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- rec:  "magnitude" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec ... 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"magnitude" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "magnitude"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "magnitude" 
 -- load:isValue:E: "magnitude" originIsValue: true E.ATd:isValueObj: true 
 fovpushg 1 
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 1 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $pattern:loadArgs: "-  : {   %basic 110;   in V: var float;   out R: var float" >E:"- 32.0":descNo:0} 
 -- ptn:loadArgs:E "- 32.0" 
 -- {(ObjectInvocation_Binary; (name: "-"); (Arguments;  (ObjectGenerator;   (Invocation;    (FloatLiteral 32.0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "32.0" 
 -- E: "ObjectGenerator" 32.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "- 32.0" "ObjectInvocation_Binary" ActArg:  "32.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "- 32.0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "32.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "32.0" 
 -- OG:before:super.gen: "32.0" 
 -- $Invocation:gen: "32.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "32.0" 
 -- isConstant: "Invocation" "32.0" 
 -- needorigin: "32.0" 
 -- needOrigin:E: "32.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "32.0" E:  "32.0" 
 -- INV:gen:E.loadArgs "32.0" 
 -- $FloatLiteral:loadArgs: "32.0"  
 -- INV:gen:after:E.loadArgs "32.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "32.0" 
 -- $FloatLiteral:invoke: "32.0"  
 pushFloatConst 32.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "32.0" :isBasicVal: true 
 -- case:B: 32.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "- 32.0" 
 -- BinaryExp:loadArgs:end: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- INV:gen:after:E.loadArgs "magnitude - 32.0" 
 -- OIadr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- IV:E.invoke:useRtnVal: true E: BinOp "magnitude - 32.0" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude ... 
 -- $BinOp:invoke: "magnitude - 32.0"  
 -- BinaryExp:invoke: "magnitude" rec: "magnitude - 32.0" 
 -- M: "- 32.0" :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- $ObjectInvocation_Binary:invoke: "- 32.0" >rec:"magnitude" ATd:"pattern" E:"- 32.0" E.ATd:"-  " unique:"False" 
 -- OI:invoke: "- 32.0" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:magnitude 
 -- OI:invoke:B: "- 32.0" E: "- 32.0"  rec: "magnitude"  useRtnV: true "-  : {   %basic 110;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern -   
 -- $pattern:invoke: "-  : {   %basic 110;   in V: var float;   out R: var float" E: "- 32.0" useRTNv: "True"} 
 -- ptn:invoke: "-  " E: "- 32.0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "magnitude" E: "- 32.0" 
 -- arg:float 
 fminus
 -- OI:invoke:V: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"- 32.0":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"- 32.0":rec:magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: - 32.0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* (5.0 / 9.0)":descNo:65} 
 -- ptn:loadArgs:E "* (5.0 / 9.0)" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (BracketedExp;     (Invocation;      (BinOp:/;       (Invocation;        (FloatLit ...} 
 -- args: "(5.0 / 9.0)" 
 -- E: "ObjectGenerator" (5.0 / 9.0) 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* (5.0 / 9.0)" "ObjectInvocation_Binary" ActArg:  "(5.0 / 9.0)" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* (5.0 / 9.0)" 
 -- $ObjectGenerator:gen: "(5.0 / 9.0)" >OGid:"/" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(5.0 / 9.0)" 
 -- OG:before:super.gen: "(5.0 / 9.0)" 
 -- $Invocation:gen: "(5.0 / 9.0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(5.0 / 9.0)" 
 -- isConstant: "Invocation" "(5.0 / 9.0)" 
 -- needorigin: "(5.0 / 9.0)" 
 -- needOrigin:E: "(5.0 / 9.0)"  E.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(5.0 / 9.0)" 
 -- computeAdr:superAdj: 0 "(5.0 / 9.0)" 
 -- computeAdr: 1 :rec: "none"  E: "(5.0 / 9.0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(5.0 / 9.0)"  
 -- $BracketedExp:loadOrigin: "(5.0 / 9.0)"  
 -- computeAdr:superAdj: 0 "5.0 / 9.0" 
 -- computeAdr: 1 :rec: "none"  E: "5.0 / 9.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "5.0 / 9.0"  
 -- $BinOp:loadOrigin: "5.0 / 9.0"  
 -- BinaryExp:loadOrigin:empty: "5.0 / 9.0" superAdj: 0 
 -- $BinOp:getAdr: "5.0 / 9.0"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "5.0 / 9.0" 
 -- BE:loadOrigin:E: 5.0 / 9.0 
 -- $BinOp:getAdr: "5.0 / 9.0"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "5.0 / 9.0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "5.0 / 9.0" E:  "5.0 / 9.0" 
 -- INV:gen:E.loadArgs "5.0 / 9.0" 
 -- $BinOp:loadArgs: "5.0 / 9.0"  
 -- BinaryExp:loadArgs: "5.0 / 9.0" superAdj: 0 
 -- $Invocation:gen: "5.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "5.0" 
 -- isConstant: "Invocation" "5.0" 
 -- needorigin: "5.0" 
 -- needOrigin:E: "5.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "5.0" E:  "5.0" 
 -- INV:gen:E.loadArgs "5.0" 
 -- $FloatLiteral:loadArgs: "5.0"  
 -- INV:gen:after:E.loadArgs "5.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "5.0" 
 -- $FloatLiteral:invoke: "5.0"  
 pushFloatConst 5.000000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "/  : {   %basic 121;   in V: var float;   out R: var float" >E:"/ 9.0":descNo:99} 
 -- ptn:loadArgs:E "/ 9.0" 
 -- {(ObjectInvocation_Binary; (name: "/"); (Arguments;  (ObjectGenerator;   (Invocation;    (FloatLiteral 9.0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "9.0" 
 -- E: "ObjectGenerator" 9.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "/ 9.0" "ObjectInvocation_Binary" ActArg:  "9.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/ 9.0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "9.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "9.0" 
 -- OG:before:super.gen: "9.0" 
 -- $Invocation:gen: "9.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "9.0" 
 -- isConstant: "Invocation" "9.0" 
 -- needorigin: "9.0" 
 -- needOrigin:E: "9.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "9.0" E:  "9.0" 
 -- INV:gen:E.loadArgs "9.0" 
 -- $FloatLiteral:loadArgs: "9.0"  
 -- INV:gen:after:E.loadArgs "9.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "9.0" 
 -- $FloatLiteral:invoke: "9.0"  
 pushFloatConst 9.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "9.0" :isBasicVal: true 
 -- case:B: 9.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "/ 9.0" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "5.0 / 9.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "5.0 / 9.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: "5.0 / 9.0"  
 -- BinaryExp:invoke: "5.0" rec: "5.0 / 9.0" 
 -- M: "/ 9.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "/ 9.0" >rec:"5.0" ATd:"pattern" E:"/ 9.0" E.ATd:"/  " unique:"False" 
 -- OI:invoke: "/ 9.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:5.0 
 -- origin:isValueObj "float" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:5.0 
 -- OI:invoke:B: "/ 9.0" E: "/ 9.0"  rec: "5.0"  useRtnV: true "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern /   
 -- $pattern:invoke: "/  : {   %basic 121;   in V: var float;   out R: var float" E: "/ 9.0" useRTNv: "True"} 
 -- ptn:invoke: "/  " E: "/ 9.0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "5.0" E: "/ 9.0" 
 -- arg:float 
 fdiv
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"/ 9.0":rec:5.0 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"/ 9.0":rec:5.0 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: / 9.0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "(5.0 / 9.0)" :isBasicVal: true 
 -- case:B: (5.0 / 9.0) ObjectGenerator 9 121 121 false false 
 -- end:loadArgs:NonVirt: "* (5.0 / 9.0)" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "(magnitude - 32.0) * (5.0 / 9.0)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":re ... 
 -- $BinOp:invoke: "(magnitude - 32.0) * (5.0 / 9.0)"  
 -- BinaryExp:invoke: "(magnitude - 32.0)" rec: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- M: "* (5.0 / 9.0)" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "* (5.0 / 9.0)" >rec:"(magnitude - 32.0)" ATd:"pattern" E:"* (5.0 / 9.0)" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* (5.0 / 9.0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:(magnitude - 32.0) 
 -- origin:isValueObj "float" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:(magnitude - 32.0) 
 -- OI:invoke:B: "* (5.0 / 9.0)" E: "* (5.0 / 9.0)"  rec: "(magnitude - 32.0)"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* (5.0 / 9.0)" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* (5.0 / 9.0)" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "(magnitude - 32.0)" E: "* (5.0 / 9.0)" 
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"* (5.0 / 9.0)":rec:(magnitude - 32.0) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"* (5.0 / 9.0)":rec:(magnitude - 32.0) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * (5.0 / 9.0) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "base" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"bas ..." 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- isArgOfAssignI2IwithUniValArg "base.magnitude := (magnitude - 32.0) * (5.0 / 9.0)" arg: "(magnitude - 32.0) * (5.0 / 9.0)" ObjectGenerator 
 -- arg.super.arg: "(magnitude - 32.0) * (5.0 / 9.0)" BinOp 
 -- recx:BinaryExp:recx: "(magnitude - 32.0) * (5.0 / 9.0)" 
 -- M: "* (5.0 / 9.0)" label: "ObjectInvocation_Binary" M.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "(magnitude - 32.0)" E: "* (5.0 / 9.0)" 
 -- arg:other 
 -- M:arg: "(5.0 / 9.0)" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 151 
 -- Items:GenClass: fromPrimary descNo: 151 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 50 isValue: false 
 -- Items:GenClass: fromPrimary descNo: 21 isValue: false 

 CLASS fromPrimary 151 1 Fahrenheit 146
 -- vdtTableCopy: I:1:50 I:2:0
 -- vdtAdd: inx=2 descInx=151 vDescInx=151 vdtTop: 2 
 -- Store itemArgs: magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super fromPrimary
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: fromPrimary 
 -- Store itemArgs: magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0 
 -- in base: var PrimaryUnit true 0 
 -- DI:store: "base" 
 jmpFalse  L3
 pushThis 
 -- vassign:B: base off: 4 size: 2 mode: 0 
 vassign  4 2 0
 jmp L4
 L3:
 invokeVal  base 40 3
 L4:
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=151 vDescInx=50 vdtTop: 2 
 -- $var:gen: "in base: var PrimaryUnit"  
 -- DI:gen: "in base: var PrimaryUnit" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  base 
 -- inArg: in base: var PrimaryUnit 
 rtnAlloc 1
 toSuper 50
DO:
 mvStack 
 L1:
 -- genclass:stmt: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- $Assign:gen: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0"  
 -- assign: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- computeAdr:superAdj: 0 "magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "magnitude" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "magnitude"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "magnitude" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "fromPrimary" on: 1 isValueObj: false 
 -- origin: Fahrenheit origin:isValueObj: true 
 -- goOrigin:originIsValue  
 rdouble 0
 rpushg fromPrimary$151 1
 rswap 0
 rdouble 0
 pushg 2 fromPrimary$151
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
 pushg 3 fromPrimary$151
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:1:superAdj:0"magnitude: var Float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- After:U*U: :Adr:off:1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- E.on: 1 
 -- beforeIsValueObj:E: "magnitude"  ATd: "magnitude: var Float" 
 -- computeAdr:isFirst: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" right.label: "ObjectGenerator" "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- $ObjectGenerator:gen: "(base.magnitude * (9.0 / 5.0)) + 32.0" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- OG:before:super.gen: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- $Invocation:gen: "(base.magnitude * (9.0 / 5.0)) + 32.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- isConstant: "Invocation" "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- needorigin: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- needOrigin:E: "(base.magnitude * (9.0 / 5.0)) + 32.0"  E.ATd: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- computeAdr:superAdj: 0 "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- computeAdr: 1 :rec: "none"  E: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "(base.magnitude * (9.0 / 5.0)) + 32.0"  
 -- $BinOp:loadOrigin: "(base.magnitude * (9.0 / 5.0)) + 32.0"  
 -- BinaryExp:loadOrigin:empty: "(base.magnitude * (9.0 / 5.0)) + 32.0" superAdj: 0 
 -- $BinOp:getAdr: "(base.magnitude * (9.0 / 5.0)) + 32.0"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "(base.magnitude * (9.0 / 5.0)) + 32.0" E:  "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- INV:gen:E.loadArgs "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- $BinOp:loadArgs: "(base.magnitude * (9.0 / 5.0)) + 32.0"  
 -- BinaryExp:loadArgs: "(base.magnitude * (9.0 / 5.0)) + 32.0" superAdj: 0 
 -- $Invocation:gen: "(base.magnitude * (9.0 / 5.0))" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(base.magnitude * (9.0 / 5.0))" 
 -- isConstant: "Invocation" "(base.magnitude * (9.0 / 5.0))" 
 -- needorigin: "(base.magnitude * (9.0 / 5.0))" 
 -- needOrigin:E: "(base.magnitude * (9.0 / 5.0))"  E.ATd: "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(base.magnitude * (9.0 / 5.0))" 
 -- computeAdr:superAdj: 0 "(base.magnitude * (9.0 / 5.0))" 
 -- computeAdr: 1 :rec: "none"  E: "(base.magnitude * (9.0 / 5.0))" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(base.magnitude * (9.0 / 5.0))"  
 -- $BracketedExp:loadOrigin: "(base.magnitude * (9.0 / 5.0))"  
 -- computeAdr:superAdj: 0 "base.magnitude * (9.0 / 5.0)" 
 -- computeAdr: 1 :rec: "none"  E: "base.magnitude * (9.0 / 5.0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "base.magnitude * (9.0 / 5.0)"  
 -- $BinOp:loadOrigin: "base.magnitude * (9.0 / 5.0)"  
 -- BinaryExp:loadOrigin:empty: "base.magnitude * (9.0 / 5.0)" superAdj: 0 
 -- $BinOp:getAdr: "base.magnitude * (9.0 / 5.0)"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "base.magnitude * (9.0 / 5.0)" 
 -- BE:loadOrigin:E: base.magnitude * (9.0 / 5.0) 
 -- $BinOp:getAdr: "base.magnitude * (9.0 / 5.0)"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "base.magnitude * (9.0 / 5.0)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "base.magnitude * (9.0 / 5.0)" E:  "base.magnitude * (9.0 / 5.0)" 
 -- INV:gen:E.loadArgs "base.magnitude * (9.0 / 5.0)" 
 -- $BinOp:loadArgs: "base.magnitude * (9.0 / 5.0)"  
 -- BinaryExp:loadArgs: "base.magnitude * (9.0 / 5.0)" superAdj: 0 
 -- $Invocation:gen: "base.magnitude" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "base.magnitude" 
 -- isConstant: "Invocation" "base.magnitude" 
 -- notConst: base in base: var PrimaryUnit 
 -- needorigin: "base.magnitude" 
 -- needOrigin:E: "magnitude"  E.ATd: "magnitude: var Float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "base.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "base" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "base"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "base" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "base" >ATd.off:4:on:0:superAdj:0"in base: var PrimaryUnit":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIs ... 
 -- $var:getAdr: "in base: var PrimaryUnit" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isVa ... 
 -- DI:OG: PrimaryUnit 
 -- before:floatTest:  "in base: var PrimaryUnit" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- computeAdr: 2 :rec: "base"  E: "magnitude"  A.E: "base" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- rec:  "base" E:  "magnitude" 
 -- INV:gen:E.loadArgs "magnitude" 
 -- $ObjectInvocation_Unary:loadArgs: "magnitude" >staticOff:0 "magnitude: var Float" superAdj:0 
 -- $var:loadArgs: "magnitude: var Float" >E:"magnitude" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "magnitude" 
 -- {(ObjectInvocation_Unary; (name: "magnitude"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "magnitude" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "magnitude" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:- 
 -- $ObjectInvocation_Unary:invoke: "magnitude" >rec:"base" ATd:"var" isValueObj E:"magnitude" E.ATd:"magnitude" unique:"False" 
 -- OI:invoke: "magnitude" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- origin:isValueObj "Unit" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"base":rec:base 
 -- OI:invoke:B: "magnitude" E: "magnitude"  rec: "base"  useRtnV: true "magnitude: var Float" 
 -- OI:invoke:before:ATdx.invoke: var magnitude 
 -- $var:invoke: "magnitude: var Float" E: "magnitude">newOff:1 useRTNv: "True" 
 -- DI:invoke: "magnitude: var Float" 
 -- load: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- isCompositeValueObj: false E: "magnitude" "magnitude: var Float" true 
 -- E.ATd.isValueObj: true rec: "base" 
 fpushg 4 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- 
 -- OI:invoke:C: magnitude :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- $pattern:loadArgs: "*  : {   %basic 112;   in V: var float;   out R: var float" >E:"* (9.0 / 5.0)":descNo:65} 
 -- ptn:loadArgs:E "* (9.0 / 5.0)" 
 -- {(ObjectInvocation_Binary; (name: "*"); (Arguments;  (ObjectGenerator;   (Invocation;    (BracketedExp;     (Invocation;      (BinOp:/;       (Invocation;        (FloatLit ...} 
 -- args: "(9.0 / 5.0)" 
 -- E: "ObjectGenerator" (9.0 / 5.0) 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "* (9.0 / 5.0)" "ObjectInvocation_Binary" ActArg:  "(9.0 / 5.0)" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:isPrim:assign,fmult:  112 "* (9.0 / 5.0)" 
 -- $ObjectGenerator:gen: "(9.0 / 5.0)" >OGid:"/" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "(9.0 / 5.0)" 
 -- OG:before:super.gen: "(9.0 / 5.0)" 
 -- $Invocation:gen: "(9.0 / 5.0)" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "(9.0 / 5.0)" 
 -- isConstant: "Invocation" "(9.0 / 5.0)" 
 -- needorigin: "(9.0 / 5.0)" 
 -- needOrigin:E: "(9.0 / 5.0)"  E.ATd: "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- doNeedOrigin:Ex: "(9.0 / 5.0)" 
 -- computeAdr:superAdj: 0 "(9.0 / 5.0)" 
 -- computeAdr: 1 :rec: "none"  E: "(9.0 / 5.0)" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BracketedExp:pushThis: "(9.0 / 5.0)"  
 -- $BracketedExp:loadOrigin: "(9.0 / 5.0)"  
 -- computeAdr:superAdj: 0 "9.0 / 5.0" 
 -- computeAdr: 1 :rec: "none"  E: "9.0 / 5.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "9.0 / 5.0"  
 -- $BinOp:loadOrigin: "9.0 / 5.0"  
 -- BinaryExp:loadOrigin:empty: "9.0 / 5.0" superAdj: 0 
 -- $BinOp:getAdr: "9.0 / 5.0"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "9.0 / 5.0" 
 -- BE:loadOrigin:E: 9.0 / 5.0 
 -- $BinOp:getAdr: "9.0 / 5.0"  
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "9.0 / 5.0" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- rec:  "9.0 / 5.0" E:  "9.0 / 5.0" 
 -- INV:gen:E.loadArgs "9.0 / 5.0" 
 -- $BinOp:loadArgs: "9.0 / 5.0"  
 -- BinaryExp:loadArgs: "9.0 / 5.0" superAdj: 0 
 -- $Invocation:gen: "9.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "9.0" 
 -- isConstant: "Invocation" "9.0" 
 -- needorigin: "9.0" 
 -- needOrigin:E: "9.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "9.0" E:  "9.0" 
 -- INV:gen:E.loadArgs "9.0" 
 -- $FloatLiteral:loadArgs: "9.0"  
 -- INV:gen:after:E.loadArgs "9.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "9.0" 
 -- $FloatLiteral:invoke: "9.0"  
 pushFloatConst 9.000000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "/  : {   %basic 121;   in V: var float;   out R: var float" >E:"/ 5.0":descNo:99} 
 -- ptn:loadArgs:E "/ 5.0" 
 -- {(ObjectInvocation_Binary; (name: "/"); (Arguments;  (ObjectGenerator;   (Invocation;    (FloatLiteral 5.0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "5.0" 
 -- E: "ObjectGenerator" 5.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "/ 5.0" "ObjectInvocation_Binary" ActArg:  "5.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "/ 5.0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "5.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "5.0" 
 -- OG:before:super.gen: "5.0" 
 -- $Invocation:gen: "5.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "5.0" 
 -- isConstant: "Invocation" "5.0" 
 -- needorigin: "5.0" 
 -- needOrigin:E: "5.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "5.0" E:  "5.0" 
 -- INV:gen:E.loadArgs "5.0" 
 -- $FloatLiteral:loadArgs: "5.0"  
 -- INV:gen:after:E.loadArgs "5.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "5.0" 
 -- $FloatLiteral:invoke: "5.0"  
 pushFloatConst 5.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "5.0" :isBasicVal: true 
 -- case:B: 5.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "/ 5.0" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "9.0 / 5.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "9.0 / 5.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:invoke: "9.0 / 5.0"  
 -- BinaryExp:invoke: "9.0" rec: "9.0 / 5.0" 
 -- M: "/ 5.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "/ 5.0" >rec:"9.0" ATd:"pattern" E:"/ 5.0" E.ATd:"/  " unique:"False" 
 -- OI:invoke: "/ 5.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:9.0 
 -- origin:isValueObj "float" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:9.0 
 -- OI:invoke:B: "/ 5.0" E: "/ 5.0"  rec: "9.0"  useRtnV: true "/  : {   %basic 121;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern /   
 -- $pattern:invoke: "/  : {   %basic 121;   in V: var float;   out R: var float" E: "/ 5.0" useRTNv: "True"} 
 -- ptn:invoke: "/  " E: "/ 5.0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "9.0" E: "/ 5.0" 
 -- arg:float 
 fdiv
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"/ 5.0":rec:9.0 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"/ 5.0":rec:9.0 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: / 5.0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "(9.0 / 5.0)" :isBasicVal: true 
 -- case:B: (9.0 / 5.0) ObjectGenerator 9 121 121 false false 
 -- end:loadArgs:NonVirt: "* (9.0 / 5.0)" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- INV:gen:after:E.loadArgs "base.magnitude * (9.0 / 5.0)" 
 -- OIadr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- IV:E.invoke:useRtnVal: true E: BinOp "base.magnitude * (9.0 / 5.0)" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":r ... 
 -- $BinOp:invoke: "base.magnitude * (9.0 / 5.0)"  
 -- BinaryExp:invoke: "base.magnitude" rec: "base.magnitude * (9.0 / 5.0)" 
 -- M: "* (9.0 / 5.0)" :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base 
 -- $ObjectInvocation_Binary:invoke: "* (9.0 / 5.0)" >rec:"base.magnitude" ATd:"pattern" E:"* (9.0 / 5.0)" E.ATd:"*  " unique:"False" 
 -- OI:invoke: "* (9.0 / 5.0)" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base.magnitude 
 -- origin:isValueObj "float" 
 -- :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"magnitude":rec:base.magnitude 
 -- OI:invoke:B: "* (9.0 / 5.0)" E: "* (9.0 / 5.0)"  rec: "base.magnitude"  useRtnV: true "*  : {   %basic 112;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern *   
 -- $pattern:invoke: "*  : {   %basic 112;   in V: var float;   out R: var float" E: "* (9.0 / 5.0)" useRTNv: "True"} 
 -- ptn:invoke: "*  " E: "* (9.0 / 5.0)" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "base.magnitude" E: "* (9.0 / 5.0)" 
 -- arg:other 
 fmult
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* (9.0 / 5.0)":rec:base.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"* (9.0 / 5.0)":rec:base.magnitude 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: * (9.0 / 5.0) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- BinaryExp:loadArgs:after:leftRec.gen: 
 -- $pattern:loadArgs: "+  : {   %basic 109;   in V: var float;   out R: var float" >E:"+ 32.0":descNo:152} 
 -- ptn:loadArgs:E "+ 32.0" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (FloatLiteral 32.0));   (Items descNo: 0 origDescNo: 0))))} 
 -- args: "32.0" 
 -- E: "ObjectGenerator" 32.0 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "+ 32.0" "ObjectInvocation_Binary" ActArg:  "32.0" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ 32.0"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "32.0" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "32.0" 
 -- OG:before:super.gen: "32.0" 
 -- $Invocation:gen: "32.0" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "32.0" 
 -- isConstant: "Invocation" "32.0" 
 -- needorigin: "32.0" 
 -- needOrigin:E: "32.0"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "32.0" E:  "32.0" 
 -- INV:gen:E.loadArgs "32.0" 
 -- $FloatLiteral:loadArgs: "32.0"  
 -- INV:gen:after:E.loadArgs "32.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "32.0" 
 -- $FloatLiteral:invoke: "32.0"  
 pushFloatConst 32.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "32.0" :isBasicVal: true 
 -- case:B: 32.0 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "+ 32.0" 
 -- BinaryExp:loadArgs:end: 
 -- INV:gen:after:E.loadArgs "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: BinOp "(base.magnitude * (9.0 / 5.0)) + 32.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"non ..." 
 -- $BinOp:invoke: "(base.magnitude * (9.0 / 5.0)) + 32.0"  
 -- BinaryExp:invoke: "(base.magnitude * (9.0 / 5.0))" rec: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- M: "+ 32.0" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Binary:invoke: "+ 32.0" >rec:"(base.magnitude * (9.0 / 5.0))" ATd:"pattern" E:"+ 32.0" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ 32.0" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:(base.magnitude * (9.0 / 5.0)) 
 -- origin:isValueObj "float" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:(base.magnitude * (9.0 / 5.0)) 
 -- OI:invoke:B: "+ 32.0" E: "+ 32.0"  rec: "(base.magnitude * (9.0 / 5.0))"  useRtnV: true "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 109;   in V: var float;   out R: var float" E: "+ 32.0" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ 32.0" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "(base.magnitude * (9.0 / 5.0))" E: "+ 32.0" 
 -- arg:float 
 fplus
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ 32.0":rec:(base.magnitude * (9.0 / 5.0)) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"+ 32.0":rec:(base.magnitude * (9.0 / 5.0)) 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + 32.0 :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "magnitude" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- isArgOfAssignI2IwithUniValArg "magnitude := (base.magnitude * (9.0 / 5.0)) + 32.0" arg: "(base.magnitude * (9.0 / 5.0)) + 32.0" ObjectGenerator 
 -- arg.super.arg: "(base.magnitude * (9.0 / 5.0)) + 32.0" BinOp 
 -- recx:BinaryExp:recx: "(base.magnitude * (9.0 / 5.0)) + 32.0" 
 -- M: "+ 32.0" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 109;   in V: var float;   out R: var float}" 
 -- checkInt2IntWithUnitArg:rec: "(base.magnitude * (9.0 / 5.0))" E: "+ 32.0" 
 -- arg:float 
 -- M:arg: "32.0" ObjectGenerator false 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:1 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:T:E:"magnitude":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- Address:store:originIsVal: 
 fovstoreg 1 
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 153 
 -- Items:GenClass: print descNo: 153 isValue: false 
 -- Items:GenClass: print descNo: 51 isValue: false 
 -- Items:GenClass: print descNo: 21 isValue: false 

 CLASS print 153 1 Fahrenheit 146
 -- vdtTableCopy: I:1:51 I:2:0
 -- vdtAdd: inx=2 descInx=153 vDescInx=153 vdtTop: 2 
 -- Store itemArgs: "Fahrenheit".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- super print
 -- push:super.origin: 
 -- isSingularImplSuper: 
 pushThis 
 rpushg iOrigin 1
 pushThis 
 pushg 2 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: -1 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 pushThis 
 pushg 3 
 -- stack: rpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- handleSuperArgs:E: "" theIS: ""Fahrenheit".print" 
 -- super.sig:not:none:superAdj: -1 
 -- $???:loadArgs: ""  
 -- hArgOrg:super: print 
 -- Store itemArgs: "Fahrenheit".print 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 store 3 origin.valueOff
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 store 2 origin.valueOff
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 allocEventQ
 -- vdtAdd: inx=1 descInx=153 vDescInx=51 vdtTop: 2 
 rtnAlloc 1
 toSuper 51
DO:
 mvStack 
 L1:
 -- genclass:stmt: ""Fahrenheit".print" 
 -- $ObjectGenerator:gen: ""Fahrenheit".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""Fahrenheit".print" 
 -- OG:before:super.gen: ""Fahrenheit".print" 
 -- $Invocation:gen: ""Fahrenheit".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""Fahrenheit".print" 
 -- isConstant: "Invocation" ""Fahrenheit".print" 
 -- needorigin: ""Fahrenheit".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""Fahrenheit"" E:  ""Fahrenheit"" 
 -- INV:gen:E.loadArgs ""Fahrenheit"" 
 -- $String::loadArgs: ""Fahrenheit""  
 -- INV:gen:after:E.loadArgs ""Fahrenheit"" 
 -- OIadr: 
 -- $String::invoke: ""Fahrenheit""  
 pushText "Fahrenheit"
 -- IV:gen:checkTail: ""Fahrenheit".print" E: ""Fahrenheit"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""Fahrenheit"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""Fahrenheit""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: -2 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 rtnInner  M
 END OSDV:0 objSize:3 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 148 
 -- Items:GenClass: FasCelsius descNo: 148 isValue: false 
 -- Items:GenClass: FasCelsius descNo: 21 isValue: false 

 CLASS FasCelsius 148 1 Temperature 82
 -- Store itemArgs: in V: var float{out R: var Celsius;R.magnitude := V} 
 -- in V: var float true 9 
 -- DI:store: "V" 
 pushThis 
 fstoreg 2 V
 -- stack: vpop : vTop: -1 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=148 vDescInx=148 vdtTop: 1 
 mvStack 
 -- $var:gen: "in V: var float"  
 -- DI:gen: "in V: var float" DI:isConst: false :isBasicValue: true :primNo: 9 
 -- DI:add:BP1:  V 
 -- $var:gen: "out R: var Celsius"  
 -- DI:gen: "out R: var Celsius" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  R 
 -- $ObjectGenerator:gen: "Celsius" >OGid:"Celsius" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Celsius" 
 -- OG:before:super.gen: "Celsius" 
 -- $Invocation:gen: "Celsius" >useRtnV:"False"superAdj: 0 descNo: 144 
 -- INV:gen: "Celsius" 
 -- isConstant: "Invocation" "Celsius" 
 -- needorigin: "Celsius" 
 -- needOrigin:E: "Celsius"  E.ATd: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Celsius" E:  "Celsius" 
 -- INV:gen:E.loadArgs "Celsius" 
 -- $ObjectInvocation_Unary:loadArgs: "Celsius" >staticOff:0 "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ..."} 
 -- $pattern:loadArgs: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   ..."} 
 -- ptn:loadArgs:E "Celsius" 
 -- {(ObjectInvocation_Unary; (name: "Celsius"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Celsius" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Celsius" 
 -- $ObjectInvocation_Unary:invoke: "Celsius" >rec:"Celsius" ATd:"pattern" isValueObj E:"Celsius" E.ATd:"Celsius" unique:"False" 
 -- OI:invoke: "Celsius" 
 -- 
 -- OI:invoke:B: "Celsius" E: "Celsius"  rec: "Celsius"  useRtnV: false "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fr ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Celsius 
 -- $pattern:invoke: "Celsius: Unit{   %Public;   thisUnit:: Celsius;   toPrimary:: ;      base.magnitude := magnitude;   fromPrimary:: ;      magnitude := base.magnitude;   p ..."} 
 -- ptn:invoke: "Celsius" E: "Celsius" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 adr:none 
 invokeVal  Celsius 144 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Celsius :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "R.magnitude := V" 
 -- $Assign:gen: "R.magnitude := V"  
 -- assign: "R.magnitude := V" 
 -- computeAdr:superAdj: 0 "R.magnitude" 
 -- computeAdr: 1 :rec: "none"  E: "R" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "R"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "R" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "R" >ATd.off:4:on:0:superAdj:0"out R: var Celsius":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "out R: var Celsius" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: Celsius 
 -- before:floatTest:  "out R: var Celsius" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- computeAdr: 2 :rec: "R"  E: "magnitude"  A.E: "R" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "magnitude" >ATd.off:1:on:0:superAdj:0"magnitude: var Float":Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originI ... 
 -- $var:getAdr: "magnitude: var Float" >newOff:1,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T ... 
 -- DI:OG: Float 
 -- before:floatTest:  "magnitude: var Float" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- getAdr:isfloat:A:  magnitude: var Float  A.isValue: true 
 -- computeAdr:isLast:E:  "magnitude" 
 -- AssignmentStatement:gen: "R.magnitude := V" right.label: "ObjectGenerator" "V" 
 -- $ObjectGenerator:gen: "V" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "V" 
 -- OG:before:super.gen: "V" 
 -- $Invocation:gen: "V" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "V" 
 -- isConstant: "Invocation" "V" 
 -- notConst: V in V: var float 
 -- needorigin: "V" 
 -- needOrigin:E: "V"  E.ATd: "in V: var float" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:2:on:0:superAdj:0"in V: var float":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"n ..." 
 -- $var:getAdr: "in V: var float" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F orig ... 
 -- DI:OG: float 
 -- before:floatTest:  "in V: var float" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- getAdr:isfloat:A:  in V: var float  A.isValue: true 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- rec:  "V" E:  "V" 
 -- INV:gen:E.loadArgs "V" 
 -- $ObjectInvocation_Unary:loadArgs: "V" >staticOff:0 "in V: var float" superAdj:0 
 -- $var:loadArgs: "in V: var float" >E:"V" 
 -- $pattern:loadArgs: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float;   ..."} 
 -- ptn:loadArgs:E "V" 
 -- {(ObjectInvocation_Unary; (name: "V"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "V" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "V" :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:- 
 -- $ObjectInvocation_Unary:invoke: "V" >rec:"V" ATd:"var" isValueObj E:"V" E.ATd:"V" unique:"False" 
 -- OI:invoke: "V" 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- OI:invoke:B: "V" E: "V"  rec: "V"  useRtnV: true "in V: var float" 
 -- OI:invoke:before:ATdx.invoke: var V 
 -- $var:invoke: "in V: var float" E: "V">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in V: var float" 
 -- load: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- isCompositeValueObj: false E: "V" "in V: var float" true 
 -- E.ATd.isValueObj: false rec: "V" 
 fpushg 2 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- 
 -- OI:invoke:C: V :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"V":rec:V 
 -- rec: "R" dstE: "magnitude" dstE.ATd: "magnitude: var Float" useRtn: false :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec ... 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: true I: false 
 -- right: "V" 
 -- isArgOfAssignI2IwithUniValArg "R.magnitude := V" arg: "V" ObjectGenerator 
 -- arg.super.arg: "V" ObjectInvocation_Unary 
 -- dstDI: "magnitude: var Float" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:T isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"R":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  true 
 fstoreg 4 address:storeg
 -- stack: vpop : vTop: -2 vTopMax: 0 rTop: 0 rTopMax: 0 V: R: 
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "FasCelsius" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 156 
 -- Items:GenClass: LengthEx descNo: 156 isValue: false 
 -- Items:GenClass: LengthEx descNo: 21 isValue: false 

 CLASS LengthEx 156 1 UnitEx 129
 -- Store itemArgs: L: var Length.Meter{F: var Length.Foot;L := Length.F2M(3.05);"kuk:\n".print;L.print;newline;F.fromPrimary(L.toPrimary);F.print;"kok:\n".print;newline} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=156 vDescInx=156 vdtTop: 1 
 mvStack 
 -- $var:gen: "L: var Length.Meter"  
 -- DI:gen: "L: var Length.Meter" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  L 
 -- $ObjectGenerator:gen: "Length.Meter" >OGid:"Meter" IS.isempty! staticOff=2 descNo=0 superAdj=0 
 -- OG:gen: "Length.Meter" 
 -- OG:before:super.gen: "Length.Meter" 
 -- $Invocation:gen: "Length.Meter" >useRtnV:"False"superAdj: 0 descNo: 74 
 -- INV:gen: "Length.Meter" 
 -- isConstant: "Invocation" "Length.Meter" 
 -- needorigin: "Length.Meter" 
 -- needOrigin:E: "Meter"  E.ATd: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magni ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude :=  ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Meter" 
 -- INV:gen:E.loadArgs "Meter" 
 -- $ObjectInvocation_Unary:loadArgs: "Meter" >staticOff:0 "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPr ..."} 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "Meter" 
 -- {(ObjectInvocation_Unary; (name: "Meter"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Meter" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Meter" 
 -- $ObjectInvocation_Unary:invoke: "Meter" >rec:"Length" ATd:"pattern" isValueObj E:"Meter" E.ATd:"Meter" unique:"False" 
 -- OI:invoke: "Meter" 
 -- 
 -- OI:invoke:B: "Meter" E: "Meter"  rec: "Length"  useRtnV: false "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Meter 
 -- $pattern:invoke: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := magni ..."} 
 -- ptn:invoke: "Meter" E: "Meter" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 2 adr:none 
 invokeVal  Meter 74 1
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Meter :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- $var:gen: "F: var Length.Foot"  
 -- DI:gen: "F: var Length.Foot" DI:isConst: false :isBasicValue: false :primNo: 0 
 -- DI:add:BP4:  F 
 -- $ObjectGenerator:gen: "Length.Foot" >OGid:"Foot" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Length.Foot" 
 -- OG:before:super.gen: "Length.Foot" 
 -- $Invocation:gen: "Length.Foot" >useRtnV:"False"superAdj: 0 descNo: 130 
 -- INV:gen: "Length.Foot" 
 -- isConstant: "Invocation" "Length.Foot" 
 -- needorigin: "Length.Foot" 
 -- needOrigin:E: "Foot"  E.ATd: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ; ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;       ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Length" E:  "Foot" 
 -- INV:gen:E.loadArgs "Foot" 
 -- $ObjectInvocation_Unary:loadArgs: "Foot" >staticOff:0 "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0 ..."} 
 -- $pattern:loadArgs: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ..."} 
 -- ptn:loadArgs:E "Foot" 
 -- {(ObjectInvocation_Unary; (name: "Foot"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Foot" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "Foot" 
 -- $ObjectInvocation_Unary:invoke: "Foot" >rec:"Length" ATd:"pattern" isValueObj E:"Foot" E.ATd:"Foot" unique:"False" 
 -- OI:invoke: "Foot" 
 -- 
 -- OI:invoke:B: "Foot" E: "Foot"  rec: "Length"  useRtnV: false "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnit ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Foot 
 -- $pattern:invoke: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put('! ..."} 
 -- ptn:invoke: "Foot" E: "Foot" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 4 adr:none 
 invokeVal  Foot 130 3
 -- OI:invoke:V: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: Foot :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := Length.F2M(3.05)" 
 -- $Assign:gen: "L := Length.F2M(3.05)"  
 -- assign: "L := Length.F2M(3.05)" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:0:superAdj:0"L: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "L: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := Length.F2M(3.05)" right.label: "ObjectGenerator" "Length.F2M(3.05)" 
 -- $ObjectGenerator:gen: "Length.F2M(3.05)" >OGid:"F2M" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Length.F2M(3.05)" 
 -- OG:before:super.gen: "Length.F2M(3.05)" 
 -- $Invocation:gen: "Length.F2M(3.05)" >useRtnV:"True"superAdj: 0 descNo: 134 
 -- INV:gen: "Length.F2M(3.05)" 
 -- isConstant: "Invocation" "Length.F2M(3.05)" 
 -- needorigin: "Length.F2M(3.05)" 
 -- needOrigin:E: "F2M(3.05)"  E.ATd: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- doNeedOrigin:Ex: "F2M(3.05)" 
 -- computeAdr:superAdj: 0 "Length.F2M(3.05)" 
 -- computeAdr: 1 :rec: "none"  E: "Length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Length" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "LengthEx" on: 1 isValueObj: false 
 -- origin: UnitEx origin:isValueObj: false 
 rpushg LengthEx$156 1
 -- IV:viaIncl:on: 1 "Dimensions"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.Squar ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: true "Dimensions" 
 -- IV:viaIncl:on: 0 "LIB"  org: "%requires Dimensions, Area, Length, Temperature, Velocity, Time{%visible Dimensions;Figure: ;   theArea:< ;      out A: var Area.SquareMeter; ...}" 
 -- viaIncl:son:isFirst: true viaIncl<>none: false "LIB" 
 -- items:goOrigin:encOG: "UnitEx" on: 3 isValueObj: false 
 -- origin: demo origin:isValueObj: false 
 rpushg UnitEx$129 1
 -- items:goOrigin:encOG: "demo" on: 2 isValueObj: false 
 -- origin: workspace origin:isValueObj: false 
 rpushg demo$128 1
 -- items:goOrigin:encOG: "workspace" on: 1 isValueObj: false 
 -- origin: BETAworld origin:isValueObj: false 
 rpushg workspace$127 1
 rpushg LIB 3
 rpushg Dimensions 4
 -- $ObjectInvocation_Unary:getAdr: "Length" >ATd.off:0 (isPtn):on:1:superAdj:0"--Length{":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue ...} 
 -- $ModuleItem:getAdr: "--Length{" } 
 -- $obj:getAdr: "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit::  ..."} 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Length"  ATd: "--Length{}" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "Length"  E: "F2M(3.05)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "F2M(3.05)" >ATd.off:0 (isPtn):on:0:superAdj:0"F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')": ...} 
 -- $pattern:getAdr: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" } 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "Length" >staticOff:0 "--Length{" superAdj:0} 
 -- $ModuleItem:loadArgs: "--Length{" } 
 -- $ObjectInvocation_Unary:invoke: "Length" >rec:"Length" ATd:"ModuleItem" E:"F2M(3.05)" E.ATd:"F2M" unique:"False" 
 -- OI:invoke: "Length" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- OI:invoke:B: "Length" E: "F2M(3.05)"  rec: "Length"  useRtnV: true "--Length{}" 
 -- OI:invoke:before:ATdx.invoke: ModuleItem Length 
 -- $ModuleItem:invoke: "--Length{" E: "F2M(3.05)" useRTNv: "True"} 
 -- ModuleItem:invoke: 
 -- $obj:invoke: "Length: obj Dimension{   %dimension "L";   %requires Area;   %Public;   PrimaryUnit:: Meter;   Meter: Unit;      %unit "m", 1;      %Public;      thisUnit::  ..."} 
 -- Module:invoke:adr<>none: false 
 rpushg Length 3
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- 
 -- OI:invoke:C: Length :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "Length" E: "F2M(3.05)" 
 -- arg:float 
 -- computeAdr:isLast:E:  "F2M(3.05)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- rec:  "Length" E:  "F2M(3.05)" 
 -- INV:gen:E.loadArgs "F2M(3.05)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "F2M(3.05)" >staticOff:0 "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" superAdj:0arg:"3.05 ..."} 
 -- $pattern:loadArgs: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" >E:"F2M(3.05)":descNo:134} 
 -- ptn:loadArgs:E "F2M(3.05)" 
 -- {(ObjectInvocation_KeyWord; (name: "F2M"); (Arguments;  (name: "F2M");  (name: "(");  (ObjectGenerator;   (Invocation;    (FloatLiteral 3.05));   (Items descNo: 0 origDesc ...} 
 -- args: "F2M(3.05)" 
 -- E: "ObjectGenerator" 3.05 
 -- E.arg: "var" in V: var float 
 -- NonVirt: "F2M(3.05)" "ObjectInvocation_KeyWord" ActArg:  "3.05" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "F2M(3.05)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "3.05" >OGid:"float" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "3.05" 
 -- OG:before:super.gen: "3.05" 
 -- $Invocation:gen: "3.05" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "3.05" 
 -- isConstant: "Invocation" "3.05" 
 -- needorigin: "3.05" 
 -- needOrigin:E: "3.05"  E.ATd: "float: Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: va ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %globals;   %basic 9;   _thisBasicValue: var Float;   %public;   +  : ;      %basic 109;      in V: var float;      out R: var float ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "3.05" E:  "3.05" 
 -- INV:gen:E.loadArgs "3.05" 
 -- $FloatLiteral:loadArgs: "3.05"  
 -- INV:gen:after:E.loadArgs "3.05" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: FloatLiteral "3.05" 
 -- $FloatLiteral:invoke: "3.05"  
 pushFloatConst 3.050000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in V: var float" :isBasicVal: true :valueObj: true 
 -- :actArg: "3.05" :isBasicVal: true 
 -- case:B: 3.05 ObjectGenerator 9 9 9 false true 
 -- end:loadArgs:NonVirt: "F2M(3.05)" 
 -- INV:gen:after:E.loadArgs "F2M(3.05)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "F2M(3.05)" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":r ... 
 -- $ObjectInvocation_KeyWord:invoke: "F2M(3.05)" >rec:"Length" ATd:"pattern" E:"F2M(3.05)" E.ATd:"F2M" unique:"False" 
 -- OI:invoke: "F2M(3.05)" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- OI:invoke:B: "F2M(3.05)" E: "F2M(3.05)"  rec: "Length"  useRtnV: true "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')}" 
 -- OI:invoke:before:ATdx.invoke: pattern F2M 
 -- $pattern:invoke: "F2M: {   in V: var float;   out R: var Meter;   put('A');   R.magnitude := V;   put('B')" E: "F2M(3.05)" useRTNv: "True"} 
 -- ptn:invoke: "F2M" E: "F2M(3.05)" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 invoke F2M 134 0 0
 -- global:pushOut: R off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- OI:invoke:C: F2M(3.05) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"F2M(3.05)":rec:Length 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var Length.Meter" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: true dstDI.OG.isUnitValObj: true 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right:isPattern: 
 -- KUK:B: 
 -- right.super.ATd:not:none 
 -- right.super.ATd.OG.super.ATD:none "ObjectGenerator" Length.F2M(3.05) 
 -- pushValue: A: off: 4 size: 5 descNo: -1 Length.F2M(3.05) 
 pushvalue  off:4 size:2 descNo: -1
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:2 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: true  descNo:  0 
 -- Address:store::srcIsVal: false  destIsVal: false  mode: 0 
 -- vassign:A: "L" off: 2 size: 2 mode: 0 
 vassign  2 2 0
 -- assign:adr.store:B: 
 -- genclass:stmt: ""kuk:\n".print" 
 -- $ObjectGenerator:gen: ""kuk:\n".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""kuk:\n".print" 
 -- OG:before:super.gen: ""kuk:\n".print" 
 -- $Invocation:gen: ""kuk:\n".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""kuk:\n".print" 
 -- isConstant: "Invocation" ""kuk:\n".print" 
 -- needorigin: ""kuk:\n".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""kuk:\n"" E:  ""kuk:\n"" 
 -- INV:gen:E.loadArgs ""kuk:\n"" 
 -- $String::loadArgs: ""kuk:\n""  
 -- INV:gen:after:E.loadArgs ""kuk:\n"" 
 -- OIadr: 
 -- $String::invoke: ""kuk:\n""  
 pushText "kuk:\n"
 -- IV:gen:checkTail: ""kuk:\n".print" E: ""kuk:\n"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""kuk:\n"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""kuk:\n""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: 0 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "L.print" 
 -- $ObjectGenerator:gen: "L.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.print" 
 -- OG:before:super.gen: "L.print" 
 -- $Invocation:gen: "L.print" >useRtnV:"False"superAdj: 0 descNo: 80 
 -- INV:gen: "L.print" 
 -- isConstant: "Invocation" "L.print" 
 -- notConst: L L: var Length.Meter 
 -- needorigin: "L.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Meter".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L.print" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:0:superAdj:0"L: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "L: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "print"  A.E: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Meter".print":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue: ...} 
 -- $pattern:getAdr: "print:: {   "Meter".print" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L: var Length.Meter" >E:"L" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "print"  rec: "L"  useRtnV: true "L: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var Length.Meter" E: "print">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- rec:  "L" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Meter".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Meter".print" >E:"print":descNo:80} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"L" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- OI:invoke:B: "print" E: "print"  rec: "L"  useRtnV: false "print:: {   "Meter".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Meter".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- isDI 
 -- isStatic: true rec: "L" 
 invoke print 80 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:L 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "F.fromPrimary(L.toPrimary)" 
 -- $ObjectGenerator:gen: "F.fromPrimary(L.toPrimary)" >OGid:"fromPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "F.fromPrimary(L.toPrimary)" 
 -- OG:before:super.gen: "F.fromPrimary(L.toPrimary)" 
 -- $Invocation:gen: "F.fromPrimary(L.toPrimary)" >useRtnV:"False"superAdj: 0 descNo: 135 
 -- INV:gen: "F.fromPrimary(L.toPrimary)" 
 -- isConstant: "Invocation" "F.fromPrimary(L.toPrimary)" 
 -- notConst: F F: var Length.Foot 
 -- needorigin: "F.fromPrimary(L.toPrimary)" 
 -- needOrigin:E: "fromPrimary(L.toPrimary)"  E.ATd: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- doNeedOrigin:Ex: "fromPrimary(L.toPrimary)" 
 -- origin:isValueObj: "Foot" 
 -- computeAdr:superAdj: 0 "F.fromPrimary(L.toPrimary)" 
 -- computeAdr: 1 :rec: "none"  E: "F" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "F"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "F" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "F" >ATd.off:4:on:0:superAdj:0"F: var Length.Foot":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "F: var Length.Foot" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: Length.Foot 
 -- before:floatTest:  "F: var Length.Foot" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdr: 2 :rec: "F"  E: "fromPrimary(L.toPrimary)"  A.E: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "fromPrimary(L.toPrimary)" >ATd.off:0 (isPtn):on:0:superAdj:0"fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048":Adr:off ...} 
 -- $pattern:getAdr: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "F" >staticOff:0 "F: var Length.Foot" superAdj:0 
 -- $var:loadArgs: "F: var Length.Foot" >E:"F" 
 -- $pattern:loadArgs: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ..."} 
 -- ptn:loadArgs:E "F" 
 -- {(ObjectInvocation_Unary; (name: "F"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "F" >rec:"F" ATd:"var" isValueObj E:"fromPrimary(L.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F" E: "fromPrimary(L.toPrimary)"  rec: "F"  useRtnV: true "F: var Length.Foot" 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: "F: var Length.Foot" E: "fromPrimary(L.toPrimary)">newOff:4 useRTNv: "True" 
 -- DI:invoke: "F: var Length.Foot" 
 -- isValueObj:isAdr: true objSize: 2  rec "F" ,E: "fromPrimary(L.toPrimary)" "ObjectInvocation_KeyWord" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 130
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- 
 -- OI:invoke:C: F :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "F" E: "fromPrimary(L.toPrimary)" 
 -- arg:other 
 -- computeAdr:isLast:E:  "fromPrimary(L.toPrimary)" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- rec:  "F" E:  "fromPrimary(L.toPrimary)" 
 -- INV:gen:E.loadArgs "fromPrimary(L.toPrimary)" 
 -- $ObjectInvocation_KeyWord:loadArgs: "fromPrimary(L.toPrimary)" >staticOff:0 "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" superAdj:0arg:"L.toPrimary ..."} 
 -- $pattern:loadArgs: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" >E:"fromPrimary(L.toPrimary)":descNo:135} 
 -- ptn:loadArgs:E "fromPrimary(L.toPrimary)" 
 -- {(ObjectInvocation_KeyWord; (name: "fromPrimary"); (Arguments;  (name: "fromPrimary");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (nam ...} 
 -- args: "fromPrimary(L.toPrimary)" 
 -- E: "ObjectGenerator" L.toPrimary 
 -- E.arg: "var" in base: var PrimaryUnit 
 -- NonVirt: "fromPrimary(L.toPrimary)" "ObjectInvocation_KeyWord" ActArg:  "L.toPrimary" isValue:  false 
 -- formalArg.OG.isBasicValue: false  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: true 
 -- loadArgs:not:*:  formalArgOf: "fromPrimary(L.toPrimary)"  isCompositeValueObj: true 
 -- $ObjectGenerator:gen: "L.toPrimary" >OGid:"toPrimary" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L.toPrimary" 
 -- OG:before:super.gen: "L.toPrimary" 
 -- $Invocation:gen: "L.toPrimary" >useRtnV:"True"superAdj: 0 descNo: 78 
 -- INV:gen: "L.toPrimary" 
 -- isConstant: "Invocation" "L.toPrimary" 
 -- notConst: L L: var Length.Meter 
 -- needorigin: "L.toPrimary" 
 -- needOrigin:E: "toPrimary"  E.ATd: "toPrimary:: {   base.magnitude := magnitude}" 
 -- doNeedOrigin:Ex: "toPrimary" 
 -- origin:isValueObj: "Meter" 
 -- computeAdr:superAdj: 0 "L.toPrimary" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:2:on:0:superAdj:0"L: var Length.Meter":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F: ... 
 -- $var:getAdr: "L: var Length.Meter" >newOff:2,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- DI:OG: Length.Meter 
 -- before:floatTest:  "L: var Length.Meter" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr: 2 :rec: "L"  E: "toPrimary"  A.E: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "toPrimary" >ATd.off:0 (isPtn):on:0:superAdj:0"toPrimary:: {   base.magnitude := magnitude":Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj ...} 
 -- $pattern:getAdr: "toPrimary:: {   base.magnitude := magnitude" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var Length.Meter" superAdj:0 
 -- $var:loadArgs: "L: var Length.Meter" >E:"L" 
 -- $pattern:loadArgs: "Meter: Unit{   %unit "m", 1;   %Public;   thisUnit:: Meter;   argUnit:: Meter;   resUnit:: Area.SquareMeter;   toPrimary:: ;      base.magnitude := mag ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "toPrimary"  rec: "L"  useRtnV: true "L: var Length.Meter" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var Length.Meter" E: "toPrimary">newOff:2 useRTNv: "True" 
 -- DI:invoke: "L: var Length.Meter" 
 -- isValueObj:isAdr: true objSize: 2  rec "L" ,E: "toPrimary" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 2
 pushc 74
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "L" E: "toPrimary" 
 -- computeAdr:isLast:E:  "toPrimary" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- rec:  "L" E:  "toPrimary" 
 -- INV:gen:E.loadArgs "toPrimary" 
 -- $ObjectInvocation_Unary:loadArgs: "toPrimary" >staticOff:0 "toPrimary:: {   base.magnitude := magnitude" superAdj:0} 
 -- $pattern:loadArgs: "toPrimary:: {   base.magnitude := magnitude" >E:"toPrimary":descNo:78} 
 -- ptn:loadArgs:E "toPrimary" 
 -- {(ObjectInvocation_Unary; (name: "toPrimary"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "toPrimary" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "toPrimary" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec ... 
 -- $ObjectInvocation_Unary:invoke: "toPrimary" >rec:"L" ATd:"pattern" E:"toPrimary" E.ATd:"toPrimary" unique:"False" 
 -- OI:invoke: "toPrimary" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- origin:isValueObj "Meter" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- OI:invoke:B: "toPrimary" E: "toPrimary"  rec: "L"  useRtnV: true "toPrimary:: {   base.magnitude := magnitude}" 
 -- OI:invoke:before:ATdx.invoke: pattern toPrimary 
 -- $pattern:invoke: "toPrimary:: {   base.magnitude := magnitude" E: "toPrimary" useRTNv: "True"} 
 -- ptn:invoke: "toPrimary" E: "toPrimary" ptnKind: 3 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- isDI 
 -- isStatic: true rec: "L" 
 invoke toPrimary 78 0 0
 -- global:pushOut: base off: 4 
 pushc 4
 pushc 0
 -- callInvoke:after:pushOut: 4 
 -- GeneralPTN:invoke:after:callInvoke:X: 4 
 -- GeneralPTN:invoke:end: 4 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- adrx: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- OI:invoke:C: toPrimary :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"toPrimary":rec:L 
 -- formalArg:isPtn: "in base: var PrimaryUnit" :isBasicVal: false :valueObj: true 
 -- :actArg: "L.toPrimary" :isBasicVal: false 
 -- case:B: L.toPrimary ObjectGenerator 0 0 0 true false 
 -- pushValue: D: off: 4 size: 2 0 in base: var PrimaryUnit 
 pushvalue  off:4 size:2 descNo: 0
 pushc 1
 -- end:loadArgs:NonVirt: "fromPrimary(L.toPrimary)" 
 -- INV:gen:after:E.loadArgs "fromPrimary(L.toPrimary)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "fromPrimary(L.toPrimary)" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F ... 
 -- $ObjectInvocation_KeyWord:invoke: "fromPrimary(L.toPrimary)" >rec:"F" ATd:"pattern" E:"fromPrimary(L.toPrimary)" E.ATd:"fromPrimary" unique:"False" 
 -- OI:invoke: "fromPrimary(L.toPrimary)" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- origin:isValueObj "Foot" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- OI:invoke:B: "fromPrimary(L.toPrimary)" E: "fromPrimary(L.toPrimary)"  rec: "F"  useRtnV: false "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048}" 
 -- OI:invoke:before:ATdx.invoke: pattern fromPrimary 
 -- $pattern:invoke: "fromPrimary:: {   put('!');   magnitude := base.magnitude / 0.3048" E: "fromPrimary(L.toPrimary)" useRTNv: "False"} 
 -- ptn:invoke: "fromPrimary" E: "fromPrimary(L.toPrimary)" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- isDI 
 -- isStatic: true rec: "F" 
 invoke fromPrimary 135 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: fromPrimary(L.toPrimary) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"fromPrimary(L.toPrimary)":rec:F 
 -- genclass:stmt: "F.print" 
 -- $ObjectGenerator:gen: "F.print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "F.print" 
 -- OG:before:super.gen: "F.print" 
 -- $Invocation:gen: "F.print" >useRtnV:"False"superAdj: 0 descNo: 136 
 -- INV:gen: "F.print" 
 -- isConstant: "Invocation" "F.print" 
 -- notConst: F F: var Length.Foot 
 -- needorigin: "F.print" 
 -- needOrigin:E: "print"  E.ATd: "print:: {   "Foot".print}" 
 -- doNeedOrigin:Ex: "print" 
 -- origin:isValueObj: "Foot" 
 -- computeAdr:superAdj: 0 "F.print" 
 -- computeAdr: 1 :rec: "none"  E: "F" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "F"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "F" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "F" >ATd.off:4:on:0:superAdj:0"F: var Length.Foot":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "F: var Length.Foot" >newOff:4,isValue:"True""False""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F  ... 
 -- DI:OG: Length.Foot 
 -- before:floatTest:  "F: var Length.Foot" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- computeAdr: 2 :rec: "F"  E: "print"  A.E: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "print" >ATd.off:0 (isPtn):on:0:superAdj:0"print:: {   "Foot".print":Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T ...} 
 -- $pattern:getAdr: "print:: {   "Foot".print" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:T superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "F" >staticOff:0 "F: var Length.Foot" superAdj:0 
 -- $var:loadArgs: "F: var Length.Foot" >E:"F" 
 -- $pattern:loadArgs: "Foot: Unit{   %unit "F", 0.3048;   thisUnit:: Foot;   %Public;   toPrimary:: ;      base.magnitude := (magnitude * 0.3048);   fromPrimary:: ;      put( ..."} 
 -- ptn:loadArgs:E "F" 
 -- {(ObjectInvocation_Unary; (name: "F"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "F" >rec:"F" ATd:"var" isValueObj E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "F" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"F":rec:F 
 -- OI:invoke:B: "F" E: "print"  rec: "F"  useRtnV: true "F: var Length.Foot" 
 -- OI:invoke:before:ATdx.invoke: var F 
 -- $var:invoke: "F: var Length.Foot" E: "print">newOff:4 useRTNv: "True" 
 -- DI:invoke: "F: var Length.Foot" 
 -- isValueObj:isAdr: true objSize: 2  rec "F" ,E: "print" "ObjectInvocation_Unary" E.isCompositeValueObj: false 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- Address:loadAdr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- loadAdr:isValue: 
 -- loadAdr:isValue:originIsPlain 
 pushc 4
 pushc 130
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- 
 -- OI:invoke:C: F :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "F" E: "print" 
 -- computeAdr:isLast:E:  "print" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- rec:  "F" E:  "print" 
 -- INV:gen:E.loadArgs "print" 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print:: {   "Foot".print" superAdj:0} 
 -- $pattern:loadArgs: "print:: {   "Foot".print" >E:"print":descNo:136} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "print" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "print" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:"F" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- origin:isValueObj "Foot" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- OI:invoke:B: "print" E: "print"  rec: "F"  useRtnV: false "print:: {   "Foot".print}" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print:: {   "Foot".print" E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 3 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 3 staticOff: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- isDI 
 -- isStatic: true rec: "F" 
 invoke print 136 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke:X: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 1 V: R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"print":rec:F 
 -- genclass:stmt: ""kok:\n".print" 
 -- $ObjectGenerator:gen: ""kok:\n".print" >OGid:"print" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: ""kok:\n".print" 
 -- OG:before:super.gen: ""kok:\n".print" 
 -- $Invocation:gen: ""kok:\n".print" >useRtnV:"False"superAdj: 0 descNo: 52 
 -- INV:gen: ""kok:\n".print" 
 -- isConstant: "Invocation" ""kok:\n".print" 
 -- needorigin: ""kok:\n".print" 
 -- needOrigin:E: "print"  E.ATd: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- Ex:loadOrign:no:loadOrigin:  "Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- ac ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  ""kok:\n"" E:  ""kok:\n"" 
 -- INV:gen:E.loadArgs ""kok:\n"" 
 -- $String::loadArgs: ""kok:\n""  
 -- INV:gen:after:E.loadArgs ""kok:\n"" 
 -- OIadr: 
 -- $String::invoke: ""kok:\n""  
 pushText "kok:\n"
 -- IV:gen:checkTail: ""kok:\n".print" E: ""kok:\n"" tail: "print"  not isLast: false 
 -- $ObjectInvocation_Unary:loadArgs: "print" >staticOff:0 "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " superAdj:0} 
 -- $pattern:loadArgs: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " >E:"print":descNo:52} 
 -- ptn:loadArgs:E "print" 
 -- {(ObjectInvocation_Unary; (name: "print"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "print" >rec:""kok:\n"" ATd:"pattern" E:"print" E.ATd:"print" unique:"False" 
 -- OI:invoke: "print" 
 -- 
 -- OI:invoke:B: "print" E: "print"  rec: ""kok:\n""  useRtnV: false "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   }" 
 -- OI:invoke:before:ATdx.invoke: pattern print 
 -- $pattern:invoke: "print: {   gogo: ;      "gogo\n".print;   for(1):to(length):repeat;      put(get[inx]);   " E: "print" useRTNv: "False"} 
 -- ptn:invoke: "print" E: "print" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke print 52 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: print :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- genclass:stmt: "newline" 
 -- $ObjectGenerator:gen: "newline" >OGid:"newline" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "newline" 
 -- OG:before:super.gen: "newline" 
 -- $Invocation:gen: "newline" >useRtnV:"False"superAdj: 0 descNo: 98 
 -- INV:gen: "newline" 
 -- isConstant: "Invocation" "newline" 
 -- needorigin: "newline" 
 -- needOrigin:E: "newline"  E.ATd: "newline: {   %globals;   put(10)}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   put(10)}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "newline" E:  "newline" 
 -- INV:gen:E.loadArgs "newline" 
 -- $ObjectInvocation_Unary:loadArgs: "newline" >staticOff:0 "newline: {   %globals;   put(10)" superAdj:0} 
 -- $pattern:loadArgs: "newline: {   %globals;   put(10)" >E:"newline":descNo:98} 
 -- ptn:loadArgs:E "newline" 
 -- {(ObjectInvocation_Unary; (name: "newline"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "newline" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Unary "newline" 
 -- $ObjectInvocation_Unary:invoke: "newline" >rec:"newline" ATd:"pattern" E:"newline" E.ATd:"newline" unique:"False" 
 -- OI:invoke: "newline" 
 -- 
 -- OI:invoke:B: "newline" E: "newline"  rec: "newline"  useRtnV: false "newline: {   %globals;   put(10)}" 
 -- OI:invoke:before:ATdx.invoke: pattern newline 
 -- $pattern:invoke: "newline: {   %globals;   put(10)" E: "newline" useRTNv: "False"} 
 -- ptn:invoke: "newline" E: "newline" ptnKind: 0 useRtnV: false 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 adr:none 
 invoke newline 98 0 0
 -- callInvoke:after:pushOut: -1 
 -- GeneralPTN:invoke:after:callInvoke: -1 
 rpop 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -5 rTopMax: 1 V: R: 
 -- OI:invoke:V: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adrx: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: newline :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 L2:
 -- pushReturn:  "LengthEx" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:5 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 170 
 -- Items:GenClass: + descNo: 170 isValue: false 
 -- Items:GenClass: + descNo: 21 isValue: false 

 CLASS + 170 1 String 10
 -- Store itemArgs: in S: var String{out V: var String;L: var integer;L := Length;doplus: do ;   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   fo ...} 
 -- in S: var String true 5 
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -2 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-2,0)=[]
 -- Store:Origin: 5 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=170 vDescInx=170 vdtTop: 1 
 mvStack 
 -- $var:gen: "in S: var String"  
 -- DI:gen: "in S: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- $var:gen: "out V: var String"  
 -- DI:gen: "out V: var String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out V: var String" 
 pushText ""
 pushThis 
 rstoreg  V 3
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -3 rTopMax: 0 V: R: 
   ;; vTop(0,0)=[] rTop(-3,0)=[]
 -- $var:gen: "L: var integer"  
 -- DI:gen: "L: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  L 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "L := Length" 
 -- $Assign:gen: "L := Length"  
 -- assign: "L := Length" 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:0 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:0:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- PING:String 0 in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.le ...} 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- AssignmentStatement:gen: "L := Length" right.label: "ObjectGenerator" "Length" 
 -- $ObjectGenerator:gen: "Length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "Length" 
 -- OG:before:super.gen: "Length" 
 -- $Invocation:gen: "Length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "Length" 
 -- isConstant: "Invocation" "Length" 
 -- needorigin: "Length" 
 -- needOrigin:E: "Length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "Length" 
 -- computeAdr:superAdj: 0 "Length" 
 -- computeAdr: 1 :rec: "none"  E: "Length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "Length"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "Length" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "+" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg +$170 1
 -- $ObjectInvocation_Unary:getAdr: "Length" >ATd.off:0 (isPtn):on:1:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- PING:String 0 in S: var String{   out V: var String;   L: var integer;   L := Length;   doplus: do ;      e: var integer;      i: var integer;      T: obj Indexed(L + S.le ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "Length"  ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- computeAdr:isLast:E:  "Length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- rec:  "Length" E:  "Length" 
 -- INV:gen:E.loadArgs "Length" 
 -- $ObjectInvocation_Unary:loadArgs: "Length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"Length":descNo:15} 
 -- ptn:loadArgs:E "Length" 
 -- {(ObjectInvocation_Unary; (name: "Length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "Length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "Length" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:- 
 -- $ObjectInvocation_Unary:invoke: "Length" >rec:"Length" ATd:"pattern" E:"Length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "Length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:B: "Length" E: "Length"  rec: "Length"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "Length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "Length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -4 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -4 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- OI:invoke:C: Length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"Length":rec:Length 
 -- rec: "L" dstE: "L" dstE.ATd: "L: var integer" useRtn: false :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "Length" 
 -- isArgOfAssignI2IwithUniValArg "L := Length" arg: "Length" ObjectGenerator 
 -- arg.super.arg: "Length" ObjectInvocation_Unary 
 -- dstDI: "L: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg +$170 4
 -- assign:adr.store:B: 
 -- genclass:stmt: "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];  ...}" 
 -- $do:gen: "doplus: do {   e: var integer;   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;    ..."} 
 -- $ObjectGenerator:gen: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   fo ..."} 
 -- OG:gen: "e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S.leng ...}" 
 pushThis 
 -- before objTmpStack:add:  171   "doplus" 
 invoke doplus 171 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 L2:
 -- pushReturn:  "+" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 171 
 -- Items:GenClass: doplus descNo: 171 isValue: false 
 -- Items:GenClass: doplus descNo: 21 isValue: false 

 CLASS doplus 171 1 + 170
 -- Store itemArgs: e: var integer{i: var integer;T: obj Indexed(L + S.length,Integer);for(1):to(L):repeat;   e := get[inx];   T.put(e):at[inx];;for(1):to(S.length):repeat;    ...} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=171 vDescInx=171 vdtTop: 1 
 mvStack 
 -- $var:gen: "e: var integer"  
 -- DI:gen: "e: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  e 
 -- $var:gen: "i: var integer"  
 -- DI:gen: "i: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  i 
 -- $obj:gen: "T: obj Indexed(L + S.length,Integer)"  
 -- DI:gen: "T: obj Indexed(L + S.length,Integer)" DI:isConst: true :isBasicValue: false :primNo: 114 
 -- DI:add:BP4:  T 
 -- $ObjectGenerator:gen: "Indexed(L + S.length,Integer)" >OGid:"T" IS.isempty! staticOff=4 descNo=0 superAdj=0 
 -- OG:gen: "Indexed(L + S.length,Integer)" 
 -- OG:before:super.gen: "Indexed(L + S.length,Integer)" 
 -- $Invocation:gen: "Indexed(L + S.length,Integer)" >useRtnV:"False"superAdj: 0 descNo: 172 
 -- INV:gen: "Indexed(L + S.length,Integer)" 
 -- isConstant: "Invocation" "Indexed(L + S.length,Integer)" 
 -- needorigin: "Indexed(L + S.length,Integer)" 
 -- needOrigin:E: "Indexed(L + S.length,Integer)"  E.ATd: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 -- IV:after:computeAdr:superAdj: 0 
 -- rec:  "Indexed(L + S.length,Integer)" E:  "Indexed(L + S.length,Integer)" 
 -- INV:gen:E.loadArgs "Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Function:loadArgs: "Indexed(L + S.length,Integer)" >staticOff:0 "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Obje ..."} 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "Indexed(L + S.length,Integer)" 
 -- {(ObjectInvocation_Function; (name: "Indexed"); (Arguments;  (ObjectGenerator;   (Invocation;    (BinOp:+;     (Invocation;      (ObjectInvocation_Unary;       (name: "L") ...} 
 -- args: "(L + S.length,Integer)" 
 -- E: "ObjectGenerator" L + S.length 
 -- E: "ObjectGenerator" Integer 
 -- E.arg: "var" in range: var Integer 
 -- NonVirt: "Indexed(L + S.length,Integer)" "ObjectInvocation_Function" ActArg:  "L + S.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "Indexed(L + S.length,Integer)"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L + S.length" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L + S.length" 
 -- OG:before:super.gen: "L + S.length" 
 -- $Invocation:gen: "L + S.length" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L + S.length" 
 -- isConstant: "Invocation" "L + S.length" 
 -- needorigin: "L + S.length" 
 -- needOrigin:E: "L + S.length"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "L + S.length" 
 -- computeAdr:superAdj: 0 "L + S.length" 
 -- computeAdr: 1 :rec: "none"  E: "L + S.length" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L + S.length"  
 -- $BinOp:loadOrigin: "L + S.length"  
 -- BinaryExp:loadOrigin:empty: "L + S.length" superAdj: 0 
 -- $BinOp:getAdr: "L + S.length"  
 -- E.on: 1 
 -- beforeIsValueObj:E: "L + S.length"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L + S.length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L + S.length" E:  "L + S.length" 
 -- INV:gen:E.loadArgs "L + S.length" 
 -- $BinOp:loadArgs: "L + S.length"  
 -- BinaryExp:loadArgs: "L + S.length" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:1:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 +$170
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L + S.length" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ S.length":descNo:60} 
 -- ptn:loadArgs:E "+ S.length" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "S");     (Arguments));    (ObjectInvocation_U ...} 
 -- args: "S.length" 
 -- E: "ObjectGenerator" S.length 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ S.length" "ObjectInvocation_Binary" ActArg:  "S.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ S.length"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "S.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S.length" 
 -- OG:before:super.gen: "S.length" 
 -- $Invocation:gen: "S.length" >useRtnV:"True"superAdj: 0 descNo: 15 
 -- INV:gen: "S.length" 
 -- isConstant: "Invocation" "S.length" 
 -- notConst: S in S: var String 
 -- needorigin: "S.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 0 "S.length" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:1:superAdj:0"in S: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "in S: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "in S: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "S"  ATd: "in S: var String" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "S"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "in S: var String" superAdj:0 
 -- $var:loadArgs: "in S: var String" >E:"S" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"var" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: var String" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: "in S: var String" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$171 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "S" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- rec:  "S" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:0} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"S" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -2 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "S.length" :isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "+ S.length" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + S.length" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + S.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L + S.length"  
 -- BinaryExp:invoke: "L" rec: "L + S.length" 
 -- M: "+ S.length" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "+ S.length" >rec:"L" ATd:"pattern" E:"+ S.length" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ S.length" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ S.length" E: "+ S.length"  rec: "L"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ S.length" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ S.length" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ S.length" 
 -- arg:other 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ S.length":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + S.length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "in range: var Integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L + S.length" :isBasicVal: true 
 -- case:B: L + S.length ObjectGenerator 1 61 61 false false 
 -- end:loadArgs:NonVirt: "Indexed(L + S.length,Integer)" 
 -- INV:gen:after:E.loadArgs "Indexed(L + S.length,Integer)" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_Function "Indexed(L + S.length,Integer)" 
 -- $ObjectInvocation_Function:invoke: "Indexed(L + S.length,Integer)" >rec:"Indexed(L + S.length,Integer)" ATd:"pattern" E:"Indexed(L + S.length,Integer)" E.ATd:"Indexed" uni ... 
 -- OI:invoke: "Indexed(L + S.length,Integer)" 
 -- 
 -- OI:invoke:B: "Indexed(L + S.length,Integer)" E: "Indexed(L + S.length,Integer)"  rec: "Indexed(L + S.length,Integer)"  useRtnV: false "Indexed: {   %globals;   %basic 114; ...}" 
 -- OI:invoke:before:ATdx.invoke: pattern Indexed 
 -- $pattern:invoke: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];    ..."} 
 -- ptn:invoke: "Indexed" E: "Indexed(L + S.length,Integer)" ptnKind: 0 useRtnV: false 
 pushThis 
 -- ObjTmpStack:add: "Indexed" : "%globals{   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];   p ...}" 
 pushc 1
 allocIndexed doplus$171 172 1 0
 pushThis 
 rstoreg  doplus$171 4
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
   ;; vTop(2,2)=[0/0,0/0] rTop(-4,0)=[]
 -- OI:invoke:V: 
 -- OI:invoke:X: 
 -- OI:invoke:C: Indexed(L + S.length,Integer) :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- $ObjectGenerator:gen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];" >OGid:"for:to:repeat$176" IS.isempty! staticOff=0 descNo=176 superAdj=0} 
 -- OG:gen: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 pushThis 
 -- before objTmpStack:add:  176   "for:to:repeat$176" 
 invoke for:to:repeat$176 176 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- $ObjectGenerator:gen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];" >OGid:"for:to:repeat$178" IS.isempty! staticOff=0 descNo=178 super ...} 
 -- OG:gen: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 pushThis 
 -- before objTmpStack:add:  178   "for:to:repeat$178" 
 invoke for:to:repeat$178 178 0 0
 -- callInvoke:after:pushOut: -1 
 rpop 
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OG:gen:end: :Adr:off:-1 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- genclass:stmt: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- $Assign:gen: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" } 
 -- assign: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr:superAdj: 0 "V" 
 -- computeAdr: 1 :rec: "none"  E: "V" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "V"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "V" >on:1 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- $ObjectInvocation_Unary:getAdr: "V" >ATd.off:3:on:1:superAdj:0"out V: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E: ... 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "out V: var String" 
 -- $var:getAdr: "out V: var String" >newOff:3,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue: ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "V"  ATd: "out V: var String" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr:isLast:E:  "V" 
 -- AssignmentStatement:gen: "V := T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" right.label: "ObjectGenerator" "T.asString{-- V: obj ...}" 
 -- $ObjectGenerator:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >OGid:"asString" IS.isempty! staticOff=0 descNo=0 superAdj=0} 
 -- OG:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OG:before:super.gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- $Invocation:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >useRtnV:"True"superAdj: 0 descNo: 179} 
 -- INV:gen: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- isConstant: "Invocation" "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- needorigin: "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- needOrigin:E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  E.ATd: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- doNeedOrigin:Ex: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr:superAdj: 0 "T.asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:0 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:4:on:0:superAdj:0"T: obj Indexed(L + S.length,Integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- $obj:getAdr: "T: obj Indexed(L + S.length,Integer)" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ... 
 -- E.on: 0 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >ATd.off:0 (isPtn):on:0:superAdj:0"asString: ;   %bas ..."} 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "asString: {   %basic 118;   out S: var LIB.StringLib.String}" 
 -- $pattern:getAdr: "asString: {   %basic 118;   out S: var LIB.StringLib.String" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: obj Indexed(L + S.length,Integer)" superAdj:0 
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)" >E:"T" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"obj" E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" E.ATd:"asString" unique:"Fal ..."} 
 -- OI:invoke: "T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- OI:invoke:B: "T" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: "T: obj Indexed(L + S.length,Integer)" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]">newOff:4 useRTNv: "True"} 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1: ..."} 
 -- isCompositeValueObj: false E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" "asString: {   %basic 118;   out S: var LIB.StringLib. ...}" false 
 -- E.ATd.isValueObj: false rec: "T" 
 rpushg doplus$171 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- computeAdr:isLast:E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- ..."} 
 -- rec:  "T" E:  "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- INV:gen:E.loadArgs "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- $ObjectInvocation_Unary:loadArgs: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >staticOff:0 "asString: ;   %basic 118;   out S: va ..."} 
 -- $pattern:loadArgs: "asString: {   %basic 118;   out S: var LIB.StringLib.String" >E:"asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]":d ...} 
 -- ptn:loadArgs:E "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- {(ObjectInvocation_Unary; (name: "asString"); (Arguments --<12> V: obj Indexed(Length + S.length);<12> V := T[1:length] + S.T[1:S.length]))} 
 -- args: "-- V: obj Indexed(Length + S.length){-- V := T[1:length] + S.T[1:S.length]}" 
 -- INV:gen:after:E.loadArgs "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" :Adr:off:4 size:0 isFloat:F is ... 
 -- $ObjectInvocation_Unary:invoke: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" >rec:"T" ATd:"pattern" E:"asString;-- V: obj Indexed( ..."} 
 -- OI:invoke: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.leng ..."} 
 -- OI:invoke:B: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + ...}"   ... "T ..."   ... true "a ..." 
 -- OI:invoke:before:ATdx.invoke: pattern asString 
 -- $pattern:invoke: "asString: {   %basic 118;   out S: var LIB.StringLib.String" E: "asString;-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]" use ...} 
 -- ptn:invoke: "asString" E: "asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]}" ptnKind: 0 useRtnV: true 
 %asString 118
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:leng ..."} 
 -- 
 -- OI:invoke:C: asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] + S.T[1:S.length]} :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"asString{-- V: obj Indexed(Length + S.length);-- V := T[1:length] +  ..."} 
 -- rec: "V" dstE: "V" dstE.ATd: "out V: var String" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- dstDI.isBasicVal: false dstDI.isValObj: false dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- isValue: false  isAdr: true  descNo:  0 
 rswap 0
 rstoreg  EisNone 3
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -8 rTopMax: 0 V: 0 R: 
   ;; vTop(2,2)=[0/0,0/0] rTop(-8,0)=[]
 -- assign:adr.store:B: 
 L2:
 -- pushReturn:  "doplus" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:4 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 172 
 -- Items:GenClass: Indexed descNo: 172 isValue: false 
 -- Items:GenClass: Indexed descNo: 21 isValue: false 

 CLASS Indexed 172 0 BETA 2
 -- Store itemArgs: %globals{%basic 114;%public;in range: var Integer;in elm:< Object;length: ;   out res: var integer;   res := get[0];put(V: var integer):at[inx: var integer ...} 
 -- in range: var Integer true 1 
 -- DI:store: "range" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=172 vDescInx=172 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%globals"  
 -- $Property:gen: "%basic 114"  
 -- $Property:gen: "%public"  
 -- $var:gen: "in range: var Integer"  
 -- DI:gen: "in range: var Integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  range 
 -- $pattern:gen: "in elm:< Object"  
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%globals" 
 -- $Property:gen: "%globals"  
 -- genclass:stmt: "%basic 114" 
 -- $Property:gen: "%basic 114"  
 -- genclass:stmt: "%public" 
 -- $Property:gen: "%public"  
 L2:
 -- pushReturn:  "Indexed" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:1
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 174 
 -- Items:GenClass: repeat$174 descNo: 174 isValue: false 
 -- Items:GenClass: repeat$174 descNo: 21 isValue: false 

 CLASS repeat$174 174 1 for:to:repeat$176 176
 -- Store itemArgs: e := get[inx]{T.put(e):at[inx]} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=174 vDescInx=174 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "e := get[inx]" 
 -- $Assign:gen: "e := get[inx]"  
 -- assign: "e := get[inx]" 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$174" on: 2 isValueObj: false 
 -- origin: for:to:repeat$176 origin:isValueObj: false 
 rpushg repeat$174$174 1
 -- items:goOrigin:encOG: "for:to:repeat$176" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$176$176 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- AssignmentStatement:gen: "e := get[inx]" right.label: "ObjectGenerator" "get[inx]" 
 -- $ObjectGenerator:gen: "get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "get[inx]" 
 -- OG:before:super.gen: "get[inx]" 
 -- $Invocation:gen: "get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "get[inx]" 
 -- isConstant: "Invocation" "get[inx]" 
 -- needorigin: "get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:pushThis: "get[inx]"  
 pushThis 
 -- $ObjectInvocation_KeyWord:loadOrigin: "get[inx]" >on:4 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$174" on: 4 isValueObj: false 
 -- origin: for:to:repeat$176 origin:isValueObj: false 
 rpushg repeat$174$174 1
 -- items:goOrigin:encOG: "for:to:repeat$176" on: 3 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$176$176 4
 -- items:goOrigin:encOG: "doplus" on: 2 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- items:goOrigin:encOG: "+" on: 1 isValueObj: false 
 -- origin: String origin:isValueObj: false 
 rpushg +$170 1
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:4:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:0 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- E.on: 4 
 -- beforeIsValueObj:E: "get[inx]"  ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- rec:  "get[inx]" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$174" on: 1 isValueObj: false 
 -- origin: for:to:repeat$176 origin:isValueObj: false 
 rpushg repeat$174$174 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$176$176
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"get[inx]" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "get[inx]"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:X: adr: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 0 
 -- OG:gen:end: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:get[inx] 
 -- rec: "e" dstE: "e" dstE.ATd: "e: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "e := get[inx]" arg: "get[inx]" ObjectGenerator 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- dstDI: "e: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$171 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.put(e):at[inx]" 
 -- $ObjectGenerator:gen: "T.put(e):at[inx]" >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T.put(e):at[inx]" 
 -- OG:before:super.gen: "T.put(e):at[inx]" 
 -- $Invocation:gen: "T.put(e):at[inx]" >useRtnV:"False"superAdj: 0 descNo: 175 
 -- INV:gen: "T.put(e):at[inx]" 
 -- isConstant: "Invocation" "T.put(e):at[inx]" 
 -- needorigin: "T.put(e):at[inx]" 
 -- needOrigin:E: "put(e):at[inx]"  E.ATd: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- doNeedOrigin:Ex: "put(e):at[inx]" 
 -- computeAdr:superAdj: 0 "T.put(e):at[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$174" on: 2 isValueObj: false 
 -- origin: for:to:repeat$176 origin:isValueObj: false 
 rpushg repeat$174$174 1
 -- items:goOrigin:encOG: "for:to:repeat$176" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$176$176 4
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:4:on:2:superAdj:0"T: obj Indexed(L + S.length,Integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- $obj:getAdr: "T: obj Indexed(L + S.length,Integer)" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "put(e):at[inx]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "put(e):at[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"put(V: var integer):at[inx: var integer]: {   %basic 115":Adr:off:4 size:0 isFloat:F  ...} 
 -- $pattern:getAdr: "put(V: var integer):at[inx: var integer]: {   %basic 115" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: obj Indexed(L + S.length,Integer)" superAdj:0 
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)" >E:"T" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"obj" E:"put(e):at[inx]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:B: "T" E: "put(e):at[inx]"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: "T: obj Indexed(L + S.length,Integer)" E: "put(e):at[inx]">newOff:4 useRTNv: "True" 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- isCompositeValueObj: false E: "put(e):at[inx]" "put(V: var integer):at[inx: var integer]: {   %basic 115}" false 
 -- E.ATd.isValueObj: false rec: "T" 
 rpushg repeat$174$174 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "put(e):at[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "put(e):at[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- rec:  "T" E:  "put(e):at[inx]" 
 -- INV:gen:E.loadArgs "put(e):at[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(e):at[inx]" >staticOff:0 "put(V: var integer):at[inx: var integer]: {   %basic 115" superAdj:0arg:"e"arg:"inx"} 
 -- $pattern:loadArgs: "put(V: var integer):at[inx: var integer]: {   %basic 115" >E:"put(e):at[inx]":descNo:175} 
 -- ptn:loadArgs:E "put(e):at[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "put:at"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "e");      ...} 
 -- args: "put(e):at[inx]" 
 -- E: "ObjectGenerator" e 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "put(e):at[inx]" "ObjectInvocation_KeyWord" ActArg:  "e" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "e" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "e" 
 -- OG:before:super.gen: "e" 
 -- $Invocation:gen: "e" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "e" 
 -- isConstant: "Invocation" "e" 
 -- notConst: e e: var integer 
 -- needorigin: "e" 
 -- needOrigin:E: "e"  E.ATd: "e: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$174" on: 2 isValueObj: false 
 -- origin: for:to:repeat$176 origin:isValueObj: false 
 rpushg repeat$174$174 1
 -- items:goOrigin:encOG: "for:to:repeat$176" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$176$176 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- rec:  "e" E:  "e" 
 -- INV:gen:E.loadArgs "e" 
 -- $ObjectInvocation_Unary:loadArgs: "e" >staticOff:0 "e: var integer" superAdj:0 
 -- $var:loadArgs: "e: var integer" >E:"e" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "e" 
 -- {(ObjectInvocation_Unary; (name: "e"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "e" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- $ObjectInvocation_Unary:invoke: "e" >rec:"e" ATd:"var" isValueObj E:"e" E.ATd:"e" unique:"False" 
 -- OI:invoke: "e" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:B: "e" E: "e"  rec: "e"  useRtnV: true "e: var integer" 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- $var:invoke: "e: var integer" E: "e">newOff:2 useRTNv: "True" 
 -- DI:invoke: "e: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- isCompositeValueObj: false E: "e" "e: var integer" true 
 -- E.ATd.isValueObj: false rec: "e" 
 pushg 2 doplus$171
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:C: e :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "e" :isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx]" 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "put(e):at[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$174" on: 1 isValueObj: false 
 -- origin: for:to:repeat$176 origin:isValueObj: false 
 rpushg repeat$174$174 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$176$176
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[inx]" 
 -- INV:gen:after:E.loadArgs "put(e):at[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[inx]" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e) ..." 
 -- $ObjectInvocation_KeyWord:invoke: "put(e):at[inx]" >rec:"T" ATd:"pattern" E:"put(e):at[inx]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "put(e):at[inx]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- OI:invoke:B: "put(e):at[inx]" E: "put(e):at[inx]"  rec: "T"  useRtnV: false "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- $pattern:invoke: "put(V: var integer):at[inx: var integer]: {   %basic 115" E: "put(e):at[inx]" useRTNv: "False"} 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(e):at[inx]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 1 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 -- 
 -- OI:invoke:C: put(e):at[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[inx]":rec:T 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 176 
 -- Items:GenClass: for:to:repeat$176 descNo: 176 isValue: false 
 -- Items:GenClass: for:to:repeat$176 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$176 176 4 doplus 171
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];" >staticOff:0 "for(first: var integer):to(last: var integer):repeat{repeat:< ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" L 
 -- E: "ObjectGenerator" e := get[inx]{   T.put(e):at[inx]} 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" "ObjectInvocation_KeyWord" ActArg:  "L" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "L" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "L" 
 -- OG:before:super.gen: "L" 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 4 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:1 superAdj:4 isValueObj:"True" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg doplus$171 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:1:superAdj:4"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:4 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 +$170
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "L" :isBasicVal: true 
 -- case:B: L ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- args:  "repeat:< object" "e := get[inx]{   T.put(e):at[inx]}" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=176 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(L):repeat{   e := get[inx];   T.put(e):at[inx];}" 
 -- vdtAdd: inx=2 descInx=176 vDescInx=174 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 177 
 -- Items:GenClass: repeat$177 descNo: 177 isValue: false 
 -- Items:GenClass: repeat$177 descNo: 21 isValue: false 

 CLASS repeat$177 177 1 for:to:repeat$178 178
 -- Store itemArgs: e := S.get[inx]{i := L + inx;T.put(e):at[i]} 
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=177 vDescInx=177 vdtTop: 1 
 mvStack 
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "e := S.get[inx]" 
 -- $Assign:gen: "e := S.get[inx]"  
 -- assign: "e := S.get[inx]" 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 2 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- items:goOrigin:encOG: "for:to:repeat$178" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$178$178 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- AssignmentStatement:gen: "e := S.get[inx]" right.label: "ObjectGenerator" "S.get[inx]" 
 -- $ObjectGenerator:gen: "S.get[inx]" >OGid:"get" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "S.get[inx]" 
 -- OG:before:super.gen: "S.get[inx]" 
 -- $Invocation:gen: "S.get[inx]" >useRtnV:"True"superAdj: 0 descNo: 16 
 -- INV:gen: "S.get[inx]" 
 -- isConstant: "Invocation" "S.get[inx]" 
 -- notConst: S in S: var String 
 -- needorigin: "S.get[inx]" 
 -- needOrigin:E: "get[inx]"  E.ATd: "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- doNeedOrigin:Ex: "get[inx]" 
 -- computeAdr:superAdj: 0 "S.get[inx]" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:3 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 3 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- items:goOrigin:encOG: "for:to:repeat$178" on: 2 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$178$178 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:3:superAdj:0"in S: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- PING:String 0 e := S.get[inx]{   i := L + inx;   T.put(e):at[i]} 
 -- BOBS:ATd: "in S: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "in S: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- E.on: 3 
 -- beforeIsValueObj:E: "S"  ATd: "in S: var String" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "S"  E: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "get[inx]" >ATd.off:0 (isPtn):on:0:superAdj:0"get[inx: var integer]: {   %basic 117;   out ch: var char":Adr:off:2 size:0 isFloat:F isUni ...} 
 -- $pattern:getAdr: "get[inx: var integer]: {   %basic 117;   out ch: var char" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "in S: var String" superAdj:0 
 -- $var:loadArgs: "in S: var String" >E:"S" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"var" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:B: "S" E: "get[inx]"  rec: "S"  useRtnV: true "in S: var String" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: "in S: var String" E: "get[inx]">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- isCompositeValueObj: false E: "get[inx]" "get[inx: var integer]: {   %basic 117;   out ch: var char}" false 
 -- E.ATd.isValueObj: false rec: "S" 
 rpushg repeat$177$177 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "S" E: "get[inx]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "get[inx]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- rec:  "S" E:  "get[inx]" 
 -- INV:gen:E.loadArgs "get[inx]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "get[inx]" >staticOff:0 "get[inx: var integer]: {   %basic 117;   out ch: var char" superAdj:0arg:"inx"} 
 -- $pattern:loadArgs: "get[inx: var integer]: {   %basic 117;   out ch: var char" >E:"get[inx]":descNo:16} 
 -- ptn:loadArgs:E "get[inx]" 
 -- {(ObjectInvocation_KeyWord; (name: "get"); (Arguments;  (name: "get");  (name: "[");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     ( ...} 
 -- args: "get[inx]" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "get[inx]" "ObjectInvocation_KeyWord" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "get[inx]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 1 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$178$178
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "get[inx]" 
 -- INV:gen:after:E.loadArgs "get[inx]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_KeyWord "get[inx]" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec ... 
 -- $ObjectInvocation_KeyWord:invoke: "get[inx]" >rec:"S" ATd:"pattern" E:"get[inx]" E.ATd:"get[inx: var integer]" unique:"False" 
 -- OI:invoke: "get[inx]" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- OI:invoke:B: "get[inx]" E: "get[inx]"  rec: "S"  useRtnV: true "get[inx: var integer]: {   %basic 117;   out ch: var char}" 
 -- OI:invoke:before:ATdx.invoke: pattern get[inx: var integer] 
 -- $pattern:invoke: "get[inx: var integer]: {   %basic 117;   out ch: var char" E: "get[inx]" useRTNv: "True"} 
 -- ptn:invoke: "get[inx: var integer]" E: "get[inx]" ptnKind: 0 useRtnV: true 
 xpushg  inx 1 0 1
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 0 vTopMax: 1 rTop: -2 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -2 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- 
 -- OI:invoke:C: get[inx] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"get[inx]":rec:S 
 -- rec: "e" dstE: "e" dstE.ATd: "e: var integer" useRtn: false :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: false 
 -- right: "S.get[inx]" 
 -- isArgOfAssignI2IwithUniValArg "e := S.get[inx]" arg: "S.get[inx]" ObjectGenerator 
 -- arg.super.arg: "S" ObjectInvocation_Unary 
 -- arg.super.arg: "get[inx]" ObjectInvocation_KeyWord 
 -- recx: "S" argx: "get[inx]" 
 -- checkInt2IntWithUnitArg:rec: "S" E: "get[inx]" 
 -- arg:other 
 -- dstDI: "e: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$171 2
 -- assign:adr.store:B: 
 -- genclass:stmt: "i := L + inx" 
 -- $Assign:gen: "i := L + inx"  
 -- assign: "i := L + inx" 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 2 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- items:goOrigin:encOG: "for:to:repeat$178" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$178$178 4
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:2:superAdj:0"i: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "i: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- AssignmentStatement:gen: "i := L + inx" right.label: "ObjectGenerator" "L + inx" 
 -- $ObjectGenerator:gen: "L + inx" >OGid:"+" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "L + inx" 
 -- OG:before:super.gen: "L + inx" 
 -- $Invocation:gen: "L + inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L + inx" 
 -- isConstant: "Invocation" "L + inx" 
 -- needorigin: "L + inx" 
 -- needOrigin:E: "L + inx"  E.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- doNeedOrigin:Ex: "L + inx" 
 -- computeAdr:superAdj: 0 "L + inx" 
 -- computeAdr: 1 :rec: "none"  E: "L + inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $BinOp:pushThis: "L + inx"  
 -- $BinOp:loadOrigin: "L + inx"  
 -- BinaryExp:loadOrigin:empty: "L + inx" superAdj: 0 
 -- $BinOp:getAdr: "L + inx"  
 -- E.on: 3 
 -- beforeIsValueObj:E: "L + inx"  ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- computeAdr:isFirst: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- computeAdr:isLast:E:  "L + inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:T:E:"none":rec:- 
 -- rec:  "L + inx" E:  "L + inx" 
 -- INV:gen:E.loadArgs "L + inx" 
 -- $BinOp:loadArgs: "L + inx"  
 -- BinaryExp:loadArgs: "L + inx" superAdj: 0 
 -- $Invocation:gen: "L" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "L" 
 -- isConstant: "Invocation" "L" 
 -- notConst: L L: var integer 
 -- needorigin: "L" 
 -- needOrigin:E: "L"  E.ATd: "L: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "L" 
 -- computeAdr: 1 :rec: "none"  E: "L" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "L"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "L" >on:3 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 3 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- items:goOrigin:encOG: "for:to:repeat$178" on: 2 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$178$178 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- $ObjectInvocation_Unary:getAdr: "L" >ATd.off:4:on:3:superAdj:0"L: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "L: var integer" >newOff:4,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "L: var integer" ObjectGenerator 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- After:U*U: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- E.on: 3 
 -- beforeIsValueObj:E: "L"  ATd: "L: var integer" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- computeAdr:isLast:E:  "L" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- rec:  "L" E:  "L" 
 -- INV:gen:E.loadArgs "L" 
 -- $ObjectInvocation_Unary:loadArgs: "L" >staticOff:0 "L: var integer" superAdj:0 
 -- $var:loadArgs: "L: var integer" >E:"L" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "L" 
 -- {(ObjectInvocation_Unary; (name: "L"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "L" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "L" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:- 
 -- $ObjectInvocation_Unary:invoke: "L" >rec:"L" ATd:"var" isValueObj E:"L" E.ATd:"L" unique:"False" 
 -- OI:invoke: "L" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "L" E: "L"  rec: "L"  useRtnV: true "L: var integer" 
 -- OI:invoke:before:ATdx.invoke: var L 
 -- $var:invoke: "L: var integer" E: "L">newOff:4 useRTNv: "True" 
 -- DI:invoke: "L: var integer" 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- isCompositeValueObj: false E: "L" "L: var integer" true 
 -- E.ATd.isValueObj: false rec: "L" 
 pushg 4 +$170
 -- stack: rpop : vTop: 1 vTopMax: 1 rTop: -3 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 2 vTopMax: 2 rTop: -3 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- 
 -- OI:invoke:C: L :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- left:#I "L + inx" 
 -- BinaryExp:loadArgs:after:leftRec.gen: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $pattern:loadArgs: "+  : {   %basic 61;   in V: var integer;   out R: var integer" >E:"+ inx":descNo:60} 
 -- ptn:loadArgs:E "+ inx" 
 -- {(ObjectInvocation_Binary; (name: "+"); (Arguments;  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "inx");     (Arguments)));   (Items descNo: 0  ...} 
 -- args: "inx" 
 -- E: "ObjectGenerator" inx 
 -- E.arg: "var" in V: var integer 
 -- NonVirt: "+ inx" "ObjectInvocation_Binary" ActArg:  "inx" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "+ inx"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "inx" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "inx" 
 -- OG:before:super.gen: "inx" 
 -- $Invocation:gen: "inx" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "inx" 
 -- isConstant: "Invocation" "inx" 
 -- notConst: inx inx: var integer 
 -- needorigin: "inx" 
 -- needOrigin:E: "inx"  E.ATd: "inx: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "inx" 
 -- computeAdr: 1 :rec: "none"  E: "inx" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "inx"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "inx" >on:1 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 1 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- $ObjectInvocation_Unary:getAdr: "inx" >ATd.off:3:on:1:superAdj:0"inx: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E ... 
 -- $var:getAdr: "inx: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ori ... 
 -- DI:OG: integer 
 -- before:floatTest:  "inx: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- E.on: 1 
 -- beforeIsValueObj:E: "inx"  ATd: "inx: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- computeAdr:isLast:E:  "inx" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- rec:  "inx" E:  "inx" 
 -- INV:gen:E.loadArgs "inx" 
 -- $ObjectInvocation_Unary:loadArgs: "inx" >staticOff:0 "inx: var integer" superAdj:0 
 -- $var:loadArgs: "inx: var integer" >E:"inx" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "inx" 
 -- {(ObjectInvocation_Unary; (name: "inx"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "inx" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "inx" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:- 
 -- $ObjectInvocation_Unary:invoke: "inx" >rec:"inx" ATd:"var" isValueObj E:"inx" E.ATd:"inx" unique:"False" 
 -- OI:invoke: "inx" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- OI:invoke:B: "inx" E: "inx"  rec: "inx"  useRtnV: true "inx: var integer" 
 -- OI:invoke:before:ATdx.invoke: var inx 
 -- $var:invoke: "inx: var integer" E: "inx">newOff:3 useRTNv: "True" 
 -- DI:invoke: "inx: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- isCompositeValueObj: false E: "inx" "inx: var integer" true 
 -- E.ATd.isValueObj: false rec: "inx" 
 pushg 3 for:to:repeat$178$178
 -- stack: rpop : vTop: 2 vTopMax: 2 rTop: -4 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 3 vTopMax: 3 rTop: -4 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- 
 -- OI:invoke:C: inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"inx":rec:inx 
 -- formalArg:isPtn: "in V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "inx" :isBasicVal: true 
 -- case:B: inx ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "+ inx" 
 -- BinaryExp:loadArgs:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- INV:gen:after:E.loadArgs "L + inx" 
 -- OIadr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- IV:E.invoke:useRtnVal: true E: BinOp "L + inx" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $BinOp:invoke: "L + inx"  
 -- BinaryExp:invoke: "L" rec: "L + inx" 
 -- M: "+ inx" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- $ObjectInvocation_Binary:invoke: "+ inx" >rec:"L" ATd:"pattern" E:"+ inx" E.ATd:"+  " unique:"False" 
 -- OI:invoke: "+ inx" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- origin:isValueObj "integer" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"L":rec:L 
 -- OI:invoke:B: "+ inx" E: "+ inx"  rec: "L"  useRtnV: true "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- OI:invoke:before:ATdx.invoke: pattern +   
 -- $pattern:invoke: "+  : {   %basic 61;   in V: var integer;   out R: var integer" E: "+ inx" useRTNv: "True"} 
 -- ptn:invoke: "+  " E: "+ inx" ptnKind: 0 useRtnV: true 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ inx" 
 -- arg:other 
 plus
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"+ inx":rec:L 
 -- adrx: :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- OI:invoke:C: + inx :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- rec: "i" dstE: "i" dstE.ATd: "i: var integer" useRtn: false :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- dstDI.isBasicVal: true dstDI.isValObj: true dstDI.OG.isUnitValObj: false 
 -- right.super.isUnitValObj: false F: false I: true 
 -- right: "L + inx" 
 -- isArgOfAssignI2IwithUniValArg "i := L + inx" arg: "L + inx" ObjectGenerator 
 -- arg.super.arg: "L + inx" BinOp 
 -- recx:BinaryExp:recx: "L + inx" 
 -- M: "+ inx" label: "ObjectInvocation_Binary" M.ATd: "+  : {   %basic 61;   in V: var integer;   out R: var integer}" 
 -- checkInt2IntWithUnitArg:rec: "L" E: "+ inx" 
 -- arg:other 
 -- M:arg: "inx" ObjectGenerator false 
 -- dstDI: "i: var integer" 
 -- assign:adr.store:A: 
 -- store: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- isValue: true  isAdr: false  descNo:  0 
 -- isFloat:D:  false 
 storeg doplus$171 3
 -- assign:adr.store:B: 
 -- genclass:stmt: "T.put(e):at[i]" 
 -- $ObjectGenerator:gen: "T.put(e):at[i]" >OGid:"put:at" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "T.put(e):at[i]" 
 -- OG:before:super.gen: "T.put(e):at[i]" 
 -- $Invocation:gen: "T.put(e):at[i]" >useRtnV:"False"superAdj: 0 descNo: 175 
 -- INV:gen: "T.put(e):at[i]" 
 -- isConstant: "Invocation" "T.put(e):at[i]" 
 -- needorigin: "T.put(e):at[i]" 
 -- needOrigin:E: "put(e):at[i]"  E.ATd: "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- doNeedOrigin:Ex: "put(e):at[i]" 
 -- computeAdr:superAdj: 0 "T.put(e):at[i]" 
 -- computeAdr: 1 :rec: "none"  E: "T" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "T"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "T" >on:2 superAdj:0 isValueObj:"False" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 2 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- items:goOrigin:encOG: "for:to:repeat$178" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$178$178 4
 -- $ObjectInvocation_Unary:getAdr: "T" >ATd.off:4:on:2:superAdj:0"T: obj Indexed(L + S.length,Integer)":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F ... 
 -- $obj:getAdr: "T: obj Indexed(L + S.length,Integer)" >newOff:4,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0  ... 
 -- E.on: 2 
 -- beforeIsValueObj:E: "T"  ATd: "T: obj Indexed(L + S.length,Integer)" 
 -- computeAdr:isFirst: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "T"  E: "put(e):at[i]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_KeyWord:getAdr: "put(e):at[i]" >ATd.off:0 (isPtn):on:0:superAdj:0"put(V: var integer):at[inx: var integer]: {   %basic 115":Adr:off:4 size:0 isFloat:F is ...} 
 -- $pattern:getAdr: "put(V: var integer):at[inx: var integer]: {   %basic 115" } 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "T" >staticOff:0 "T: obj Indexed(L + S.length,Integer)" superAdj:0 
 -- $obj:loadArgs: "T: obj Indexed(L + S.length,Integer)" >E:"T" 
 -- $pattern:loadArgs: "Indexed: {   %globals;   %basic 114;   %public;   in range: var Integer;   in elm:< Object;   length: ;      out res: var integer;      res := get[0];  ..."} 
 -- ptn:loadArgs:E "T" 
 -- {(ObjectInvocation_Unary; (name: "T"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "T" >rec:"T" ATd:"obj" E:"put(e):at[i]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "T" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:B: "T" E: "put(e):at[i]"  rec: "T"  useRtnV: true "T: obj Indexed(L + S.length,Integer)" 
 -- OI:invoke:before:ATdx.invoke: obj T 
 -- $obj:invoke: "T: obj Indexed(L + S.length,Integer)" E: "put(e):at[i]">newOff:4 useRTNv: "True" 
 -- DI:invoke: "T: obj Indexed(L + S.length,Integer)" 
 -- >Object:unique: false 
 -- load: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- isCompositeValueObj: false E: "put(e):at[i]" "put(V: var integer):at[inx: var integer]: {   %basic 115}" false 
 -- E.ATd.isValueObj: false rec: "T" 
 rpushg repeat$177$177 4
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:C: T :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "T" E: "put(e):at[i]" 
 -- arg:other 
 -- computeAdr:isLast:E:  "put(e):at[i]" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- rec:  "T" E:  "put(e):at[i]" 
 -- INV:gen:E.loadArgs "put(e):at[i]" 
 -- $ObjectInvocation_KeyWord:loadArgs: "put(e):at[i]" >staticOff:0 "put(V: var integer):at[inx: var integer]: {   %basic 115" superAdj:0arg:"e"arg:"i"} 
 -- $pattern:loadArgs: "put(V: var integer):at[inx: var integer]: {   %basic 115" >E:"put(e):at[i]":descNo:175} 
 -- ptn:loadArgs:E "put(e):at[i]" 
 -- {(ObjectInvocation_KeyWord; (name: "put:at"); (Arguments;  (name: "put");  (name: "(");  (ObjectGenerator;   (Invocation;    (ObjectInvocation_Unary;     (name: "e");      ...} 
 -- args: "put(e):at[i]" 
 -- E: "ObjectGenerator" e 
 -- E: "ObjectGenerator" i 
 -- E.arg: "var" V: var integer 
 -- NonVirt: "put(e):at[i]" "ObjectInvocation_KeyWord" ActArg:  "e" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "e" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "e" 
 -- OG:before:super.gen: "e" 
 -- $Invocation:gen: "e" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "e" 
 -- isConstant: "Invocation" "e" 
 -- notConst: e e: var integer 
 -- needorigin: "e" 
 -- needOrigin:E: "e"  E.ATd: "e: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "e" 
 -- computeAdr: 1 :rec: "none"  E: "e" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "e"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "e" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 2 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- items:goOrigin:encOG: "for:to:repeat$178" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$178$178 4
 -- $ObjectInvocation_Unary:getAdr: "e" >ATd.off:2:on:2:superAdj:0"e: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "e: var integer" >newOff:2,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "e: var integer" ObjectGenerator 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- After:U*U: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "e"  ATd: "e: var integer" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- computeAdr:isLast:E:  "e" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- rec:  "e" E:  "e" 
 -- INV:gen:E.loadArgs "e" 
 -- $ObjectInvocation_Unary:loadArgs: "e" >staticOff:0 "e: var integer" superAdj:0 
 -- $var:loadArgs: "e: var integer" >E:"e" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "e" 
 -- {(ObjectInvocation_Unary; (name: "e"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "e" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "e" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:- 
 -- $ObjectInvocation_Unary:invoke: "e" >rec:"e" ATd:"var" isValueObj E:"e" E.ATd:"e" unique:"False" 
 -- OI:invoke: "e" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- OI:invoke:B: "e" E: "e"  rec: "e"  useRtnV: true "e: var integer" 
 -- OI:invoke:before:ATdx.invoke: var e 
 -- $var:invoke: "e: var integer" E: "e">newOff:2 useRTNv: "True" 
 -- DI:invoke: "e: var integer" 
 -- load: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- isCompositeValueObj: false E: "e" "e: var integer" true 
 -- E.ATd.isValueObj: false rec: "e" 
 pushg 2 doplus$171
 -- stack: rpop : vTop: 3 vTopMax: 3 rTop: -5 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 4 vTopMax: 4 rTop: -5 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- 
 -- OI:invoke:C: e :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"e":rec:e 
 -- formalArg:isPtn: "V: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "e" :isBasicVal: true 
 -- case:B: e ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i]" 
 -- E.arg: "var" inx: var integer 
 -- NonVirt: "put(e):at[i]" "ObjectInvocation_KeyWord" ActArg:  "i" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "put(e):at[i]"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "i" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=0 
 -- OG:gen: "i" 
 -- OG:before:super.gen: "i" 
 -- $Invocation:gen: "i" >useRtnV:"True"superAdj: 0 
 -- INV:gen: "i" 
 -- isConstant: "Invocation" "i" 
 -- notConst: i i: var integer 
 -- needorigin: "i" 
 -- needOrigin:E: "i"  E.ATd: "i: var integer" 
 -- needOrigin:dataItem:leave 
 -- computeAdr:superAdj: 0 "i" 
 -- computeAdr: 1 :rec: "none"  E: "i" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "i"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "i" >on:2 superAdj:0 isValueObj:"True" 
 -- superAdj:E 
 -- items:goOrigin:encOG: "repeat$177" on: 2 isValueObj: false 
 -- origin: for:to:repeat$178 origin:isValueObj: false 
 rpushg repeat$177$177 1
 -- items:goOrigin:encOG: "for:to:repeat$178" on: 1 isValueObj: false 
 -- origin: doplus origin:isValueObj: false 
 rpushg for:to:repeat$178$178 4
 -- $ObjectInvocation_Unary:getAdr: "i" >ATd.off:3:on:2:superAdj:0"i: var integer":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"no ..." 
 -- $var:getAdr: "i: var integer" >newOff:3,isValue:"True""True""True""True":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F origi ... 
 -- DI:OG: integer 
 -- before:floatTest:  "i: var integer" ObjectGenerator 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- After:U*U: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- E.on: 2 
 -- beforeIsValueObj:E: "i"  ATd: "i: var integer" 
 -- computeAdr:isFirst: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- computeAdr:isLast:E:  "i" 
 -- IV:after:computeAdr:superAdj: 0 :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- rec:  "i" E:  "i" 
 -- INV:gen:E.loadArgs "i" 
 -- $ObjectInvocation_Unary:loadArgs: "i" >staticOff:0 "i: var integer" superAdj:0 
 -- $var:loadArgs: "i: var integer" >E:"i" 
 -- $pattern:loadArgs: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var integer ..."} 
 -- ptn:loadArgs:E "i" 
 -- {(ObjectInvocation_Unary; (name: "i"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "i" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "i" :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:- 
 -- $ObjectInvocation_Unary:invoke: "i" >rec:"i" ATd:"var" isValueObj E:"i" E.ATd:"i" unique:"False" 
 -- OI:invoke: "i" 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- OI:invoke:B: "i" E: "i"  rec: "i"  useRtnV: true "i: var integer" 
 -- OI:invoke:before:ATdx.invoke: var i 
 -- $var:invoke: "i: var integer" E: "i">newOff:3 useRTNv: "True" 
 -- DI:invoke: "i: var integer" 
 -- load: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- isCompositeValueObj: false E: "i" "i: var integer" true 
 -- E.ATd.isValueObj: false rec: "i" 
 pushg 3 doplus$171
 -- stack: rpop : vTop: 4 vTopMax: 4 rTop: -6 rTopMax: 0 V: 0 R: 
 -- stack: vpush : vTop: 5 vTopMax: 5 rTop: -6 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:X: adr: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- 
 -- OI:invoke:C: i :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 3 
 -- OG:gen:end: :Adr:off:3 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:T originIsValue:F:E:"i":rec:i 
 -- formalArg:isPtn: "inx: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "i" :isBasicVal: true 
 -- case:B: i ObjectGenerator 1 0 1 false false 
 -- end:loadArgs:NonVirt: "put(e):at[i]" 
 -- INV:gen:after:E.loadArgs "put(e):at[i]" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: false E: ObjectInvocation_KeyWord "put(e):at[i]" :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):a ..." 
 -- $ObjectInvocation_KeyWord:invoke: "put(e):at[i]" >rec:"T" ATd:"pattern" E:"put(e):at[i]" E.ATd:"put(V: var integer):at[inx: var integer]" unique:"False" 
 -- OI:invoke: "put(e):at[i]" 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- OI:invoke:B: "put(e):at[i]" E: "put(e):at[i]"  rec: "T"  useRtnV: false "put(V: var integer):at[inx: var integer]: {   %basic 115}" 
 -- OI:invoke:before:ATdx.invoke: pattern put(V: var integer):at[inx: var integer] 
 -- $pattern:invoke: "put(V: var integer):at[inx: var integer]: {   %basic 115" E: "put(e):at[i]" useRTNv: "False"} 
 -- ptn:invoke: "put(V: var integer):at[inx: var integer]" E: "put(e):at[i]" ptnKind: 0 useRtnV: false 
 xstoreg  inx 1 0 1
 -- stack: rpop : vTop: 5 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- stack: vpop : vTop: 3 vTopMax: 5 rTop: -7 rTopMax: 0 V: 0 R: 
 -- OI:invoke:V: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:X: adr: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 -- 
 -- OI:invoke:C: put(e):at[i] :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 4 
 -- OG:gen:end: :Adr:off:4 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"put(e):at[i]":rec:T 
 L2:
 -- pushReturn:  
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:1 isIndexed:0
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 178 
 -- Items:GenClass: for:to:repeat$178 descNo: 178 isValue: false 
 -- Items:GenClass: for:to:repeat$178 descNo: 28 isValue: false 
 -- Items:GenClass: for:to:repeat descNo: 21 isValue: false 

 CLASS for:to:repeat$178 178 4 doplus 171
 -- vdtTableCopy: I:1:28 V:2:29
 -- Store itemArgs:  
 -- Store:Origin: 0 
 tstOriginIsNone 
 rstore  4 origin
 -- super for:to:repeat
 -- push:super.origin: 
 -- handleSuperArgs:E: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" theIS: "" 
 -- super.sig:none:superAdj: 4 
 -- $ObjectInvocation_KeyWord:loadArgs: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];" >staticOff:0 "for(first: var integer):to(last: var i ..."} 
 -- $pattern:loadArgs: "for(first: var integer):to(last: var integer):repeat{repeat:< object}: {   %OSDvisibility skipInternal;   %globals inSub;   inx: var integer;   inx :=  ..."} 
 -- ptn:loadArgs:E "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- {(ObjectInvocation_KeyWord; (name: "for:to:repeat"); (Arguments;  (name: "for");  (name: "(");  (ObjectGenerator;   (Invocation;    (ConstLiteral 1));   (Items descNo: 0 o ...} 
 -- args: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- E: "ObjectGenerator" 1 
 -- E: "ObjectGenerator" S.length 
 -- E: "ObjectGenerator" e := S.get[inx]{   i := L + inx;   T.put(e):at[i]} 
 -- E.arg: "var" first: var integer 
 -- NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" "ObjectInvocation_KeyWord" ActArg:  "1" isValue:  true 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "1" >OGid:"integer" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "1" 
 -- OG:before:super.gen: "1" 
 -- $Invocation:gen: "1" >useRtnV:"True"superAdj: 4 
 -- INV:gen: "1" 
 -- isConstant: "Invocation" "1" 
 -- needorigin: "1" 
 -- needOrigin:E: "1"  E.ATd: "integer: value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var  ...}" 
 -- Ex:loadOrign:no:loadOrigin:  "value{   %ID integer;   %basic 1, 32;   %globals;   %public;   _thisBasicValue: var Universal;   +  : ;      %basic 61;      in V: var intege ...}" 
 -- IV:after:computeAdr:superAdj: 4 
 -- rec:  "1" E:  "1" 
 -- INV:gen:E.loadArgs "1" 
 -- $ConstLiteral:loadArgs: "1"  
 -- INV:gen:after:E.loadArgs "1" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ConstLiteral "1" 
 -- $ConstLiteral:invoke: "1"  
 pushc 1
 -- INV:gen:end:off: 
 -- OG:gen:end: 
 -- formalArg:isPtn: "first: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "1" :isBasicVal: true 
 -- case:B: 1 ObjectGenerator 1 1 1 false true 
 -- convDone: false 
 -- end:loadArgs:NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- E.arg: "var" last: var integer 
 -- NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" "ObjectInvocation_KeyWord" ActArg:  "S.length" isValue:  false 
 -- formalArg.OG.isBasicValue: true  formalArg.OG.isValueObj: true 
 --  formalArg.OG.isNonBasicValueObj: false 
 -- loadArgs:not:*:  formalArgOf: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}"  isCompositeValueObj: false 
 -- $ObjectGenerator:gen: "S.length" >OGid:"length" IS.isempty! staticOff=0 descNo=0 superAdj=4 
 -- OG:gen: "S.length" 
 -- OG:before:super.gen: "S.length" 
 -- $Invocation:gen: "S.length" >useRtnV:"True"superAdj: 4 descNo: 15 
 -- INV:gen: "S.length" 
 -- isConstant: "Invocation" "S.length" 
 -- notConst: S in S: var String 
 -- needorigin: "S.length" 
 -- needOrigin:E: "length"  E.ATd: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- doNeedOrigin:Ex: "length" 
 -- computeAdr:superAdj: 4 "S.length" 
 -- computeAdr: 1 :rec: "none"  E: "S" 
 -- :Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:pushThis: "S"  
 pushThis 
 -- $ObjectInvocation_Unary:loadOrigin: "S" >on:1 superAdj:4 isValueObj:"False" 
 -- superAdj:E 
 -- AdjustOrigin:originOff: 4 
 rpushg doplus$171 4
 -- items:goOrigin:encOG: "doplus" on: 1 isValueObj: false 
 -- origin: + origin:isValueObj: false 
 rpushg doplus$171 1
 -- $ObjectInvocation_Unary:getAdr: "S" >ATd.off:2:on:1:superAdj:4"in S: var String":Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F originIsValue:F:E:" ..." 
 -- PING:String 0 e: var integer{   i: var integer;   T: obj Indexed(L + S.length,Integer);   for(1):to(L):repeat;      e := get[inx];      T.put(e):at[inx];   ;   for(1):to(S ...} 
 -- BOBS:ATd: "in S: var String" 
 -- Is not: in Veq: var this(Value) 
 -- $var:getAdr: "in S: var String" >newOff:2,isValue:"False""False""False""False":value_prim:"False":A::Adr:off:0 size:0 isFloat:F isUnitVal:F superAdj:4 isUnique:F isValue:F ... 
 -- E.on: 1 
 -- beforeIsValueObj:E: "S"  ATd: "in S: var String" 
 -- computeAdr:isFirst: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- computeAdr: 2 :rec: "S"  E: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"none":rec:- 
 -- $ObjectInvocation_Unary:getAdr: "length" >ATd.off:0 (isPtn):on:0:superAdj:0"length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length":Adr ...} 
 -- $pattern:getAdr: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" } 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:- 
 -- ptn.isUnitValueObj: false  isFloat:E: false 
 -- $ObjectInvocation_Unary:loadArgs: "S" >staticOff:0 "in S: var String" superAdj:4 
 -- $var:loadArgs: "in S: var String" >E:"S" 
 -- $pattern:loadArgs: "String: Value{   %id "String pattern";   %OSDvisibility disguised;   %basic 5;   %public;   length: ;      out V: var integer;      V := get[0] -- actu ..."} 
 -- ptn:loadArgs:E "S" 
 -- {(ObjectInvocation_Unary; (name: "S"); (Arguments))} 
 -- args: "" 
 -- $ObjectInvocation_Unary:invoke: "S" >rec:"S" ATd:"var" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "S" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "S" E: "length"  rec: "S"  useRtnV: true "in S: var String" 
 -- OI:invoke:before:ATdx.invoke: var S 
 -- $var:invoke: "in S: var String" E: "length">newOff:2 useRTNv: "True" 
 -- DI:invoke: "in S: var String" 
 -- >Object:unique: false 
 -- Address:loadAdr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 rpushg doplus$171 2
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- 
 -- OI:invoke:C: S :unit:  -none-  convFactor:  0.000000
 -- checkInt2IntWithUnitArg:rec: "S" E: "length" 
 -- computeAdr:isLast:E:  "length" 
 -- IV:after:computeAdr:superAdj: 4 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- rec:  "S" E:  "length" 
 -- INV:gen:E.loadArgs "length" 
 -- $ObjectInvocation_Unary:loadArgs: "length" >staticOff:0 "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" superAdj:4} 
 -- $pattern:loadArgs: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" >E:"length":descNo:15} 
 -- ptn:loadArgs:E "length" 
 -- {(ObjectInvocation_Unary; (name: "length"); (Arguments))} 
 -- args: "" 
 -- INV:gen:after:E.loadArgs "length" 
 -- OIadr: 
 -- IV:E.invoke:useRtnVal: true E: ObjectInvocation_Unary "length" :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- $ObjectInvocation_Unary:invoke: "length" >rec:"S" ATd:"pattern" E:"length" E.ATd:"length" unique:"False" 
 -- OI:invoke: "length" 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:B: "length" E: "length"  rec: "S"  useRtnV: true "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length}" 
 -- OI:invoke:before:ATdx.invoke: pattern length 
 -- $pattern:invoke: "length: {   out V: var integer;   V := get[0] -- actually an index error, accessing length" E: "length" useRTNv: "True"} 
 -- ptn:invoke: "length" E: "length" ptnKind: 0 useRtnV: true 
 -- GeneralPTN:invoke:ptnKind: 0 staticOff: 0 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 invoke length 15 0 0
 -- global:pushOut: V off: 2 
 pushg 2 
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 0 V: R: 
 -- stack: vpush : vTop: 1 vTopMax: 1 rTop: -1 rTopMax: 0 V: 0 R: 
 -- callInvoke:after:pushOut: 2 
 -- GeneralPTN:invoke:after:callInvoke: 2 
 -- GeneralPTN:invoke:end: 2 :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:V: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:X: adr: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- adrx: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- OI:invoke:C: length :unit:  -none-  convFactor:  0.000000
 -- INV:gen:end:off: 2 
 -- OG:gen:end: :Adr:off:2 size:0 isFloat:F isUnitVal:F superAdj:0 isUnique:F isValue:F originIsValue:F:E:"length":rec:S 
 -- formalArg:isPtn: "last: var integer" :isBasicVal: true :valueObj: true 
 -- :actArg: "S.length" :isBasicVal: true 
 -- case:B: S.length ObjectGenerator 1 0 0 false false 
 -- end:loadArgs:NonVirt: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- args:  "repeat:< object" "e := S.get[inx]{   i := L + inx;   T.put(e):at[i]}" for:to:repeat 
 -- hArgOrg:super: for:to:repeat 
 -- Store itemArgs:  
 -- last: var integer true 1 
 -- DI:store: "last" 
 pushThis 
 storeg integer$5 2
 -- first: var integer true 1 
 -- DI:store: "first" 
 pushThis 
 storeg integer$5 1
 allocEventQ
 -- vdtAdd: inx=1 descInx=178 vDescInx=28 vdtTop: 2 
 -- $Property:gen: "%OSDvisibility skipInternal"  
 -- $Property:gen: "%globals inSub"  
 -- $var:gen: "inx: var integer"  
 -- DI:gen: "inx: var integer" DI:isConst: false :isBasicValue: true :primNo: 1 
 -- DI:add:BP1:  inx 
 rtnAlloc 1
 toSuper 28
DO:
 mvStack 
 L1:
 L2:
 rtnInner  M
 END OSDV:1 objSize:4 isIndexed:0
 -- Handle VB: "" E: "for(1):to(S.length):repeat{   e := S.get[inx];   i := L + inx;   T.put(e):at[i];}" 
 -- vdtAdd: inx=2 descInx=178 vDescInx=177 vdtTop: 2 
 -- objTmpStack:next:   : done: false 
 -- objTmpStack:next:genClass: 179 
 -- Items:GenClass: asString descNo: 179 isValue: false 
 -- Items:GenClass: asString descNo: 21 isValue: false 

 CLASS asString 179 1 Indexed 172
 -- Store itemArgs: %basic 118{out S: var LIB.StringLib.String} 
 -- Store:Origin: 114 
 tstOriginIsNone 
 rstore  1 origin
 allocEventQ
 -- vdtAdd: inx=1 descInx=179 vDescInx=179 vdtTop: 1 
 mvStack 
 -- $Property:gen: "%basic 118"  
 -- $var:gen: "out S: var LIB.StringLib.String"  
 -- DI:gen: "out S: var LIB.StringLib.String" DI:isConst: false :isBasicValue: false :primNo: 5 
 -- StringVar "out S: var LIB.StringLib.String" 
 pushText ""
 pushThis 
 rstoreg  S 2
 -- stack: rpop : vTop: 0 vTopMax: 0 rTop: -1 rTopMax: 1 V: R: 
   ;; vTop(0,0)=[] rTop(-1,1)=[]
 rtnAlloc 1
DO:
 doEventQ
 mvStack 
 L1:
 -- genclass:stmt: "%basic 118" 
 -- $Property:gen: "%basic 118"  
 L2:
 -- pushReturn:  "asString" 
 setThisStack 
 pushThis 
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0
 -- objTmpStack:next:   : done: false 

 CLASS valProx 180 1 Object 0
 END OSDV:0 objSize:4 isIndexed:0

 CLASS VM 181 0 Object 0
 L1:
 pushThis 
 invoke BETAworld 1 0 1
 stop
 L2:
 rtn(D)
 END OSDV:0 objSize:2 isIndexed:0

 CLASS EventProcessor 182 0 Object 0
 stop
 END OSDV:0 objSize:1 isIndexed:0

 CLASS ThreadStub 183 0 Object 0
DO:
 call(D)ThreadStub
 stop
 END OSDV:0 objSize:1 isIndexed:0
 -- vdtAdd: inx=2 descInx=55 vDescInx=53 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=30 vDescInx=24 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=176 vDescInx=174 vdtTop: 2 
 -- vdtAdd: inx=2 descInx=178 vDescInx=177 vdtTop: 2 

Class BETAworld descInx:1 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	pushthis 
7:	saveBETAworld
8:	mvStack
allocE: 
9:	pushthis 
10:	invoke 2 2 1
16:	rpop 
17:	pushthis 
18:	invoke 33 3 1
24:	rpop 
25:	pushthis 
26:	invoke 127 4 1
32:	rpop 
33:	rtnAlloc 1
doE: 
35:	doEventQ 
36:	mvStack
37:	setThisStack
38:	pushthis 
39:	rtn D


Class BETA descInx:2 objSize:3 originOff: 1 visibility: 2
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 3 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class ascii descInx:3 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushc 10
9:	pushthis 
10:	storeg 2
12:	pushc 13
14:	pushthis 
15:	storeg 3
17:	pushc 0
19:	pushthis 
20:	storeg 4
22:	rtnAlloc 1
doE: 
24:	doEventQ 
25:	mvStack
26:	pushthis 
27:	pushc 10
29:	storeg 5
31:	setThisStack
32:	pushthis 
33:	rtn D


Class Value descInx:4 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class integer descInx:5 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class universal descInx:6 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class char descInx:7 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class ConsoleIF descInx:8 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class put descInx:9 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class String descInx:10 objSize:0 originOff: 0 visibility: 2
storeOrgAndArgsE:
1:	allocEventQ 1
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	setThisStack
9:	pushthis 
10:	rtn D


Class = descInx:11 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 31 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	rtnAlloc 1
doE: 
31:	doEventQ 
32:	mvStack
33:	pushthis 
34:	innerP 2
36:	rpopThisObj
37:	setThisStack
38:	pushthis 
39:	rtn D


Class = descInx:13 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
doE: 
22:	doEventQ 
23:	mvStack
24:	pushthis 
25:	invoke 14 0 0
31:	rpop 
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:14 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 4
27:	pushthis 
28:	pushg 4
30:	pushthis 
31:	rpushg 1
33:	rpushg 2
35:	invoke 15 0 0
41:	pushg 2
43:	ne 
44:	jmpFalse 55
47:	pushthis 
48:	invoke 18 0 0
54:	rpop 
55:	pushthis 
56:	rpushg 1
58:	invoke 23 0 0
64:	pushg 1
66:	storeg 3
68:	pushthis 
69:	invoke 30 0 0
75:	rpop 
76:	setThisStack
77:	pushthis 
78:	rtn D


Class length descInx:15 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	pushc 0
17:	xpushg 1 0 1
21:	storeg 2
23:	setThisStack
24:	pushthis 
25:	rtn D


Class $18 descInx:18 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 1 2 14 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class if:then descInx:20 objSize:1 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class BETAworld descInx:21 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class thenPart#22 descInx:22 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class True descInx:23 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 1
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class repeat$24 descInx:24 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	rpushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xpushg 1 0 1
59:	storeg 3
61:	pushthis 
62:	rpushg 1
64:	rpushg 4
66:	pushg 2
68:	pushthis 
69:	rpushg 1
71:	rpushg 4
73:	pushg 3
75:	ne 
76:	jmpFalse 87
79:	pushthis 
80:	invoke 26 0 0
86:	rpop 
87:	setThisStack
88:	pushthis 
89:	rtn D


Class $26 descInx:26 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 4
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 3 2 14 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class False descInx:27 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushthis 
9:	pushc 0
11:	storeg 1
13:	setThisStack
14:	pushthis 
15:	rtn D


Class for:to:repeat descInx:28 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	pushthis 
5:	storeg 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	pushthis 
16:	pushg 1
18:	storeg 3
20:	pushthis 
21:	invoke 57 0 0
27:	rpop 
28:	setThisStack
29:	pushthis 
30:	rtn D


Class repeat#29 descInx:29 objSize:3 originOff: 0 visibility: 1
storeOrgAndArgsE:
1:	invoke 21 0 0
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class for:to:repeat$30 descInx:30 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 1
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class this descInx:31 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class X_asString descInx:32 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	pushthis 
17:	innerP 2
19:	rpopThisObj
20:	setThisStack
21:	pushthis 
22:	rtn D


Class LIB descInx:33 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 34 3 1
14:	rpop 
15:	pushthis 
16:	invoke 38 4 1
22:	rpop 
23:	pushthis 
24:	invoke 107 5 1
30:	rpop 
31:	rtnAlloc 1
doE: 
33:	doEventQ 
34:	mvStack
35:	setThisStack
36:	pushthis 
37:	rtn D


Class BasicIO descInx:34 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 35 2 1
14:	rpop 
15:	pushthis 
16:	invoke 36 3 1
22:	rpop 
23:	rtnAlloc 1
doE: 
25:	doEventQ 
26:	mvStack
27:	setThisStack
28:	pushthis 
29:	rtn D


Class keyboard descInx:35 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class screen descInx:36 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	invoke 37 2 1
16:	rpop 
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	setThisStack
22:	pushthis 
23:	rtn D


Class Lock descInx:37 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Dimensions descInx:38 objSize:6 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 66 2 1
14:	rpop 
15:	pushthis 
16:	invoke 72 3 1
22:	rpop 
23:	pushthis 
24:	invoke 82 4 1
30:	rpop 
31:	pushthis 
32:	invoke 83 5 1
38:	rpop 
39:	pushthis 
40:	invoke 90 6 1
46:	rpop 
47:	rtnAlloc 1
doE: 
49:	doEventQ 
50:	mvStack
51:	setThisStack
52:	pushthis 
53:	rtn D


Class Dimension descInx:39 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 8
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class Unit descInx:40 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class PrimaryUnit#44 descInx:44 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgL#45 descInx:45 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgR#46 descInx:46 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultRes#47 descInx:47 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 40 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class float descInx:48 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class toPrimary descInx:49 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	allocEventQ 0
10:	mvStack
allocE: 
11:	invokeVal 40 3 0
17:	rtnAlloc 1
doE: 
19:	doEventQ 
20:	mvStack
21:	pushthis 
22:	innerP 2
24:	rpopThisObj
25:	setThisStack
26:	pushthis 
27:	rtn D


Class fromPrimary descInx:50 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 40 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	rtnAlloc 1
doE: 
31:	doEventQ 
32:	mvStack
33:	pushthis 
34:	innerP 2
36:	rpopThisObj
37:	setThisStack
38:	pushthis 
39:	rtn D


Class print descInx:51 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	allocEventQ 0
10:	mvStack
allocE: 
11:	rtnAlloc 1
doE: 
13:	doEventQ 
14:	mvStack
15:	pushText 1
17:	invoke 52 0 0
23:	rpop 
24:	pushthis 
25:	innerP 2
27:	rpopThisObj
28:	pushc 58
30:	%prim put 2
32:	pushthis 
33:	rdouble 
34:	rpushg 1
36:	rswap 0
38:	rdouble 
39:	pushg 2
41:	pushg 3
43:	fovpushg 1
45:	%prim printf 142
47:	vpop 
48:	setThisStack
49:	pushthis 
50:	rtn D


Class print descInx:52 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 55 0 0
18:	rpop 
19:	setThisStack
20:	pushthis 
21:	rtn D


Class repeat$53 descInx:53 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	rpushg 1
18:	pushthis 
19:	rpushg 1
21:	pushg 3
23:	xpushg 1 0 1
27:	%prim put 2
29:	setThisStack
30:	pushthis 
31:	rtn D


Class put descInx:54 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class for:to:repeat$55 descInx:55 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	invoke 15 0 0
17:	pushg 2
19:	pushthis 
20:	storeg 2
22:	pushthis 
23:	storeg 1
25:	allocEventQ 0
allocE: 
27:	rtnAlloc 1
29:	toSuper 28
doE: 
32:	mvStack
33:	rtnInner


Class putFloat descInx:56 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	setThisStack
15:	pushthis 
16:	rtn D


Class _doIt descInx:57 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 2
21:	le
22:	jmpFalse 36
25:	pushthis 
26:	invoke 59 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 62 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class <= descInx:58 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 31 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	rtnAlloc 1
doE: 
31:	doEventQ 
32:	mvStack
33:	setThisStack
34:	pushthis 
35:	rtn D


Class $59 descInx:59 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	invokev 2 0 0
20:	rpop 
21:	pushthis 
22:	rpushg 1
24:	rpushg 1
26:	pushthis 
27:	rpushg 1
29:	rpushg 1
31:	pushg 3
33:	pushc 1
35:	+
36:	storeg 3
38:	break 1 1 57 0
45:	setThisStack
46:	pushthis 
47:	rtn D


Class $62 descInx:62 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushthis 
17:	rpushg 1
19:	rpushg 1
21:	pushg 3
23:	storeg 3
25:	setThisStack
26:	pushthis 
27:	rtn D


Class symbol descInx:63 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	pushText 1
6:	pushthis 
7:	rstoreg 2
9:	rtnAlloc 1
doE: 
11:	doEventQ 
12:	mvStack
13:	pushthis 
14:	innerP 2
16:	rpopThisObj
17:	setThisStack
18:	pushthis 
19:	rtn D


Class gMult descInx:64 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 40 3 0
19:	jmpFalse 31
22:	pushthis 
23:	vassign 2 2 0
28:	jmp 37
31:	invokeVal 40 1 0
37:	tstOriginNone 
38:	rstore 1
40:	allocEventQ 0
42:	mvStack
allocE: 
43:	invokeVal 40 5 0
49:	rtnAlloc 1
doE: 
51:	doEventQ 
52:	mvStack
53:	pushthis 
54:	pushthis 
55:	fpushg 2
57:	pushthis 
58:	fpushg 4
60:	fmult 
61:	fstoreg 6
63:	setThisStack
64:	pushthis 
65:	rtn D


Class Area descInx:66 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#67 descInx:67 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 68 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class SquareMeter descInx:68 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class print descInx:70 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class symbol descInx:71 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class Length descInx:72 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#73 descInx:73 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 74 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Meter descInx:74 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class toPrimary descInx:78 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	invokeVal 40 3 0
32:	rtnAlloc 1
34:	toSuper 49
doE: 
37:	mvStack
38:	pushthis 
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	fstoreg 4
54:	rtnInner


Class fromPrimary descInx:79 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	jmpFalse 29
20:	pushthis 
21:	vassign 4 2 0
26:	jmp 35
29:	invokeVal 40 3 0
35:	tstOriginNone 
36:	rstore 1
38:	store 3
40:	store 2
42:	allocEventQ 0
allocE: 
44:	rtnAlloc 1
46:	toSuper 50
doE: 
49:	mvStack
50:	pushthis 
51:	rdouble 
52:	rpushg 1
54:	rswap 0
56:	rdouble 
57:	pushg 2
59:	pushg 3
61:	pushthis 
62:	fpushg 4
64:	fovstoreg 1
66:	rtnInner


Class print descInx:80 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class symbol descInx:81 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class Temperature descInx:82 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class Time descInx:83 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	rtnInner


Class PrimaryUnit#84 descInx:84 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 85 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class Second descInx:85 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class toPrimary descInx:87 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	invokeVal 40 3 0
32:	rtnAlloc 1
34:	toSuper 49
doE: 
37:	mvStack
38:	pushthis 
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	fstoreg 4
54:	rtnInner


Class fromPrimary descInx:88 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	jmpFalse 29
20:	pushthis 
21:	vassign 4 2 0
26:	jmp 35
29:	invokeVal 40 3 0
35:	tstOriginNone 
36:	rstore 1
38:	store 3
40:	store 2
42:	allocEventQ 0
allocE: 
44:	rtnAlloc 1
46:	toSuper 50
doE: 
49:	mvStack
50:	pushthis 
51:	rdouble 
52:	rpushg 1
54:	rswap 0
56:	rdouble 
57:	pushg 2
59:	pushg 3
61:	pushthis 
62:	fpushg 4
64:	fovstoreg 1
66:	rtnInner


Class print descInx:89 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class Velocity descInx:90 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	rtnAlloc 1
14:	toSuper 39
doE: 
17:	mvStack
18:	pushthis 
19:	invoke 95 0 0
25:	rpop 
26:	rtnInner


Class PrimaryUnit#91 descInx:91 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 96 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgL#92 descInx:92 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 74 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultArgR#93 descInx:93 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 102 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class MultRes#94 descInx:94 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	invoke 96 0 1
7:	pushthis 
8:	rstoreg 2
10:	setThisStack
11:	pushthis 
12:	rpushg 2
14:	rtn D


Class test descInx:95 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 96 1 0
13:	invokeVal 74 3 0
19:	invokeVal 85 5 0
25:	rtnAlloc 1
doE: 
27:	doEventQ 
28:	mvStack
29:	pushthis 
30:	pushc 10
32:	i2f
33:	fstoreg 4
35:	pushthis 
36:	pushc 4
38:	pushc 74
40:	invoke 80 0 0
46:	rpop 
47:	invoke 98 0 0
53:	rpop 
54:	pushthis 
55:	pushc 20
57:	i2f
58:	fstoreg 6
60:	pushthis 
61:	pushc 6
63:	pushc 85
65:	invoke 89 0 0
71:	rpop 
72:	invoke 98 0 0
78:	rpop 
79:	pushthis 
80:	pushthis 
81:	fpushg 4
83:	pushthis 
84:	fpushg 6
86:	fdiv 
87:	fstoreg 2
89:	pushthis 
90:	pushc 2
92:	pushc 96
94:	invoke 100 0 0
100:	rpop 
101:	setThisStack
102:	pushthis 
103:	rtn D


Class MeterPerSecond descInx:96 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class newline descInx:98 objSize:0 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
3:	mvStack
allocE: 
4:	rtnAlloc 1
doE: 
6:	doEventQ 
7:	mvStack
8:	pushc 10
10:	%prim put 2
12:	setThisStack
13:	pushthis 
14:	rtn D


Class print descInx:100 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class symbol descInx:101 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	allocEventQ 0
allocE: 
3:	pushText 5
5:	pushthis 
6:	rstoreg 2
8:	rtnAlloc 1
10:	toSuper 63
doE: 
13:	mvStack
14:	pushthis 
15:	pushText 6
17:	rswap 0
19:	rstoreg 2
21:	rtnInner


Class Minutes descInx:102 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class toPrimary descInx:104 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	invokeVal 40 3 0
32:	rtnAlloc 1
34:	toSuper 49
doE: 
37:	mvStack
38:	pushthis 
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	pushc 60
54:	i2f
55:	fmult 
56:	fstoreg 4
58:	rtnInner


Class fromPrimary descInx:105 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	jmpFalse 29
20:	pushthis 
21:	vassign 4 2 0
26:	jmp 35
29:	invokeVal 40 3 0
35:	tstOriginNone 
36:	rstore 1
38:	store 3
40:	store 2
42:	allocEventQ 0
allocE: 
44:	rtnAlloc 1
46:	toSuper 50
doE: 
49:	mvStack
50:	pushthis 
51:	rdouble 
52:	rpushg 1
54:	rswap 0
56:	rdouble 
57:	pushg 2
59:	pushg 3
61:	pushthis 
62:	fpushg 4
64:	pushc 60
66:	i2f
67:	fdiv 
68:	fovstoreg 1
70:	rtnInner


Class print descInx:106 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class StringLib descInx:107 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	saveStringOrigin
7:	mvStack
allocE: 
8:	rtnAlloc 1
doE: 
10:	doEventQ 
11:	mvStack
12:	setThisStack
13:	pushthis 
14:	rtn D


Class Boolean descInx:108 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
doE: 
1:	rtnV
2:	rtn D


Class <= descInx:109 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	rshiftup 1
3:	tstOriginNone 
4:	rstore 1
6:	allocEventQ 0
8:	pushthis 
9:	rpushg 1
11:	rshiftdown 1
13:	pushthis 
14:	rstoreg 2
16:	tstOriginNone 
17:	rstore 1
19:	allocEventQ 0
21:	mvStack
allocE: 
22:	pushthis 
23:	invoke 110 4 1
29:	rpop 
doE: 
30:	doEventQ 
31:	mvStack
32:	setThisStack
33:	pushthis 
34:	rtn D


Class loop descInx:110 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	pushthis 
13:	rpushg 1
15:	rpushg 1
17:	invoke 15 0 0
23:	pushg 2
25:	storeg 3
27:	pushthis 
28:	pushthis 
29:	rpushg 1
31:	rpushg 2
33:	invoke 15 0 0
39:	pushg 2
41:	storeg 4
43:	pushthis 
44:	pushg 3
46:	pushthis 
47:	pushg 4
49:	lt
50:	jmpFalse 64
53:	pushthis 
54:	invoke 112 0 0
60:	rpop 
61:	jmp 72
64:	pushthis 
65:	invoke 113 0 0
71:	rpop 
72:	pushthis 
73:	invoke 114 0 0
79:	rpop 
80:	setThisStack
81:	pushthis 
82:	rtn D


Class $112 descInx:112 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 3
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class $113 descInx:113 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 4
19:	storeg 2
21:	setThisStack
22:	pushthis 
23:	rtn D


Class matchEq descInx:114 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	invoke 115 0 0
18:	rpop 
19:	pushthis 
20:	invoke 118 0 0
26:	rpop 
27:	pushthis 
28:	invoke 121 0 0
34:	rpop 
35:	setThisStack
36:	pushthis 
37:	rtn D


Class isEmpty descInx:115 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 3
18:	pushc 0
20:	eq 
21:	jmpFalse 32
24:	pushthis 
25:	invoke 116 0 0
31:	rpop 
32:	pushthis 
33:	rpushg 1
35:	rpushg 1
37:	pushg 4
39:	pushc 0
41:	eq 
42:	jmpFalse 53
45:	pushthis 
46:	invoke 117 0 0
52:	rpop 
53:	setThisStack
54:	pushthis 
55:	rtn D


Class $116 descInx:116 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 114 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $117 descInx:117 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	invoke 27 0 0
26:	pushg 1
28:	storeg 3
30:	break 2 2 114 0
37:	setThisStack
38:	pushthis 
39:	rtn D


Class loop descInx:118 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	pushg 2
19:	pushc 1
21:	+
22:	storeg 2
24:	pushthis 
25:	rpushg 1
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushthis 
37:	rpushg 1
39:	pushg 2
41:	xpushg 1 0 1
45:	storeg 3
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	rpushg 1
53:	rpushg 1
55:	rpushg 1
57:	rpushg 2
59:	pushthis 
60:	rpushg 1
62:	pushg 2
64:	xpushg 1 0 1
68:	storeg 4
70:	pushthis 
71:	rpushg 1
73:	pushg 3
75:	pushthis 
76:	rpushg 1
78:	pushg 4
80:	eq 
81:	jmpFalse 92
84:	pushthis 
85:	invoke 119 0 0
91:	rpop 
92:	setThisStack
93:	pushthis 
94:	rtn D


Class $119 descInx:119 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	pushg 2
18:	pushthis 
19:	rpushg 1
21:	rpushg 1
23:	rpushg 1
25:	pushg 2
27:	lt
28:	jmpFalse 39
31:	pushthis 
32:	invoke 120 0 0
38:	rpop 
39:	setThisStack
40:	pushthis 
41:	rtn D


Class $120 descInx:120 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	break 2 1 118 0
18:	setThisStack
19:	pushthis 
20:	rtn D


Class doit descInx:121 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushg 3
16:	pushthis 
17:	rpushg 1
19:	pushg 4
21:	eq 
22:	jmpFalse 36
25:	pushthis 
26:	invoke 122 0 0
32:	rpop 
33:	jmp 44
36:	pushthis 
37:	invoke 123 0 0
43:	rpop 
44:	setThisStack
45:	pushthis 
46:	rtn D


Class $122 descInx:122 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	rpushg 1
27:	pushg 3
29:	pushthis 
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	pushg 4
38:	le
39:	storeg 3
41:	break 2 2 114 0
48:	setThisStack
49:	pushthis 
50:	rtn D


Class $123 descInx:123 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 1
16:	rpushg 1
18:	rpushg 1
20:	pushthis 
21:	rpushg 1
23:	rpushg 1
25:	pushg 3
27:	pushthis 
28:	rpushg 1
30:	rpushg 1
32:	pushg 4
34:	lt
35:	storeg 3
37:	break 2 2 114 0
44:	setThisStack
45:	pushthis 
46:	rtn D


Class puttext descInx:125 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class putint descInx:126 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	rtnAlloc 1
doE: 
12:	doEventQ 
13:	mvStack
14:	pushthis 
15:	innerP 2
17:	rpopThisObj
18:	setThisStack
19:	pushthis 
20:	rtn D


Class workspace descInx:127 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 128 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class demo descInx:128 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	pushthis 
8:	invoke 129 2 1
14:	rpop 
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	setThisStack
20:	pushthis 
21:	rtn D


Class UnitEx descInx:129 objSize:14 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	invokeVal 74 1 0
13:	invokeVal 130 3 0
19:	invokeVal 74 5 0
25:	pushthis 
26:	invoke 133 8 1
32:	rpop 
33:	invokeVal 96 8 0
39:	invokeVal 102 10 0
45:	invokeVal 68 12 0
51:	rtnAlloc 1
doE: 
53:	doEventQ 
54:	mvStack
55:	pushText 1
57:	invoke 52 0 0
63:	rpop 
64:	pushthis 
65:	pushthis 
66:	rpushg 1
68:	rpushg 1
70:	rpushg 1
72:	rpushg 3
74:	rpushg 4
76:	rpushg 3
78:	pushFloatConst 12.000000
87:	invoke 134 0 0
93:	pushc 4
95:	pushc 0
97:	pushValue 4 2
101:	vassign 2 2 0
106:	pushthis 
107:	pushc 2
109:	pushc 74
111:	invoke 80 0 0
117:	rpop 
118:	invoke 98 0 0
124:	rpop 
125:	pushthis 
126:	pushc 4
128:	pushc 130
130:	pushthis 
131:	pushc 2
133:	pushc 74
135:	invoke 78 0 0
141:	pushc 4
143:	pushc 0
145:	pushValue 4 2
149:	pushc 1
151:	invoke 135 0 0
157:	rpop 
158:	pushthis 
159:	pushc 4
161:	pushc 130
163:	invoke 136 0 0
169:	rpop 
170:	invoke 98 0 0
176:	rpop 
177:	pushthis 
178:	pushthis 
179:	rpushg 1
181:	rpushg 1
183:	rpushg 1
185:	rpushg 3
187:	rpushg 4
189:	rpushg 3
191:	pushFloatConst 3.000000
200:	invoke 134 0 0
206:	pushc 4
208:	pushc 0
210:	pushValue 4 2
214:	vassign 6 2 0
219:	pushthis 
220:	rpushg 8
222:	pushthis 
223:	pushc 2
225:	pushc 74
227:	pushValue 2 2
231:	pushc 1
233:	pushthis 
234:	pushc 6
236:	pushc 74
238:	pushValue 6 2
242:	pushc 1
244:	invoke 137 0 0
250:	rpop 
251:	pushthis 
252:	rpushg 8
254:	invoke 141 0 0
260:	rpop 
261:	invoke 98 0 0
267:	rpop 
268:	pushthis 
269:	pushc 3
271:	i2f
272:	fstoreg 11
274:	pushthis 
275:	pushc 11
277:	pushc 102
279:	invoke 106 0 0
285:	rpop 
286:	invoke 98 0 0
292:	rpop 
293:	pushthis 
294:	pushthis 
295:	rpushg 1
297:	rpushg 1
299:	rpushg 1
301:	rpushg 3
303:	rpushg 4
305:	rpushg 6
307:	pushthis 
308:	pushc 2
310:	pushc 74
312:	pushValue 2 2
316:	pushc 1
318:	pushthis 
319:	pushc 11
321:	pushc 102
323:	pushValue 11 2
327:	pushc 1
329:	invoke 142 0 0
335:	pushc 6
337:	pushc 0
339:	pushValue 6 2
343:	vassign 9 2 0
348:	pushthis 
349:	pushc 9
351:	pushc 96
353:	invoke 100 0 0
359:	rpop 
360:	invoke 98 0 0
366:	rpop 
367:	pushText 15
369:	invoke 52 0 0
375:	rpop 
376:	pushthis 
377:	pushc 2
379:	pushc 74
381:	invoke 80 0 0
387:	rpop 
388:	pushText 31
390:	invoke 52 0 0
396:	rpop 
397:	pushthis 
398:	pushc 6
400:	pushc 74
402:	invoke 80 0 0
408:	rpop 
409:	pushText 37
411:	invoke 52 0 0
417:	rpop 
418:	pushthis 
419:	pushc 2
421:	pushc 74
423:	pushthis 
424:	pushc 6
426:	pushc 74
428:	pushValue 6 2
432:	pushc 1
434:	invoke 162 0 0
440:	pushc 6
442:	pushc 0
444:	invoke 80 0 0
450:	rpop 
451:	invoke 98 0 0
457:	rpop 
458:	pushText 42
460:	invoke 52 0 0
466:	rpop 
467:	pushthis 
468:	pushc 2
470:	pushc 74
472:	invoke 80 0 0
478:	rpop 
479:	pushText 58
481:	invoke 52 0 0
487:	rpop 
488:	pushthis 
489:	pushc 6
491:	pushc 74
493:	invoke 80 0 0
499:	rpop 
500:	pushText 64
502:	invoke 52 0 0
508:	rpop 
509:	pushthis 
510:	pushc 2
512:	pushc 74
514:	pushthis 
515:	pushc 6
517:	pushc 74
519:	pushValue 6 2
523:	pushc 1
525:	invoke 166 0 0
531:	pushc 6
533:	pushc 0
535:	invoke 80 0 0
541:	rpop 
542:	invoke 98 0 0
548:	rpop 
549:	pushthis 
550:	pushthis 
551:	fpushg 2
553:	pushthis 
554:	fpushg 6
556:	fmult 
557:	fstoreg 13
559:	pushthis 
560:	pushc 13
562:	pushc 68
564:	invoke 70 0 0
570:	rpop 
571:	invoke 98 0 0
577:	rpop 
578:	pushthis 
579:	invoke 143 0 0
585:	rpop 
586:	pushthis 
587:	invoke 156 0 0
593:	rpop 
594:	pushthis 
595:	pushFloatConst 15.600000
604:	fstoreg 13
606:	pushthis 
607:	pushc 13
609:	pushc 68
611:	invoke 70 0 0
617:	rpop 
618:	invoke 98 0 0
624:	rpop 
625:	setThisStack
626:	pushthis 
627:	rtn D


Class Foot descInx:130 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class Figure descInx:132 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class Rectangle descInx:133 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 74 1 0
18:	invokeVal 74 3 0
24:	rtnAlloc 1
26:	toSuper 132
doE: 
29:	mvStack
30:	rtnInner


Class F2M descInx:134 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	invokeVal 74 3 0
16:	rtnAlloc 1
doE: 
18:	doEventQ 
19:	mvStack
20:	pushc 65
22:	%prim put 2
24:	pushthis 
25:	pushthis 
26:	fpushg 2
28:	fstoreg 4
30:	pushc 66
32:	%prim put 2
34:	setThisStack
35:	pushthis 
36:	rtn D


Class fromPrimary descInx:135 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	jmpFalse 29
20:	pushthis 
21:	vassign 4 2 0
26:	jmp 35
29:	invokeVal 40 3 0
35:	tstOriginNone 
36:	rstore 1
38:	store 3
40:	store 2
42:	allocEventQ 0
allocE: 
44:	rtnAlloc 1
46:	toSuper 50
doE: 
49:	mvStack
50:	pushc 33
52:	%prim put 2
54:	pushthis 
55:	rdouble 
56:	rpushg 1
58:	rswap 0
60:	rdouble 
61:	pushg 2
63:	pushg 3
65:	pushthis 
66:	fpushg 4
68:	pushFloatConst 0.304800
77:	fdiv 
78:	fovstoreg 1
80:	rtnInner


Class print descInx:136 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class set descInx:137 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 74 3 0
19:	jmpFalse 31
22:	pushthis 
23:	vassign 2 2 0
28:	jmp 37
31:	invokeVal 74 1 0
37:	tstOriginNone 
38:	rstore 1
40:	allocEventQ 0
42:	mvStack
allocE: 
43:	rtnAlloc 1
doE: 
45:	doEventQ 
46:	mvStack
47:	pushthis 
48:	rpushg 1
50:	pushthis 
51:	fpushg 2
53:	fstoreg 2
55:	pushthis 
56:	rpushg 1
58:	pushthis 
59:	fpushg 4
61:	fstoreg 4
63:	setThisStack
64:	pushthis 
65:	rtn D


Class print descInx:138 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 68 1 0
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	pushText 1
19:	invoke 52 0 0
25:	rpop 
26:	pushthis 
27:	innerP 3
29:	rpopThisObj
30:	pushText 9
32:	invoke 52 0 0
38:	rpop 
39:	pushthis 
40:	pushthis 
41:	rpushg 1
43:	invokev 2 0 0
47:	pushc 2
49:	pushc 0
51:	pushValue 2 2
55:	vassign 2 2 0
60:	pushthis 
61:	pushc 2
63:	pushc 68
65:	invoke 70 0 0
71:	rpop 
72:	pushthis 
73:	invokev 2 0 0
77:	rpop 
78:	setThisStack
79:	pushthis 
80:	rtn D


Class theArea descInx:139 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 68 1 0
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	pushthis 
18:	innerP 2
20:	rpopThisObj
21:	setThisStack
22:	pushthis 
23:	rtn D


Class printMore descInx:140 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	innerP 2
14:	rpopThisObj
15:	setThisStack
16:	pushthis 
17:	rtn D


Class print descInx:141 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 68 1 0
18:	rtnAlloc 1
20:	toSuper 138
doE: 
23:	mvStack
24:	pushText 16
26:	invoke 52 0 0
32:	rpop 
33:	pushthis 
34:	rpushg 1
36:	pushc 2
38:	pushc 74
40:	invoke 80 0 0
46:	rpop 
47:	pushText 33
49:	invoke 52 0 0
55:	rpop 
56:	pushthis 
57:	rpushg 1
59:	pushc 4
61:	pushc 74
63:	invoke 80 0 0
69:	rpop 
70:	rtnInner


Class mult descInx:142 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 102 3 0
19:	jmpFalse 31
22:	pushthis 
23:	vassign 2 2 0
28:	jmp 37
31:	invokeVal 74 1 0
37:	tstOriginNone 
38:	rstore 1
40:	allocEventQ 0
42:	mvStack
allocE: 
43:	invokeVal 96 5 0
49:	rtnAlloc 1
doE: 
51:	doEventQ 
52:	mvStack
53:	pushthis 
54:	pushthis 
55:	fpushg 2
57:	pushthis 
58:	fpushg 4
60:	fmult 
61:	fstoreg 6
63:	setThisStack
64:	pushthis 
65:	rtn D


Class temperatureEx descInx:143 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 144 1 0
13:	invokeVal 146 3 0
19:	rtnAlloc 1
doE: 
21:	doEventQ 
22:	mvStack
23:	pushthis 
24:	pushthis 
25:	rpushg 1
27:	rpushg 1
29:	rpushg 1
31:	rpushg 1
33:	rpushg 3
35:	rpushg 4
37:	rpushg 4
39:	pushFloatConst 100.000000
48:	invoke 148 0 0
54:	pushc 4
56:	pushc 0
58:	pushValue 4 2
62:	vassign 2 2 0
67:	pushthis 
68:	pushc 2
70:	pushc 144
72:	invoke 149 0 0
78:	rpop 
79:	invoke 98 0 0
85:	rpop 
86:	pushthis 
87:	pushc 4
89:	pushc 146
91:	pushthis 
92:	pushc 2
94:	pushc 144
96:	invoke 150 0 0
102:	pushc 4
104:	pushc 0
106:	pushValue 4 2
110:	pushc 1
112:	invoke 151 0 0
118:	rpop 
119:	pushthis 
120:	pushc 4
122:	pushc 146
124:	invoke 153 0 0
130:	rpop 
131:	invoke 98 0 0
137:	rpop 
138:	pushthis 
139:	pushc 2
141:	pushc 144
143:	pushthis 
144:	pushc 4
146:	pushc 146
148:	invoke 154 0 0
154:	pushc 4
156:	pushc 0
158:	pushValue 4 2
162:	pushc 1
164:	invoke 155 0 0
170:	rpop 
171:	pushthis 
172:	pushc 2
174:	pushc 144
176:	invoke 149 0 0
182:	rpop 
183:	invoke 98 0 0
189:	rpop 
190:	setThisStack
191:	pushthis 
192:	rtn D


Class Celsius descInx:144 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class Fahrenheit descInx:146 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
allocE: 
1:	rtnAlloc 1
3:	toSuper 40
doE: 
6:	rtnInner


Class FasCelsius descInx:148 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	fstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	invokeVal 144 3 0
16:	rtnAlloc 1
doE: 
18:	doEventQ 
19:	mvStack
20:	pushthis 
21:	pushthis 
22:	fpushg 2
24:	fstoreg 4
26:	setThisStack
27:	pushthis 
28:	rtn D


Class print descInx:149 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class toPrimary descInx:150 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	invokeVal 40 3 0
32:	rtnAlloc 1
34:	toSuper 49
doE: 
37:	mvStack
38:	pushthis 
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	fstoreg 4
54:	rtnInner


Class fromPrimary descInx:151 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	jmpFalse 29
20:	pushthis 
21:	vassign 4 2 0
26:	jmp 35
29:	invokeVal 40 3 0
35:	tstOriginNone 
36:	rstore 1
38:	store 3
40:	store 2
42:	allocEventQ 0
allocE: 
44:	rtnAlloc 1
46:	toSuper 50
doE: 
49:	mvStack
50:	pushthis 
51:	rdouble 
52:	rpushg 1
54:	rswap 0
56:	rdouble 
57:	pushg 2
59:	pushg 3
61:	pushthis 
62:	fpushg 4
64:	pushFloatConst 9.000000
73:	pushFloatConst 5.000000
82:	fdiv 
83:	fmult 
84:	pushFloatConst 32.000000
93:	fplus 
94:	fovstoreg 1
96:	rtnInner


Class print descInx:153 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	rtnAlloc 1
28:	toSuper 51
doE: 
31:	mvStack
32:	pushText 14
34:	invoke 52 0 0
40:	rpop 
41:	rtnInner


Class toPrimary descInx:154 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	invokeVal 40 3 0
32:	rtnAlloc 1
34:	toSuper 49
doE: 
37:	mvStack
38:	pushthis 
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	pushFloatConst 32.000000
61:	fminus 
62:	pushFloatConst 5.000000
71:	pushFloatConst 9.000000
80:	fdiv 
81:	fmult 
82:	fstoreg 4
84:	rtnInner


Class fromPrimary descInx:155 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	jmpFalse 29
20:	pushthis 
21:	vassign 4 2 0
26:	jmp 35
29:	invokeVal 40 3 0
35:	tstOriginNone 
36:	rstore 1
38:	store 3
40:	store 2
42:	allocEventQ 0
allocE: 
44:	rtnAlloc 1
46:	toSuper 50
doE: 
49:	mvStack
50:	pushthis 
51:	rdouble 
52:	rpushg 1
54:	rswap 0
56:	rdouble 
57:	pushg 2
59:	pushg 3
61:	pushthis 
62:	fpushg 4
64:	fovstoreg 1
66:	rtnInner


Class LengthEx descInx:156 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 74 1 0
13:	invokeVal 130 3 0
19:	rtnAlloc 1
doE: 
21:	doEventQ 
22:	mvStack
23:	pushthis 
24:	pushthis 
25:	rpushg 1
27:	rpushg 1
29:	rpushg 1
31:	rpushg 1
33:	rpushg 3
35:	rpushg 4
37:	rpushg 3
39:	pushFloatConst 3.050000
48:	invoke 134 0 0
54:	pushc 4
56:	pushc 0
58:	pushValue 4 2
62:	vassign 2 2 0
67:	pushText 1
69:	invoke 52 0 0
75:	rpop 
76:	pushthis 
77:	pushc 2
79:	pushc 74
81:	invoke 80 0 0
87:	rpop 
88:	invoke 98 0 0
94:	rpop 
95:	pushthis 
96:	pushc 4
98:	pushc 130
100:	pushthis 
101:	pushc 2
103:	pushc 74
105:	invoke 78 0 0
111:	pushc 4
113:	pushc 0
115:	pushValue 4 2
119:	pushc 1
121:	invoke 135 0 0
127:	rpop 
128:	pushthis 
129:	pushc 4
131:	pushc 130
133:	invoke 136 0 0
139:	rpop 
140:	pushText 7
142:	invoke 52 0 0
148:	rpop 
149:	invoke 98 0 0
155:	rpop 
156:	setThisStack
157:	pushthis 
158:	rtn D


Class toPrimary descInx:157 objSize:5 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	store 3
6:	store 2
8:	pushthis 
9:	rpushg 1
11:	pushthis 
12:	pushg 2
14:	pushthis 
15:	pushg 3
17:	tstOriginNone 
18:	rstore 1
20:	store 3
22:	store 2
24:	allocEventQ 0
allocE: 
26:	invokeVal 40 3 0
32:	rtnAlloc 1
34:	toSuper 49
doE: 
37:	mvStack
38:	pushthis 
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	pushFloatConst 0.304800
61:	fmult 
62:	fstoreg 4
64:	rtnInner


Class theArea descInx:158 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 68 1 0
18:	rtnAlloc 1
20:	toSuper 139
doE: 
23:	mvStack
24:	pushthis 
25:	pushthis 
26:	rpushg 1
28:	rpushg 1
30:	rpushg 1
32:	rpushg 1
34:	rpushg 1
36:	rpushg 3
38:	rpushg 4
40:	rpushg 2
42:	pushthis 
43:	rpushg 1
45:	pushc 2
47:	pushc 74
49:	pushValue 2 2
53:	pushc 1
55:	pushthis 
56:	rpushg 1
58:	pushc 4
60:	pushc 74
62:	pushValue 4 2
66:	pushc 1
68:	invoke 159 0 0
74:	pushc 6
76:	pushc 0
78:	pushValue 6 2
82:	vassign 2 2 0
87:	rtnInner


Class mult descInx:159 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 74 3 0
19:	jmpFalse 31
22:	pushthis 
23:	vassign 2 2 0
28:	jmp 37
31:	invokeVal 74 1 0
37:	tstOriginNone 
38:	rstore 1
40:	allocEventQ 0
42:	mvStack
allocE: 
43:	invokeVal 68 5 0
49:	rtnAlloc 1
doE: 
51:	doEventQ 
52:	mvStack
53:	pushthis 
54:	pushthis 
55:	fpushg 2
57:	pushthis 
58:	fpushg 4
60:	fmult 
61:	fstoreg 6
63:	setThisStack
64:	pushthis 
65:	rtn D


Class printMore descInx:160 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	pushthis 
5:	rpushg 1
7:	tstOriginNone 
8:	rstore 1
10:	allocEventQ 0
allocE: 
12:	invokeVal 74 1 0
18:	rtnAlloc 1
20:	toSuper 140
doE: 
23:	mvStack
24:	pushText 5
26:	invoke 52 0 0
32:	rpop 
33:	pushthis 
34:	pushthis 
35:	rpushg 1
37:	rpushg 1
39:	invoke 161 0 0
45:	pushc 2
47:	pushc 0
49:	pushValue 2 2
53:	vassign 2 2 0
58:	pushthis 
59:	pushc 2
61:	pushc 74
63:	invoke 80 0 0
69:	rpop 
70:	rtnInner


Class perimeter descInx:161 objSize:3 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	invokeVal 74 1 0
13:	rtnAlloc 1
doE: 
15:	doEventQ 
16:	mvStack
17:	pushthis 
18:	pushthis 
19:	rpushg 1
21:	fpushg 2
23:	pushthis 
24:	rpushg 1
26:	fpushg 4
28:	fplus 
29:	pushFloatConst 2.000000
38:	fmult 
39:	fstoreg 2
41:	setThisStack
42:	pushthis 
43:	rtn D


Class min descInx:162 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 40 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	invokeVal 40 5 0
35:	rtnAlloc 1
doE: 
37:	doEventQ 
38:	mvStack
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	pushthis 
53:	fpushg 4
55:	123
56:	jmpFalse 70
59:	pushthis 
60:	invoke 164 0 0
66:	rpop 
67:	jmp 78
70:	pushthis 
71:	invoke 165 0 0
77:	rpop 
78:	setThisStack
79:	pushthis 
80:	rtn D


Class $164 descInx:164 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	rdouble 
18:	rpushg 1
20:	rswap 0
22:	rdouble 
23:	pushg 2
25:	pushg 3
27:	fovpushg 1
29:	fstoreg 6
31:	setThisStack
32:	pushthis 
33:	rtn D


Class $165 descInx:165 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	fpushg 4
19:	fstoreg 6
21:	setThisStack
22:	pushthis 
23:	rtn D


Class max descInx:166 objSize:7 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	jmpFalse 13
4:	pushthis 
5:	vassign 4 2 0
10:	jmp 19
13:	invokeVal 40 3 0
19:	tstOriginNone 
20:	rstore 1
22:	store 3
24:	store 2
26:	allocEventQ 0
28:	mvStack
allocE: 
29:	invokeVal 40 5 0
35:	rtnAlloc 1
doE: 
37:	doEventQ 
38:	mvStack
39:	pushthis 
40:	rdouble 
41:	rpushg 1
43:	rswap 0
45:	rdouble 
46:	pushg 2
48:	pushg 3
50:	fovpushg 1
52:	pushthis 
53:	fpushg 4
55:	125
56:	jmpFalse 70
59:	pushthis 
60:	invoke 168 0 0
66:	rpop 
67:	jmp 78
70:	pushthis 
71:	invoke 169 0 0
77:	rpop 
78:	setThisStack
79:	pushthis 
80:	rtn D


Class $168 descInx:168 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	rdouble 
18:	rpushg 1
20:	rswap 0
22:	rdouble 
23:	pushg 2
25:	pushg 3
27:	fovpushg 1
29:	fstoreg 6
31:	setThisStack
32:	pushthis 
33:	rtn D


Class $169 descInx:169 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	pushthis 
15:	rpushg 1
17:	fpushg 4
19:	fstoreg 6
21:	setThisStack
22:	pushthis 
23:	rtn D


Class + descInx:170 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	rstoreg 2
4:	tstOriginNone 
5:	rstore 1
7:	allocEventQ 0
9:	mvStack
allocE: 
10:	pushText 1
12:	pushthis 
13:	rstoreg 3
15:	rtnAlloc 1
doE: 
17:	doEventQ 
18:	mvStack
19:	pushthis 
20:	pushthis 
21:	rpushg 1
23:	invoke 15 0 0
29:	pushg 2
31:	storeg 4
33:	pushthis 
34:	invoke 171 0 0
40:	rpop 
41:	setThisStack
42:	pushthis 
43:	rtn D


Class doplus descInx:171 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushthis 
8:	rpushg 1
10:	pushg 4
12:	pushthis 
13:	rpushg 1
15:	rpushg 2
17:	invoke 15 0 0
23:	pushg 2
25:	+
26:	pushthis 
27:	pushc 1
29:	allocIndexed 172 1 0 
34:	pushthis 
35:	rstoreg 4
37:	rtnAlloc 1
doE: 
39:	doEventQ 
40:	mvStack
41:	pushthis 
42:	invoke 176 0 0
48:	rpop 
49:	pushthis 
50:	invoke 178 0 0
56:	rpop 
57:	pushthis 
58:	rpushg 1
60:	pushthis 
61:	rpushg 4
63:	%prim asString 118
65:	rswap 0
67:	rstoreg 3
69:	setThisStack
70:	pushthis 
71:	rtn D


Class Indexed descInx:172 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	storeg 1
4:	allocEventQ 1
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	setThisStack
12:	pushthis 
13:	rtn D


Class repeat$174 descInx:174 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 1
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	rpushg 4
43:	pushthis 
44:	rpushg 1
46:	rpushg 4
48:	pushg 2
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	xstoreg 1 0 1 
59:	setThisStack
60:	pushthis 
61:	rtn D


Class for:to:repeat$176 descInx:176 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	pushg 4
13:	pushthis 
14:	storeg 2
16:	pushthis 
17:	storeg 1
19:	allocEventQ 0
allocE: 
21:	rtnAlloc 1
23:	toSuper 28
doE: 
26:	mvStack
27:	rtnInner


Class repeat$177 descInx:177 objSize:1 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	rtnAlloc 1
doE: 
9:	doEventQ 
10:	mvStack
11:	pushthis 
12:	rpushg 1
14:	rpushg 4
16:	pushthis 
17:	rpushg 1
19:	rpushg 4
21:	rpushg 1
23:	rpushg 2
25:	pushthis 
26:	rpushg 1
28:	pushg 3
30:	xpushg 1 0 1
34:	storeg 2
36:	pushthis 
37:	rpushg 1
39:	rpushg 4
41:	pushthis 
42:	rpushg 1
44:	rpushg 4
46:	rpushg 1
48:	pushg 4
50:	pushthis 
51:	rpushg 1
53:	pushg 3
55:	+
56:	storeg 3
58:	pushthis 
59:	rpushg 1
61:	rpushg 4
63:	rpushg 4
65:	pushthis 
66:	rpushg 1
68:	rpushg 4
70:	pushg 2
72:	pushthis 
73:	rpushg 1
75:	rpushg 4
77:	pushg 3
79:	xstoreg 1 0 1 
83:	setThisStack
84:	pushthis 
85:	rtn D


Class for:to:repeat$178 descInx:178 objSize:4 originOff: 4 visibility: 1
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 4
4:	pushc 1
6:	pushthis 
7:	rpushg 4
9:	rpushg 1
11:	rpushg 2
13:	invoke 15 0 0
19:	pushg 2
21:	pushthis 
22:	storeg 2
24:	pushthis 
25:	storeg 1
27:	allocEventQ 0
allocE: 
29:	rtnAlloc 1
31:	toSuper 28
doE: 
34:	mvStack
35:	rtnInner


Class asString descInx:179 objSize:2 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	tstOriginNone 
2:	rstore 1
4:	allocEventQ 0
6:	mvStack
allocE: 
7:	pushText 1
9:	pushthis 
10:	rstoreg 2
12:	rtnAlloc 1
doE: 
14:	doEventQ 
15:	mvStack
16:	setThisStack
17:	pushthis 
18:	rtn D


Class valProx descInx:180 objSize:4 originOff: 1 visibility: 0
storeOrgAndArgsE:
1:	0


Class VM descInx:181 objSize:2 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	pushthis 
2:	invoke 1 0 1
8:	stop 
9:	rtn D


Class EventProcessor descInx:182 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
1:	stop 


Class ThreadStub descInx:183 objSize:1 originOff: 0 visibility: 0
storeOrgAndArgsE:
doE: 
1:	call D
3:	stop 

