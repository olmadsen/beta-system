ChemicalPlantSystem: obj
   %requires Containers,MapLib,Set
   %include Containers
   Qualification:
      in Q: var integer
      print: {"Qualification:".print; putint(Q)}
   Qualifications: Set.Set(#Qualification)
      print: {scan{current.print}} 
   
   Expert:
      in name: ref StringLib.String   
      in quali: ref Qualifications
      print:
         "Expert:".print
         name.print
         put(':')
         quali.print
         newline 
   Experts: Set.Set(#Expert)
      print: {scan{current.print}}
   
   Alarm:
      in descr: ref StringLib.String
      in reqQuali: ref Qualification
      print:
         "alarm: ".print
         descr.print
         put(':')
         reqQuali.print	 
   Alarms: Set.Set(#Alarm)
      print:
         scan
            current.print	 
            put(',')
         newline
   Period:
      in start: var integer
      in end: var integer
      print:
         "Period:".print
         putint(start)
         put(',')
         putint(end)
         newline 
   Periods: Set.Set(#Period)
      print: {scan{current.print}}
   
   Schedule: MapLib.Map(#Period,#Experts)
      dum: var integer
   
   Plant:
      in theAlarms: ref Alarms
      in theSchedule: ref Schedule
      PlantInvA:
          out B: var Boolean
          B := theSchedule.forAll({E.elm.isEmpty.not }) \	     
               && \
               theAlarms.forAll(
	          { in A: ref Alarm; out BB: var Boolean;
                    BB := theSchedule.forAll(
                     { E.elm.exists(
		       { in Ex: ref Expert; out R: var Boolean;
                         R := Ex.quali.has(A.reqQuali)})})})

      PlantInvB:
          out B: var Boolean
          B := true
          theSchedule.scan
              B := B && current.elm.isEmpty.not
          theAlarms.forAllX -- for all A in alarm
              A: ref Alarm
              A := current
              theSchedule.scan -- for all current in schedule
                 -- an Expert E with qualifications needed 
                 -- for the Alarm A must exist
                 bbb: var Boolean
                 bbb := current.elm.exists( 
                      {in E: ref Expert; out R: var Boolean; 
                       R := E.quali.has(A.reqQuali)})
                 B := B && bbb
      ExpertToPage:
         in a: ref Alarm
         in p: ref Period
         out exp: ref Expert
         theSchedule.lookup(p).scan -- exp not defined, should be current?
            @if exp.quali.has(A.reqQuali) :then
                @leave ExpertToPage
      numberOfExperts:
         in p: ref Period
         out n: var integer
         n := theSchedule.lookup(p).card
      expertIsOnDuty:
         in ep: ref Expert
         out fp: obj Periods
         theSchedule.scan
            @if current.elm.has(ep) :then
                fp.insert(current.inx)
         fp.print
      expertIsOnDutyR:
         in ep: ref Expert
         out fp: ref Periods
         fp:= theSchedule.select({in p: ref Period; in ES: ref Experts; out B: var boolean; B := ES.has(ep)})
         fp.print
   Q: obj Qualification(17)
   QS: obj Qualifications
   
   E1: ref Expert
   E2: ref Expert
   ES1: obj set.set(#Expert){}
   ES2: obj set.set(#Expert){}
   A: ref Alarm
   AS: obj Alarms
   
   S: obj Schedule
   
   P: obj Plant(AS,S){}
   
   QS.insert(Q)
   A := Alarm("OverHeat",Q)
   E1 := Expert("John",QS)
   ES1.insert(E1)
   E1:= Expert("Laura",QS)
   ES1.insert(E1)   
   S.add(Period(0,8),ES1)
   E2:= Expert("Surayya",QS)
   ES2.insert(E2)
   S.add(Period(8,16),ES2)
   S.add(Period(16,24),ES1)
   AS.insert(A)
   AS.print
   @if P.PlantInvA :then
      "P.plantInvA = true\n".print
   :else
      "P.plantInvA = not true\n".print

   @if P.PlantInvB :then
      "P.plantInvB = True\n".print
   :else
      "P.plantInvB = NOT true\n".print
   newline

   "On duty:".print
   E1.print
   P.expertIsOnDuty(E1)
   "On duty:".print
   E2.print   
   P.expertIsOnDuty(E2)   
   newline
   
   "On duty:".print
   E1.print
   P.expertIsOnDutyR(E1)
   "On duty:".print
   E2.print   
   P.expertIsOnDutyR(E2)    
   
   
   